{
    "id": "J-32",
    "original_text": "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents. When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs. It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem. In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees. This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games. The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently. Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time. We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium. We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2. Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree. We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2. It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable). Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1. INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players. The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games. A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players. The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree. The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time. This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves. It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1. During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2). The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V . The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue. The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk. By the end of the upstream pass, all children of the root have computed their best response policies. In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice. It also selects a strategy for each child. A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root. The equilibrium then propagates downstream, with each vertex selecting its childrens actions. The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent. To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid. The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect. In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game. In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output. Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ). This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.) We can improve the running time of the generic algorithm using the ideas of [9]. In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary). We obtain the following theorem THEOREM 1. There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path. There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game. In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem. THEOREM 2. There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2. In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree. Even when the tree has bounded degree, the running time can be exponential. We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies. In particular, we show the following. THEOREM 3. There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space. It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths. It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1. This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8. In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth. We prove the following theorem. THEOREM 4. Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete. Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria. To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2. PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree. Each vertex has two actions, which are denoted by 0 and 1. A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1. Fur the purposes of the algorithm, the tree is rooted arbitrarily. For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child. This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function. Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1. Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}. Typically, W is the parent of V , and this is just referred to as the best response policy for V . The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}. The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root. With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child. The root selects any pair (w, v) from B(W, V ). It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive. When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3. ALGORITHM OF LITTMAN ET AL. The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex. As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium. This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1]. We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1. In [9], it is suggested that we can select the breakpoint policy in a particular way. Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt. The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1. We say such a breakpoint policy has t − 1 breakpoints. The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk. The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child. Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl. Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t. P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies. The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1]. It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl. The authors then claim that any such cover can be transformed into a breakpoint policy for V . Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5). They illustrate their approach in a figure, which is reproduced as Figure 1 here. In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7. The thick connected path is the corresponding breakpoint policy. It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right. To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U. Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise. Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1). Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2. The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0. The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back). The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3. Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium. For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2. The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).) In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1. The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible. Any other trimming would be just as bad. For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1. The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9. The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0. We conclude that the LKS algorithm does not always find a Nash equilibrium. In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium. For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2. Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees. In the next section, we show that it runs in polynomial time on a path. 4. FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}. We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point. THEOREM 5. For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles. Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ). PROOF. For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly. Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A. We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points. To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game. For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true. Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively. The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}. Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111. If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy. Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0. In this case, P0 > P1 if and only if A1u + A0 < 0. If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true. Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1. Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}. By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points. For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies. To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1. The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0. Assume for now that A1 > 0; the other two cases can be treated similarly. In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1. Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅. Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1). Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle. Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1. Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 . Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α. Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1]. The set B(W, V )|V =1 can be described in a similar manner. By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points. Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4. Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0. In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously. Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1. For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1]. Sometimes we drop the subscript V when it is clear from the context. LEMMA 1. For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u). PROOF. Fix an arbitrary v ∈ (0, 1). Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies. Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w). Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1. Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies. As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1). Choose u = vj−1; by construction, u ∈ pbrU (v). Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1. However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy. Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0. LEMMA 2. For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w). PROOF. Consider an arbitrary u0 ∈ pbrU (0). If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0). Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w). The argument for the case B(u0) < 0 is similar. Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours. Note that for any such vector we have vj−1 ∈ pbrU (0). By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru. Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}. In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1. The argument for ˆf(1) is similar. Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 . It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time. Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U). If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle. Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles. Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2). Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems. For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles. The case limu→u∗− f(u) = −∞ is similar. As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles. Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each. We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles. Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U). Hence, B(W, V ) has at most 2j + 4 event points. The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm. The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ). However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game. In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1. Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies. While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has. Definition 3. A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U). We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union. Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments. Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1. As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium. Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6]. THEOREM 6. For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5. NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2. A graph having maximum degree 2 is, of course, a union of paths and cycles. Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles. Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies. For i ≤ k let vi denote the probability that Vi plays 1. The first search can be done as follows. For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1. Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2. Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3. Apply the upstream pass to P 4. Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5. Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.) For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1). Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1). Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 . Choose any vertex Vi. We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game. If the equation is non-trivial it has at most 2 solutions in (0, 1). For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1). For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1). If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria. The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6. FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children. We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ). Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj). Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively. Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments. Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments. Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1. For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}. As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial. In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments. Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time. In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail. S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy. In the rest of this subsection, we describe this construction. Consider the tree Tn given by Figure 5; let Vn be the root of this tree. For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2. It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1. The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6. LEMMA 3. Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively. Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments. Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}. PROOF. The proof proceeds by induction on k. For k = 0, the statement is obvious. Now, suppose it is true for B(Vk, Vk−1). One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk). Let us examine them in turn. To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2. Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}. For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2]. We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}. Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}. Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk). It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk). Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis. Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint. Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}. Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other. We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma. To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies. We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables. Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree. Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}. Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk. LEMMA 4. Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk). The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 . The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments. However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified. More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ). This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ). Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj). This implies Theorem 3. THEOREM 7. For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0. We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6]. We proceed by induction. For j = 1, the argument is similar to that in Section 3. For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7. PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time. We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j. The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1. The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree). For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview. Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems. A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input. In a total search problem, there is a guarantee that at least one solution exists for any input. Nashs theorem assures us that the problem of finding Nash equilibria is total. A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS. Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets. Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem. Definition 4. END OF THE LINE. Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n . Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x. S and P can be thought of as standing for successor and predecessor. Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE. END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3. Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows. Definition 5. 3-DIMENSIONAL BROUWER. Input: a circuit C having 3n input bits and 2 output bits. The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision. The output represents one of four colours assigned by C to a cubelet. C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube. A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours. The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint. The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH. To prove the theorem, we begin with some preliminary results as follows. Each player has 2 actions, denoted 0 and 1. For a player at vertex V let p[V ] denote the probability that the player plays 1. LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ]. COROLLARY 1. There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ]. PROOF. Make a chain of n copies of Gshift in Lemma 5. Each subset of vertices in the path decomposition is the vertices in a copy of Gshift. Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false. The following uses gadgets from [7, 4]. COROLLARY 2. There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]). PROOF OF THEOREM 4. Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER. Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1. The probability that V plays 1 is denoted p[V ]. G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube. G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER. For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0. Construct V (i) C from V (i−1) C using Corollary 2. Let G(i) be the graphical game that does this. Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ). Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n). Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz]. Similarly to [4], the output of GC affects Vx, Vy and Vz as follows. Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1). We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points. That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex). This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]). Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]). At a Nash equilibrium the outputs of each copy will cancel each other out. The pathwidth of the whole game is at most M times the pathwidth GC. 8. OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time. Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space. However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed. In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively. Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1. It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial. In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn. For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them. Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}. Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1. Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts. Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi]. Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments? If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment? It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0. This implies that even for a caterpillar, the best response policy can be exponentially large. However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size. If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9. REFERENCES [1] H. Bodlaender and T. Kloks. Efficient and constructive algorithms for the pathwidth and treewidth of graphs. Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete. Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng. Settling the complexity of 2-player Nash equilibrium. Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou. The complexity of computing a Nash equilibrium. In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou. Three-player games are hard. Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg. Nash equilibria in graphical games on trees revisited. Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou. Reducibility among equilibrium problems. In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh. Graphical models for game theory. In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh. An efficient exact algorithm for singly connected graphical games. In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns. Nash propagation for loopy graphical games. In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou. On the complexity of the parity argument and other inefficient proofs of existence. J. Comput. Syst. Sci., 48(3):498-532, 1994. 109",
    "original_translation": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V. El algoritmo genérico no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente. En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta. La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2). Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del algoritmo genérico de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino). Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9]. En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un juego gráfico en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario). Obtenemos el siguiente teorema TEOREMA 1. Existe un algoritmo O(n2) que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un camino de n vértices. Existe un algoritmo O(n3) que calcula una representación de todos los equilibrios de Nash de dicho juego. En la Sección 5 extendemos los resultados de la Sección 4 a grafos de grado 2 en general, obteniendo el siguiente teorema. TEOREMA 2. Existe un algoritmo de tiempo polinómico que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un grafo con grado máximo 2. En la Sección 6 ampliamos nuestro algoritmo para que pueda ser utilizado para encontrar un equilibrio de Nash de un juego gráfico en un árbol arbitrario. Incluso cuando el árbol tiene grado acotado, el tiempo de ejecución puede ser exponencial. Mostramos que esto es inevitable construyendo una familia de juegos gráficos en árboles de grado acotado para los cuales las políticas de mejor respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de dos pasos (es decir, un algoritmo que es similar en espíritu al de [8]) tiene que almacenar casi todos los puntos de las políticas de mejor respuesta. En particular, mostramos lo siguiente. TEOREMA 3. Existe una familia infinita de juegos gráficos en árboles de grado acotado con ancho de camino 2, tal que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales. Es interesante notar que los árboles utilizados en la demostración del Teorema 3 tienen un ancho de camino de 2, es decir, están muy cerca de ser caminos. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico para grafos de ancho de camino 1. Esta pregunta puede ser vista como una generalización de un problema muy natural de geometría computacional; lo describimos con más detalle en la Sección 8. En la Sección 7, presentamos un resultado de intractabilidad teórica de complejidad para el problema de encontrar un equilibrio de Nash de un juego gráfico en un grafo con un ancho de camino pequeño. Demostramos el siguiente teorema. TEOREMA 4. Considera el problema de encontrar un equilibrio de Nash para un juego gráfico en el cual el grafo subyacente tiene un grado máximo de 3 y un ancho de camino k. Existe una constante k tal que este problema es PPAD-completo. El teorema 4 limita la medida en que podemos explotar las propiedades de tipo camino del grafo subyacente para encontrar equilibrios de Nash. Para demostrar el Teorema 4, utilizamos resultados recientes de completitud de PPAD para juegos, en particular los artículos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de grado d (para d ≥ 3) es computacionalmente equivalente al problema de resolver juegos en forma normal de r jugadores (para r ≥ 4), ambos de los cuales son PPAD-completos. CONSIDERACIONES PREVIAS Y NOTACIÓN Consideramos juegos gráficos en los que el grafo subyacente G es un árbol de n vértices. Cada vértice tiene dos acciones, que se denotan como 0 y 1. Una estrategia mixta se define por un único número x ∈ [0, 1], que indica la probabilidad de que el jugador seleccione la acción 1. Para los propósitos del algoritmo, el árbol está enraizado de manera arbitraria. Para mayor comodidad, asumimos sin pérdida de generalidad que la raíz tiene un solo hijo y que su recompensa es independiente de la acción elegida por el hijo. Esto se puede lograr primero eligiendo una raíz arbitraria del árbol, y luego agregando un padre ficticio de esta raíz, asignándole una función de pago constante. Dado un borde (V, W) del árbol G, y una estrategia mixta w para W, sea G(V,W), W=w la instancia obtenida de G mediante (1) eliminar todos los nodos Z que están separados de V por W (es decir, todos los nodos Z tales que el camino de Z a V pasa por W), y (2) restringir la instancia de modo que se requiera que W juegue la estrategia mixta w. Definición 1. Supongamos que (V, W) es un borde del árbol, que v es una estrategia mixta para V y que w es una estrategia mixta para W. Decimos que v es una mejor respuesta potencial para w (indicado por v ∈ pbrV(w)) si hay un equilibrio en la instancia G(V, W), W = w en el que V tiene la estrategia mixta v. Definimos la política de mejor respuesta para V, dada W, como B(W, V) = {(w, v) | v ∈ pbrV(w), w ∈ [0, 1]}. Normalmente, W es el padre de V, y esto se conoce simplemente como la política de mejor respuesta para V. La expresión B(W, V )|V =v se utiliza para denotar el conjunto B(W, V ) ∩ [0, 1]×{v}. El paso ascendente del algoritmo genérico de [8] calcula la política de mejor respuesta para V en cada nodo V que no sea la raíz. Con las suposiciones anteriores sobre la raíz, el paso aguas abajo es sencillo: Sea W la raíz y V su hijo. La raíz selecciona cualquier par (w, v) de B(W, V). Decide jugar con la estrategia mixta w e instruye a V a jugar con la estrategia mixta v. El resto del paso descendente es recursivo. Cuando un nodo V recibe instrucciones de su padre para adoptar la estrategia mixta v, hace lo siguiente para cada hijo U: encuentra un par (v, u) ∈ B(V, U) (con el mismo valor de v que le fue dado por su padre) e instruye a U a jugar u. ALGORITMO DE LITTMAN ET AL. El algoritmo de [9] se basa en la siguiente observación: para calcular un equilibrio de Nash único mediante un algoritmo de dos pasos, no es necesario construir la política de mejor respuesta completa para cada vértice. Si, en cada paso de la pasada descendente, el vértice en consideración puede seleccionar un vector de estrategias para todos sus hijos de manera que la estrategia de cada hijo sea una mejor respuesta potencial a la estrategia del padre, el algoritmo logra producir un equilibrio de Nash. Esto se puede lograr si, al comienzo del paso aguas abajo, tenemos una estructura de datos en la que cada vértice V con padre W almacena un conjunto ˆB(W, V ) ⊆ B(W, V ) (llamado una política de puntos de quiebre) que cubre cada posible w ∈ [0, 1]. Mostraremos más adelante que una condición suficiente para la construcción de una estructura de datos así es la invariante de que, en cada nivel del paso ascendente, ˆB(W, V) contiene un camino continuo desde w = 0 hasta w = 1. En [9], se sugiere que podemos seleccionar la política de punto de quiebre de una manera particular. Es decir, el documento utiliza la siguiente definición: Definición 2. (cf. [9]) Una política de puntos de ruptura para un nodo V con padre W consiste en un conjunto ordenado de puntos de ruptura de W, w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 y un conjunto asociado de valores de V, v1, . . . , vt. La interpretación es que para cualquier w ∈ [0, 1], si wi−1 < w < wi para algún índice i y W juega w, entonces V deberá jugar vi; y si w = wi para algún índice i, entonces V deberá jugar cualquier valor entre vi y vi+1. Decimos que una política de punto de quiebre tiene t - 1 puntos de quiebre. El artículo luego afirma que cualquier vértice V puede calcular su política de punto de interrupción con respecto a su padre W dadas las políticas de punto de interrupción de sus hijos U1, . . . , Uk. La prueba procede ordenando los puntos de quiebre de los niños (es decir, los valores respectivos de v) de izquierda a derecha (se puede asumir sin pérdida de generalidad que todos estos puntos de quiebre son distintos) y considerándolos sucesivamente; cada punto vl ∈ {v1, . . . , vL} corresponde a una elección fija de estrategias para k − 1 niños y un intervalo de estrategias admisibles para un niño. Supongamos, para mayor comodidad, que este niño es U1 y su intervalo de estrategias admisibles en vl es [a, b]; supongamos también que para Uj, j = 2, . . . , k, sus respectivas políticas de puntos de quiebre les prescriben jugar uj en respuesta a vl. Sea P i (u, w), i = 0, 1, el pago esperado para V cuando V juega i, U1 juega u, cada Uj, j = 2, . . . , k, juega uj, y W juega w, y considera el conjunto Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] tal que P 0 (u, w) = P1 (u, w)}; nota que para cualquier w ∈ Wl tenemos vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figura 1: LKS: Recorte para encontrar políticas de puntos de quiebre. Los autores muestran que para cualquier punto de quiebre vl, el conjunto Wl está vacío, es un solo intervalo, o es una unión de dos intervalos no flotantes (un intervalo es no flotante si uno de sus extremos es 0 o 1); además, la unión de todos los conjuntos Wl, l = 1, . . . , L, cubre el intervalo [0, 1]. Se sigue fácilmente que se puede cubrir [0, 1] con a lo sumo L+2 intervalos, cada uno de los cuales es un subconjunto de algún Wl. Los autores afirman entonces que cualquier cobertura de este tipo puede ser transformada en una política de puntos de ruptura para V. Es decir, afirman que para cualquier par de intervalos Wl1 y Wl2 en la cobertura, cualquier superposición entre Wl1 y Wl2 puede asignarse arbitrariamente a la cobertura por Wl1 y Wl2 recortados en consecuencia (cf. [9], p. 5). Ellos ilustran su enfoque en una figura, la cual se reproduce como Figura 1 aquí. En la figura, las líneas horizontales discontinuas representan los puntos de quiebre v1, v2, . . . , v7 y los intervalos sólidos a lo largo de estos puntos de quiebre son los conjuntos W1, W2, . . . , W7. El camino grueso conectado es la política de punto de quiebre correspondiente. Se elige de la siguiente manera: comenzar en la izquierda y siempre saltar al intervalo que permita el mayor avance hacia la derecha. Para entender por qué este enfoque no funciona en general, considera un camino de longitud 4 que consiste en una raíz indiferente R, su hijo W, el hijo de W V y el hijo de V U. Supongamos que U recibe un pago de 1 si juega de manera diferente a V y 0 en caso contrario. Así, si v denota la estrategia mixta de V (es decir, V juega 1 con probabilidad v), entonces la ganancia esperada que U obtiene al jugar 0 se da por P0(U) = v y la ganancia esperada que U obtiene al jugar 1 se da por P1(U) = 1 − v. Supongamos que V no obtiene ganancia al jugar 1 (por lo que P1(V) = 0) y que su matriz de ganancias al jugar 0 es 1 −9 9 −1, entonces si u denota la estrategia mixta de U y w denota la estrategia mixta de W, la ganancia esperada que V obtiene al jugar 0 se da por P0(V) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1). Usando las técnicas de [8] (o, alternativamente, las de la Sección 4), no es difícil verificar que las políticas de mejor respuesta para U y V (como en la Definición 1) están dadas por los gráficos en la Figura 2. La mejor política de respuesta para U es una política de punto de quiebre para U (como en la Definición 2) con puntos de quiebre V v0 = 0, v1 = 1/2 y v2 = 1 con valores asociados u1 = 1 y u2 = 0. La mejor política de respuesta para V no es una política de punto de quiebre (debido a cómo la curva de w = 0 a w = 1 retrocede). El algoritmo LKS recortaría para obtener una política de puntos de quiebre como la que se muestra en la Figura 3. Se observa que esta política de punto de quiebre ˆB(W, V) es inválida en el sentido de que no satisface ˆB(W, V) ⊆ B(W, V). El punto es que la matriz de pagos de W ahora puede ser elegida para evitar que el algoritmo LKS encuentre un equilibrio de Nash. Por ejemplo, supongamos que las ganancias se dan de tal manera que P0 (W) = v y P1 (W) = (1−v)2. La mejor política de respuesta para W es una línea horizontal en w = 0.1 (Este es el valor de w que permite v = 2/3 - ver Figura 2, lo que hace que P0 (W) = P1 (W).) En el paso descendente, los valores elegidos son w = .1, luego, a partir del recorte, v = 0 y u = 1, lo cual no es un equilibrio de Nash ya que W prefiere la acción 1. El fallo del algoritmo no se debe al hecho de que la política de recorte llegue tan lejos a la derecha como sea posible. Cualquier otro recorte sería igual de malo. Por ejemplo, supongamos que la política de punto de quiebre para V tiene v = 0 hasta algún punto w∗ < .9 y luego salta a v = 1. El algoritmo es entonces derrotado por la matriz de pagos con P0(W) = 2v y P1(W) = (1 − v) en la que la política de mejor respuesta para W es una línea horizontal en w = .9. El algoritmo luego da w = .9, v = 1, y u = 0, lo cual no es un equilibrio de Nash ya que W prefiere la acción 0. Concluimos que el algoritmo LKS no siempre encuentra un equilibrio de Nash. En las Secciones 4 y 6 mostramos cómo modificar el algoritmo para que siempre encuentre un equilibrio de Nash. Para el algoritmo modificado, debemos extender la definición de la política de punto de quiebre (ver Definición 3) para que incluya políticas de punto de quiebre como la política de mejor respuesta para V en la Figura 2. Desafortunadamente, una política de punto de interrupción de este tipo puede ser exponencial en tamaño (ver Figura 7), por lo que el algoritmo corregido no se ejecuta en tiempo polinómico en todos los árboles. En la siguiente sección, mostramos que se ejecuta en tiempo polinómico en un camino. 4. ENCONTRANDO EQUILIBRIOS EN UN CAMINO En esta sección, nos enfocamos en el caso en el que el grafo subyacente es un camino, es decir, su conjunto de vértices es {V1, . . . , Vn}, y su conjunto de aristas es {(Vj , Vj+1) | j = 1, . . . , n − 1}. Mostramos que en este caso la mejor política de respuesta para cada vértice puede ser representada como una unión de un número polinomial de rectángulos, donde un rectángulo está definido por un par de intervalos cerrados (IV, IU) y consiste en todos los puntos en IV × IU; puede ser el caso de que uno o ambos de los intervalos IV e IU consistan en un solo punto. TEOREMA 5. Para cualquier j = 1, . . . , n, el conjunto B(Vj , Vj−1) puede ser representado como una unión disjunta de a lo sumo (j + 4)2 rectángulos. Además, dado tal representación de B(Vj , Vj−1), se puede calcular una representación de B(Vj+1, Vj) en tiempo O(j2). PRUEBA. Para cualquier conjunto A ⊆ [0, 1]2 que esté representado como una unión de un número finito de rectángulos, decimos que un punto u ∈ [0, 1] en el eje U es un punto de evento U de A si u = 0 o u = 1 o A contiene un rectángulo de la forma IV × IU y u es un extremo de IU; los puntos de evento V se definen de manera similar. Observa que para cualquier u ∈ [0, 1], el número de componentes conectadas de [0, 1]×{u} ∩ A es a lo sumo el número de puntos de V-evento de A. Utilizamos inducción en j para demostrar que para cada Vj se cumple la afirmación del teorema y, además, cada B(Vj, Vj−1) tiene como máximo 2j + 4 puntos de evento. Para simplificar el caso base, modificamos el juego gráfico agregando un vértice ficticio V0 al principio del camino: el único vecino de V0 es V1, las ganancias de V0 siempre son iguales a 0, y las ganancias de todos los demás vértices (incluido V1) son las mismas que en el juego original. Para j = 0, tenemos B(V1, V0) = [0, 1]2, por lo que la afirmación del teorema es trivialmente verdadera. Ahora, supongamos que j > 0, establezca V = Vj y permita que U = Vj−1 y W = Vj+1 sean los vértices que preceden y siguen a V, respectivamente. Los pagos para V están descritos por una matriz 2×2×2 P: Pxyz es el pago que V recibe cuando U juega x, V juega y, y W juega z, donde x, y, z ∈ {0, 1}. Supongamos que U juega 1 con probabilidad u y W juega 1 con probabilidad w. Entonces la ganancia esperada de V al jugar 0 es P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, mientras que su ganancia esperada al jugar 1 es P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111. Si P0 > P1, V prefiere estrictamente jugar 0; si P0 < P1, V prefiere estrictamente jugar 1; y si P0 = P1, V es indiferente, es decir, puede jugar cualquier estrategia (mixta). Dado que P0 y P1 son lineales en w y u, existen algunas constantes A1, A0, B1 y B0 que dependen de la matriz P, pero no de u y w, de modo que P0 − P1 = w(B1u + B0) − (A1u + A0). Dependiendo de los valores de A1, A0, B1 y B0, subdividimos el resto de la prueba en los siguientes casos. • B1 = 0, B0 = 0. En este caso, P0 > P1 si y solo si A1u + A0 < 0. Si también A1 = 0, A0 = 0, claramente, B(W, V) = [0, 1]2, y la afirmación del teorema es trivialmente verdadera. De lo contrario, el vértice V es indiferente entre 0 y 1 si y solo si A1 = 0 y u = −A0/A1. Sea V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}. Por la hipótesis inductiva, V consiste en a lo sumo 2(j − 1) + 4 segmentos y puntos aislados. Para cualquier v ∈ V, tenemos B(W, V)|V = v = [0, 1]: no importa lo que juegue W, siempre y cuando U esté jugando −A0/A1, V está contento de jugar v. Por otro lado, para cualquier v ∈ (0, 1) \\ V tenemos B(W, V)|V = v = ∅: cuando V juega v, U solo puede responder con u = −A0/A1, en cuyo caso V puede beneficiarse cambiando a una de las estrategias puras. Para completar la descripción de B(W, V), queda por analizar los casos v = 0 y v = 1. El vértice V prefiere jugar 0 si A1 > 0 y u ≤ −A0/A1, o A1 < 0 y u ≥ −A0/A1, o 103 A1 = 0 y A0 < 0. Supongamos por ahora que A1 > 0; los otros dos casos pueden ser tratados de manera similar. En este caso, 0 ∈ pbrV (w) para algún w ∈ [0, 1] si y solo si existe un u ∈ pbrU (0) tal que u ≤ −A0/A1: si no existe tal u, cada vez que V juega 0, la respuesta de U no está en pbrU (0) o V puede mejorar su recompensa jugando 1. Por lo tanto, o bien B(W, V)|V=0 = [0, 1] o B(W, V)|V=0 = ∅. De manera similar, B(W, V)|V=1 es igual a [0, 1] o ∅, dependiendo de pbrU(1). Por lo tanto, el conjunto B(W, V) consiste en un máximo de 2j + 4 ≤ (j + 4)2 rectángulos: B(W, V) ∩ [0, 1]×(0, 1) = [0, 1]×V contribuye como máximo con 2j + 2 rectángulos, y cada uno de los conjuntos B(W, V)|V=0 y B(W, V)|V=1 contribuye como máximo con un rectángulo. De manera similar, su número total de puntos de evento es a lo sumo 2j + 4: los únicos puntos de evento W son 0 y 1, cada punto de evento V de B(W, V) es un punto de evento V de B(V, U), y hay a lo sumo 2j + 2 de ellos. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 para algún α ∈ R. En este caso, V es indiferente entre 0 y 1 si y solo si w = α, o B1 = 0 y u = −B0/B1 = −A0/A1. De manera similar al caso anterior, podemos mostrar que B(W, V)∩[0, 1]×(0, 1) consiste en el rectángulo {α}×[0, 1] y como máximo 2j + 2 rectángulos de la forma [0, 1]×IV, donde cada IV corresponde a un componente conectado de B(V, U)|U=−B0/B1. Además, V prefiere jugar 0 si B1u + B0 > 0 y w ≥ α o B1u + B0 < 0 y w ≤ α. Por lo tanto, si B1u∗ + B0 > 0 para algún u∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [α, +∞) ∩ [0, 1] y si B1u∗∗ + B0 < 0 para algún u∗∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [−∞, α] ∩ [0, 1]; si ambos u∗ y u∗∗ existen, B(W, V )|V =0 = [0, 1]. El conjunto B(W, V)|V=1 se puede describir de manera similar. Por la hipótesis inductiva, B(V, U) tiene a lo sumo 2j + 2 puntos de evento; dado que al menos dos de estos son puntos de evento U, tiene a lo sumo 2j puntos de evento V. Dado que cada punto de evento V de B(W, V) es un punto de evento V de B(V, U) y B(W, V) tiene como máximo 3 puntos de evento W (0, 1 y α), su número total de puntos de evento es como máximo 2j + 3 < 2j + 4. Además, de manera similar al caso anterior, se sigue que B(W, V) consiste en un máximo de 2j + 4 < (j + 4)2 rectángulos. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0. En este caso, se puede definir la función de indiferencia f(·) como f(u) = A(u) B(u) = A1u+A0 B1u+B0, donde A(u) y B(u) nunca se anulan simultáneamente. Observa que siempre que w = f(u) y u, w ∈ [0, 1], V es indiferente entre jugar 0 y 1. Para cualquier A ⊆ [0, 1]2, definimos una función ˆfV por ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; nota que ˆfV mapea subconjuntos de [0, 1]2 a subconjuntos de R×[0, 1]. A veces omitimos el subíndice V cuando es evidente por el contexto. LEMMA 1. \n\nLEMMA 1. Para cualquier (w, v) ∈ [0, 1]×(0, 1) tenemos que (w, v) ∈ B(W, V) si y solo si existe un u ∈ [0, 1] tal que (v, u) ∈ B(V, U) y w = f(u). PRUEBA. Fije un v arbitrario en (0, 1). Supongamos que U juega algún u ∈ pbrU (v), w = f(u) satisface w ∈ [0, 1], y W juega w. Existe un vector de estrategias v1, . . . , vj−1 = u, vj = v tal que para cada Vk, k < j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que w = f(u), V es indiferente entre jugar 0 y 1; en particular, puede jugar v. Por lo tanto, si definimos vj+1 = w, el vector de estrategias (v1, . . . , vj+1) cumplirá las condiciones en la definición de mejor respuesta potencial, es decir, tenemos v ∈ pbrV (w). Por el contrario, supongamos que v ∈ pbrV (w) para algún w ∈ [0, 1], v = 0, 1. Entonces existe un vector de estrategias v1, . . . , vj−1, vj = v, vj+1 = w tal que para cada Vk, k ≤ j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que v = 0, 1, V, de hecho, es indiferente entre jugar 0 y 1, lo cual solo es posible si w = f(vj−1). Elige u = vj−1; por construcción, u ∈ pbrU (v). El lema 1 describe las situaciones en las que V es indiferente entre jugar 0 y jugar 1. Sin embargo, para caracterizar completamente B(W, V), también necesitamos saber cuándo V prefiere una estrategia pura. Define ˆf(0) = ∪u∈pbrU (0)Ru, donde Ru = ´ [f(u), +∞)×{0} si B(u) > 0, (−∞, f(u)]×{0} si B(u) < 0. y ˆf(1) = ∪u∈pbrU (1)Ru, donde Ru = ´ [f(u), +∞)×{1} si B(u) < 0, (−∞, f(u)]×{1} si B(u) > 0. LEMMA 2. \n\nLEMMA 2. Para cualquier w ∈ [0, 1], tenemos que (w, 0) ∈ ˆf(0) si y solo si 0 ∈ pbrV (w) y (w, 1) ∈ ˆf(1) si y solo si 1 ∈ pbrV (w). PRUEBA. Considera un u0 arbitrario ∈ pbrU (0). Si B(u0) > 0, para u = u0 la desigualdad P0 ≥ P1 es equivalente a w ≥ f(u0). Por lo tanto, cuando U juega u0 y W juega w, w ≥ f(u0), V prefiere jugar 0; dado que u0 ∈ pbrU (u), se sigue que 0 ∈ pbrV (w). El argumento para el caso B(u0) < 0 es similar. Por el contrario, si 0 ∈ pbrV (w) para algún w ∈ [0, 1], existe un vector (v1, . . . , vj−1, vj = 0, vj+1 = w) tal que para cada Vk, k ≤ j, Vk juega vk, y esta estrategia es una mejor respuesta a las estrategias de los vecinos de Vk. Ten en cuenta que para cualquier vector de este tipo tenemos vj−1 ∈ pbrU (0). Por contradicción, asumimos que (w, 0) ∈ Ë u∈pbrU (0) Ru. Entonces debe ser el caso que para cualquier u0 ∈ pbrU (0) ya sea que f(u0) < w y Ru0 = (−∞, f(u0)]×{0} o f(u0) > w y Ru0 = [f(u0), +∞)×{0}. En ambos casos, cuando V juega 0, U juega u0, y V juega w, la desigualdad entre f(u0) y w es equivalente a P0 < P1, es decir, V se beneficiaría al cambiar a 1. El argumento para ˆf(1) es similar. Juntas, el Lema 1 y el Lema 2 describen completamente el conjunto B(W, V): tenemos B(W, V) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2. Queda por demostrar que B(W, V) puede representarse como una unión de como máximo (j + 4)2 rectángulos, tiene como máximo 2j + 4 puntos de evento, y puede ser calculado en tiempo O(j2). Sea u∗ = −B0/B1. Considera un rectángulo arbitrario R = [v1, v2]×[u1, u2] ⊆ B(V, U). Si u∗ ∈ [u1, u2], la función f(·) es continua en [u1, u2] y por lo tanto ˆf(R) = [fmin, fmax]×[v1, v2], donde fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste en un solo rectángulo. Ahora, supongamos que R es intersectado por la línea [0, 1]×{u∗}; como se mencionó anteriormente, hay a lo sumo 2j+2 rectángulos de este tipo. Se supone que limu→u∗− f(u) = +∞; dado que f(·) es una función lineal fraccional, esto implica que limu→u∗+ f(u) = −∞ y también f(u1) > f(u2). Dado que f(·) es continua en [u1, u∗ ) y (u∗ , u2], es fácil ver que ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2]. El caso B1 = 0 no causa problemas especiales. Para completitud, establezca u∗ como cualquier valor fuera de [0, 1] en este caso. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figura 4: f es creciente en (−∞, u∗ ) y (u∗ , +∞). y ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste de a lo sumo dos rectángulos. El caso limu→u∗− f(u) = −∞ es similar. Dado que ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), se sigue que ˆf(B(V, U)) consiste en un máximo de (j + 3)2 + 2j + 2 rectángulos. Además, es fácil ver que tanto ˆf(0) como ˆf(1) consisten en un máximo de 2 segmentos de línea cada uno. Concluimos que B(W, V) puede ser representado como una unión de a lo sumo (j + 3)2 + 2j + 6 < (j + 4)2 rectángulos. Además, si v es un punto de evento V de B(W, V), entonces v es un punto de evento V de B(V, U) (esto incluye los casos v = 0 y v = 1, ya que 0 y 1 son puntos de evento V de B(V, U)) y si w es un punto de evento W de B(W, V), entonces o bien w = 0 o w = 1 o existe algún u ∈ [0, 1] tal que w = f(u) y u es un punto de evento U de B(V, U). Por lo tanto, B(W, V) tiene como máximo 2j + 4 puntos de evento. El límite O(j2) en el tiempo de ejecución en el Teorema 5 se deriva de nuestra descripción del algoritmo. El límite de O(n3) en el tiempo total de ejecución para encontrar un equilibrio de Nash (y una representación de todos los equilibrios de Nash) se sigue. 4.1 Encontrar un solo equilibrio de Nash en tiempo O(n2) El límite superior en el tiempo de ejecución de nuestro algoritmo es ajustado, al menos asumiendo la implementación directa, en la que cada B(Vj+1, Vj) se almacena como una unión de rectángulos: no es difícil construir un ejemplo en el que el tamaño de B(Vj+1, Vj) sea Ω(j2). Sin embargo, en algunos casos no es necesario representar todos los equilibrios de Nash; más bien, el objetivo es encontrar un equilibrio arbitrario del juego. En esta sección, demostramos que este problema puede resolverse en tiempo cuadrático, obteniendo así una prueba del Teorema 1. Nuestra solución se basa en la idea de [9], es decir, trabajar con subconjuntos de las políticas de mejor respuesta en lugar de las políticas de mejor respuesta en sí mismas; siguiendo [9], nos referiremos a tales subconjuntos como políticas de punto de quiebre. Si bien no siempre es posible construir una política de puntos de interrupción según se define en [9], mostramos cómo modificar esta definición para garantizar que siempre exista una política de puntos de interrupción; además, demostramos que para un grafo de camino, la política de puntos de interrupción de cualquier vértice puede ser almacenada en una estructura de datos cuyo tamaño es lineal en el número de descendientes que tiene este vértice. Definición 3. Una política de puntos de quiebre ˆB(V, U) para un vértice U cuyo padre es V es una curva no auto-intersectante de la forma X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, donde Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] y ui, vi ∈ [0, 1] para i = 0, . . . , m. Decimos que una política de puntos de quiebre es válida si v0 = 0, vm = 1, y ˆB(V, U) ⊆ B(V, U). A veces abusaremos de la notación al referirnos a ˆB(V, U) como una colección de segmentos Xi, Yi en lugar de su unión. Se debe tener en cuenta que no requerimos que vi ≤ vi+1 o ui ≤ ui+1; por lo tanto, en cualquier argumento que involucre políticas de puntos de quiebre, todos los segmentos deben tratarse como segmentos dirigidos. Observe que cualquier política de puntos de quiebre válida ˆB(V, U) puede ser vista como un mapeo continuo 1-1 γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2, donde γ(0) = (0, u1), γ(1) = (1, um) y existen algunos t0 = 0, t1, . . . , t2m−2 = 1 tales que {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1. Como se explica en la Sección 3, podemos utilizar una política de punto de quiebre válida en lugar de la política de mejor respuesta durante el paso descendente, y aún así garantizar que al final, produciremos un equilibrio de Nash. El Teorema 6 muestra que se puede calcular de forma inductiva políticas de puntos de quiebre válidas para todos los vértices en el camino; la prueba de este teorema se puede encontrar en la versión completa de este artículo [6]. TEOREMA 6. Para cualquier V = Vj, se puede encontrar en tiempo polinómico una política de puntos de quiebre válida ˆB(W, V) que consiste en a lo sumo 2j + 1 segmentos. EQUILIBRIOS DE NASH EN GRÁFICOS CON GRADO MÁXIMO 2 En esta sección mostramos cómo el algoritmo para caminos puede aplicarse para resolver un juego en cualquier gráfico cuyos vértices tengan un grado de a lo sumo 2. Un grafo con grado máximo 2 es, por supuesto, una unión de caminos y ciclos. Dado que cada componente conectado puede ser manejado de forma independiente, para obtener una prueba del Teorema 2, solo necesitamos mostrar cómo tratar con los ciclos. Dado un ciclo con vértices V1, . . . , Vk (en orden cíclico), realizamos dos búsquedas separadas de un equilibrio de Nash: primero buscamos un equilibrio de Nash donde algún vértice juega una estrategia pura, luego buscamos un equilibrio de Nash completamente mixto, donde todos los vértices juegan estrategias mixtas. Para i ≤ k, dejemos que vi denote la probabilidad de que Vi juegue 1. La primera búsqueda se puede hacer de la siguiente manera. Para cada i ∈ {1, . . . , k} y cada b ∈ {0, 1}, haz lo siguiente. 1. Sea P el camino (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2. El pago a Vi+1 se basa en poner vi = b (por lo que depende solo de vi+1 y vi+2). 3. Aplica el pase ascendente a P 4. Pon vi = b; aplica el pase aguas abajo. Para cada vértice, Vj, lleva un registro de todas las posibles estrategias mixtas vj 5. Verificar si Vi+1 tiene alguna respuesta consistente con vi = b; si es así, tenemos un equilibrio de Nash. (De lo contrario, no hay un equilibrio de Nash del tipo deseado). Para la segunda búsqueda, hay que tener en cuenta que si Vi juega una estrategia mixta, entonces vi+1 y vi−1 satisfacen una ecuación de la forma vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1). Dado que todos los vértices en el ciclo juegan estrategias mixtas, tenemos vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1). Componiendo las dos transformaciones lineales fraccionarias, obtenemos vi+3 = (A0 + A1 vi−1)/(B0 + B1 vi−1), para algunas nuevas constantes A0, A1, B0, B1. Elige cualquier vértice Vi. Podemos expresar vi en términos de vi+2, luego vi+4, vi+6, etc. y finalmente vi mismo para obtener una ecuación cuadrática (para vi) que es fácil de derivar a partir de los pagos en el juego. Si la ecuación no es trivial, tiene como máximo 2 soluciones en (0, 1). Para un ciclo de longitud impar, todos los demás vj son derivables a partir de esas soluciones, y si existe un equilibrio de Nash completamente mezclado, todos los vj deberían resultar ser números reales en el rango (0, 1). Para un ciclo de longitud par, obtenemos dos ecuaciones cuadráticas, una para vi y otra para 105 vi+1, y de la misma manera podemos probar si alguna solución a estas ecuaciones produce valores para los otros vj, todos los cuales se encuentran en el intervalo (0, 1). Si la ecuación cuadrática es trivial, potencialmente hay un continuo de equilibrios completamente mezclados. Los valores de vi que pueden ocurrir en un equilibrio de Nash son aquellos para los cuales todos los valores dependientes vj se encuentran en el intervalo (0, 1); esta última condición es fácil de verificar calculando la imagen del intervalo (0, 1) bajo transformaciones lineales fraccionarias respectivas. 6. ENCONTRANDO EQUILIBRIOS EN UN ÁRBOL (ARBITRARIO) Para árboles arbitrarios, la estructura general del algoritmo permanece igual, es decir, se puede construir una política de mejor respuesta (o, alternativamente, una política de punto de quiebre) para cualquier vértice basada en las políticas de mejor respuesta de sus hijos. Suponemos que el grado de cada vértice está limitado por una constante K, es decir, la matriz de pagos para cada vértice es de tamaño O(2K). Consideremos un vértice V cuyos hijos son U1, . . . , Uk y cuyo padre es W; la política de mejor respuesta de cada Uj es B(V, Uj). De manera similar a la sección anterior, podemos calcular los pagos esperados V de jugar 0 o 1, respectivamente. Es decir, cuando cada uno de los Uj juega uj y W juega w, tenemos P0 = L0 (u1, . . . , uk, w), P1 = L1 (u1, . . . , uk, w), donde las funciones L0 (·, . . . , ·), L1 (·, . . . , ·) son lineales en todos sus argumentos. Por lo tanto, la desigualdad P0 > P1 se puede reescribir como wB(u1, . . . , uk) > A(u1, . . . , uk), donde tanto A(·, . . . , ·) como B(·, . . . , ·) son lineales en todos sus argumentos. Dado u = (u1, . . . , uk) y defina la función de indiferencia f : [0, 1]k → [0, 1] como f(u) = A(u)/B(u); claramente, si cada Uj juega uj, W juega w y w = f(u), V es indiferente entre jugar 0 y 1. Para cualquier X = X1 × · · · × Xk, donde Xi ⊆ [0, 1]2 se define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k}. Además, se establece ˆf(0) = {(w, 0) | ∃u tal que ui ∈ pbrUi (0) y wB(u) ≥ A(u)} y ˆf(1) = {(w, 1) | ∃u tal que ui ∈ pbrUi (1) y wB(u) ≤ A(u)}. Como en la sección anterior, podemos demostrar que B(W, V) es igual a ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2; además, cualquier camino de w = 0 a w = 1 que sea un subconjunto de B(W, V) constituye una política de puntos de quiebre válida. Política de Puntos de Quiebre de Tamaño Exponencial. Si bien el algoritmo de la Sección 4 se puede generalizar para árboles de grado acotado, su tiempo de ejecución ya no es polinomial. De hecho, la afirmación contraria es cierta: podemos construir una familia de árboles y matrices de pago para todos los jugadores de manera que las políticas de mejor respuesta para algunos de los jugadores consistan en un número exponencial de segmentos. Además, en nuestro ejemplo las políticas de puntos de quiebre coinciden con las políticas de mejor respuesta, lo que significa que incluso encontrar un solo equilibrio de Nash utilizando el enfoque de [8, 9] llevará un tiempo exponencialmente largo. De hecho, una afirmación más fuerte es cierta: para cualquier algoritmo de dos pasos de tiempo polinómico (definido más adelante) que funcione con subconjuntos de políticas de mejor respuesta para este grafo, podemos elegir las recompensas de los vértices de manera que el paso posterior de este algoritmo falle. La figura 5: El árbol Tn que corresponde a la política de puntos de quiebre de tamaño exponencial. En el resto de esta subsección, describimos esta construcción. Considera el árbol Tn dado por la Figura 5; sea Vn la raíz de este árbol. Para cada k = 1, . . . , n, permita que las ganancias de Sk y Tk sean las mismas que las de U y V descritas en la Sección 3; recuerde que las políticas de puntos de quiebre para U y V se muestran en la Figura 2. No es difícil ver que la función de indiferencia para Tk está dada por f(s) = .8s + .1. El pago de V0 es 1 si V1 selecciona la misma acción que V0 y 0 en caso contrario; la política de mejor respuesta de V0 está dada por la Figura 6. LEMMA 3. \n\nLEMMA 3. Dado k < n, y sean u, t, v y w las estrategias de Vk−1, Tk, Vk y Vk+1, respectivamente. Supongamos que Vk prefiere jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Entonces B(Vk+1, Vk) consta de al menos 3k segmentos. Además, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} y {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}. PRUEBA. La demostración procede por inducción en k. Para k = 0, la afirmación es obvia. Ahora, supongamos que es cierto para B(Vk, Vk−1). Se puede ver B(Vk+1, Vk) como una unión de siete componentes: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, y cinco componentes que corresponden a los segmentos de B(Vk, Tk). Examinémoslos uno por uno. Para describir ˆf(0)∩[0, 1]×{0}, observe que f(u, t) = .5t+.1u+.2 es monótona en t y u y cumple con f(0, 0) = .2. Además, tenemos pbrVk−1 (0) = {0} y pbrTk (0) = {0}. Para cualquier w ∈ [0, 1] tenemos f(0, 0) ≥ w si y solo si w ∈ [0, .2]. Concluimos que ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}. De manera similar, se sigue que ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}. Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; estos conjuntos corresponden a segmentos horizontales de B(Vk, Tk). Es fácil ver que S1, S2, S3 ⊂ B(Vk+1, Vk). Dado que f es una función continua, el número de segmentos en cada Si es al menos el número de segmentos en B(Vk, Vk−1)∩[.1, .9]×[0, 1], que es al menos 3k−1 por hipótesis de inducción. Además, dado que f es monótona en u y f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), todos los Si, i = 1, 2, 3, son disjuntos. Finalmente, el conjunto B(Vk+1, Vk) contiene dos segmentos que corresponden a los segmentos verticales de B(Vk, Tk), es decir, S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} y S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}. Claramente, S4 conecta S2 y S3, S5 conecta S1 y S2, y S4 y S5 no se intersectan entre sí. Concluimos que B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figura 6: Políticas de puntos de quiebre para V0 y V1, es una línea continua que consiste en al menos 3k segmentos y satisface la condición del lema. Para completar la construcción, necesitamos demostrar que podemos diseñar la matriz de pagos para Vk de manera que prefiera jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Con este fin, demostramos una afirmación más general, a saber, que la función de indiferencia de un vértice puede ser una función multilineal fraccional arbitraria de las estrategias de sus descendientes. Decimos que una función de k variables es multilineal si puede ser representada como una suma de monomios y cada uno de estos monomios es lineal en todas sus variables. Ten en cuenta que esta definición es diferente de una más estándar en el sentido de que no requerimos que todos los monomios tengan el mismo grado. Recuerde que las ganancias de un vértice con k + 1 vecinos están descritas por las matrices P0 y P1, donde Pj i0i1...ik es la ganancia que V obtiene cuando juega j, y sus vecinos juegan i0, . . . , ik, y j, i0, . . . , ik ∈ {0, 1}. Sea P[j] = P[j](w, u1, . . . , uk) la ganancia esperada obtenida por este vértice cuando juega j y las estrategias (mixtas) de sus vecinos están dadas por un vector (w, u1, . . . , uk), es decir, P[j] = E[P j i0i1...ik ] donde i0, . . . , ik son variables aleatorias de Bernoulli independientes, cada una de las cuales es 1 con las respectivas probabilidades w, u1, . . . , uk. LEMMA 4. \n\nLEMMA 4. Dado un vértice del árbol V cuyo padre es W y cuyos hijos son U1, . . . , Uk, para cualquier función f = f(u1, . . . , uk) que pueda representarse como una razón de dos funciones multilineales f1, f2, es decir, f = f1(u1,...,uk) f2(u1,...,uk), existen matrices de pago P0 y P1 para V tales que P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk). La prueba de este lema se basa en el hecho de que cada monomio de la forma as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, puede ser representado como t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk para algunos Ct, t ∈ {0, 1}k+1. Los detalles se pueden encontrar en la versión completa de este documento [6]. 6.2 Irreducibilidad de la Política de Mejor Respuesta para Tn Si bien la política de mejor respuesta construida en la subsección anterior tiene un tamaño exponencial, no está claro `a priori que sea necesario hacer un seguimiento de todos sus segmentos de línea en lugar de centrarse en un pequeño subconjunto de estos segmentos. Sin embargo, resulta que para algoritmos de dos pasadas como el algoritmo de [8], la política de mejor respuesta no se puede simplificar. Más precisamente, decimos que un algoritmo A es un algoritmo de dos pasadas si 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figura 7: Política de punto de quiebre para V2. • A consta de un paso ascendente y un paso descendente. • Durante el paso ascendente, para cada vértice V con padre W, A construye un conjunto BB(W, V) ⊆ B(W, V). Este conjunto se produce a partir de los conjuntos {BB(V, U) | U es un hijo de V} aplicando el procedimiento desde el principio de la Sección 6 (sustituyendo BB(V, Uj) por B(V, Uj) para todos los hijos Uj de V), y luego posiblemente omitiendo algunos de los puntos del conjunto resultante (que luego se almacena explícitamente). El paso aguas abajo es idéntico al paso aguas abajo de [8] como se describe en la Sección 2, excepto que opera en los conjuntos BB(W, V) en lugar de en los conjuntos B(W, V). El Teorema 7 demuestra que cualquier algoritmo de dos pasadas fallará durante la pasada aguas abajo en Tn si existe un índice j tal que el conjunto BB(Vj+1, Vj) omite algún punto interior de cualquiera de los (al menos 3j) segmentos de B(Vj+1, Vj). Esto implica el Teorema 3. TEOREMA 7. Para cualquier algoritmo de dos pasos A para el cual exista un índice j, j ∈ [1, n/4], un segmento S de B(Vj, Vj−1), y un punto interior (x, y) de S tal que BB(Vj, Vj−1) no contenga (x, y), podemos elegir matrices de pago de los vértices Vj, . . . , Vn para que el paso descendente de A falle, y, además, los pagos a V4j, . . . , Vn sean idénticamente 0. Esbozamos la demostración del Teorema 7; los detalles se pueden encontrar en la versión completa de este artículo [6]. Procedemos por inducción. Para j = 1, el argumento es similar al de la Sección 3. Para el paso inductivo, la idea principal es que podemos enfocarnos en cualquier parte de una política de mejor respuesta (¡incluyendo la parte que fue omitida!) utilizando una función de indiferencia apropiada; esto nos permite reducir el caso j = j0 a j = j0 − 1. En la sección anterior, demostramos que para juegos gráficos en árboles que son casi, pero no del todo, caminos, los algoritmos de dos pasos no logran encontrar equilibrios de Nash en tiempo polinómico. A continuación mostramos que una propiedad de grafo similar a un camino más suave nos permite construir juegos gráficos para los cuales es poco probable que cualquier algoritmo de tiempo polinómico encuentre equilibrios de Nash. 7.1 Ancho de camino Una descomposición de camino de un grafo G = (V, E) es una secuencia de subconjuntos Si(V) ⊆ V tal que para cada arista (v, v') ∈ E, v, v' ∈ Si(V) para algún i, y además, para cada v ∈ V, si v ∈ Si(V) y v ∈ Sj(V) para j > i, entonces v ∈ Sk(V) para todo i ≤ k ≤ j. La descomposición del camino tiene ancho k si todos los conjuntos Si(V) tienen una cardinalidad de a lo sumo k + 1. El ancho de camino de G es el ancho mínimo de cualquier descomposición de camino de G. 107 El ancho de camino es una restricción del ancho de árbol (en el cual se buscaría un árbol cuyos vértices fueran los conjuntos Si(V), y los conjuntos que contienen algún vértice tendrían que formar un subárbol). Para cualquier constante k, se puede decidir en tiempo polinómico si un grafo tiene un ancho de camino (o ancho de árbol) k. Además, muchos problemas de teoría de grafos parecen más fáciles de resolver en tiempo polinómico cuando se restringen a grafos con un ancho de árbol o un ancho de camino fijo, consulte [1] para obtener una visión general. Ten en cuenta que un camino tiene un ancho de camino de 1 y un ciclo tiene un ancho de camino de 2. 7.2 Completitud de PPAD Revisamos algunas definiciones básicas de la teoría de complejidad computacional de problemas de búsqueda. Un problema de búsqueda asocia cualquier entrada (aquí, un juego gráfico) con un conjunto de soluciones (aquí, los equilibrios de Nash del juego de entrada), donde la longitud de la descripción de cualquier solución debe estar acotada de forma polinómica en función de la longitud de la descripción de su entrada. En un problema de búsqueda total, hay una garantía de que al menos una solución existe para cualquier entrada. El teorema de Nash nos asegura que el problema de encontrar equilibrios de Nash es total. Una reducción del problema de búsqueda S al problema S es un mecanismo que muestra que cualquier algoritmo de tiempo polinómico para S implica un algoritmo de tiempo polinómico para S. Consiste en funciones f y g, computables en tiempo polinómico, donde f mapea entradas de S a entradas de S, y g mapea soluciones de S a soluciones de S, de tal manera que si IS es una entrada para S, y SS es una solución para f(IS), entonces g(SS) es una solución para IS. Observe que los problemas de búsqueda total no permiten las reducciones anteriores de problemas como CIRCUIT SAT (donde la entrada es un circuito booleano, y las soluciones son vectores de entrada que hacen que la salida sea verdadera) debido a que CIRCUIT SAT y otros problemas NP-completos tienen entradas con conjuntos de soluciones vacíos. En cambio, el trabajo reciente sobre la complejidad computacional de encontrar un equilibrio de Nash [7, 4, 5, 2, 3] lo ha relacionado con el siguiente problema. Definición 4. FIN DE LA LÍNEA. Circuitos booleanos S y P, cada uno con n bits de entrada y n bits de salida, donde P(0n) = 0n y S(0n) = 0n. Solución: x ∈ {0, 1}n tal que S(x) = x, o alternativamente x ∈ {0, 1}n tal que P(S(x)) = x. S y P pueden ser consideradas como representando sucesor y predecesor. Observe que al calcular Si (0n) (para i = 0, 1, 2, ...) y comparar con P(Si+1 (0n)), eventualmente debemos encontrar una solución para EL FIN DE LA LÍNEA. END OF THE LINE caracteriza la clase de complejidad PPAD (que significa argumento de paridad en un grafo, versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda S es PPAD-completo si END OF THE LINE se reduce a S. Otros problemas PPAD-completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para descripciones más detalladas de estos problemas). 3-GRAPHICAL NASH es el problema de encontrar un equilibrio de Nash para un juego gráfico cuyo grafo tiene grado 3. Daskalakis et al. [4] muestran la completitud de PPAD de NASH 3-GRÁFICO mediante una reducción de BROUWER TRIDIMENSIONAL, introducida en [4] y definida de la siguiente manera. Definición 5. BROUWER TRIDIMENSIONAL. Un circuito C que tiene 3n bits de entrada y 2 bits de salida. Los bits de entrada definen un cubilete del cubo unitario, compuesto por las 3 coordenadas de sus puntos, dadas con una precisión de n bits. La salida representa uno de los cuatro colores asignados por C a un cubito. C está restringido para asignar el color 1 a los cubitos adyacentes al plano (y, z), el color 2 a los cubitos restantes adyacentes al plano (x, z), el color 3 a los cubitos restantes en el plano (x, y), y el color 0 a todos los demás cubitos en la superficie del cubo unitario. Una solución es un vértice pancromático, un vértice adyacente a cubiletes que tienen 4 colores distintos. La razón por la que se garantiza la existencia de una solución es que se puede construir una función de Brouwer asociada φ, es decir, una función continua del cubo unitario a sí mismo, de modo que los vértices pancromáticos correspondan a los puntos fijos de φ. El Teorema del Punto Fijo de Brouwer promete la existencia de un punto fijo. La prueba del Teorema 4 utiliza una modificación de la reducción de [4] de 3-DIMENSIONAL BROUWER a 3-GRAPHICAL NASH. Para demostrar el teorema, comenzamos con algunos resultados preliminares de la siguiente manera. Cada jugador tiene 2 acciones, denominadas 0 y 1. Para un jugador en el vértice V, dejemos que p[V] denote la probabilidad de que el jugador juegue 1. LEMMA 5. [7] Existe un juego gráfico Gshift de tamaño fijo con vértices V, V donde p[V] es la parte fraccionaria de 2p[V]. COROLARIO 1. Existe un juego gráfico Gn−shift de tamaño Θ(n) de ancho de camino constante, con vértices V, Vn donde p[Vn] es la parte fraccionaria de 2n .p[V]. PRUEBA. Crear una cadena de n copias de Gshift en el Lema 5. Cada subconjunto de vértices en la descomposición del camino son los vértices en una copia de Gshift. Que In(x) denote el n-ésimo bit de la expansión binaria de x, donde interpretamos 1 como verdadero y 0 como falso. Lo siguiente utiliza dispositivos de [7, 4]. COROLARIO 2. Existe un valor k tal que para todo n, y para todo n1, n2, n3 ≤ n, existe un juego gráfico de tamaño O(n) con ancho de camino k, teniendo vértices V1, V2, V3 donde p[V3] = p[V1] + 2−n3 (En1 p[V1] ∧ En2 p[V2]). PRUEBA DEL TEOREMA 4. Sea C el circuito booleano que describe una instancia de BROUWER TRIDIMENSIONAL. Sean g1, . . . , gp(n) las compuertas de C indexadas de tal manera que la(s) entrada(s) de cualquier compuerta son la(s) salida(s) de las compuertas de índice inferior. g1, . . . , g3n serán las 3n entradas de C. Todos los jugadores en el juego gráfico G construido en [4] tienen 2 acciones denotadas como 0 y 1. La probabilidad de que V juegue 1 se denota como p[V]. G tiene 3 jugadores Vx, Vy y Vz para los cuales p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto en el cubo unitario. G está diseñado para incentivar a Vx, Vy y Vz a ajustar sus probabilidades en direcciones dadas por una función de Brouwer que está especificada por el circuito C. En un equilibrio de Nash, p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto fijo de una función que pertenece a la clase de funciones representadas por el BROUWER TRIDIMENSIONAL. Para 1 ≤ i ≤ p(n) introducimos un vértice V (i) C tal que para 1 ≤ j ≤ i, Ij(p[V (i) C ]) es la salida de la compuerta gj; para i < j ≤ p(n), Ij(p[V (i) C ]) es 0. Construye V (i) C a partir de V (i−1) C utilizando el Corolario 2. Sea G(i) el juego gráfico que hace esto. Sea S1(G(i)), . . . , Sn(G(i)) una descomposición de camino de longitud n de G(i), donde V(i−1) ⊂ S1(G(i)) y V(i) ⊂ Sn(G(i)). Luego, se obtiene una descomposición de camino de ∪1≤i≤p(n)G(i) tomando la unión de las descomposiciones de camino separadas, junto con Sn(G(i−1) ) ∪ S1(G(i) ) para 2 ≤ i ≤ p(n). Sea GC el juego gráfico anterior que simula C. GC tiene 3n entradas, que consisten en los primeros n bits de las expansiones binarias de p[Vx], p[Vy] y p[Vz]. De manera similar a [4], la salida de GC afecta a Vx, Vy y Vz de la siguiente manera. El color 0 incentiva a Vx, Vy y Vz 108 a ajustar sus probabilidades p[Vx], p[Vy] y p[Vz] en la dirección (−1, −1, −1); el color 2 los incentiva a moverse en la dirección (1, 0, 0); el color 2, dirección (0, 1, 0); el color 3, dirección (0, 0, 1). Necesitamos asegurarnos de que en los puntos en los límites de los cubitos adyacentes, el cambio de dirección será aproximadamente el promedio de las direcciones de los puntos circundantes. De esta manera, los cuatro colores/direcciones deben estar cerca para que puedan anularse entre sí (y estemos en un vértice pancromático). Esto se logra utilizando el mismo truco que [4], en el cual hacemos un número constante M de copias de GC, que difieren en que cada copia agrega un vector de desplazamiento pequeño a sus copias de p[Vx], p[Vy] y p[Vz] (que se derivan del original utilizando el dispositivo de adición de [7]). Usando los dispositivos de suma y multiplicación de [7], promediamos las direcciones y sumamos un pequeño múltiplo de este promedio a (p[Vx], p[Vy], p[Vz]). En un equilibrio de Nash, las salidas de cada copia se cancelarán mutuamente. El ancho de camino del juego completo es a lo sumo M veces el ancho de camino GC. 8. PROBLEMAS ABIERTOS El problema más importante que queda abierto en este artículo es si es posible encontrar un equilibrio de Nash de un juego gráfico en un árbol de grado acotado en tiempo polinómico. Nuestra construcción muestra que cualquier algoritmo de dos pasadas que almacene explícitamente políticas de puntos de quiebre necesita tiempo y espacio exponenciales. Sin embargo, esto no excluye la existencia de un algoritmo que se base en una idea similar, pero en lugar de calcular la política de punto de ruptura completa para cada vértice, utiliza un pequeño número de pasadas adicionales a través del grafo para decidir qué partes (de tamaño polinómico) de cada política de punto de ruptura deben ser calculadas. En particular, dicho algoritmo puede basarse en el algoritmo de aproximación de [8], donde el valor de es elegido de forma adaptativa. Otra pregunta intrigante está relacionada con el hecho de que el grafo para el cual construimos una política de puntos de quiebre de tamaño exponencial tiene un ancho de camino de 2, mientras que nuestros resultados positivos son para un camino, es decir, un grafo de ancho de camino 1. No está claro si para cualquier grafo de grado acotado con ancho de camino 1, el tiempo de ejecución de nuestro algoritmo (versión basada en política de puntos de interrupción) será polinomial. En particular, resulta instructivo considerar un grafo oruga, es decir, el grafo que se puede obtener a partir de Tn al eliminar los vértices S1, . . . , Sn. Para este gráfico, la mejor política de respuesta de un vértice Vk en la columna vertebral de la oruga se obtiene combinando la mejor política de respuesta de su predecesor en la columna vertebral Vk−1 y su otro hijo Tk; dado que este último es una hoja, su mejor política de respuesta es trivial (es decir, [0, 1]2, [0, 1]×{0} o [0, 1]×{1}) o consiste en dos segmentos horizontales y un segmento vertical de la forma {α}×[0, 1] que los conecta. Suponiendo, para mayor comodidad, que B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, y f es la función de indiferencia para Vk, observamos que la política de mejor respuesta para Vk consta de 5 componentes: ˆf(0), ˆf(1), y tres componentes que corresponden a [0, α]×{0}, {α}×[0, 1], y [α, 1]×{1}. Por lo tanto, se puede pensar en la construcción de B(Vk+1, Vk) como el siguiente proceso: girar B(Vk, Vk−1) en π/2, cortarlo a lo largo de la línea (ahora horizontal) vk = α, aplicar una transformación lineal fraccional a la coordenada horizontal de ambas partes y volver a conectarlas usando la imagen del segmento {α}×[0, 1] bajo f. Esto implica que el problema de acotar el tamaño de la política de mejor respuesta (o, alternativamente, la política de punto de quiebre) se puede ver como una generalización del siguiente problema de geometría computacional, que creemos puede ser de interés independiente: PROBLEMA 1. Dada una colección de segmentos paralelos a los ejes en R2, considera la siguiente operación: elige una línea paralela a los ejes li (ya sea vertical u horizontal), corta el plano a lo largo de esta línea y desplaza una de las dos partes resultantes por una cantidad arbitraria δi; como resultado, algunos segmentos se dividirán en dos partes. Reconecte estas partes, es decir, para cada segmento de la forma [a, b] × {c} que fue transformado en [a, t] × {c + δi} y [t, b] × {c}, introduzca un segmento {t} × [c, c+δi]. ¿Es posible comenzar con el segmento [0, 1] y después de n operaciones obtener un conjunto que no pueda representarse como una unión de poli(n) segmentos de línea? ¿En caso afirmativo, puede ser que en este conjunto no haya un camino con un número polinomial de giros que conecte los extremos del segmento original? Resulta que en general, la respuesta a la primera pregunta es positiva, es decir, después de n pasos, es posible obtener un conjunto que consiste en Θ(cn) segmentos para algún c > 0. Esto implica que incluso para una oruga, la mejor política de respuesta puede ser exponencialmente grande. Sin embargo, en nuestro ejemplo (que se omite en esta versión del documento debido a limitaciones de espacio), existe un camino de tamaño polinómico a través de la política de mejor respuesta, es decir, no demuestra que la política de punto de quiebre sea necesariamente exponencial en tamaño. Si se puede demostrar que esto siempre es cierto, puede ser posible adaptar esta prueba para mostrar que puede haber una brecha exponencial entre los tamaños de las políticas de mejor respuesta y las políticas de punto de quiebre. 9. REFERENCIAS [1] H. Bodlaender y T. Kloks. Algoritmos eficientes y constructivos para el ancho de camino y el ancho de árbol de grafos. Revista de Algoritmos, 21:358-402, 1996. [2] X. Chen y X. Deng. 3-NASH es PPAD-completo. Informe técnico TR-05-134, Coloquio Electrónico en Complejidad Computacional, 2005. [3] X. Chen y X. Deng. Resolviendo la complejidad del equilibrio de Nash de 2 jugadores. Informe técnico TR-05-140, Coloquio Electrónico en Complejidad Computacional, 2005. [4] C. Daskalakis, P. Goldberg y C. Papadimitriou. La complejidad de calcular un equilibrio de Nash. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [5] C. Daskalakis y C. Papadimitriou. Los juegos de tres jugadores son difíciles. Informe técnico TR-05-139, Coloquio Electrónico en Complejidad Computacional, 2005. [6] E. Elkind, L. Goldberg y P. Goldberg. Equilibrios de Nash en juegos gráficos en árboles revisados. Informe técnico TR-06-005, Coloquio Electrónico en Complejidad Computacional, 2006. [7] P. Goldberg y C. Papadimitriou. Reductibilidad entre problemas de equilibrio. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [8] M. Kearns, M. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, 2001. [9] M. Littman, M. Kearns y S. Singh. Un algoritmo exacto eficiente para juegos gráficos de conexión simple. En Actas de la 15ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2001. [10] L. Ortiz y M. Kearns. Propagación de Nash para juegos gráficos con bucles. En Actas de la 17ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2003. [11] C. Papadimitriou. Sobre la complejidad del argumento de paridad y otras demostraciones ineficientes de existencia. J. Comput. This is not a complete sentence. Please provide more context or the full sentence you would like me to translate. Cienc., 48(3):498-532, 1994. 109",
    "original_sentences": [
        "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
        "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
        "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
        "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
        "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
        "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
        "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
        "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
        "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
        "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
        "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
        "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
        "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
        "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
        "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
        "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
        "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
        "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
        "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
        "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
        "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
        "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
        "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
        "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
        "By the end of the upstream pass, all children of the root have computed their best response policies.",
        "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
        "It also selects a strategy for each child.",
        "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
        "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
        "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
        "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
        "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
        "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
        "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
        "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
        "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
        "We can improve the running time of the generic algorithm using the ideas of [9].",
        "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
        "We obtain the following theorem THEOREM 1.",
        "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
        "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
        "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
        "THEOREM 2.",
        "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
        "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
        "Even when the tree has bounded degree, the running time can be exponential.",
        "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
        "In particular, we show the following.",
        "THEOREM 3.",
        "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
        "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
        "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
        "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
        "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
        "We prove the following theorem.",
        "THEOREM 4.",
        "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
        "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
        "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
        "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
        "Each vertex has two actions, which are denoted by 0 and 1.",
        "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
        "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
        "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
        "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
        "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
        "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
        "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
        "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
        "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
        "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
        "The root selects any pair (w, v) from B(W, V ).",
        "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
        "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
        "ALGORITHM OF LITTMAN ET AL.",
        "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
        "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
        "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
        "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
        "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
        "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
        "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
        "We say such a breakpoint policy has t − 1 breakpoints.",
        "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
        "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
        "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
        "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
        "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
        "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
        "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
        "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
        "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
        "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
        "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
        "The thick connected path is the corresponding breakpoint policy.",
        "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
        "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
        "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
        "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
        "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
        "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
        "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
        "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
        "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
        "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
        "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
        "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
        "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
        "Any other trimming would be just as bad.",
        "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
        "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
        "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
        "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
        "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
        "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
        "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
        "In the next section, we show that it runs in polynomial time on a path. 4.",
        "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
        "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
        "THEOREM 5.",
        "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
        "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
        "PROOF.",
        "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
        "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
        "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
        "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
        "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
        "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
        "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
        "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
        "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
        "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
        "In this case, P0 > P1 if and only if A1u + A0 < 0.",
        "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
        "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
        "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
        "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
        "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
        "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
        "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
        "Assume for now that A1 > 0; the other two cases can be treated similarly.",
        "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
        "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
        "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
        "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
        "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
        "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
        "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
        "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
        "The set B(W, V )|V =1 can be described in a similar manner.",
        "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
        "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
        "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
        "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
        "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
        "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
        "Sometimes we drop the subscript V when it is clear from the context.",
        "LEMMA 1.",
        "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
        "PROOF.",
        "Fix an arbitrary v ∈ (0, 1).",
        "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
        "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
        "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
        "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
        "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
        "Choose u = vj−1; by construction, u ∈ pbrU (v).",
        "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
        "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
        "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
        "LEMMA 2.",
        "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
        "PROOF.",
        "Consider an arbitrary u0 ∈ pbrU (0).",
        "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
        "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
        "The argument for the case B(u0) < 0 is similar.",
        "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
        "Note that for any such vector we have vj−1 ∈ pbrU (0).",
        "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
        "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
        "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
        "The argument for ˆf(1) is similar.",
        "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
        "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
        "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
        "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
        "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
        "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
        "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
        "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
        "The case limu→u∗− f(u) = −∞ is similar.",
        "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
        "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
        "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
        "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
        "Hence, B(W, V ) has at most 2j + 4 event points.",
        "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
        "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
        "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
        "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
        "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
        "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
        "Definition 3.",
        "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
        "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
        "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
        "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
        "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
        "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
        "THEOREM 6.",
        "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
        "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
        "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
        "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
        "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
        "For i ≤ k let vi denote the probability that Vi plays 1.",
        "The first search can be done as follows.",
        "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
        "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
        "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
        "Apply the upstream pass to P 4.",
        "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
        "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
        "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
        "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
        "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
        "Choose any vertex Vi.",
        "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
        "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
        "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
        "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
        "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
        "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
        "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
        "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
        "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
        "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
        "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
        "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
        "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
        "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
        "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
        "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
        "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
        "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
        "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
        "In the rest of this subsection, we describe this construction.",
        "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
        "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
        "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
        "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
        "LEMMA 3.",
        "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
        "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
        "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
        "PROOF.",
        "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
        "Now, suppose it is true for B(Vk, Vk−1).",
        "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
        "Let us examine them in turn.",
        "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
        "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
        "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
        "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
        "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
        "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
        "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
        "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
        "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
        "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
        "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
        "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
        "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
        "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
        "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
        "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
        "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
        "LEMMA 4.",
        "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
        "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
        "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
        "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
        "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
        "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
        "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
        "This implies Theorem 3.",
        "THEOREM 7.",
        "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
        "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
        "We proceed by induction.",
        "For j = 1, the argument is similar to that in Section 3.",
        "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
        "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
        "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
        "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
        "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
        "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
        "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
        "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
        "In a total search problem, there is a guarantee that at least one solution exists for any input.",
        "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
        "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
        "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
        "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
        "Definition 4.",
        "END OF THE LINE.",
        "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
        "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
        "S and P can be thought of as standing for successor and predecessor.",
        "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
        "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
        "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
        "Definition 5. 3-DIMENSIONAL BROUWER.",
        "Input: a circuit C having 3n input bits and 2 output bits.",
        "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
        "The output represents one of four colours assigned by C to a cubelet.",
        "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
        "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
        "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
        "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
        "To prove the theorem, we begin with some preliminary results as follows.",
        "Each player has 2 actions, denoted 0 and 1.",
        "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
        "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
        "COROLLARY 1.",
        "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
        "PROOF.",
        "Make a chain of n copies of Gshift in Lemma 5.",
        "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
        "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
        "The following uses gadgets from [7, 4].",
        "COROLLARY 2.",
        "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
        "PROOF OF THEOREM 4.",
        "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
        "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
        "The probability that V plays 1 is denoted p[V ].",
        "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
        "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
        "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
        "Construct V (i) C from V (i−1) C using Corollary 2.",
        "Let G(i) be the graphical game that does this.",
        "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
        "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
        "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
        "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
        "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
        "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
        "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
        "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
        "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
        "At a Nash equilibrium the outputs of each copy will cancel each other out.",
        "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
        "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
        "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
        "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
        "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
        "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
        "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
        "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
        "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
        "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
        "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
        "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
        "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
        "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
        "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
        "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
        "This implies that even for a caterpillar, the best response policy can be exponentially large.",
        "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
        "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
        "REFERENCES [1] H. Bodlaender and T. Kloks.",
        "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
        "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
        "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
        "Settling the complexity of 2-player Nash equilibrium.",
        "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
        "The complexity of computing a Nash equilibrium.",
        "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
        "Three-player games are hard.",
        "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
        "Nash equilibria in graphical games on trees revisited.",
        "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
        "Reducibility among equilibrium problems.",
        "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
        "Graphical models for game theory.",
        "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
        "An efficient exact algorithm for singly connected graphical games.",
        "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
        "Nash propagation for loopy graphical games.",
        "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
        "On the complexity of the parity argument and other inefficient proofs of existence.",
        "J. Comput.",
        "Syst.",
        "Sci., 48(3):498-532, 1994. 109"
    ],
    "translated_text_sentences": [
        "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos.",
        "Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores.",
        "Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema.",
        "En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado.",
        "Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos.",
        "El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente.",
        "Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico.",
        "Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash.",
        "Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2.",
        "Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado.",
        "Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2.",
        "Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable).",
        "Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1.",
        "INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores.",
        "La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala.",
        "Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores.",
        "Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol.",
        "El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico.",
        "Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas.",
        "Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1.",
        "Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2).",
        "La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V.",
        "El algoritmo genérico no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema.",
        "El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk.",
        "Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta.",
        "Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección.",
        "También selecciona una estrategia para cada niño.",
        "Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz.",
        "El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos.",
        "La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre.",
        "Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico.",
        "La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto.",
        "En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente.",
        "En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta.",
        "La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2).",
        "Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del algoritmo genérico de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino).",
        "Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9].",
        "En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un juego gráfico en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario).",
        "Obtenemos el siguiente teorema TEOREMA 1.",
        "Existe un algoritmo O(n2) que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un camino de n vértices.",
        "Existe un algoritmo O(n3) que calcula una representación de todos los equilibrios de Nash de dicho juego.",
        "En la Sección 5 extendemos los resultados de la Sección 4 a grafos de grado 2 en general, obteniendo el siguiente teorema.",
        "TEOREMA 2.",
        "Existe un algoritmo de tiempo polinómico que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un grafo con grado máximo 2.",
        "En la Sección 6 ampliamos nuestro algoritmo para que pueda ser utilizado para encontrar un equilibrio de Nash de un juego gráfico en un árbol arbitrario.",
        "Incluso cuando el árbol tiene grado acotado, el tiempo de ejecución puede ser exponencial.",
        "Mostramos que esto es inevitable construyendo una familia de juegos gráficos en árboles de grado acotado para los cuales las políticas de mejor respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de dos pasos (es decir, un algoritmo que es similar en espíritu al de [8]) tiene que almacenar casi todos los puntos de las políticas de mejor respuesta.",
        "En particular, mostramos lo siguiente.",
        "TEOREMA 3.",
        "Existe una familia infinita de juegos gráficos en árboles de grado acotado con ancho de camino 2, tal que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales.",
        "Es interesante notar que los árboles utilizados en la demostración del Teorema 3 tienen un ancho de camino de 2, es decir, están muy cerca de ser caminos.",
        "Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico para grafos de ancho de camino 1.",
        "Esta pregunta puede ser vista como una generalización de un problema muy natural de geometría computacional; lo describimos con más detalle en la Sección 8.",
        "En la Sección 7, presentamos un resultado de intractabilidad teórica de complejidad para el problema de encontrar un equilibrio de Nash de un juego gráfico en un grafo con un ancho de camino pequeño.",
        "Demostramos el siguiente teorema.",
        "TEOREMA 4.",
        "Considera el problema de encontrar un equilibrio de Nash para un juego gráfico en el cual el grafo subyacente tiene un grado máximo de 3 y un ancho de camino k. Existe una constante k tal que este problema es PPAD-completo.",
        "El teorema 4 limita la medida en que podemos explotar las propiedades de tipo camino del grafo subyacente para encontrar equilibrios de Nash.",
        "Para demostrar el Teorema 4, utilizamos resultados recientes de completitud de PPAD para juegos, en particular los artículos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de grado d (para d ≥ 3) es computacionalmente equivalente al problema de resolver juegos en forma normal de r jugadores (para r ≥ 4), ambos de los cuales son PPAD-completos.",
        "CONSIDERACIONES PREVIAS Y NOTACIÓN Consideramos juegos gráficos en los que el grafo subyacente G es un árbol de n vértices.",
        "Cada vértice tiene dos acciones, que se denotan como 0 y 1.",
        "Una estrategia mixta se define por un único número x ∈ [0, 1], que indica la probabilidad de que el jugador seleccione la acción 1.",
        "Para los propósitos del algoritmo, el árbol está enraizado de manera arbitraria.",
        "Para mayor comodidad, asumimos sin pérdida de generalidad que la raíz tiene un solo hijo y que su recompensa es independiente de la acción elegida por el hijo.",
        "Esto se puede lograr primero eligiendo una raíz arbitraria del árbol, y luego agregando un padre ficticio de esta raíz, asignándole una función de pago constante.",
        "Dado un borde (V, W) del árbol G, y una estrategia mixta w para W, sea G(V,W), W=w la instancia obtenida de G mediante (1) eliminar todos los nodos Z que están separados de V por W (es decir, todos los nodos Z tales que el camino de Z a V pasa por W), y (2) restringir la instancia de modo que se requiera que W juegue la estrategia mixta w. Definición 1.",
        "Supongamos que (V, W) es un borde del árbol, que v es una estrategia mixta para V y que w es una estrategia mixta para W. Decimos que v es una mejor respuesta potencial para w (indicado por v ∈ pbrV(w)) si hay un equilibrio en la instancia G(V, W), W = w en el que V tiene la estrategia mixta v. Definimos la política de mejor respuesta para V, dada W, como B(W, V) = {(w, v) | v ∈ pbrV(w), w ∈ [0, 1]}.",
        "Normalmente, W es el padre de V, y esto se conoce simplemente como la política de mejor respuesta para V.",
        "La expresión B(W, V )|V =v se utiliza para denotar el conjunto B(W, V ) ∩ [0, 1]×{v}.",
        "El paso ascendente del algoritmo genérico de [8] calcula la política de mejor respuesta para V en cada nodo V que no sea la raíz.",
        "Con las suposiciones anteriores sobre la raíz, el paso aguas abajo es sencillo: Sea W la raíz y V su hijo.",
        "La raíz selecciona cualquier par (w, v) de B(W, V).",
        "Decide jugar con la estrategia mixta w e instruye a V a jugar con la estrategia mixta v. El resto del paso descendente es recursivo.",
        "Cuando un nodo V recibe instrucciones de su padre para adoptar la estrategia mixta v, hace lo siguiente para cada hijo U: encuentra un par (v, u) ∈ B(V, U) (con el mismo valor de v que le fue dado por su padre) e instruye a U a jugar u.",
        "ALGORITMO DE LITTMAN ET AL.",
        "El algoritmo de [9] se basa en la siguiente observación: para calcular un equilibrio de Nash único mediante un algoritmo de dos pasos, no es necesario construir la política de mejor respuesta completa para cada vértice.",
        "Si, en cada paso de la pasada descendente, el vértice en consideración puede seleccionar un vector de estrategias para todos sus hijos de manera que la estrategia de cada hijo sea una mejor respuesta potencial a la estrategia del padre, el algoritmo logra producir un equilibrio de Nash.",
        "Esto se puede lograr si, al comienzo del paso aguas abajo, tenemos una estructura de datos en la que cada vértice V con padre W almacena un conjunto ˆB(W, V ) ⊆ B(W, V ) (llamado una política de puntos de quiebre) que cubre cada posible w ∈ [0, 1].",
        "Mostraremos más adelante que una condición suficiente para la construcción de una estructura de datos así es la invariante de que, en cada nivel del paso ascendente, ˆB(W, V) contiene un camino continuo desde w = 0 hasta w = 1.",
        "En [9], se sugiere que podemos seleccionar la política de punto de quiebre de una manera particular.",
        "Es decir, el documento utiliza la siguiente definición: Definición 2. (cf. [9]) Una política de puntos de ruptura para un nodo V con padre W consiste en un conjunto ordenado de puntos de ruptura de W, w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 y un conjunto asociado de valores de V, v1, . . . , vt.",
        "La interpretación es que para cualquier w ∈ [0, 1], si wi−1 < w < wi para algún índice i y W juega w, entonces V deberá jugar vi; y si w = wi para algún índice i, entonces V deberá jugar cualquier valor entre vi y vi+1.",
        "Decimos que una política de punto de quiebre tiene t - 1 puntos de quiebre.",
        "El artículo luego afirma que cualquier vértice V puede calcular su política de punto de interrupción con respecto a su padre W dadas las políticas de punto de interrupción de sus hijos U1, . . . , Uk.",
        "La prueba procede ordenando los puntos de quiebre de los niños (es decir, los valores respectivos de v) de izquierda a derecha (se puede asumir sin pérdida de generalidad que todos estos puntos de quiebre son distintos) y considerándolos sucesivamente; cada punto vl ∈ {v1, . . . , vL} corresponde a una elección fija de estrategias para k − 1 niños y un intervalo de estrategias admisibles para un niño.",
        "Supongamos, para mayor comodidad, que este niño es U1 y su intervalo de estrategias admisibles en vl es [a, b]; supongamos también que para Uj, j = 2, . . . , k, sus respectivas políticas de puntos de quiebre les prescriben jugar uj en respuesta a vl.",
        "Sea P i (u, w), i = 0, 1, el pago esperado para V cuando V juega i, U1 juega u, cada Uj, j = 2, . . . , k, juega uj, y W juega w, y considera el conjunto Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] tal que",
        "P 0 (u, w) = P1 (u, w)}; nota que para cualquier w ∈ Wl tenemos vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figura 1: LKS: Recorte para encontrar políticas de puntos de quiebre.",
        "Los autores muestran que para cualquier punto de quiebre vl, el conjunto Wl está vacío, es un solo intervalo, o es una unión de dos intervalos no flotantes (un intervalo es no flotante si uno de sus extremos es 0 o 1); además, la unión de todos los conjuntos Wl, l = 1, . . . , L, cubre el intervalo [0, 1].",
        "Se sigue fácilmente que se puede cubrir [0, 1] con a lo sumo L+2 intervalos, cada uno de los cuales es un subconjunto de algún Wl.",
        "Los autores afirman entonces que cualquier cobertura de este tipo puede ser transformada en una política de puntos de ruptura para V.",
        "Es decir, afirman que para cualquier par de intervalos Wl1 y Wl2 en la cobertura, cualquier superposición entre Wl1 y Wl2 puede asignarse arbitrariamente a la cobertura por Wl1 y Wl2 recortados en consecuencia (cf. [9], p. 5).",
        "Ellos ilustran su enfoque en una figura, la cual se reproduce como Figura 1 aquí.",
        "En la figura, las líneas horizontales discontinuas representan los puntos de quiebre v1, v2, . . . , v7 y los intervalos sólidos a lo largo de estos puntos de quiebre son los conjuntos W1, W2, . . . , W7.",
        "El camino grueso conectado es la política de punto de quiebre correspondiente.",
        "Se elige de la siguiente manera: comenzar en la izquierda y siempre saltar al intervalo que permita el mayor avance hacia la derecha.",
        "Para entender por qué este enfoque no funciona en general, considera un camino de longitud 4 que consiste en una raíz indiferente R, su hijo W, el hijo de W V y el hijo de V U.",
        "Supongamos que U recibe un pago de 1 si juega de manera diferente a V y 0 en caso contrario.",
        "Así, si v denota la estrategia mixta de V (es decir, V juega 1 con probabilidad v), entonces la ganancia esperada que U obtiene al jugar 0 se da por P0(U) = v y la ganancia esperada que U obtiene al jugar 1 se da por P1(U) = 1 − v. Supongamos que V no obtiene ganancia al jugar 1 (por lo que P1(V) = 0) y que su matriz de ganancias al jugar 0 es 1 −9 9 −1, entonces si u denota la estrategia mixta de U y w denota la estrategia mixta de W, la ganancia esperada que V obtiene al jugar 0 se da por P0(V) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
        "Usando las técnicas de [8] (o, alternativamente, las de la Sección 4), no es difícil verificar que las políticas de mejor respuesta para U y V (como en la Definición 1) están dadas por los gráficos en la Figura 2.",
        "La mejor política de respuesta para U es una política de punto de quiebre para U (como en la Definición 2) con puntos de quiebre V v0 = 0, v1 = 1/2 y v2 = 1 con valores asociados u1 = 1 y u2 = 0.",
        "La mejor política de respuesta para V no es una política de punto de quiebre (debido a cómo la curva de w = 0 a w = 1 retrocede).",
        "El algoritmo LKS recortaría para obtener una política de puntos de quiebre como la que se muestra en la Figura 3.",
        "Se observa que esta política de punto de quiebre ˆB(W, V) es inválida en el sentido de que no satisface ˆB(W, V) ⊆ B(W, V). El punto es que la matriz de pagos de W ahora puede ser elegida para evitar que el algoritmo LKS encuentre un equilibrio de Nash.",
        "Por ejemplo, supongamos que las ganancias se dan de tal manera que P0 (W) = v y P1 (W) = (1−v)2.",
        "La mejor política de respuesta para W es una línea horizontal en w = 0.1 (Este es el valor de w que permite v = 2/3 - ver Figura 2, lo que hace que P0 (W) = P1 (W).)",
        "En el paso descendente, los valores elegidos son w = .1, luego, a partir del recorte, v = 0 y u = 1, lo cual no es un equilibrio de Nash ya que W prefiere la acción 1.",
        "El fallo del algoritmo no se debe al hecho de que la política de recorte llegue tan lejos a la derecha como sea posible.",
        "Cualquier otro recorte sería igual de malo.",
        "Por ejemplo, supongamos que la política de punto de quiebre para V tiene v = 0 hasta algún punto w∗ < .9 y luego salta a v = 1.",
        "El algoritmo es entonces derrotado por la matriz de pagos con P0(W) = 2v y P1(W) = (1 − v) en la que la política de mejor respuesta para W es una línea horizontal en w = .9.",
        "El algoritmo luego da w = .9, v = 1, y u = 0, lo cual no es un equilibrio de Nash ya que W prefiere la acción 0.",
        "Concluimos que el algoritmo LKS no siempre encuentra un equilibrio de Nash.",
        "En las Secciones 4 y 6 mostramos cómo modificar el algoritmo para que siempre encuentre un equilibrio de Nash.",
        "Para el algoritmo modificado, debemos extender la definición de la política de punto de quiebre (ver Definición 3) para que incluya políticas de punto de quiebre como la política de mejor respuesta para V en la Figura 2.",
        "Desafortunadamente, una política de punto de interrupción de este tipo puede ser exponencial en tamaño (ver Figura 7), por lo que el algoritmo corregido no se ejecuta en tiempo polinómico en todos los árboles.",
        "En la siguiente sección, mostramos que se ejecuta en tiempo polinómico en un camino. 4.",
        "ENCONTRANDO EQUILIBRIOS EN UN CAMINO En esta sección, nos enfocamos en el caso en el que el grafo subyacente es un camino, es decir, su conjunto de vértices es {V1, . . . , Vn}, y su conjunto de aristas es {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
        "Mostramos que en este caso la mejor política de respuesta para cada vértice puede ser representada como una unión de un número polinomial de rectángulos, donde un rectángulo está definido por un par de intervalos cerrados (IV, IU) y consiste en todos los puntos en IV × IU; puede ser el caso de que uno o ambos de los intervalos IV e IU consistan en un solo punto.",
        "TEOREMA 5.",
        "Para cualquier j = 1, . . . , n, el conjunto B(Vj , Vj−1) puede ser representado como una unión disjunta de a lo sumo (j + 4)2 rectángulos.",
        "Además, dado tal representación de B(Vj , Vj−1), se puede calcular una representación de B(Vj+1, Vj) en tiempo O(j2).",
        "PRUEBA.",
        "Para cualquier conjunto A ⊆ [0, 1]2 que esté representado como una unión de un número finito de rectángulos, decimos que un punto u ∈ [0, 1] en el eje U es un punto de evento U de A si u = 0 o u = 1 o A contiene un rectángulo de la forma IV × IU y u es un extremo de IU; los puntos de evento V se definen de manera similar.",
        "Observa que para cualquier u ∈ [0, 1], el número de componentes conectadas de [0, 1]×{u} ∩ A es a lo sumo el número de puntos de V-evento de A.",
        "Utilizamos inducción en j para demostrar que para cada Vj se cumple la afirmación del teorema y, además, cada B(Vj, Vj−1) tiene como máximo 2j + 4 puntos de evento.",
        "Para simplificar el caso base, modificamos el juego gráfico agregando un vértice ficticio V0 al principio del camino: el único vecino de V0 es V1, las ganancias de V0 siempre son iguales a 0, y las ganancias de todos los demás vértices (incluido V1) son las mismas que en el juego original.",
        "Para j = 0, tenemos B(V1, V0) = [0, 1]2, por lo que la afirmación del teorema es trivialmente verdadera.",
        "Ahora, supongamos que j > 0, establezca V = Vj y permita que U = Vj−1 y W = Vj+1 sean los vértices que preceden y siguen a V, respectivamente.",
        "Los pagos para V están descritos por una matriz 2×2×2 P: Pxyz es el pago que V recibe cuando U juega x, V juega y, y W juega z, donde x, y, z ∈ {0, 1}.",
        "Supongamos que U juega 1 con probabilidad u y W juega 1 con probabilidad w. Entonces la ganancia esperada de V al jugar 0 es P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, mientras que su ganancia esperada al jugar 1 es P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
        "Si P0 > P1, V prefiere estrictamente jugar 0; si P0 < P1, V prefiere estrictamente jugar 1; y si P0 = P1, V es indiferente, es decir, puede jugar cualquier estrategia (mixta).",
        "Dado que P0 y P1 son lineales en w y u, existen algunas constantes A1, A0, B1 y B0 que dependen de la matriz P, pero no de u y w, de modo que P0 − P1 = w(B1u + B0) − (A1u + A0). Dependiendo de los valores de A1, A0, B1 y B0, subdividimos el resto de la prueba en los siguientes casos. • B1 = 0, B0 = 0.",
        "En este caso, P0 > P1 si y solo si A1u + A0 < 0.",
        "Si también A1 = 0, A0 = 0, claramente, B(W, V) = [0, 1]2, y la afirmación del teorema es trivialmente verdadera.",
        "De lo contrario, el vértice V es indiferente entre 0 y 1 si y solo si A1 = 0 y u = −A0/A1.",
        "Sea V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
        "Por la hipótesis inductiva, V consiste en a lo sumo 2(j − 1) + 4 segmentos y puntos aislados.",
        "Para cualquier v ∈ V, tenemos B(W, V)|V = v = [0, 1]: no importa lo que juegue W, siempre y cuando U esté jugando −A0/A1, V está contento de jugar v. Por otro lado, para cualquier v ∈ (0, 1) \\ V tenemos B(W, V)|V = v = ∅: cuando V juega v, U solo puede responder con u = −A0/A1, en cuyo caso V puede beneficiarse cambiando a una de las estrategias puras.",
        "Para completar la descripción de B(W, V), queda por analizar los casos v = 0 y v = 1.",
        "El vértice V prefiere jugar 0 si A1 > 0 y u ≤ −A0/A1, o A1 < 0 y u ≥ −A0/A1, o 103 A1 = 0 y A0 < 0.",
        "Supongamos por ahora que A1 > 0; los otros dos casos pueden ser tratados de manera similar.",
        "En este caso, 0 ∈ pbrV (w) para algún w ∈ [0, 1] si y solo si existe un u ∈ pbrU (0) tal que u ≤ −A0/A1: si no existe tal u, cada vez que V juega 0, la respuesta de U no está en pbrU (0) o V puede mejorar su recompensa jugando 1.",
        "Por lo tanto, o bien B(W, V)|V=0 = [0, 1] o B(W, V)|V=0 = ∅.",
        "De manera similar, B(W, V)|V=1 es igual a [0, 1] o ∅, dependiendo de pbrU(1).",
        "Por lo tanto, el conjunto B(W, V) consiste en un máximo de 2j + 4 ≤ (j + 4)2 rectángulos: B(W, V) ∩ [0, 1]×(0, 1) = [0, 1]×V contribuye como máximo con 2j + 2 rectángulos, y cada uno de los conjuntos B(W, V)|V=0 y B(W, V)|V=1 contribuye como máximo con un rectángulo.",
        "De manera similar, su número total de puntos de evento es a lo sumo 2j + 4: los únicos puntos de evento W son 0 y 1, cada punto de evento V de B(W, V) es un punto de evento V de B(V, U), y hay a lo sumo 2j + 2 de ellos. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 para algún α ∈ R. En este caso, V es indiferente entre 0 y 1 si y solo si w = α, o B1 = 0 y u = −B0/B1 = −A0/A1.",
        "De manera similar al caso anterior, podemos mostrar que B(W, V)∩[0, 1]×(0, 1) consiste en el rectángulo {α}×[0, 1] y como máximo 2j + 2 rectángulos de la forma [0, 1]×IV, donde cada IV corresponde a un componente conectado de B(V, U)|U=−B0/B1.",
        "Además, V prefiere jugar 0 si B1u + B0 > 0 y w ≥ α o B1u + B0 < 0 y w ≤ α.",
        "Por lo tanto, si B1u∗ + B0 > 0 para algún u∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [α, +∞) ∩ [0, 1] y si B1u∗∗ + B0 < 0 para algún u∗∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [−∞, α] ∩ [0, 1]; si ambos u∗ y u∗∗ existen, B(W, V )|V =0 = [0, 1].",
        "El conjunto B(W, V)|V=1 se puede describir de manera similar.",
        "Por la hipótesis inductiva, B(V, U) tiene a lo sumo 2j + 2 puntos de evento; dado que al menos dos de estos son puntos de evento U, tiene a lo sumo 2j puntos de evento V.",
        "Dado que cada punto de evento V de B(W, V) es un punto de evento V de B(V, U) y B(W, V) tiene como máximo 3 puntos de evento W (0, 1 y α), su número total de puntos de evento es como máximo 2j + 3 < 2j + 4.",
        "Además, de manera similar al caso anterior, se sigue que B(W, V) consiste en un máximo de 2j + 4 < (j + 4)2 rectángulos. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
        "En este caso, se puede definir la función de indiferencia f(·) como f(u) = A(u) B(u) = A1u+A0 B1u+B0, donde A(u) y B(u) nunca se anulan simultáneamente.",
        "Observa que siempre que w = f(u) y u, w ∈ [0, 1], V es indiferente entre jugar 0 y 1.",
        "Para cualquier A ⊆ [0, 1]2, definimos una función ˆfV por ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; nota que ˆfV mapea subconjuntos de [0, 1]2 a subconjuntos de R×[0, 1].",
        "A veces omitimos el subíndice V cuando es evidente por el contexto.",
        "LEMMA 1. \n\nLEMMA 1.",
        "Para cualquier (w, v) ∈ [0, 1]×(0, 1) tenemos que (w, v) ∈ B(W, V) si y solo si existe un u ∈ [0, 1] tal que (v, u) ∈ B(V, U) y w = f(u).",
        "PRUEBA.",
        "Fije un v arbitrario en (0, 1).",
        "Supongamos que U juega algún u ∈ pbrU (v), w = f(u) satisface w ∈ [0, 1], y W juega w. Existe un vector de estrategias v1, . . . , vj−1 = u, vj = v tal que para cada Vk, k < j, su estrategia es una mejor respuesta a las estrategias de sus vecinos.",
        "Dado que w = f(u), V es indiferente entre jugar 0 y 1; en particular, puede jugar v. Por lo tanto, si definimos vj+1 = w, el vector de estrategias (v1, . . . , vj+1) cumplirá las condiciones en la definición de mejor respuesta potencial, es decir, tenemos v ∈ pbrV (w).",
        "Por el contrario, supongamos que v ∈ pbrV (w) para algún w ∈ [0, 1], v = 0, 1.",
        "Entonces existe un vector de estrategias v1, . . . , vj−1, vj = v, vj+1 = w tal que para cada Vk, k ≤ j, su estrategia es una mejor respuesta a las estrategias de sus vecinos.",
        "Dado que v = 0, 1, V, de hecho, es indiferente entre jugar 0 y 1, lo cual solo es posible si w = f(vj−1).",
        "Elige u = vj−1; por construcción, u ∈ pbrU (v).",
        "El lema 1 describe las situaciones en las que V es indiferente entre jugar 0 y jugar 1.",
        "Sin embargo, para caracterizar completamente B(W, V), también necesitamos saber cuándo V prefiere una estrategia pura.",
        "Define ˆf(0) = ∪u∈pbrU (0)Ru, donde Ru = ´ [f(u), +∞)×{0} si B(u) > 0, (−∞, f(u)]×{0} si B(u) < 0. y ˆf(1) = ∪u∈pbrU (1)Ru, donde Ru = ´ [f(u), +∞)×{1} si B(u) < 0, (−∞, f(u)]×{1} si B(u) > 0.",
        "LEMMA 2. \n\nLEMMA 2.",
        "Para cualquier w ∈ [0, 1], tenemos que (w, 0) ∈ ˆf(0) si y solo si 0 ∈ pbrV (w) y (w, 1) ∈ ˆf(1) si y solo si 1 ∈ pbrV (w).",
        "PRUEBA.",
        "Considera un u0 arbitrario ∈ pbrU (0).",
        "Si B(u0) > 0, para u = u0 la desigualdad P0 ≥ P1 es equivalente a w ≥ f(u0).",
        "Por lo tanto, cuando U juega u0 y W juega w, w ≥ f(u0), V prefiere jugar 0; dado que u0 ∈ pbrU (u), se sigue que 0 ∈ pbrV (w).",
        "El argumento para el caso B(u0) < 0 es similar.",
        "Por el contrario, si 0 ∈ pbrV (w) para algún w ∈ [0, 1], existe un vector (v1, . . . , vj−1, vj = 0, vj+1 = w) tal que para cada Vk, k ≤ j, Vk juega vk, y esta estrategia es una mejor respuesta a las estrategias de los vecinos de Vk.",
        "Ten en cuenta que para cualquier vector de este tipo tenemos vj−1 ∈ pbrU (0).",
        "Por contradicción, asumimos que (w, 0) ∈ Ë u∈pbrU (0) Ru.",
        "Entonces debe ser el caso que para cualquier u0 ∈ pbrU (0) ya sea que f(u0) < w y Ru0 = (−∞, f(u0)]×{0} o f(u0) > w y Ru0 = [f(u0), +∞)×{0}.",
        "En ambos casos, cuando V juega 0, U juega u0, y V juega w, la desigualdad entre f(u0) y w es equivalente a P0 < P1, es decir, V se beneficiaría al cambiar a 1.",
        "El argumento para ˆf(1) es similar.",
        "Juntas, el Lema 1 y el Lema 2 describen completamente el conjunto B(W, V): tenemos B(W, V) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2.",
        "Queda por demostrar que B(W, V) puede representarse como una unión de como máximo (j + 4)2 rectángulos, tiene como máximo 2j + 4 puntos de evento, y puede ser calculado en tiempo O(j2).",
        "Sea u∗ = −B0/B1. Considera un rectángulo arbitrario R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
        "Si u∗ ∈ [u1, u2], la función f(·) es continua en [u1, u2] y por lo tanto ˆf(R) = [fmin, fmax]×[v1, v2], donde fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste en un solo rectángulo.",
        "Ahora, supongamos que R es intersectado por la línea [0, 1]×{u∗}; como se mencionó anteriormente, hay a lo sumo 2j+2 rectángulos de este tipo.",
        "Se supone que limu→u∗− f(u) = +∞; dado que f(·) es una función lineal fraccional, esto implica que limu→u∗+ f(u) = −∞ y también f(u1) > f(u2).",
        "Dado que f(·) es continua en [u1, u∗ ) y (u∗ , u2], es fácil ver que ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2]. El caso B1 = 0 no causa problemas especiales.",
        "Para completitud, establezca u∗ como cualquier valor fuera de [0, 1] en este caso. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figura 4: f es creciente en (−∞, u∗ ) y (u∗ , +∞). y ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste de a lo sumo dos rectángulos.",
        "El caso limu→u∗− f(u) = −∞ es similar.",
        "Dado que ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), se sigue que ˆf(B(V, U)) consiste en un máximo de (j + 3)2 + 2j + 2 rectángulos.",
        "Además, es fácil ver que tanto ˆf(0) como ˆf(1) consisten en un máximo de 2 segmentos de línea cada uno.",
        "Concluimos que B(W, V) puede ser representado como una unión de a lo sumo (j + 3)2 + 2j + 6 < (j + 4)2 rectángulos.",
        "Además, si v es un punto de evento V de B(W, V), entonces v es un punto de evento V de B(V, U) (esto incluye los casos v = 0 y v = 1, ya que 0 y 1 son puntos de evento V de B(V, U)) y si w es un punto de evento W de B(W, V), entonces o bien w = 0 o w = 1 o existe algún u ∈ [0, 1] tal que w = f(u) y u es un punto de evento U de B(V, U).",
        "Por lo tanto, B(W, V) tiene como máximo 2j + 4 puntos de evento.",
        "El límite O(j2) en el tiempo de ejecución en el Teorema 5 se deriva de nuestra descripción del algoritmo.",
        "El límite de O(n3) en el tiempo total de ejecución para encontrar un equilibrio de Nash (y una representación de todos los equilibrios de Nash) se sigue. 4.1 Encontrar un solo equilibrio de Nash en tiempo O(n2) El límite superior en el tiempo de ejecución de nuestro algoritmo es ajustado, al menos asumiendo la implementación directa, en la que cada B(Vj+1, Vj) se almacena como una unión de rectángulos: no es difícil construir un ejemplo en el que el tamaño de B(Vj+1, Vj) sea Ω(j2).",
        "Sin embargo, en algunos casos no es necesario representar todos los equilibrios de Nash; más bien, el objetivo es encontrar un equilibrio arbitrario del juego.",
        "En esta sección, demostramos que este problema puede resolverse en tiempo cuadrático, obteniendo así una prueba del Teorema 1.",
        "Nuestra solución se basa en la idea de [9], es decir, trabajar con subconjuntos de las políticas de mejor respuesta en lugar de las políticas de mejor respuesta en sí mismas; siguiendo [9], nos referiremos a tales subconjuntos como políticas de punto de quiebre.",
        "Si bien no siempre es posible construir una política de puntos de interrupción según se define en [9], mostramos cómo modificar esta definición para garantizar que siempre exista una política de puntos de interrupción; además, demostramos que para un grafo de camino, la política de puntos de interrupción de cualquier vértice puede ser almacenada en una estructura de datos cuyo tamaño es lineal en el número de descendientes que tiene este vértice.",
        "Definición 3.",
        "Una política de puntos de quiebre ˆB(V, U) para un vértice U cuyo padre es V es una curva no auto-intersectante de la forma X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, donde Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] y ui, vi ∈ [0, 1] para i = 0, . . . , m. Decimos que una política de puntos de quiebre es válida si v0 = 0, vm = 1, y ˆB(V, U) ⊆ B(V, U).",
        "A veces abusaremos de la notación al referirnos a ˆB(V, U) como una colección de segmentos Xi, Yi en lugar de su unión.",
        "Se debe tener en cuenta que no requerimos que vi ≤ vi+1 o ui ≤ ui+1; por lo tanto, en cualquier argumento que involucre políticas de puntos de quiebre, todos los segmentos deben tratarse como segmentos dirigidos.",
        "Observe que cualquier política de puntos de quiebre válida ˆB(V, U) puede ser vista como un mapeo continuo 1-1 γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2, donde γ(0) = (0, u1), γ(1) = (1, um) y existen algunos t0 = 0, t1, . . . , t2m−2 = 1 tales que {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
        "Como se explica en la Sección 3, podemos utilizar una política de punto de quiebre válida en lugar de la política de mejor respuesta durante el paso descendente, y aún así garantizar que al final, produciremos un equilibrio de Nash.",
        "El Teorema 6 muestra que se puede calcular de forma inductiva políticas de puntos de quiebre válidas para todos los vértices en el camino; la prueba de este teorema se puede encontrar en la versión completa de este artículo [6].",
        "TEOREMA 6.",
        "Para cualquier V = Vj, se puede encontrar en tiempo polinómico una política de puntos de quiebre válida ˆB(W, V) que consiste en a lo sumo 2j + 1 segmentos.",
        "EQUILIBRIOS DE NASH EN GRÁFICOS CON GRADO MÁXIMO 2 En esta sección mostramos cómo el algoritmo para caminos puede aplicarse para resolver un juego en cualquier gráfico cuyos vértices tengan un grado de a lo sumo 2.",
        "Un grafo con grado máximo 2 es, por supuesto, una unión de caminos y ciclos.",
        "Dado que cada componente conectado puede ser manejado de forma independiente, para obtener una prueba del Teorema 2, solo necesitamos mostrar cómo tratar con los ciclos.",
        "Dado un ciclo con vértices V1, . . . , Vk (en orden cíclico), realizamos dos búsquedas separadas de un equilibrio de Nash: primero buscamos un equilibrio de Nash donde algún vértice juega una estrategia pura, luego buscamos un equilibrio de Nash completamente mixto, donde todos los vértices juegan estrategias mixtas.",
        "Para i ≤ k, dejemos que vi denote la probabilidad de que Vi juegue 1.",
        "La primera búsqueda se puede hacer de la siguiente manera.",
        "Para cada i ∈ {1, . . . , k} y cada b ∈ {0, 1}, haz lo siguiente. 1.",
        "Sea P el camino (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
        "El pago a Vi+1 se basa en poner vi = b (por lo que depende solo de vi+1 y vi+2). 3.",
        "Aplica el pase ascendente a P 4.",
        "Pon vi = b; aplica el pase aguas abajo. Para cada vértice, Vj, lleva un registro de todas las posibles estrategias mixtas vj 5.",
        "Verificar si Vi+1 tiene alguna respuesta consistente con vi = b; si es así, tenemos un equilibrio de Nash. (De lo contrario, no hay un equilibrio de Nash del tipo deseado).",
        "Para la segunda búsqueda, hay que tener en cuenta que si Vi juega una estrategia mixta, entonces vi+1 y vi−1 satisfacen una ecuación de la forma vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
        "Dado que todos los vértices en el ciclo juegan estrategias mixtas, tenemos vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
        "Componiendo las dos transformaciones lineales fraccionarias, obtenemos vi+3 = (A0 + A1 vi−1)/(B0 + B1 vi−1), para algunas nuevas constantes A0, A1, B0, B1.",
        "Elige cualquier vértice Vi.",
        "Podemos expresar vi en términos de vi+2, luego vi+4, vi+6, etc. y finalmente vi mismo para obtener una ecuación cuadrática (para vi) que es fácil de derivar a partir de los pagos en el juego.",
        "Si la ecuación no es trivial, tiene como máximo 2 soluciones en (0, 1).",
        "Para un ciclo de longitud impar, todos los demás vj son derivables a partir de esas soluciones, y si existe un equilibrio de Nash completamente mezclado, todos los vj deberían resultar ser números reales en el rango (0, 1).",
        "Para un ciclo de longitud par, obtenemos dos ecuaciones cuadráticas, una para vi y otra para 105 vi+1, y de la misma manera podemos probar si alguna solución a estas ecuaciones produce valores para los otros vj, todos los cuales se encuentran en el intervalo (0, 1).",
        "Si la ecuación cuadrática es trivial, potencialmente hay un continuo de equilibrios completamente mezclados.",
        "Los valores de vi que pueden ocurrir en un equilibrio de Nash son aquellos para los cuales todos los valores dependientes vj se encuentran en el intervalo (0, 1); esta última condición es fácil de verificar calculando la imagen del intervalo (0, 1) bajo transformaciones lineales fraccionarias respectivas. 6.",
        "ENCONTRANDO EQUILIBRIOS EN UN ÁRBOL (ARBITRARIO) Para árboles arbitrarios, la estructura general del algoritmo permanece igual, es decir, se puede construir una política de mejor respuesta (o, alternativamente, una política de punto de quiebre) para cualquier vértice basada en las políticas de mejor respuesta de sus hijos.",
        "Suponemos que el grado de cada vértice está limitado por una constante K, es decir, la matriz de pagos para cada vértice es de tamaño O(2K).",
        "Consideremos un vértice V cuyos hijos son U1, . . . , Uk y cuyo padre es W; la política de mejor respuesta de cada Uj es B(V, Uj).",
        "De manera similar a la sección anterior, podemos calcular los pagos esperados V de jugar 0 o 1, respectivamente.",
        "Es decir, cuando cada uno de los Uj juega uj y W juega w, tenemos P0 = L0 (u1, . . . , uk, w), P1 = L1 (u1, . . . , uk, w), donde las funciones L0 (·, . . . , ·), L1 (·, . . . , ·) son lineales en todos sus argumentos.",
        "Por lo tanto, la desigualdad P0 > P1 se puede reescribir como wB(u1, . . . , uk) > A(u1, . . . , uk), donde tanto A(·, . . . , ·) como B(·, . . . , ·) son lineales en todos sus argumentos.",
        "Dado u = (u1, . . . , uk) y defina la función de indiferencia f : [0, 1]k → [0, 1] como f(u) = A(u)/B(u); claramente, si cada Uj juega uj, W juega w y w = f(u), V es indiferente entre jugar 0 y 1.",
        "Para cualquier X = X1 × · · · × Xk, donde Xi ⊆ [0, 1]2 se define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k}. Además, se establece ˆf(0) = {(w, 0) | ∃u tal que ui ∈ pbrUi (0) y wB(u) ≥ A(u)} y ˆf(1) = {(w, 1) | ∃u tal que ui ∈ pbrUi (1) y wB(u) ≤ A(u)}.",
        "Como en la sección anterior, podemos demostrar que B(W, V) es igual a ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2; además, cualquier camino de w = 0 a w = 1 que sea un subconjunto de B(W, V) constituye una política de puntos de quiebre válida. Política de Puntos de Quiebre de Tamaño Exponencial. Si bien el algoritmo de la Sección 4 se puede generalizar para árboles de grado acotado, su tiempo de ejecución ya no es polinomial.",
        "De hecho, la afirmación contraria es cierta: podemos construir una familia de árboles y matrices de pago para todos los jugadores de manera que las políticas de mejor respuesta para algunos de los jugadores consistan en un número exponencial de segmentos.",
        "Además, en nuestro ejemplo las políticas de puntos de quiebre coinciden con las políticas de mejor respuesta, lo que significa que incluso encontrar un solo equilibrio de Nash utilizando el enfoque de [8, 9] llevará un tiempo exponencialmente largo.",
        "De hecho, una afirmación más fuerte es cierta: para cualquier algoritmo de dos pasos de tiempo polinómico (definido más adelante) que funcione con subconjuntos de políticas de mejor respuesta para este grafo, podemos elegir las recompensas de los vértices de manera que el paso posterior de este algoritmo falle.",
        "La figura 5: El árbol Tn que corresponde a la política de puntos de quiebre de tamaño exponencial.",
        "En el resto de esta subsección, describimos esta construcción.",
        "Considera el árbol Tn dado por la Figura 5; sea Vn la raíz de este árbol.",
        "Para cada k = 1, . . . , n, permita que las ganancias de Sk y Tk sean las mismas que las de U y V descritas en la Sección 3; recuerde que las políticas de puntos de quiebre para U y V se muestran en la Figura 2.",
        "No es difícil ver que la función de indiferencia para Tk está dada por f(s) = .8s + .1.",
        "El pago de V0 es 1 si V1 selecciona la misma acción que V0 y 0 en caso contrario; la política de mejor respuesta de V0 está dada por la Figura 6.",
        "LEMMA 3. \n\nLEMMA 3.",
        "Dado k < n, y sean u, t, v y w las estrategias de Vk−1, Tk, Vk y Vk+1, respectivamente.",
        "Supongamos que Vk prefiere jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Entonces B(Vk+1, Vk) consta de al menos 3k segmentos.",
        "Además, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} y {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
        "PRUEBA.",
        "La demostración procede por inducción en k. Para k = 0, la afirmación es obvia.",
        "Ahora, supongamos que es cierto para B(Vk, Vk−1).",
        "Se puede ver B(Vk+1, Vk) como una unión de siete componentes: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, y cinco componentes que corresponden a los segmentos de B(Vk, Tk).",
        "Examinémoslos uno por uno.",
        "Para describir ˆf(0)∩[0, 1]×{0}, observe que f(u, t) = .5t+.1u+.2 es monótona en t y u y cumple con f(0, 0) = .2.",
        "Además, tenemos pbrVk−1 (0) = {0} y pbrTk (0) = {0}.",
        "Para cualquier w ∈ [0, 1] tenemos f(0, 0) ≥ w si y solo si w ∈ [0, .2].",
        "Concluimos que ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
        "De manera similar, se sigue que ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
        "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; estos conjuntos corresponden a segmentos horizontales de B(Vk, Tk).",
        "Es fácil ver que S1, S2, S3 ⊂ B(Vk+1, Vk).",
        "Dado que f es una función continua, el número de segmentos en cada Si es al menos el número de segmentos en B(Vk, Vk−1)∩[.1, .9]×[0, 1], que es al menos 3k−1 por hipótesis de inducción.",
        "Además, dado que f es monótona en u y f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), todos los Si, i = 1, 2, 3, son disjuntos.",
        "Finalmente, el conjunto B(Vk+1, Vk) contiene dos segmentos que corresponden a los segmentos verticales de B(Vk, Tk), es decir, S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} y S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
        "Claramente, S4 conecta S2 y S3, S5 conecta S1 y S2, y S4 y S5 no se intersectan entre sí.",
        "Concluimos que B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figura 6: Políticas de puntos de quiebre para V0 y V1, es una línea continua que consiste en al menos 3k segmentos y satisface la condición del lema.",
        "Para completar la construcción, necesitamos demostrar que podemos diseñar la matriz de pagos para Vk de manera que prefiera jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Con este fin, demostramos una afirmación más general, a saber, que la función de indiferencia de un vértice puede ser una función multilineal fraccional arbitraria de las estrategias de sus descendientes.",
        "Decimos que una función de k variables es multilineal si puede ser representada como una suma de monomios y cada uno de estos monomios es lineal en todas sus variables.",
        "Ten en cuenta que esta definición es diferente de una más estándar en el sentido de que no requerimos que todos los monomios tengan el mismo grado.",
        "Recuerde que las ganancias de un vértice con k + 1 vecinos están descritas por las matrices P0 y P1, donde Pj i0i1...ik es la ganancia que V obtiene cuando juega j, y sus vecinos juegan i0, . . . , ik, y j, i0, . . . , ik ∈ {0, 1}.",
        "Sea P[j] = P[j](w, u1, . . . , uk) la ganancia esperada obtenida por este vértice cuando juega j y las estrategias (mixtas) de sus vecinos están dadas por un vector (w, u1, . . . , uk), es decir, P[j] = E[P j i0i1...ik ] donde i0, . . . , ik son variables aleatorias de Bernoulli independientes, cada una de las cuales es 1 con las respectivas probabilidades w, u1, . . . , uk.",
        "LEMMA 4. \n\nLEMMA 4.",
        "Dado un vértice del árbol V cuyo padre es W y cuyos hijos son U1, . . . , Uk, para cualquier función f = f(u1, . . . , uk) que pueda representarse como una razón de dos funciones multilineales f1, f2, es decir, f = f1(u1,...,uk) f2(u1,...,uk), existen matrices de pago P0 y P1 para V tales que P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
        "La prueba de este lema se basa en el hecho de que cada monomio de la forma as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, puede ser representado como t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk para algunos Ct, t ∈ {0, 1}k+1.",
        "Los detalles se pueden encontrar en la versión completa de este documento [6]. 6.2 Irreducibilidad de la Política de Mejor Respuesta para Tn Si bien la política de mejor respuesta construida en la subsección anterior tiene un tamaño exponencial, no está claro `a priori que sea necesario hacer un seguimiento de todos sus segmentos de línea en lugar de centrarse en un pequeño subconjunto de estos segmentos.",
        "Sin embargo, resulta que para algoritmos de dos pasadas como el algoritmo de [8], la política de mejor respuesta no se puede simplificar.",
        "Más precisamente, decimos que un algoritmo A es un algoritmo de dos pasadas si 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figura 7: Política de punto de quiebre para V2. • A consta de un paso ascendente y un paso descendente. • Durante el paso ascendente, para cada vértice V con padre W, A construye un conjunto BB(W, V) ⊆ B(W, V).",
        "Este conjunto se produce a partir de los conjuntos {BB(V, U) | U es un hijo de V} aplicando el procedimiento desde el principio de la Sección 6 (sustituyendo BB(V, Uj) por B(V, Uj) para todos los hijos Uj de V), y luego posiblemente omitiendo algunos de los puntos del conjunto resultante (que luego se almacena explícitamente). El paso aguas abajo es idéntico al paso aguas abajo de [8] como se describe en la Sección 2, excepto que opera en los conjuntos BB(W, V) en lugar de en los conjuntos B(W, V).",
        "El Teorema 7 demuestra que cualquier algoritmo de dos pasadas fallará durante la pasada aguas abajo en Tn si existe un índice j tal que el conjunto BB(Vj+1, Vj) omite algún punto interior de cualquiera de los (al menos 3j) segmentos de B(Vj+1, Vj).",
        "Esto implica el Teorema 3.",
        "TEOREMA 7.",
        "Para cualquier algoritmo de dos pasos A para el cual exista un índice j, j ∈ [1, n/4], un segmento S de B(Vj, Vj−1), y un punto interior (x, y) de S tal que BB(Vj, Vj−1) no contenga (x, y), podemos elegir matrices de pago de los vértices Vj, . . . , Vn para que el paso descendente de A falle, y, además, los pagos a V4j, . . . , Vn sean idénticamente 0.",
        "Esbozamos la demostración del Teorema 7; los detalles se pueden encontrar en la versión completa de este artículo [6].",
        "Procedemos por inducción.",
        "Para j = 1, el argumento es similar al de la Sección 3.",
        "Para el paso inductivo, la idea principal es que podemos enfocarnos en cualquier parte de una política de mejor respuesta (¡incluyendo la parte que fue omitida!) utilizando una función de indiferencia apropiada; esto nos permite reducir el caso j = j0 a j = j0 − 1.",
        "En la sección anterior, demostramos que para juegos gráficos en árboles que son casi, pero no del todo, caminos, los algoritmos de dos pasos no logran encontrar equilibrios de Nash en tiempo polinómico.",
        "A continuación mostramos que una propiedad de grafo similar a un camino más suave nos permite construir juegos gráficos para los cuales es poco probable que cualquier algoritmo de tiempo polinómico encuentre equilibrios de Nash. 7.1 Ancho de camino Una descomposición de camino de un grafo G = (V, E) es una secuencia de subconjuntos Si(V) ⊆ V tal que para cada arista (v, v') ∈ E, v, v' ∈ Si(V) para algún i, y además, para cada v ∈ V, si v ∈ Si(V) y v ∈ Sj(V) para j > i, entonces v ∈ Sk(V) para todo i ≤ k ≤ j.",
        "La descomposición del camino tiene ancho k si todos los conjuntos Si(V) tienen una cardinalidad de a lo sumo k + 1.",
        "El ancho de camino de G es el ancho mínimo de cualquier descomposición de camino de G. 107 El ancho de camino es una restricción del ancho de árbol (en el cual se buscaría un árbol cuyos vértices fueran los conjuntos Si(V), y los conjuntos que contienen algún vértice tendrían que formar un subárbol).",
        "Para cualquier constante k, se puede decidir en tiempo polinómico si un grafo tiene un ancho de camino (o ancho de árbol) k. Además, muchos problemas de teoría de grafos parecen más fáciles de resolver en tiempo polinómico cuando se restringen a grafos con un ancho de árbol o un ancho de camino fijo, consulte [1] para obtener una visión general.",
        "Ten en cuenta que un camino tiene un ancho de camino de 1 y un ciclo tiene un ancho de camino de 2. 7.2 Completitud de PPAD Revisamos algunas definiciones básicas de la teoría de complejidad computacional de problemas de búsqueda.",
        "Un problema de búsqueda asocia cualquier entrada (aquí, un juego gráfico) con un conjunto de soluciones (aquí, los equilibrios de Nash del juego de entrada), donde la longitud de la descripción de cualquier solución debe estar acotada de forma polinómica en función de la longitud de la descripción de su entrada.",
        "En un problema de búsqueda total, hay una garantía de que al menos una solución existe para cualquier entrada.",
        "El teorema de Nash nos asegura que el problema de encontrar equilibrios de Nash es total.",
        "Una reducción del problema de búsqueda S al problema S es un mecanismo que muestra que cualquier algoritmo de tiempo polinómico para S implica un algoritmo de tiempo polinómico para S. Consiste en funciones f y g, computables en tiempo polinómico, donde f mapea entradas de S a entradas de S, y g mapea soluciones de S a soluciones de S, de tal manera que si IS es una entrada para S, y SS es una solución para f(IS), entonces g(SS) es una solución para IS.",
        "Observe que los problemas de búsqueda total no permiten las reducciones anteriores de problemas como CIRCUIT SAT (donde la entrada es un circuito booleano, y las soluciones son vectores de entrada que hacen que la salida sea verdadera) debido a que CIRCUIT SAT y otros problemas NP-completos tienen entradas con conjuntos de soluciones vacíos.",
        "En cambio, el trabajo reciente sobre la complejidad computacional de encontrar un equilibrio de Nash [7, 4, 5, 2, 3] lo ha relacionado con el siguiente problema.",
        "Definición 4.",
        "FIN DE LA LÍNEA.",
        "Circuitos booleanos S y P, cada uno con n bits de entrada y n bits de salida, donde P(0n) = 0n y S(0n) = 0n.",
        "Solución: x ∈ {0, 1}n tal que S(x) = x, o alternativamente x ∈ {0, 1}n tal que P(S(x)) = x.",
        "S y P pueden ser consideradas como representando sucesor y predecesor.",
        "Observe que al calcular Si (0n) (para i = 0, 1, 2, ...) y comparar con P(Si+1 (0n)), eventualmente debemos encontrar una solución para EL FIN DE LA LÍNEA.",
        "END OF THE LINE caracteriza la clase de complejidad PPAD (que significa argumento de paridad en un grafo, versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda S es PPAD-completo si END OF THE LINE se reduce a S. Otros problemas PPAD-completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para descripciones más detalladas de estos problemas). 3-GRAPHICAL NASH es el problema de encontrar un equilibrio de Nash para un juego gráfico cuyo grafo tiene grado 3.",
        "Daskalakis et al. [4] muestran la completitud de PPAD de NASH 3-GRÁFICO mediante una reducción de BROUWER TRIDIMENSIONAL, introducida en [4] y definida de la siguiente manera.",
        "Definición 5. BROUWER TRIDIMENSIONAL.",
        "Un circuito C que tiene 3n bits de entrada y 2 bits de salida.",
        "Los bits de entrada definen un cubilete del cubo unitario, compuesto por las 3 coordenadas de sus puntos, dadas con una precisión de n bits.",
        "La salida representa uno de los cuatro colores asignados por C a un cubito.",
        "C está restringido para asignar el color 1 a los cubitos adyacentes al plano (y, z), el color 2 a los cubitos restantes adyacentes al plano (x, z), el color 3 a los cubitos restantes en el plano (x, y), y el color 0 a todos los demás cubitos en la superficie del cubo unitario.",
        "Una solución es un vértice pancromático, un vértice adyacente a cubiletes que tienen 4 colores distintos.",
        "La razón por la que se garantiza la existencia de una solución es que se puede construir una función de Brouwer asociada φ, es decir, una función continua del cubo unitario a sí mismo, de modo que los vértices pancromáticos correspondan a los puntos fijos de φ. El Teorema del Punto Fijo de Brouwer promete la existencia de un punto fijo.",
        "La prueba del Teorema 4 utiliza una modificación de la reducción de [4] de 3-DIMENSIONAL BROUWER a 3-GRAPHICAL NASH.",
        "Para demostrar el teorema, comenzamos con algunos resultados preliminares de la siguiente manera.",
        "Cada jugador tiene 2 acciones, denominadas 0 y 1.",
        "Para un jugador en el vértice V, dejemos que p[V] denote la probabilidad de que el jugador juegue 1.",
        "LEMMA 5. [7] Existe un juego gráfico Gshift de tamaño fijo con vértices V, V donde p[V] es la parte fraccionaria de 2p[V].",
        "COROLARIO 1.",
        "Existe un juego gráfico Gn−shift de tamaño Θ(n) de ancho de camino constante, con vértices V, Vn donde p[Vn] es la parte fraccionaria de 2n .p[V].",
        "PRUEBA.",
        "Crear una cadena de n copias de Gshift en el Lema 5.",
        "Cada subconjunto de vértices en la descomposición del camino son los vértices en una copia de Gshift.",
        "Que In(x) denote el n-ésimo bit de la expansión binaria de x, donde interpretamos 1 como verdadero y 0 como falso.",
        "Lo siguiente utiliza dispositivos de [7, 4].",
        "COROLARIO 2.",
        "Existe un valor k tal que para todo n, y para todo n1, n2, n3 ≤ n, existe un juego gráfico de tamaño O(n) con ancho de camino k, teniendo vértices V1, V2, V3 donde p[V3] = p[V1] + 2−n3 (En1 p[V1] ∧ En2 p[V2]).",
        "PRUEBA DEL TEOREMA 4.",
        "Sea C el circuito booleano que describe una instancia de BROUWER TRIDIMENSIONAL.",
        "Sean g1, . . . , gp(n) las compuertas de C indexadas de tal manera que la(s) entrada(s) de cualquier compuerta son la(s) salida(s) de las compuertas de índice inferior. g1, . . . , g3n serán las 3n entradas de C. Todos los jugadores en el juego gráfico G construido en [4] tienen 2 acciones denotadas como 0 y 1.",
        "La probabilidad de que V juegue 1 se denota como p[V].",
        "G tiene 3 jugadores Vx, Vy y Vz para los cuales p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto en el cubo unitario.",
        "G está diseñado para incentivar a Vx, Vy y Vz a ajustar sus probabilidades en direcciones dadas por una función de Brouwer que está especificada por el circuito C. En un equilibrio de Nash, p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto fijo de una función que pertenece a la clase de funciones representadas por el BROUWER TRIDIMENSIONAL.",
        "Para 1 ≤ i ≤ p(n) introducimos un vértice V (i) C tal que para 1 ≤ j ≤ i, Ij(p[V (i) C ]) es la salida de la compuerta gj; para i < j ≤ p(n), Ij(p[V (i) C ]) es 0.",
        "Construye V (i) C a partir de V (i−1) C utilizando el Corolario 2.",
        "Sea G(i) el juego gráfico que hace esto.",
        "Sea S1(G(i)), . . . , Sn(G(i)) una descomposición de camino de longitud n de G(i), donde V(i−1) ⊂ S1(G(i)) y V(i) ⊂ Sn(G(i)).",
        "Luego, se obtiene una descomposición de camino de ∪1≤i≤p(n)G(i) tomando la unión de las descomposiciones de camino separadas, junto con Sn(G(i−1) ) ∪ S1(G(i) ) para 2 ≤ i ≤ p(n).",
        "Sea GC el juego gráfico anterior que simula C. GC tiene 3n entradas, que consisten en los primeros n bits de las expansiones binarias de p[Vx], p[Vy] y p[Vz].",
        "De manera similar a [4], la salida de GC afecta a Vx, Vy y Vz de la siguiente manera.",
        "El color 0 incentiva a Vx, Vy y Vz 108 a ajustar sus probabilidades p[Vx], p[Vy] y p[Vz] en la dirección (−1, −1, −1); el color 2 los incentiva a moverse en la dirección (1, 0, 0); el color 2, dirección (0, 1, 0); el color 3, dirección (0, 0, 1).",
        "Necesitamos asegurarnos de que en los puntos en los límites de los cubitos adyacentes, el cambio de dirección será aproximadamente el promedio de las direcciones de los puntos circundantes.",
        "De esta manera, los cuatro colores/direcciones deben estar cerca para que puedan anularse entre sí (y estemos en un vértice pancromático).",
        "Esto se logra utilizando el mismo truco que [4], en el cual hacemos un número constante M de copias de GC, que difieren en que cada copia agrega un vector de desplazamiento pequeño a sus copias de p[Vx], p[Vy] y p[Vz] (que se derivan del original utilizando el dispositivo de adición de [7]).",
        "Usando los dispositivos de suma y multiplicación de [7], promediamos las direcciones y sumamos un pequeño múltiplo de este promedio a (p[Vx], p[Vy], p[Vz]).",
        "En un equilibrio de Nash, las salidas de cada copia se cancelarán mutuamente.",
        "El ancho de camino del juego completo es a lo sumo M veces el ancho de camino GC. 8.",
        "PROBLEMAS ABIERTOS El problema más importante que queda abierto en este artículo es si es posible encontrar un equilibrio de Nash de un juego gráfico en un árbol de grado acotado en tiempo polinómico.",
        "Nuestra construcción muestra que cualquier algoritmo de dos pasadas que almacene explícitamente políticas de puntos de quiebre necesita tiempo y espacio exponenciales.",
        "Sin embargo, esto no excluye la existencia de un algoritmo que se base en una idea similar, pero en lugar de calcular la política de punto de ruptura completa para cada vértice, utiliza un pequeño número de pasadas adicionales a través del grafo para decidir qué partes (de tamaño polinómico) de cada política de punto de ruptura deben ser calculadas.",
        "En particular, dicho algoritmo puede basarse en el algoritmo de aproximación de [8], donde el valor de es elegido de forma adaptativa.",
        "Otra pregunta intrigante está relacionada con el hecho de que el grafo para el cual construimos una política de puntos de quiebre de tamaño exponencial tiene un ancho de camino de 2, mientras que nuestros resultados positivos son para un camino, es decir, un grafo de ancho de camino 1.",
        "No está claro si para cualquier grafo de grado acotado con ancho de camino 1, el tiempo de ejecución de nuestro algoritmo (versión basada en política de puntos de interrupción) será polinomial.",
        "En particular, resulta instructivo considerar un grafo oruga, es decir, el grafo que se puede obtener a partir de Tn al eliminar los vértices S1, . . . , Sn.",
        "Para este gráfico, la mejor política de respuesta de un vértice Vk en la columna vertebral de la oruga se obtiene combinando la mejor política de respuesta de su predecesor en la columna vertebral Vk−1 y su otro hijo Tk; dado que este último es una hoja, su mejor política de respuesta es trivial (es decir, [0, 1]2, [0, 1]×{0} o [0, 1]×{1}) o consiste en dos segmentos horizontales y un segmento vertical de la forma {α}×[0, 1] que los conecta.",
        "Suponiendo, para mayor comodidad, que B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, y f es la función de indiferencia para Vk, observamos que la política de mejor respuesta para Vk consta de 5 componentes: ˆf(0), ˆf(1), y tres componentes que corresponden a [0, α]×{0}, {α}×[0, 1], y [α, 1]×{1}.",
        "Por lo tanto, se puede pensar en la construcción de B(Vk+1, Vk) como el siguiente proceso: girar B(Vk, Vk−1) en π/2, cortarlo a lo largo de la línea (ahora horizontal) vk = α, aplicar una transformación lineal fraccional a la coordenada horizontal de ambas partes y volver a conectarlas usando la imagen del segmento {α}×[0, 1] bajo f. Esto implica que el problema de acotar el tamaño de la política de mejor respuesta (o, alternativamente, la política de punto de quiebre) se puede ver como una generalización del siguiente problema de geometría computacional, que creemos puede ser de interés independiente: PROBLEMA 1.",
        "Dada una colección de segmentos paralelos a los ejes en R2, considera la siguiente operación: elige una línea paralela a los ejes li (ya sea vertical u horizontal), corta el plano a lo largo de esta línea y desplaza una de las dos partes resultantes por una cantidad arbitraria δi; como resultado, algunos segmentos se dividirán en dos partes.",
        "Reconecte estas partes, es decir, para cada segmento de la forma [a, b] × {c} que fue transformado en [a, t] × {c + δi} y [t, b] × {c}, introduzca un segmento {t} × [c, c+δi].",
        "¿Es posible comenzar con el segmento [0, 1] y después de n operaciones obtener un conjunto que no pueda representarse como una unión de poli(n) segmentos de línea?",
        "¿En caso afirmativo, puede ser que en este conjunto no haya un camino con un número polinomial de giros que conecte los extremos del segmento original?",
        "Resulta que en general, la respuesta a la primera pregunta es positiva, es decir, después de n pasos, es posible obtener un conjunto que consiste en Θ(cn) segmentos para algún c > 0.",
        "Esto implica que incluso para una oruga, la mejor política de respuesta puede ser exponencialmente grande.",
        "Sin embargo, en nuestro ejemplo (que se omite en esta versión del documento debido a limitaciones de espacio), existe un camino de tamaño polinómico a través de la política de mejor respuesta, es decir, no demuestra que la política de punto de quiebre sea necesariamente exponencial en tamaño.",
        "Si se puede demostrar que esto siempre es cierto, puede ser posible adaptar esta prueba para mostrar que puede haber una brecha exponencial entre los tamaños de las políticas de mejor respuesta y las políticas de punto de quiebre. 9.",
        "REFERENCIAS [1] H. Bodlaender y T. Kloks.",
        "Algoritmos eficientes y constructivos para el ancho de camino y el ancho de árbol de grafos.",
        "Revista de Algoritmos, 21:358-402, 1996. [2] X. Chen y X. Deng. 3-NASH es PPAD-completo.",
        "Informe técnico TR-05-134, Coloquio Electrónico en Complejidad Computacional, 2005. [3] X. Chen y X. Deng.",
        "Resolviendo la complejidad del equilibrio de Nash de 2 jugadores.",
        "Informe técnico TR-05-140, Coloquio Electrónico en Complejidad Computacional, 2005. [4] C. Daskalakis, P. Goldberg y C. Papadimitriou.",
        "La complejidad de calcular un equilibrio de Nash.",
        "En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [5] C. Daskalakis y C. Papadimitriou.",
        "Los juegos de tres jugadores son difíciles.",
        "Informe técnico TR-05-139, Coloquio Electrónico en Complejidad Computacional, 2005. [6] E. Elkind, L. Goldberg y P. Goldberg.",
        "Equilibrios de Nash en juegos gráficos en árboles revisados.",
        "Informe técnico TR-06-005, Coloquio Electrónico en Complejidad Computacional, 2006. [7] P. Goldberg y C. Papadimitriou.",
        "Reductibilidad entre problemas de equilibrio.",
        "En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [8] M. Kearns, M. Littman y S. Singh.",
        "Modelos gráficos para teoría de juegos.",
        "En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, 2001. [9] M. Littman, M. Kearns y S. Singh.",
        "Un algoritmo exacto eficiente para juegos gráficos de conexión simple.",
        "En Actas de la 15ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2001. [10] L. Ortiz y M. Kearns.",
        "Propagación de Nash para juegos gráficos con bucles.",
        "En Actas de la 17ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2003. [11] C. Papadimitriou.",
        "Sobre la complejidad del argumento de paridad y otras demostraciones ineficientes de existencia.",
        "J. Comput.",
        "This is not a complete sentence. Please provide more context or the full sentence you would like me to translate.",
        "Cienc., 48(3):498-532, 1994. 109"
    ],
    "error_count": 0,
    "keys": {
        "graphical game": {
            "translated_key": "juego gráfico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 <br>graphical game</br> with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action <br>graphical game</br> in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A <br>graphical game</br> associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the <br>graphical game</br> downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a <br>graphical game</br> on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a <br>graphical game</br> with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a <br>graphical game</br> with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a <br>graphical game</br> on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a <br>graphical game</br> on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a <br>graphical game</br> in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the <br>graphical game</br> by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a <br>graphical game</br>) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a <br>graphical game</br> whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a <br>graphical game</br> Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a <br>graphical game</br> Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a <br>graphical game</br> of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the <br>graphical game</br> G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the <br>graphical game</br> that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above <br>graphical game</br> that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a <br>graphical game</br> on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 <br>graphical game</br> with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action <br>graphical game</br> in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "A <br>graphical game</br> associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the <br>graphical game</br> downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a <br>graphical game</br> on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary)."
            ],
            "translated_annotated_samples": [
                "Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un <br>juego gráfico</br> de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema.",
                "Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un <br>juego gráfico</br> de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable).",
                "Un <br>juego gráfico</br> asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores.",
                "Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el <br>juego gráfico</br> aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2).",
                "En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un <br>juego gráfico</br> en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario)."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un <br>juego gráfico</br> de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un <br>juego gráfico</br> de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un <br>juego gráfico</br> asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el <br>juego gráfico</br> aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V. El algoritmo genérico no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente. En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta. La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2). Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del algoritmo genérico de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino). Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9]. En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un <br>juego gráfico</br> en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario). ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "large-scale distributed network": {
            "translated_key": "redes distribuidas a gran escala",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of <br>large-scale distributed network</br>s of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of <br>large-scale distributed network</br>s of non-cooperative agents."
            ],
            "translated_annotated_samples": [
                "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de <br>redes distribuidas a gran escala</br> de agentes no cooperativos."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de <br>redes distribuidas a gran escala</br> de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V. El algoritmo genérico no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente. En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta. La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2). Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del algoritmo genérico de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino). Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9]. En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un juego gráfico en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario). Obtenemos el siguiente teorema TEOREMA 1. Existe un algoritmo O(n2) que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un camino de n vértices. Existe un algoritmo O(n3) que calcula una representación de todos los equilibrios de Nash de dicho juego. En la Sección 5 extendemos los resultados de la Sección 4 a grafos de grado 2 en general, obteniendo el siguiente teorema. TEOREMA 2. Existe un algoritmo de tiempo polinómico que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un grafo con grado máximo 2. En la Sección 6 ampliamos nuestro algoritmo para que pueda ser utilizado para encontrar un equilibrio de Nash de un juego gráfico en un árbol arbitrario. Incluso cuando el árbol tiene grado acotado, el tiempo de ejecución puede ser exponencial. Mostramos que esto es inevitable construyendo una familia de juegos gráficos en árboles de grado acotado para los cuales las políticas de mejor respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de dos pasos (es decir, un algoritmo que es similar en espíritu al de [8]) tiene que almacenar casi todos los puntos de las políticas de mejor respuesta. En particular, mostramos lo siguiente. TEOREMA 3. Existe una familia infinita de juegos gráficos en árboles de grado acotado con ancho de camino 2, tal que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales. Es interesante notar que los árboles utilizados en la demostración del Teorema 3 tienen un ancho de camino de 2, es decir, están muy cerca de ser caminos. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico para grafos de ancho de camino 1. Esta pregunta puede ser vista como una generalización de un problema muy natural de geometría computacional; lo describimos con más detalle en la Sección 8. En la Sección 7, presentamos un resultado de intractabilidad teórica de complejidad para el problema de encontrar un equilibrio de Nash de un juego gráfico en un grafo con un ancho de camino pequeño. Demostramos el siguiente teorema. TEOREMA 4. Considera el problema de encontrar un equilibrio de Nash para un juego gráfico en el cual el grafo subyacente tiene un grado máximo de 3 y un ancho de camino k. Existe una constante k tal que este problema es PPAD-completo. El teorema 4 limita la medida en que podemos explotar las propiedades de tipo camino del grafo subyacente para encontrar equilibrios de Nash. Para demostrar el Teorema 4, utilizamos resultados recientes de completitud de PPAD para juegos, en particular los artículos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de grado d (para d ≥ 3) es computacionalmente equivalente al problema de resolver juegos en forma normal de r jugadores (para r ≥ 4), ambos de los cuales son PPAD-completos. CONSIDERACIONES PREVIAS Y NOTACIÓN Consideramos juegos gráficos en los que el grafo subyacente G es un árbol de n vértices. Cada vértice tiene dos acciones, que se denotan como 0 y 1. Una estrategia mixta se define por un único número x ∈ [0, 1], que indica la probabilidad de que el jugador seleccione la acción 1. Para los propósitos del algoritmo, el árbol está enraizado de manera arbitraria. Para mayor comodidad, asumimos sin pérdida de generalidad que la raíz tiene un solo hijo y que su recompensa es independiente de la acción elegida por el hijo. Esto se puede lograr primero eligiendo una raíz arbitraria del árbol, y luego agregando un padre ficticio de esta raíz, asignándole una función de pago constante. Dado un borde (V, W) del árbol G, y una estrategia mixta w para W, sea G(V,W), W=w la instancia obtenida de G mediante (1) eliminar todos los nodos Z que están separados de V por W (es decir, todos los nodos Z tales que el camino de Z a V pasa por W), y (2) restringir la instancia de modo que se requiera que W juegue la estrategia mixta w. Definición 1. Supongamos que (V, W) es un borde del árbol, que v es una estrategia mixta para V y que w es una estrategia mixta para W. Decimos que v es una mejor respuesta potencial para w (indicado por v ∈ pbrV(w)) si hay un equilibrio en la instancia G(V, W), W = w en el que V tiene la estrategia mixta v. Definimos la política de mejor respuesta para V, dada W, como B(W, V) = {(w, v) | v ∈ pbrV(w), w ∈ [0, 1]}. Normalmente, W es el padre de V, y esto se conoce simplemente como la política de mejor respuesta para V. La expresión B(W, V )|V =v se utiliza para denotar el conjunto B(W, V ) ∩ [0, 1]×{v}. El paso ascendente del algoritmo genérico de [8] calcula la política de mejor respuesta para V en cada nodo V que no sea la raíz. Con las suposiciones anteriores sobre la raíz, el paso aguas abajo es sencillo: Sea W la raíz y V su hijo. La raíz selecciona cualquier par (w, v) de B(W, V). Decide jugar con la estrategia mixta w e instruye a V a jugar con la estrategia mixta v. El resto del paso descendente es recursivo. Cuando un nodo V recibe instrucciones de su padre para adoptar la estrategia mixta v, hace lo siguiente para cada hijo U: encuentra un par (v, u) ∈ B(V, U) (con el mismo valor de v que le fue dado por su padre) e instruye a U a jugar u. ALGORITMO DE LITTMAN ET AL. El algoritmo de [9] se basa en la siguiente observación: para calcular un equilibrio de Nash único mediante un algoritmo de dos pasos, no es necesario construir la política de mejor respuesta completa para cada vértice. Si, en cada paso de la pasada descendente, el vértice en consideración puede seleccionar un vector de estrategias para todos sus hijos de manera que la estrategia de cada hijo sea una mejor respuesta potencial a la estrategia del padre, el algoritmo logra producir un equilibrio de Nash. Esto se puede lograr si, al comienzo del paso aguas abajo, tenemos una estructura de datos en la que cada vértice V con padre W almacena un conjunto ˆB(W, V ) ⊆ B(W, V ) (llamado una política de puntos de quiebre) que cubre cada posible w ∈ [0, 1]. Mostraremos más adelante que una condición suficiente para la construcción de una estructura de datos así es la invariante de que, en cada nivel del paso ascendente, ˆB(W, V) contiene un camino continuo desde w = 0 hasta w = 1. En [9], se sugiere que podemos seleccionar la política de punto de quiebre de una manera particular. Es decir, el documento utiliza la siguiente definición: Definición 2. (cf. [9]) Una política de puntos de ruptura para un nodo V con padre W consiste en un conjunto ordenado de puntos de ruptura de W, w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 y un conjunto asociado de valores de V, v1, . . . , vt. La interpretación es que para cualquier w ∈ [0, 1], si wi−1 < w < wi para algún índice i y W juega w, entonces V deberá jugar vi; y si w = wi para algún índice i, entonces V deberá jugar cualquier valor entre vi y vi+1. Decimos que una política de punto de quiebre tiene t - 1 puntos de quiebre. El artículo luego afirma que cualquier vértice V puede calcular su política de punto de interrupción con respecto a su padre W dadas las políticas de punto de interrupción de sus hijos U1, . . . , Uk. La prueba procede ordenando los puntos de quiebre de los niños (es decir, los valores respectivos de v) de izquierda a derecha (se puede asumir sin pérdida de generalidad que todos estos puntos de quiebre son distintos) y considerándolos sucesivamente; cada punto vl ∈ {v1, . . . , vL} corresponde a una elección fija de estrategias para k − 1 niños y un intervalo de estrategias admisibles para un niño. Supongamos, para mayor comodidad, que este niño es U1 y su intervalo de estrategias admisibles en vl es [a, b]; supongamos también que para Uj, j = 2, . . . , k, sus respectivas políticas de puntos de quiebre les prescriben jugar uj en respuesta a vl. Sea P i (u, w), i = 0, 1, el pago esperado para V cuando V juega i, U1 juega u, cada Uj, j = 2, . . . , k, juega uj, y W juega w, y considera el conjunto Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] tal que P 0 (u, w) = P1 (u, w)}; nota que para cualquier w ∈ Wl tenemos vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figura 1: LKS: Recorte para encontrar políticas de puntos de quiebre. Los autores muestran que para cualquier punto de quiebre vl, el conjunto Wl está vacío, es un solo intervalo, o es una unión de dos intervalos no flotantes (un intervalo es no flotante si uno de sus extremos es 0 o 1); además, la unión de todos los conjuntos Wl, l = 1, . . . , L, cubre el intervalo [0, 1]. Se sigue fácilmente que se puede cubrir [0, 1] con a lo sumo L+2 intervalos, cada uno de los cuales es un subconjunto de algún Wl. Los autores afirman entonces que cualquier cobertura de este tipo puede ser transformada en una política de puntos de ruptura para V. Es decir, afirman que para cualquier par de intervalos Wl1 y Wl2 en la cobertura, cualquier superposición entre Wl1 y Wl2 puede asignarse arbitrariamente a la cobertura por Wl1 y Wl2 recortados en consecuencia (cf. [9], p. 5). Ellos ilustran su enfoque en una figura, la cual se reproduce como Figura 1 aquí. En la figura, las líneas horizontales discontinuas representan los puntos de quiebre v1, v2, . . . , v7 y los intervalos sólidos a lo largo de estos puntos de quiebre son los conjuntos W1, W2, . . . , W7. El camino grueso conectado es la política de punto de quiebre correspondiente. Se elige de la siguiente manera: comenzar en la izquierda y siempre saltar al intervalo que permita el mayor avance hacia la derecha. Para entender por qué este enfoque no funciona en general, considera un camino de longitud 4 que consiste en una raíz indiferente R, su hijo W, el hijo de W V y el hijo de V U. Supongamos que U recibe un pago de 1 si juega de manera diferente a V y 0 en caso contrario. Así, si v denota la estrategia mixta de V (es decir, V juega 1 con probabilidad v), entonces la ganancia esperada que U obtiene al jugar 0 se da por P0(U) = v y la ganancia esperada que U obtiene al jugar 1 se da por P1(U) = 1 − v. Supongamos que V no obtiene ganancia al jugar 1 (por lo que P1(V) = 0) y que su matriz de ganancias al jugar 0 es 1 −9 9 −1, entonces si u denota la estrategia mixta de U y w denota la estrategia mixta de W, la ganancia esperada que V obtiene al jugar 0 se da por P0(V) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1). Usando las técnicas de [8] (o, alternativamente, las de la Sección 4), no es difícil verificar que las políticas de mejor respuesta para U y V (como en la Definición 1) están dadas por los gráficos en la Figura 2. La mejor política de respuesta para U es una política de punto de quiebre para U (como en la Definición 2) con puntos de quiebre V v0 = 0, v1 = 1/2 y v2 = 1 con valores asociados u1 = 1 y u2 = 0. La mejor política de respuesta para V no es una política de punto de quiebre (debido a cómo la curva de w = 0 a w = 1 retrocede). El algoritmo LKS recortaría para obtener una política de puntos de quiebre como la que se muestra en la Figura 3. Se observa que esta política de punto de quiebre ˆB(W, V) es inválida en el sentido de que no satisface ˆB(W, V) ⊆ B(W, V). El punto es que la matriz de pagos de W ahora puede ser elegida para evitar que el algoritmo LKS encuentre un equilibrio de Nash. Por ejemplo, supongamos que las ganancias se dan de tal manera que P0 (W) = v y P1 (W) = (1−v)2. La mejor política de respuesta para W es una línea horizontal en w = 0.1 (Este es el valor de w que permite v = 2/3 - ver Figura 2, lo que hace que P0 (W) = P1 (W).) En el paso descendente, los valores elegidos son w = .1, luego, a partir del recorte, v = 0 y u = 1, lo cual no es un equilibrio de Nash ya que W prefiere la acción 1. El fallo del algoritmo no se debe al hecho de que la política de recorte llegue tan lejos a la derecha como sea posible. Cualquier otro recorte sería igual de malo. Por ejemplo, supongamos que la política de punto de quiebre para V tiene v = 0 hasta algún punto w∗ < .9 y luego salta a v = 1. El algoritmo es entonces derrotado por la matriz de pagos con P0(W) = 2v y P1(W) = (1 − v) en la que la política de mejor respuesta para W es una línea horizontal en w = .9. El algoritmo luego da w = .9, v = 1, y u = 0, lo cual no es un equilibrio de Nash ya que W prefiere la acción 0. Concluimos que el algoritmo LKS no siempre encuentra un equilibrio de Nash. En las Secciones 4 y 6 mostramos cómo modificar el algoritmo para que siempre encuentre un equilibrio de Nash. Para el algoritmo modificado, debemos extender la definición de la política de punto de quiebre (ver Definición 3) para que incluya políticas de punto de quiebre como la política de mejor respuesta para V en la Figura 2. Desafortunadamente, una política de punto de interrupción de este tipo puede ser exponencial en tamaño (ver Figura 7), por lo que el algoritmo corregido no se ejecuta en tiempo polinómico en todos los árboles. En la siguiente sección, mostramos que se ejecuta en tiempo polinómico en un camino. 4. ENCONTRANDO EQUILIBRIOS EN UN CAMINO En esta sección, nos enfocamos en el caso en el que el grafo subyacente es un camino, es decir, su conjunto de vértices es {V1, . . . , Vn}, y su conjunto de aristas es {(Vj , Vj+1) | j = 1, . . . , n − 1}. Mostramos que en este caso la mejor política de respuesta para cada vértice puede ser representada como una unión de un número polinomial de rectángulos, donde un rectángulo está definido por un par de intervalos cerrados (IV, IU) y consiste en todos los puntos en IV × IU; puede ser el caso de que uno o ambos de los intervalos IV e IU consistan en un solo punto. TEOREMA 5. Para cualquier j = 1, . . . , n, el conjunto B(Vj , Vj−1) puede ser representado como una unión disjunta de a lo sumo (j + 4)2 rectángulos. Además, dado tal representación de B(Vj , Vj−1), se puede calcular una representación de B(Vj+1, Vj) en tiempo O(j2). PRUEBA. Para cualquier conjunto A ⊆ [0, 1]2 que esté representado como una unión de un número finito de rectángulos, decimos que un punto u ∈ [0, 1] en el eje U es un punto de evento U de A si u = 0 o u = 1 o A contiene un rectángulo de la forma IV × IU y u es un extremo de IU; los puntos de evento V se definen de manera similar. Observa que para cualquier u ∈ [0, 1], el número de componentes conectadas de [0, 1]×{u} ∩ A es a lo sumo el número de puntos de V-evento de A. Utilizamos inducción en j para demostrar que para cada Vj se cumple la afirmación del teorema y, además, cada B(Vj, Vj−1) tiene como máximo 2j + 4 puntos de evento. Para simplificar el caso base, modificamos el juego gráfico agregando un vértice ficticio V0 al principio del camino: el único vecino de V0 es V1, las ganancias de V0 siempre son iguales a 0, y las ganancias de todos los demás vértices (incluido V1) son las mismas que en el juego original. Para j = 0, tenemos B(V1, V0) = [0, 1]2, por lo que la afirmación del teorema es trivialmente verdadera. Ahora, supongamos que j > 0, establezca V = Vj y permita que U = Vj−1 y W = Vj+1 sean los vértices que preceden y siguen a V, respectivamente. Los pagos para V están descritos por una matriz 2×2×2 P: Pxyz es el pago que V recibe cuando U juega x, V juega y, y W juega z, donde x, y, z ∈ {0, 1}. Supongamos que U juega 1 con probabilidad u y W juega 1 con probabilidad w. Entonces la ganancia esperada de V al jugar 0 es P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, mientras que su ganancia esperada al jugar 1 es P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111. Si P0 > P1, V prefiere estrictamente jugar 0; si P0 < P1, V prefiere estrictamente jugar 1; y si P0 = P1, V es indiferente, es decir, puede jugar cualquier estrategia (mixta). Dado que P0 y P1 son lineales en w y u, existen algunas constantes A1, A0, B1 y B0 que dependen de la matriz P, pero no de u y w, de modo que P0 − P1 = w(B1u + B0) − (A1u + A0). Dependiendo de los valores de A1, A0, B1 y B0, subdividimos el resto de la prueba en los siguientes casos. • B1 = 0, B0 = 0. En este caso, P0 > P1 si y solo si A1u + A0 < 0. Si también A1 = 0, A0 = 0, claramente, B(W, V) = [0, 1]2, y la afirmación del teorema es trivialmente verdadera. De lo contrario, el vértice V es indiferente entre 0 y 1 si y solo si A1 = 0 y u = −A0/A1. Sea V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}. Por la hipótesis inductiva, V consiste en a lo sumo 2(j − 1) + 4 segmentos y puntos aislados. Para cualquier v ∈ V, tenemos B(W, V)|V = v = [0, 1]: no importa lo que juegue W, siempre y cuando U esté jugando −A0/A1, V está contento de jugar v. Por otro lado, para cualquier v ∈ (0, 1) \\ V tenemos B(W, V)|V = v = ∅: cuando V juega v, U solo puede responder con u = −A0/A1, en cuyo caso V puede beneficiarse cambiando a una de las estrategias puras. Para completar la descripción de B(W, V), queda por analizar los casos v = 0 y v = 1. El vértice V prefiere jugar 0 si A1 > 0 y u ≤ −A0/A1, o A1 < 0 y u ≥ −A0/A1, o 103 A1 = 0 y A0 < 0. Supongamos por ahora que A1 > 0; los otros dos casos pueden ser tratados de manera similar. En este caso, 0 ∈ pbrV (w) para algún w ∈ [0, 1] si y solo si existe un u ∈ pbrU (0) tal que u ≤ −A0/A1: si no existe tal u, cada vez que V juega 0, la respuesta de U no está en pbrU (0) o V puede mejorar su recompensa jugando 1. Por lo tanto, o bien B(W, V)|V=0 = [0, 1] o B(W, V)|V=0 = ∅. De manera similar, B(W, V)|V=1 es igual a [0, 1] o ∅, dependiendo de pbrU(1). Por lo tanto, el conjunto B(W, V) consiste en un máximo de 2j + 4 ≤ (j + 4)2 rectángulos: B(W, V) ∩ [0, 1]×(0, 1) = [0, 1]×V contribuye como máximo con 2j + 2 rectángulos, y cada uno de los conjuntos B(W, V)|V=0 y B(W, V)|V=1 contribuye como máximo con un rectángulo. De manera similar, su número total de puntos de evento es a lo sumo 2j + 4: los únicos puntos de evento W son 0 y 1, cada punto de evento V de B(W, V) es un punto de evento V de B(V, U), y hay a lo sumo 2j + 2 de ellos. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 para algún α ∈ R. En este caso, V es indiferente entre 0 y 1 si y solo si w = α, o B1 = 0 y u = −B0/B1 = −A0/A1. De manera similar al caso anterior, podemos mostrar que B(W, V)∩[0, 1]×(0, 1) consiste en el rectángulo {α}×[0, 1] y como máximo 2j + 2 rectángulos de la forma [0, 1]×IV, donde cada IV corresponde a un componente conectado de B(V, U)|U=−B0/B1. Además, V prefiere jugar 0 si B1u + B0 > 0 y w ≥ α o B1u + B0 < 0 y w ≤ α. Por lo tanto, si B1u∗ + B0 > 0 para algún u∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [α, +∞) ∩ [0, 1] y si B1u∗∗ + B0 < 0 para algún u∗∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [−∞, α] ∩ [0, 1]; si ambos u∗ y u∗∗ existen, B(W, V )|V =0 = [0, 1]. El conjunto B(W, V)|V=1 se puede describir de manera similar. Por la hipótesis inductiva, B(V, U) tiene a lo sumo 2j + 2 puntos de evento; dado que al menos dos de estos son puntos de evento U, tiene a lo sumo 2j puntos de evento V. Dado que cada punto de evento V de B(W, V) es un punto de evento V de B(V, U) y B(W, V) tiene como máximo 3 puntos de evento W (0, 1 y α), su número total de puntos de evento es como máximo 2j + 3 < 2j + 4. Además, de manera similar al caso anterior, se sigue que B(W, V) consiste en un máximo de 2j + 4 < (j + 4)2 rectángulos. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0. En este caso, se puede definir la función de indiferencia f(·) como f(u) = A(u) B(u) = A1u+A0 B1u+B0, donde A(u) y B(u) nunca se anulan simultáneamente. Observa que siempre que w = f(u) y u, w ∈ [0, 1], V es indiferente entre jugar 0 y 1. Para cualquier A ⊆ [0, 1]2, definimos una función ˆfV por ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; nota que ˆfV mapea subconjuntos de [0, 1]2 a subconjuntos de R×[0, 1]. A veces omitimos el subíndice V cuando es evidente por el contexto. LEMMA 1. \n\nLEMMA 1. Para cualquier (w, v) ∈ [0, 1]×(0, 1) tenemos que (w, v) ∈ B(W, V) si y solo si existe un u ∈ [0, 1] tal que (v, u) ∈ B(V, U) y w = f(u). PRUEBA. Fije un v arbitrario en (0, 1). Supongamos que U juega algún u ∈ pbrU (v), w = f(u) satisface w ∈ [0, 1], y W juega w. Existe un vector de estrategias v1, . . . , vj−1 = u, vj = v tal que para cada Vk, k < j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que w = f(u), V es indiferente entre jugar 0 y 1; en particular, puede jugar v. Por lo tanto, si definimos vj+1 = w, el vector de estrategias (v1, . . . , vj+1) cumplirá las condiciones en la definición de mejor respuesta potencial, es decir, tenemos v ∈ pbrV (w). Por el contrario, supongamos que v ∈ pbrV (w) para algún w ∈ [0, 1], v = 0, 1. Entonces existe un vector de estrategias v1, . . . , vj−1, vj = v, vj+1 = w tal que para cada Vk, k ≤ j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que v = 0, 1, V, de hecho, es indiferente entre jugar 0 y 1, lo cual solo es posible si w = f(vj−1). Elige u = vj−1; por construcción, u ∈ pbrU (v). El lema 1 describe las situaciones en las que V es indiferente entre jugar 0 y jugar 1. Sin embargo, para caracterizar completamente B(W, V), también necesitamos saber cuándo V prefiere una estrategia pura. Define ˆf(0) = ∪u∈pbrU (0)Ru, donde Ru = ´ [f(u), +∞)×{0} si B(u) > 0, (−∞, f(u)]×{0} si B(u) < 0. y ˆf(1) = ∪u∈pbrU (1)Ru, donde Ru = ´ [f(u), +∞)×{1} si B(u) < 0, (−∞, f(u)]×{1} si B(u) > 0. LEMMA 2. \n\nLEMMA 2. Para cualquier w ∈ [0, 1], tenemos que (w, 0) ∈ ˆf(0) si y solo si 0 ∈ pbrV (w) y (w, 1) ∈ ˆf(1) si y solo si 1 ∈ pbrV (w). PRUEBA. Considera un u0 arbitrario ∈ pbrU (0). Si B(u0) > 0, para u = u0 la desigualdad P0 ≥ P1 es equivalente a w ≥ f(u0). Por lo tanto, cuando U juega u0 y W juega w, w ≥ f(u0), V prefiere jugar 0; dado que u0 ∈ pbrU (u), se sigue que 0 ∈ pbrV (w). El argumento para el caso B(u0) < 0 es similar. Por el contrario, si 0 ∈ pbrV (w) para algún w ∈ [0, 1], existe un vector (v1, . . . , vj−1, vj = 0, vj+1 = w) tal que para cada Vk, k ≤ j, Vk juega vk, y esta estrategia es una mejor respuesta a las estrategias de los vecinos de Vk. Ten en cuenta que para cualquier vector de este tipo tenemos vj−1 ∈ pbrU (0). Por contradicción, asumimos que (w, 0) ∈ Ë u∈pbrU (0) Ru. Entonces debe ser el caso que para cualquier u0 ∈ pbrU (0) ya sea que f(u0) < w y Ru0 = (−∞, f(u0)]×{0} o f(u0) > w y Ru0 = [f(u0), +∞)×{0}. En ambos casos, cuando V juega 0, U juega u0, y V juega w, la desigualdad entre f(u0) y w es equivalente a P0 < P1, es decir, V se beneficiaría al cambiar a 1. El argumento para ˆf(1) es similar. Juntas, el Lema 1 y el Lema 2 describen completamente el conjunto B(W, V): tenemos B(W, V) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2. Queda por demostrar que B(W, V) puede representarse como una unión de como máximo (j + 4)2 rectángulos, tiene como máximo 2j + 4 puntos de evento, y puede ser calculado en tiempo O(j2). Sea u∗ = −B0/B1. Considera un rectángulo arbitrario R = [v1, v2]×[u1, u2] ⊆ B(V, U). Si u∗ ∈ [u1, u2], la función f(·) es continua en [u1, u2] y por lo tanto ˆf(R) = [fmin, fmax]×[v1, v2], donde fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste en un solo rectángulo. Ahora, supongamos que R es intersectado por la línea [0, 1]×{u∗}; como se mencionó anteriormente, hay a lo sumo 2j+2 rectángulos de este tipo. Se supone que limu→u∗− f(u) = +∞; dado que f(·) es una función lineal fraccional, esto implica que limu→u∗+ f(u) = −∞ y también f(u1) > f(u2). Dado que f(·) es continua en [u1, u∗ ) y (u∗ , u2], es fácil ver que ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2]. El caso B1 = 0 no causa problemas especiales. Para completitud, establezca u∗ como cualquier valor fuera de [0, 1] en este caso. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figura 4: f es creciente en (−∞, u∗ ) y (u∗ , +∞). y ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste de a lo sumo dos rectángulos. El caso limu→u∗− f(u) = −∞ es similar. Dado que ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), se sigue que ˆf(B(V, U)) consiste en un máximo de (j + 3)2 + 2j + 2 rectángulos. Además, es fácil ver que tanto ˆf(0) como ˆf(1) consisten en un máximo de 2 segmentos de línea cada uno. Concluimos que B(W, V) puede ser representado como una unión de a lo sumo (j + 3)2 + 2j + 6 < (j + 4)2 rectángulos. Además, si v es un punto de evento V de B(W, V), entonces v es un punto de evento V de B(V, U) (esto incluye los casos v = 0 y v = 1, ya que 0 y 1 son puntos de evento V de B(V, U)) y si w es un punto de evento W de B(W, V), entonces o bien w = 0 o w = 1 o existe algún u ∈ [0, 1] tal que w = f(u) y u es un punto de evento U de B(V, U). Por lo tanto, B(W, V) tiene como máximo 2j + 4 puntos de evento. El límite O(j2) en el tiempo de ejecución en el Teorema 5 se deriva de nuestra descripción del algoritmo. El límite de O(n3) en el tiempo total de ejecución para encontrar un equilibrio de Nash (y una representación de todos los equilibrios de Nash) se sigue. 4.1 Encontrar un solo equilibrio de Nash en tiempo O(n2) El límite superior en el tiempo de ejecución de nuestro algoritmo es ajustado, al menos asumiendo la implementación directa, en la que cada B(Vj+1, Vj) se almacena como una unión de rectángulos: no es difícil construir un ejemplo en el que el tamaño de B(Vj+1, Vj) sea Ω(j2). Sin embargo, en algunos casos no es necesario representar todos los equilibrios de Nash; más bien, el objetivo es encontrar un equilibrio arbitrario del juego. En esta sección, demostramos que este problema puede resolverse en tiempo cuadrático, obteniendo así una prueba del Teorema 1. Nuestra solución se basa en la idea de [9], es decir, trabajar con subconjuntos de las políticas de mejor respuesta en lugar de las políticas de mejor respuesta en sí mismas; siguiendo [9], nos referiremos a tales subconjuntos como políticas de punto de quiebre. Si bien no siempre es posible construir una política de puntos de interrupción según se define en [9], mostramos cómo modificar esta definición para garantizar que siempre exista una política de puntos de interrupción; además, demostramos que para un grafo de camino, la política de puntos de interrupción de cualquier vértice puede ser almacenada en una estructura de datos cuyo tamaño es lineal en el número de descendientes que tiene este vértice. Definición 3. Una política de puntos de quiebre ˆB(V, U) para un vértice U cuyo padre es V es una curva no auto-intersectante de la forma X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, donde Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] y ui, vi ∈ [0, 1] para i = 0, . . . , m. Decimos que una política de puntos de quiebre es válida si v0 = 0, vm = 1, y ˆB(V, U) ⊆ B(V, U). A veces abusaremos de la notación al referirnos a ˆB(V, U) como una colección de segmentos Xi, Yi en lugar de su unión. Se debe tener en cuenta que no requerimos que vi ≤ vi+1 o ui ≤ ui+1; por lo tanto, en cualquier argumento que involucre políticas de puntos de quiebre, todos los segmentos deben tratarse como segmentos dirigidos. Observe que cualquier política de puntos de quiebre válida ˆB(V, U) puede ser vista como un mapeo continuo 1-1 γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2, donde γ(0) = (0, u1), γ(1) = (1, um) y existen algunos t0 = 0, t1, . . . , t2m−2 = 1 tales que {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1. Como se explica en la Sección 3, podemos utilizar una política de punto de quiebre válida en lugar de la política de mejor respuesta durante el paso descendente, y aún así garantizar que al final, produciremos un equilibrio de Nash. El Teorema 6 muestra que se puede calcular de forma inductiva políticas de puntos de quiebre válidas para todos los vértices en el camino; la prueba de este teorema se puede encontrar en la versión completa de este artículo [6]. TEOREMA 6. Para cualquier V = Vj, se puede encontrar en tiempo polinómico una política de puntos de quiebre válida ˆB(W, V) que consiste en a lo sumo 2j + 1 segmentos. EQUILIBRIOS DE NASH EN GRÁFICOS CON GRADO MÁXIMO 2 En esta sección mostramos cómo el algoritmo para caminos puede aplicarse para resolver un juego en cualquier gráfico cuyos vértices tengan un grado de a lo sumo 2. Un grafo con grado máximo 2 es, por supuesto, una unión de caminos y ciclos. Dado que cada componente conectado puede ser manejado de forma independiente, para obtener una prueba del Teorema 2, solo necesitamos mostrar cómo tratar con los ciclos. Dado un ciclo con vértices V1, . . . , Vk (en orden cíclico), realizamos dos búsquedas separadas de un equilibrio de Nash: primero buscamos un equilibrio de Nash donde algún vértice juega una estrategia pura, luego buscamos un equilibrio de Nash completamente mixto, donde todos los vértices juegan estrategias mixtas. Para i ≤ k, dejemos que vi denote la probabilidad de que Vi juegue 1. La primera búsqueda se puede hacer de la siguiente manera. Para cada i ∈ {1, . . . , k} y cada b ∈ {0, 1}, haz lo siguiente. 1. Sea P el camino (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2. El pago a Vi+1 se basa en poner vi = b (por lo que depende solo de vi+1 y vi+2). 3. Aplica el pase ascendente a P 4. Pon vi = b; aplica el pase aguas abajo. Para cada vértice, Vj, lleva un registro de todas las posibles estrategias mixtas vj 5. Verificar si Vi+1 tiene alguna respuesta consistente con vi = b; si es así, tenemos un equilibrio de Nash. (De lo contrario, no hay un equilibrio de Nash del tipo deseado). Para la segunda búsqueda, hay que tener en cuenta que si Vi juega una estrategia mixta, entonces vi+1 y vi−1 satisfacen una ecuación de la forma vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1). Dado que todos los vértices en el ciclo juegan estrategias mixtas, tenemos vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1). Componiendo las dos transformaciones lineales fraccionarias, obtenemos vi+3 = (A0 + A1 vi−1)/(B0 + B1 vi−1), para algunas nuevas constantes A0, A1, B0, B1. Elige cualquier vértice Vi. Podemos expresar vi en términos de vi+2, luego vi+4, vi+6, etc. y finalmente vi mismo para obtener una ecuación cuadrática (para vi) que es fácil de derivar a partir de los pagos en el juego. Si la ecuación no es trivial, tiene como máximo 2 soluciones en (0, 1). Para un ciclo de longitud impar, todos los demás vj son derivables a partir de esas soluciones, y si existe un equilibrio de Nash completamente mezclado, todos los vj deberían resultar ser números reales en el rango (0, 1). Para un ciclo de longitud par, obtenemos dos ecuaciones cuadráticas, una para vi y otra para 105 vi+1, y de la misma manera podemos probar si alguna solución a estas ecuaciones produce valores para los otros vj, todos los cuales se encuentran en el intervalo (0, 1). Si la ecuación cuadrática es trivial, potencialmente hay un continuo de equilibrios completamente mezclados. Los valores de vi que pueden ocurrir en un equilibrio de Nash son aquellos para los cuales todos los valores dependientes vj se encuentran en el intervalo (0, 1); esta última condición es fácil de verificar calculando la imagen del intervalo (0, 1) bajo transformaciones lineales fraccionarias respectivas. 6. ENCONTRANDO EQUILIBRIOS EN UN ÁRBOL (ARBITRARIO) Para árboles arbitrarios, la estructura general del algoritmo permanece igual, es decir, se puede construir una política de mejor respuesta (o, alternativamente, una política de punto de quiebre) para cualquier vértice basada en las políticas de mejor respuesta de sus hijos. Suponemos que el grado de cada vértice está limitado por una constante K, es decir, la matriz de pagos para cada vértice es de tamaño O(2K). Consideremos un vértice V cuyos hijos son U1, . . . , Uk y cuyo padre es W; la política de mejor respuesta de cada Uj es B(V, Uj). De manera similar a la sección anterior, podemos calcular los pagos esperados V de jugar 0 o 1, respectivamente. Es decir, cuando cada uno de los Uj juega uj y W juega w, tenemos P0 = L0 (u1, . . . , uk, w), P1 = L1 (u1, . . . , uk, w), donde las funciones L0 (·, . . . , ·), L1 (·, . . . , ·) son lineales en todos sus argumentos. Por lo tanto, la desigualdad P0 > P1 se puede reescribir como wB(u1, . . . , uk) > A(u1, . . . , uk), donde tanto A(·, . . . , ·) como B(·, . . . , ·) son lineales en todos sus argumentos. Dado u = (u1, . . . , uk) y defina la función de indiferencia f : [0, 1]k → [0, 1] como f(u) = A(u)/B(u); claramente, si cada Uj juega uj, W juega w y w = f(u), V es indiferente entre jugar 0 y 1. Para cualquier X = X1 × · · · × Xk, donde Xi ⊆ [0, 1]2 se define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k}. Además, se establece ˆf(0) = {(w, 0) | ∃u tal que ui ∈ pbrUi (0) y wB(u) ≥ A(u)} y ˆf(1) = {(w, 1) | ∃u tal que ui ∈ pbrUi (1) y wB(u) ≤ A(u)}. Como en la sección anterior, podemos demostrar que B(W, V) es igual a ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2; además, cualquier camino de w = 0 a w = 1 que sea un subconjunto de B(W, V) constituye una política de puntos de quiebre válida. Política de Puntos de Quiebre de Tamaño Exponencial. Si bien el algoritmo de la Sección 4 se puede generalizar para árboles de grado acotado, su tiempo de ejecución ya no es polinomial. De hecho, la afirmación contraria es cierta: podemos construir una familia de árboles y matrices de pago para todos los jugadores de manera que las políticas de mejor respuesta para algunos de los jugadores consistan en un número exponencial de segmentos. Además, en nuestro ejemplo las políticas de puntos de quiebre coinciden con las políticas de mejor respuesta, lo que significa que incluso encontrar un solo equilibrio de Nash utilizando el enfoque de [8, 9] llevará un tiempo exponencialmente largo. De hecho, una afirmación más fuerte es cierta: para cualquier algoritmo de dos pasos de tiempo polinómico (definido más adelante) que funcione con subconjuntos de políticas de mejor respuesta para este grafo, podemos elegir las recompensas de los vértices de manera que el paso posterior de este algoritmo falle. La figura 5: El árbol Tn que corresponde a la política de puntos de quiebre de tamaño exponencial. En el resto de esta subsección, describimos esta construcción. Considera el árbol Tn dado por la Figura 5; sea Vn la raíz de este árbol. Para cada k = 1, . . . , n, permita que las ganancias de Sk y Tk sean las mismas que las de U y V descritas en la Sección 3; recuerde que las políticas de puntos de quiebre para U y V se muestran en la Figura 2. No es difícil ver que la función de indiferencia para Tk está dada por f(s) = .8s + .1. El pago de V0 es 1 si V1 selecciona la misma acción que V0 y 0 en caso contrario; la política de mejor respuesta de V0 está dada por la Figura 6. LEMMA 3. \n\nLEMMA 3. Dado k < n, y sean u, t, v y w las estrategias de Vk−1, Tk, Vk y Vk+1, respectivamente. Supongamos que Vk prefiere jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Entonces B(Vk+1, Vk) consta de al menos 3k segmentos. Además, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} y {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}. PRUEBA. La demostración procede por inducción en k. Para k = 0, la afirmación es obvia. Ahora, supongamos que es cierto para B(Vk, Vk−1). Se puede ver B(Vk+1, Vk) como una unión de siete componentes: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, y cinco componentes que corresponden a los segmentos de B(Vk, Tk). Examinémoslos uno por uno. Para describir ˆf(0)∩[0, 1]×{0}, observe que f(u, t) = .5t+.1u+.2 es monótona en t y u y cumple con f(0, 0) = .2. Además, tenemos pbrVk−1 (0) = {0} y pbrTk (0) = {0}. Para cualquier w ∈ [0, 1] tenemos f(0, 0) ≥ w si y solo si w ∈ [0, .2]. Concluimos que ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}. De manera similar, se sigue que ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}. Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; estos conjuntos corresponden a segmentos horizontales de B(Vk, Tk). Es fácil ver que S1, S2, S3 ⊂ B(Vk+1, Vk). Dado que f es una función continua, el número de segmentos en cada Si es al menos el número de segmentos en B(Vk, Vk−1)∩[.1, .9]×[0, 1], que es al menos 3k−1 por hipótesis de inducción. Además, dado que f es monótona en u y f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), todos los Si, i = 1, 2, 3, son disjuntos. Finalmente, el conjunto B(Vk+1, Vk) contiene dos segmentos que corresponden a los segmentos verticales de B(Vk, Tk), es decir, S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} y S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}. Claramente, S4 conecta S2 y S3, S5 conecta S1 y S2, y S4 y S5 no se intersectan entre sí. Concluimos que B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figura 6: Políticas de puntos de quiebre para V0 y V1, es una línea continua que consiste en al menos 3k segmentos y satisface la condición del lema. Para completar la construcción, necesitamos demostrar que podemos diseñar la matriz de pagos para Vk de manera que prefiera jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Con este fin, demostramos una afirmación más general, a saber, que la función de indiferencia de un vértice puede ser una función multilineal fraccional arbitraria de las estrategias de sus descendientes. Decimos que una función de k variables es multilineal si puede ser representada como una suma de monomios y cada uno de estos monomios es lineal en todas sus variables. Ten en cuenta que esta definición es diferente de una más estándar en el sentido de que no requerimos que todos los monomios tengan el mismo grado. Recuerde que las ganancias de un vértice con k + 1 vecinos están descritas por las matrices P0 y P1, donde Pj i0i1...ik es la ganancia que V obtiene cuando juega j, y sus vecinos juegan i0, . . . , ik, y j, i0, . . . , ik ∈ {0, 1}. Sea P[j] = P[j](w, u1, . . . , uk) la ganancia esperada obtenida por este vértice cuando juega j y las estrategias (mixtas) de sus vecinos están dadas por un vector (w, u1, . . . , uk), es decir, P[j] = E[P j i0i1...ik ] donde i0, . . . , ik son variables aleatorias de Bernoulli independientes, cada una de las cuales es 1 con las respectivas probabilidades w, u1, . . . , uk. LEMMA 4. \n\nLEMMA 4. Dado un vértice del árbol V cuyo padre es W y cuyos hijos son U1, . . . , Uk, para cualquier función f = f(u1, . . . , uk) que pueda representarse como una razón de dos funciones multilineales f1, f2, es decir, f = f1(u1,...,uk) f2(u1,...,uk), existen matrices de pago P0 y P1 para V tales que P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk). La prueba de este lema se basa en el hecho de que cada monomio de la forma as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, puede ser representado como t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk para algunos Ct, t ∈ {0, 1}k+1. Los detalles se pueden encontrar en la versión completa de este documento [6]. 6.2 Irreducibilidad de la Política de Mejor Respuesta para Tn Si bien la política de mejor respuesta construida en la subsección anterior tiene un tamaño exponencial, no está claro `a priori que sea necesario hacer un seguimiento de todos sus segmentos de línea en lugar de centrarse en un pequeño subconjunto de estos segmentos. Sin embargo, resulta que para algoritmos de dos pasadas como el algoritmo de [8], la política de mejor respuesta no se puede simplificar. Más precisamente, decimos que un algoritmo A es un algoritmo de dos pasadas si 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figura 7: Política de punto de quiebre para V2. • A consta de un paso ascendente y un paso descendente. • Durante el paso ascendente, para cada vértice V con padre W, A construye un conjunto BB(W, V) ⊆ B(W, V). Este conjunto se produce a partir de los conjuntos {BB(V, U) | U es un hijo de V} aplicando el procedimiento desde el principio de la Sección 6 (sustituyendo BB(V, Uj) por B(V, Uj) para todos los hijos Uj de V), y luego posiblemente omitiendo algunos de los puntos del conjunto resultante (que luego se almacena explícitamente). El paso aguas abajo es idéntico al paso aguas abajo de [8] como se describe en la Sección 2, excepto que opera en los conjuntos BB(W, V) en lugar de en los conjuntos B(W, V). El Teorema 7 demuestra que cualquier algoritmo de dos pasadas fallará durante la pasada aguas abajo en Tn si existe un índice j tal que el conjunto BB(Vj+1, Vj) omite algún punto interior de cualquiera de los (al menos 3j) segmentos de B(Vj+1, Vj). Esto implica el Teorema 3. TEOREMA 7. Para cualquier algoritmo de dos pasos A para el cual exista un índice j, j ∈ [1, n/4], un segmento S de B(Vj, Vj−1), y un punto interior (x, y) de S tal que BB(Vj, Vj−1) no contenga (x, y), podemos elegir matrices de pago de los vértices Vj, . . . , Vn para que el paso descendente de A falle, y, además, los pagos a V4j, . . . , Vn sean idénticamente 0. Esbozamos la demostración del Teorema 7; los detalles se pueden encontrar en la versión completa de este artículo [6]. Procedemos por inducción. Para j = 1, el argumento es similar al de la Sección 3. Para el paso inductivo, la idea principal es que podemos enfocarnos en cualquier parte de una política de mejor respuesta (¡incluyendo la parte que fue omitida!) utilizando una función de indiferencia apropiada; esto nos permite reducir el caso j = j0 a j = j0 − 1. En la sección anterior, demostramos que para juegos gráficos en árboles que son casi, pero no del todo, caminos, los algoritmos de dos pasos no logran encontrar equilibrios de Nash en tiempo polinómico. A continuación mostramos que una propiedad de grafo similar a un camino más suave nos permite construir juegos gráficos para los cuales es poco probable que cualquier algoritmo de tiempo polinómico encuentre equilibrios de Nash. 7.1 Ancho de camino Una descomposición de camino de un grafo G = (V, E) es una secuencia de subconjuntos Si(V) ⊆ V tal que para cada arista (v, v') ∈ E, v, v' ∈ Si(V) para algún i, y además, para cada v ∈ V, si v ∈ Si(V) y v ∈ Sj(V) para j > i, entonces v ∈ Sk(V) para todo i ≤ k ≤ j. La descomposición del camino tiene ancho k si todos los conjuntos Si(V) tienen una cardinalidad de a lo sumo k + 1. El ancho de camino de G es el ancho mínimo de cualquier descomposición de camino de G. 107 El ancho de camino es una restricción del ancho de árbol (en el cual se buscaría un árbol cuyos vértices fueran los conjuntos Si(V), y los conjuntos que contienen algún vértice tendrían que formar un subárbol). Para cualquier constante k, se puede decidir en tiempo polinómico si un grafo tiene un ancho de camino (o ancho de árbol) k. Además, muchos problemas de teoría de grafos parecen más fáciles de resolver en tiempo polinómico cuando se restringen a grafos con un ancho de árbol o un ancho de camino fijo, consulte [1] para obtener una visión general. Ten en cuenta que un camino tiene un ancho de camino de 1 y un ciclo tiene un ancho de camino de 2. 7.2 Completitud de PPAD Revisamos algunas definiciones básicas de la teoría de complejidad computacional de problemas de búsqueda. Un problema de búsqueda asocia cualquier entrada (aquí, un juego gráfico) con un conjunto de soluciones (aquí, los equilibrios de Nash del juego de entrada), donde la longitud de la descripción de cualquier solución debe estar acotada de forma polinómica en función de la longitud de la descripción de su entrada. En un problema de búsqueda total, hay una garantía de que al menos una solución existe para cualquier entrada. El teorema de Nash nos asegura que el problema de encontrar equilibrios de Nash es total. Una reducción del problema de búsqueda S al problema S es un mecanismo que muestra que cualquier algoritmo de tiempo polinómico para S implica un algoritmo de tiempo polinómico para S. Consiste en funciones f y g, computables en tiempo polinómico, donde f mapea entradas de S a entradas de S, y g mapea soluciones de S a soluciones de S, de tal manera que si IS es una entrada para S, y SS es una solución para f(IS), entonces g(SS) es una solución para IS. Observe que los problemas de búsqueda total no permiten las reducciones anteriores de problemas como CIRCUIT SAT (donde la entrada es un circuito booleano, y las soluciones son vectores de entrada que hacen que la salida sea verdadera) debido a que CIRCUIT SAT y otros problemas NP-completos tienen entradas con conjuntos de soluciones vacíos. En cambio, el trabajo reciente sobre la complejidad computacional de encontrar un equilibrio de Nash [7, 4, 5, 2, 3] lo ha relacionado con el siguiente problema. Definición 4. FIN DE LA LÍNEA. Circuitos booleanos S y P, cada uno con n bits de entrada y n bits de salida, donde P(0n) = 0n y S(0n) = 0n. Solución: x ∈ {0, 1}n tal que S(x) = x, o alternativamente x ∈ {0, 1}n tal que P(S(x)) = x. S y P pueden ser consideradas como representando sucesor y predecesor. Observe que al calcular Si (0n) (para i = 0, 1, 2, ...) y comparar con P(Si+1 (0n)), eventualmente debemos encontrar una solución para EL FIN DE LA LÍNEA. END OF THE LINE caracteriza la clase de complejidad PPAD (que significa argumento de paridad en un grafo, versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda S es PPAD-completo si END OF THE LINE se reduce a S. Otros problemas PPAD-completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para descripciones más detalladas de estos problemas). 3-GRAPHICAL NASH es el problema de encontrar un equilibrio de Nash para un juego gráfico cuyo grafo tiene grado 3. Daskalakis et al. [4] muestran la completitud de PPAD de NASH 3-GRÁFICO mediante una reducción de BROUWER TRIDIMENSIONAL, introducida en [4] y definida de la siguiente manera. Definición 5. BROUWER TRIDIMENSIONAL. Un circuito C que tiene 3n bits de entrada y 2 bits de salida. Los bits de entrada definen un cubilete del cubo unitario, compuesto por las 3 coordenadas de sus puntos, dadas con una precisión de n bits. La salida representa uno de los cuatro colores asignados por C a un cubito. C está restringido para asignar el color 1 a los cubitos adyacentes al plano (y, z), el color 2 a los cubitos restantes adyacentes al plano (x, z), el color 3 a los cubitos restantes en el plano (x, y), y el color 0 a todos los demás cubitos en la superficie del cubo unitario. Una solución es un vértice pancromático, un vértice adyacente a cubiletes que tienen 4 colores distintos. La razón por la que se garantiza la existencia de una solución es que se puede construir una función de Brouwer asociada φ, es decir, una función continua del cubo unitario a sí mismo, de modo que los vértices pancromáticos correspondan a los puntos fijos de φ. El Teorema del Punto Fijo de Brouwer promete la existencia de un punto fijo. La prueba del Teorema 4 utiliza una modificación de la reducción de [4] de 3-DIMENSIONAL BROUWER a 3-GRAPHICAL NASH. Para demostrar el teorema, comenzamos con algunos resultados preliminares de la siguiente manera. Cada jugador tiene 2 acciones, denominadas 0 y 1. Para un jugador en el vértice V, dejemos que p[V] denote la probabilidad de que el jugador juegue 1. LEMMA 5. [7] Existe un juego gráfico Gshift de tamaño fijo con vértices V, V donde p[V] es la parte fraccionaria de 2p[V]. COROLARIO 1. Existe un juego gráfico Gn−shift de tamaño Θ(n) de ancho de camino constante, con vértices V, Vn donde p[Vn] es la parte fraccionaria de 2n .p[V]. PRUEBA. Crear una cadena de n copias de Gshift en el Lema 5. Cada subconjunto de vértices en la descomposición del camino son los vértices en una copia de Gshift. Que In(x) denote el n-ésimo bit de la expansión binaria de x, donde interpretamos 1 como verdadero y 0 como falso. Lo siguiente utiliza dispositivos de [7, 4]. COROLARIO 2. Existe un valor k tal que para todo n, y para todo n1, n2, n3 ≤ n, existe un juego gráfico de tamaño O(n) con ancho de camino k, teniendo vértices V1, V2, V3 donde p[V3] = p[V1] + 2−n3 (En1 p[V1] ∧ En2 p[V2]). PRUEBA DEL TEOREMA 4. Sea C el circuito booleano que describe una instancia de BROUWER TRIDIMENSIONAL. Sean g1, . . . , gp(n) las compuertas de C indexadas de tal manera que la(s) entrada(s) de cualquier compuerta son la(s) salida(s) de las compuertas de índice inferior. g1, . . . , g3n serán las 3n entradas de C. Todos los jugadores en el juego gráfico G construido en [4] tienen 2 acciones denotadas como 0 y 1. La probabilidad de que V juegue 1 se denota como p[V]. G tiene 3 jugadores Vx, Vy y Vz para los cuales p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto en el cubo unitario. G está diseñado para incentivar a Vx, Vy y Vz a ajustar sus probabilidades en direcciones dadas por una función de Brouwer que está especificada por el circuito C. En un equilibrio de Nash, p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto fijo de una función que pertenece a la clase de funciones representadas por el BROUWER TRIDIMENSIONAL. Para 1 ≤ i ≤ p(n) introducimos un vértice V (i) C tal que para 1 ≤ j ≤ i, Ij(p[V (i) C ]) es la salida de la compuerta gj; para i < j ≤ p(n), Ij(p[V (i) C ]) es 0. Construye V (i) C a partir de V (i−1) C utilizando el Corolario 2. Sea G(i) el juego gráfico que hace esto. Sea S1(G(i)), . . . , Sn(G(i)) una descomposición de camino de longitud n de G(i), donde V(i−1) ⊂ S1(G(i)) y V(i) ⊂ Sn(G(i)). Luego, se obtiene una descomposición de camino de ∪1≤i≤p(n)G(i) tomando la unión de las descomposiciones de camino separadas, junto con Sn(G(i−1) ) ∪ S1(G(i) ) para 2 ≤ i ≤ p(n). Sea GC el juego gráfico anterior que simula C. GC tiene 3n entradas, que consisten en los primeros n bits de las expansiones binarias de p[Vx], p[Vy] y p[Vz]. De manera similar a [4], la salida de GC afecta a Vx, Vy y Vz de la siguiente manera. El color 0 incentiva a Vx, Vy y Vz 108 a ajustar sus probabilidades p[Vx], p[Vy] y p[Vz] en la dirección (−1, −1, −1); el color 2 los incentiva a moverse en la dirección (1, 0, 0); el color 2, dirección (0, 1, 0); el color 3, dirección (0, 0, 1). Necesitamos asegurarnos de que en los puntos en los límites de los cubitos adyacentes, el cambio de dirección será aproximadamente el promedio de las direcciones de los puntos circundantes. De esta manera, los cuatro colores/direcciones deben estar cerca para que puedan anularse entre sí (y estemos en un vértice pancromático). Esto se logra utilizando el mismo truco que [4], en el cual hacemos un número constante M de copias de GC, que difieren en que cada copia agrega un vector de desplazamiento pequeño a sus copias de p[Vx], p[Vy] y p[Vz] (que se derivan del original utilizando el dispositivo de adición de [7]). Usando los dispositivos de suma y multiplicación de [7], promediamos las direcciones y sumamos un pequeño múltiplo de este promedio a (p[Vx], p[Vy], p[Vz]). En un equilibrio de Nash, las salidas de cada copia se cancelarán mutuamente. El ancho de camino del juego completo es a lo sumo M veces el ancho de camino GC. 8. PROBLEMAS ABIERTOS El problema más importante que queda abierto en este artículo es si es posible encontrar un equilibrio de Nash de un juego gráfico en un árbol de grado acotado en tiempo polinómico. Nuestra construcción muestra que cualquier algoritmo de dos pasadas que almacene explícitamente políticas de puntos de quiebre necesita tiempo y espacio exponenciales. Sin embargo, esto no excluye la existencia de un algoritmo que se base en una idea similar, pero en lugar de calcular la política de punto de ruptura completa para cada vértice, utiliza un pequeño número de pasadas adicionales a través del grafo para decidir qué partes (de tamaño polinómico) de cada política de punto de ruptura deben ser calculadas. En particular, dicho algoritmo puede basarse en el algoritmo de aproximación de [8], donde el valor de es elegido de forma adaptativa. Otra pregunta intrigante está relacionada con el hecho de que el grafo para el cual construimos una política de puntos de quiebre de tamaño exponencial tiene un ancho de camino de 2, mientras que nuestros resultados positivos son para un camino, es decir, un grafo de ancho de camino 1. No está claro si para cualquier grafo de grado acotado con ancho de camino 1, el tiempo de ejecución de nuestro algoritmo (versión basada en política de puntos de interrupción) será polinomial. En particular, resulta instructivo considerar un grafo oruga, es decir, el grafo que se puede obtener a partir de Tn al eliminar los vértices S1, . . . , Sn. Para este gráfico, la mejor política de respuesta de un vértice Vk en la columna vertebral de la oruga se obtiene combinando la mejor política de respuesta de su predecesor en la columna vertebral Vk−1 y su otro hijo Tk; dado que este último es una hoja, su mejor política de respuesta es trivial (es decir, [0, 1]2, [0, 1]×{0} o [0, 1]×{1}) o consiste en dos segmentos horizontales y un segmento vertical de la forma {α}×[0, 1] que los conecta. Suponiendo, para mayor comodidad, que B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, y f es la función de indiferencia para Vk, observamos que la política de mejor respuesta para Vk consta de 5 componentes: ˆf(0), ˆf(1), y tres componentes que corresponden a [0, α]×{0}, {α}×[0, 1], y [α, 1]×{1}. Por lo tanto, se puede pensar en la construcción de B(Vk+1, Vk) como el siguiente proceso: girar B(Vk, Vk−1) en π/2, cortarlo a lo largo de la línea (ahora horizontal) vk = α, aplicar una transformación lineal fraccional a la coordenada horizontal de ambas partes y volver a conectarlas usando la imagen del segmento {α}×[0, 1] bajo f. Esto implica que el problema de acotar el tamaño de la política de mejor respuesta (o, alternativamente, la política de punto de quiebre) se puede ver como una generalización del siguiente problema de geometría computacional, que creemos puede ser de interés independiente: PROBLEMA 1. Dada una colección de segmentos paralelos a los ejes en R2, considera la siguiente operación: elige una línea paralela a los ejes li (ya sea vertical u horizontal), corta el plano a lo largo de esta línea y desplaza una de las dos partes resultantes por una cantidad arbitraria δi; como resultado, algunos segmentos se dividirán en dos partes. Reconecte estas partes, es decir, para cada segmento de la forma [a, b] × {c} que fue transformado en [a, t] × {c + δi} y [t, b] × {c}, introduzca un segmento {t} × [c, c+δi]. ¿Es posible comenzar con el segmento [0, 1] y después de n operaciones obtener un conjunto que no pueda representarse como una unión de poli(n) segmentos de línea? ¿En caso afirmativo, puede ser que en este conjunto no haya un camino con un número polinomial de giros que conecte los extremos del segmento original? Resulta que en general, la respuesta a la primera pregunta es positiva, es decir, después de n pasos, es posible obtener un conjunto que consiste en Θ(cn) segmentos para algún c > 0. Esto implica que incluso para una oruga, la mejor política de respuesta puede ser exponencialmente grande. Sin embargo, en nuestro ejemplo (que se omite en esta versión del documento debido a limitaciones de espacio), existe un camino de tamaño polinómico a través de la política de mejor respuesta, es decir, no demuestra que la política de punto de quiebre sea necesariamente exponencial en tamaño. Si se puede demostrar que esto siempre es cierto, puede ser posible adaptar esta prueba para mostrar que puede haber una brecha exponencial entre los tamaños de las políticas de mejor respuesta y las políticas de punto de quiebre. 9. REFERENCIAS [1] H. Bodlaender y T. Kloks. Algoritmos eficientes y constructivos para el ancho de camino y el ancho de árbol de grafos. Revista de Algoritmos, 21:358-402, 1996. [2] X. Chen y X. Deng. 3-NASH es PPAD-completo. Informe técnico TR-05-134, Coloquio Electrónico en Complejidad Computacional, 2005. [3] X. Chen y X. Deng. Resolviendo la complejidad del equilibrio de Nash de 2 jugadores. Informe técnico TR-05-140, Coloquio Electrónico en Complejidad Computacional, 2005. [4] C. Daskalakis, P. Goldberg y C. Papadimitriou. La complejidad de calcular un equilibrio de Nash. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [5] C. Daskalakis y C. Papadimitriou. Los juegos de tres jugadores son difíciles. Informe técnico TR-05-139, Coloquio Electrónico en Complejidad Computacional, 2005. [6] E. Elkind, L. Goldberg y P. Goldberg. Equilibrios de Nash en juegos gráficos en árboles revisados. Informe técnico TR-06-005, Coloquio Electrónico en Complejidad Computacional, 2006. [7] P. Goldberg y C. Papadimitriou. Reductibilidad entre problemas de equilibrio. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [8] M. Kearns, M. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, 2001. [9] M. Littman, M. Kearns y S. Singh. Un algoritmo exacto eficiente para juegos gráficos de conexión simple. En Actas de la 15ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2001. [10] L. Ortiz y M. Kearns. Propagación de Nash para juegos gráficos con bucles. En Actas de la 17ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2003. [11] C. Papadimitriou. Sobre la complejidad del argumento de paridad y otras demostraciones ineficientes de existencia. J. Comput. This is not a complete sentence. Please provide more context or the full sentence you would like me to translate. Cienc., 48(3):498-532, 1994. 109 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "nash equilibrium": {
            "translated_key": "equilibrio de Nash",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single <br>nash equilibrium</br> in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a <br>nash equilibrium</br>.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a <br>nash equilibrium</br> for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single <br>nash equilibrium</br> in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a <br>nash equilibrium</br> in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a <br>nash equilibrium</br> of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a <br>nash equilibrium</br>, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a <br>nash equilibrium</br> of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a <br>nash equilibrium</br> of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a <br>nash equilibrium</br> of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a <br>nash equilibrium</br> of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a <br>nash equilibrium</br> of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a <br>nash equilibrium</br> for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single <br>nash equilibrium</br> by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a <br>nash equilibrium</br>.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a <br>nash equilibrium</br>.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a <br>nash equilibrium</br> since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a <br>nash equilibrium</br> since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a <br>nash equilibrium</br>.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a <br>nash equilibrium</br>.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a <br>nash equilibrium</br> (and a representation of all Nash equilibria) follows. 4.1 Finding a Single <br>nash equilibrium</br> in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a <br>nash equilibrium</br>.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a <br>nash equilibrium</br>: first we search for a <br>nash equilibrium</br> where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a <br>nash equilibrium</br>. (Otherwise, there is no <br>nash equilibrium</br> of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed <br>nash equilibrium</br> exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a <br>nash equilibrium</br> are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single <br>nash equilibrium</br> using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a <br>nash equilibrium</br> [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a <br>nash equilibrium</br> for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a <br>nash equilibrium</br>, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a <br>nash equilibrium</br> the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a <br>nash equilibrium</br> of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player <br>nash equilibrium</br>.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a <br>nash equilibrium</br>.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single <br>nash equilibrium</br> in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a <br>nash equilibrium</br>.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a <br>nash equilibrium</br> for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single <br>nash equilibrium</br> in polynomial time.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a <br>nash equilibrium</br> in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2)."
            ],
            "translated_annotated_samples": [
                "Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único <br>equilibrio de Nash</br> en tiempo polinómico.",
                "Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un <br>equilibrio de Nash</br>.",
                "Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un <br>equilibrio de Nash</br> para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable).",
                "El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único <br>equilibrio de Nash</br> en tiempo polinómico.",
                "Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un <br>equilibrio de Nash</br> en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2)."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único <br>equilibrio de Nash</br> en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un <br>equilibrio de Nash</br>. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un <br>equilibrio de Nash</br> para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único <br>equilibrio de Nash</br> en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un <br>equilibrio de Nash</br> en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "degree": {
            "translated_key": "grado",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low <br>degree</br>, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general <br>degree</br>-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-<br>degree</br> trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum <br>degree</br> 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded <br>degree</br>.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-<br>degree</br> trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum <br>degree</br> 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low <br>degree</br>, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum <br>degree</br> 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded <br>degree</br>, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-<br>degree</br> trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-<br>degree</br> trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum <br>degree</br> 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of <br>degree</br> d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM <br>degree</br> 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have <br>degree</br> at most 2.",
                "A graph having maximum <br>degree</br> 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the <br>degree</br> of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same <br>degree</br>.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has <br>degree</br> 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-<br>degree</br> tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-<br>degree</br> graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "When the number of players is large, and the underlying graph has low <br>degree</br>, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general <br>degree</br>-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-<br>degree</br> trees.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum <br>degree</br> 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded <br>degree</br>."
            ],
            "translated_annotated_samples": [
                "Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo <br>grado</br>, proporcionan una forma concisa de representar las ganancias de los jugadores.",
                "Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de <br>grado</br>-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema.",
                "En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de <br>grado</br> acotado.",
                "Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de <br>grado</br> máximo 2.",
                "Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene <br>grado</br> acotado."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo <br>grado</br>, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de <br>grado</br>-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de <br>grado</br> acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de <br>grado</br> máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene <br>grado</br> acotado. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "dynamic programming-based algorithm": {
            "translated_key": "algoritmo basado en programación dinámica",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a <br>dynamic programming-based algorithm</br> that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "This setting was first considered by Kearns, Littman and Singh, who proposed a <br>dynamic programming-based algorithm</br> that computes all Nash equilibria of such games."
            ],
            "translated_annotated_samples": [
                "Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un <br>algoritmo basado en programación dinámica</br> que calcula todos los equilibrios de Nash de tales juegos."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un <br>algoritmo basado en programación dinámica</br> que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V. El algoritmo genérico no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente. En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta. La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2). Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del algoritmo genérico de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino). Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9]. En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un juego gráfico en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario). Obtenemos el siguiente teorema TEOREMA 1. Existe un algoritmo O(n2) que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un camino de n vértices. Existe un algoritmo O(n3) que calcula una representación de todos los equilibrios de Nash de dicho juego. En la Sección 5 extendemos los resultados de la Sección 4 a grafos de grado 2 en general, obteniendo el siguiente teorema. TEOREMA 2. Existe un algoritmo de tiempo polinómico que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un grafo con grado máximo 2. En la Sección 6 ampliamos nuestro algoritmo para que pueda ser utilizado para encontrar un equilibrio de Nash de un juego gráfico en un árbol arbitrario. Incluso cuando el árbol tiene grado acotado, el tiempo de ejecución puede ser exponencial. Mostramos que esto es inevitable construyendo una familia de juegos gráficos en árboles de grado acotado para los cuales las políticas de mejor respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de dos pasos (es decir, un algoritmo que es similar en espíritu al de [8]) tiene que almacenar casi todos los puntos de las políticas de mejor respuesta. En particular, mostramos lo siguiente. TEOREMA 3. Existe una familia infinita de juegos gráficos en árboles de grado acotado con ancho de camino 2, tal que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales. Es interesante notar que los árboles utilizados en la demostración del Teorema 3 tienen un ancho de camino de 2, es decir, están muy cerca de ser caminos. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico para grafos de ancho de camino 1. Esta pregunta puede ser vista como una generalización de un problema muy natural de geometría computacional; lo describimos con más detalle en la Sección 8. En la Sección 7, presentamos un resultado de intractabilidad teórica de complejidad para el problema de encontrar un equilibrio de Nash de un juego gráfico en un grafo con un ancho de camino pequeño. Demostramos el siguiente teorema. TEOREMA 4. Considera el problema de encontrar un equilibrio de Nash para un juego gráfico en el cual el grafo subyacente tiene un grado máximo de 3 y un ancho de camino k. Existe una constante k tal que este problema es PPAD-completo. El teorema 4 limita la medida en que podemos explotar las propiedades de tipo camino del grafo subyacente para encontrar equilibrios de Nash. Para demostrar el Teorema 4, utilizamos resultados recientes de completitud de PPAD para juegos, en particular los artículos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de grado d (para d ≥ 3) es computacionalmente equivalente al problema de resolver juegos en forma normal de r jugadores (para r ≥ 4), ambos de los cuales son PPAD-completos. CONSIDERACIONES PREVIAS Y NOTACIÓN Consideramos juegos gráficos en los que el grafo subyacente G es un árbol de n vértices. Cada vértice tiene dos acciones, que se denotan como 0 y 1. Una estrategia mixta se define por un único número x ∈ [0, 1], que indica la probabilidad de que el jugador seleccione la acción 1. Para los propósitos del algoritmo, el árbol está enraizado de manera arbitraria. Para mayor comodidad, asumimos sin pérdida de generalidad que la raíz tiene un solo hijo y que su recompensa es independiente de la acción elegida por el hijo. Esto se puede lograr primero eligiendo una raíz arbitraria del árbol, y luego agregando un padre ficticio de esta raíz, asignándole una función de pago constante. Dado un borde (V, W) del árbol G, y una estrategia mixta w para W, sea G(V,W), W=w la instancia obtenida de G mediante (1) eliminar todos los nodos Z que están separados de V por W (es decir, todos los nodos Z tales que el camino de Z a V pasa por W), y (2) restringir la instancia de modo que se requiera que W juegue la estrategia mixta w. Definición 1. Supongamos que (V, W) es un borde del árbol, que v es una estrategia mixta para V y que w es una estrategia mixta para W. Decimos que v es una mejor respuesta potencial para w (indicado por v ∈ pbrV(w)) si hay un equilibrio en la instancia G(V, W), W = w en el que V tiene la estrategia mixta v. Definimos la política de mejor respuesta para V, dada W, como B(W, V) = {(w, v) | v ∈ pbrV(w), w ∈ [0, 1]}. Normalmente, W es el padre de V, y esto se conoce simplemente como la política de mejor respuesta para V. La expresión B(W, V )|V =v se utiliza para denotar el conjunto B(W, V ) ∩ [0, 1]×{v}. El paso ascendente del algoritmo genérico de [8] calcula la política de mejor respuesta para V en cada nodo V que no sea la raíz. Con las suposiciones anteriores sobre la raíz, el paso aguas abajo es sencillo: Sea W la raíz y V su hijo. La raíz selecciona cualquier par (w, v) de B(W, V). Decide jugar con la estrategia mixta w e instruye a V a jugar con la estrategia mixta v. El resto del paso descendente es recursivo. Cuando un nodo V recibe instrucciones de su padre para adoptar la estrategia mixta v, hace lo siguiente para cada hijo U: encuentra un par (v, u) ∈ B(V, U) (con el mismo valor de v que le fue dado por su padre) e instruye a U a jugar u. ALGORITMO DE LITTMAN ET AL. El algoritmo de [9] se basa en la siguiente observación: para calcular un equilibrio de Nash único mediante un algoritmo de dos pasos, no es necesario construir la política de mejor respuesta completa para cada vértice. Si, en cada paso de la pasada descendente, el vértice en consideración puede seleccionar un vector de estrategias para todos sus hijos de manera que la estrategia de cada hijo sea una mejor respuesta potencial a la estrategia del padre, el algoritmo logra producir un equilibrio de Nash. Esto se puede lograr si, al comienzo del paso aguas abajo, tenemos una estructura de datos en la que cada vértice V con padre W almacena un conjunto ˆB(W, V ) ⊆ B(W, V ) (llamado una política de puntos de quiebre) que cubre cada posible w ∈ [0, 1]. Mostraremos más adelante que una condición suficiente para la construcción de una estructura de datos así es la invariante de que, en cada nivel del paso ascendente, ˆB(W, V) contiene un camino continuo desde w = 0 hasta w = 1. En [9], se sugiere que podemos seleccionar la política de punto de quiebre de una manera particular. Es decir, el documento utiliza la siguiente definición: Definición 2. (cf. [9]) Una política de puntos de ruptura para un nodo V con padre W consiste en un conjunto ordenado de puntos de ruptura de W, w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 y un conjunto asociado de valores de V, v1, . . . , vt. La interpretación es que para cualquier w ∈ [0, 1], si wi−1 < w < wi para algún índice i y W juega w, entonces V deberá jugar vi; y si w = wi para algún índice i, entonces V deberá jugar cualquier valor entre vi y vi+1. Decimos que una política de punto de quiebre tiene t - 1 puntos de quiebre. El artículo luego afirma que cualquier vértice V puede calcular su política de punto de interrupción con respecto a su padre W dadas las políticas de punto de interrupción de sus hijos U1, . . . , Uk. La prueba procede ordenando los puntos de quiebre de los niños (es decir, los valores respectivos de v) de izquierda a derecha (se puede asumir sin pérdida de generalidad que todos estos puntos de quiebre son distintos) y considerándolos sucesivamente; cada punto vl ∈ {v1, . . . , vL} corresponde a una elección fija de estrategias para k − 1 niños y un intervalo de estrategias admisibles para un niño. Supongamos, para mayor comodidad, que este niño es U1 y su intervalo de estrategias admisibles en vl es [a, b]; supongamos también que para Uj, j = 2, . . . , k, sus respectivas políticas de puntos de quiebre les prescriben jugar uj en respuesta a vl. Sea P i (u, w), i = 0, 1, el pago esperado para V cuando V juega i, U1 juega u, cada Uj, j = 2, . . . , k, juega uj, y W juega w, y considera el conjunto Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] tal que P 0 (u, w) = P1 (u, w)}; nota que para cualquier w ∈ Wl tenemos vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figura 1: LKS: Recorte para encontrar políticas de puntos de quiebre. Los autores muestran que para cualquier punto de quiebre vl, el conjunto Wl está vacío, es un solo intervalo, o es una unión de dos intervalos no flotantes (un intervalo es no flotante si uno de sus extremos es 0 o 1); además, la unión de todos los conjuntos Wl, l = 1, . . . , L, cubre el intervalo [0, 1]. Se sigue fácilmente que se puede cubrir [0, 1] con a lo sumo L+2 intervalos, cada uno de los cuales es un subconjunto de algún Wl. Los autores afirman entonces que cualquier cobertura de este tipo puede ser transformada en una política de puntos de ruptura para V. Es decir, afirman que para cualquier par de intervalos Wl1 y Wl2 en la cobertura, cualquier superposición entre Wl1 y Wl2 puede asignarse arbitrariamente a la cobertura por Wl1 y Wl2 recortados en consecuencia (cf. [9], p. 5). Ellos ilustran su enfoque en una figura, la cual se reproduce como Figura 1 aquí. En la figura, las líneas horizontales discontinuas representan los puntos de quiebre v1, v2, . . . , v7 y los intervalos sólidos a lo largo de estos puntos de quiebre son los conjuntos W1, W2, . . . , W7. El camino grueso conectado es la política de punto de quiebre correspondiente. Se elige de la siguiente manera: comenzar en la izquierda y siempre saltar al intervalo que permita el mayor avance hacia la derecha. Para entender por qué este enfoque no funciona en general, considera un camino de longitud 4 que consiste en una raíz indiferente R, su hijo W, el hijo de W V y el hijo de V U. Supongamos que U recibe un pago de 1 si juega de manera diferente a V y 0 en caso contrario. Así, si v denota la estrategia mixta de V (es decir, V juega 1 con probabilidad v), entonces la ganancia esperada que U obtiene al jugar 0 se da por P0(U) = v y la ganancia esperada que U obtiene al jugar 1 se da por P1(U) = 1 − v. Supongamos que V no obtiene ganancia al jugar 1 (por lo que P1(V) = 0) y que su matriz de ganancias al jugar 0 es 1 −9 9 −1, entonces si u denota la estrategia mixta de U y w denota la estrategia mixta de W, la ganancia esperada que V obtiene al jugar 0 se da por P0(V) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1). Usando las técnicas de [8] (o, alternativamente, las de la Sección 4), no es difícil verificar que las políticas de mejor respuesta para U y V (como en la Definición 1) están dadas por los gráficos en la Figura 2. La mejor política de respuesta para U es una política de punto de quiebre para U (como en la Definición 2) con puntos de quiebre V v0 = 0, v1 = 1/2 y v2 = 1 con valores asociados u1 = 1 y u2 = 0. La mejor política de respuesta para V no es una política de punto de quiebre (debido a cómo la curva de w = 0 a w = 1 retrocede). El algoritmo LKS recortaría para obtener una política de puntos de quiebre como la que se muestra en la Figura 3. Se observa que esta política de punto de quiebre ˆB(W, V) es inválida en el sentido de que no satisface ˆB(W, V) ⊆ B(W, V). El punto es que la matriz de pagos de W ahora puede ser elegida para evitar que el algoritmo LKS encuentre un equilibrio de Nash. Por ejemplo, supongamos que las ganancias se dan de tal manera que P0 (W) = v y P1 (W) = (1−v)2. La mejor política de respuesta para W es una línea horizontal en w = 0.1 (Este es el valor de w que permite v = 2/3 - ver Figura 2, lo que hace que P0 (W) = P1 (W).) En el paso descendente, los valores elegidos son w = .1, luego, a partir del recorte, v = 0 y u = 1, lo cual no es un equilibrio de Nash ya que W prefiere la acción 1. El fallo del algoritmo no se debe al hecho de que la política de recorte llegue tan lejos a la derecha como sea posible. Cualquier otro recorte sería igual de malo. Por ejemplo, supongamos que la política de punto de quiebre para V tiene v = 0 hasta algún punto w∗ < .9 y luego salta a v = 1. El algoritmo es entonces derrotado por la matriz de pagos con P0(W) = 2v y P1(W) = (1 − v) en la que la política de mejor respuesta para W es una línea horizontal en w = .9. El algoritmo luego da w = .9, v = 1, y u = 0, lo cual no es un equilibrio de Nash ya que W prefiere la acción 0. Concluimos que el algoritmo LKS no siempre encuentra un equilibrio de Nash. En las Secciones 4 y 6 mostramos cómo modificar el algoritmo para que siempre encuentre un equilibrio de Nash. Para el algoritmo modificado, debemos extender la definición de la política de punto de quiebre (ver Definición 3) para que incluya políticas de punto de quiebre como la política de mejor respuesta para V en la Figura 2. Desafortunadamente, una política de punto de interrupción de este tipo puede ser exponencial en tamaño (ver Figura 7), por lo que el algoritmo corregido no se ejecuta en tiempo polinómico en todos los árboles. En la siguiente sección, mostramos que se ejecuta en tiempo polinómico en un camino. 4. ENCONTRANDO EQUILIBRIOS EN UN CAMINO En esta sección, nos enfocamos en el caso en el que el grafo subyacente es un camino, es decir, su conjunto de vértices es {V1, . . . , Vn}, y su conjunto de aristas es {(Vj , Vj+1) | j = 1, . . . , n − 1}. Mostramos que en este caso la mejor política de respuesta para cada vértice puede ser representada como una unión de un número polinomial de rectángulos, donde un rectángulo está definido por un par de intervalos cerrados (IV, IU) y consiste en todos los puntos en IV × IU; puede ser el caso de que uno o ambos de los intervalos IV e IU consistan en un solo punto. TEOREMA 5. Para cualquier j = 1, . . . , n, el conjunto B(Vj , Vj−1) puede ser representado como una unión disjunta de a lo sumo (j + 4)2 rectángulos. Además, dado tal representación de B(Vj , Vj−1), se puede calcular una representación de B(Vj+1, Vj) en tiempo O(j2). PRUEBA. Para cualquier conjunto A ⊆ [0, 1]2 que esté representado como una unión de un número finito de rectángulos, decimos que un punto u ∈ [0, 1] en el eje U es un punto de evento U de A si u = 0 o u = 1 o A contiene un rectángulo de la forma IV × IU y u es un extremo de IU; los puntos de evento V se definen de manera similar. Observa que para cualquier u ∈ [0, 1], el número de componentes conectadas de [0, 1]×{u} ∩ A es a lo sumo el número de puntos de V-evento de A. Utilizamos inducción en j para demostrar que para cada Vj se cumple la afirmación del teorema y, además, cada B(Vj, Vj−1) tiene como máximo 2j + 4 puntos de evento. Para simplificar el caso base, modificamos el juego gráfico agregando un vértice ficticio V0 al principio del camino: el único vecino de V0 es V1, las ganancias de V0 siempre son iguales a 0, y las ganancias de todos los demás vértices (incluido V1) son las mismas que en el juego original. Para j = 0, tenemos B(V1, V0) = [0, 1]2, por lo que la afirmación del teorema es trivialmente verdadera. Ahora, supongamos que j > 0, establezca V = Vj y permita que U = Vj−1 y W = Vj+1 sean los vértices que preceden y siguen a V, respectivamente. Los pagos para V están descritos por una matriz 2×2×2 P: Pxyz es el pago que V recibe cuando U juega x, V juega y, y W juega z, donde x, y, z ∈ {0, 1}. Supongamos que U juega 1 con probabilidad u y W juega 1 con probabilidad w. Entonces la ganancia esperada de V al jugar 0 es P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, mientras que su ganancia esperada al jugar 1 es P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111. Si P0 > P1, V prefiere estrictamente jugar 0; si P0 < P1, V prefiere estrictamente jugar 1; y si P0 = P1, V es indiferente, es decir, puede jugar cualquier estrategia (mixta). Dado que P0 y P1 son lineales en w y u, existen algunas constantes A1, A0, B1 y B0 que dependen de la matriz P, pero no de u y w, de modo que P0 − P1 = w(B1u + B0) − (A1u + A0). Dependiendo de los valores de A1, A0, B1 y B0, subdividimos el resto de la prueba en los siguientes casos. • B1 = 0, B0 = 0. En este caso, P0 > P1 si y solo si A1u + A0 < 0. Si también A1 = 0, A0 = 0, claramente, B(W, V) = [0, 1]2, y la afirmación del teorema es trivialmente verdadera. De lo contrario, el vértice V es indiferente entre 0 y 1 si y solo si A1 = 0 y u = −A0/A1. Sea V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}. Por la hipótesis inductiva, V consiste en a lo sumo 2(j − 1) + 4 segmentos y puntos aislados. Para cualquier v ∈ V, tenemos B(W, V)|V = v = [0, 1]: no importa lo que juegue W, siempre y cuando U esté jugando −A0/A1, V está contento de jugar v. Por otro lado, para cualquier v ∈ (0, 1) \\ V tenemos B(W, V)|V = v = ∅: cuando V juega v, U solo puede responder con u = −A0/A1, en cuyo caso V puede beneficiarse cambiando a una de las estrategias puras. Para completar la descripción de B(W, V), queda por analizar los casos v = 0 y v = 1. El vértice V prefiere jugar 0 si A1 > 0 y u ≤ −A0/A1, o A1 < 0 y u ≥ −A0/A1, o 103 A1 = 0 y A0 < 0. Supongamos por ahora que A1 > 0; los otros dos casos pueden ser tratados de manera similar. En este caso, 0 ∈ pbrV (w) para algún w ∈ [0, 1] si y solo si existe un u ∈ pbrU (0) tal que u ≤ −A0/A1: si no existe tal u, cada vez que V juega 0, la respuesta de U no está en pbrU (0) o V puede mejorar su recompensa jugando 1. Por lo tanto, o bien B(W, V)|V=0 = [0, 1] o B(W, V)|V=0 = ∅. De manera similar, B(W, V)|V=1 es igual a [0, 1] o ∅, dependiendo de pbrU(1). Por lo tanto, el conjunto B(W, V) consiste en un máximo de 2j + 4 ≤ (j + 4)2 rectángulos: B(W, V) ∩ [0, 1]×(0, 1) = [0, 1]×V contribuye como máximo con 2j + 2 rectángulos, y cada uno de los conjuntos B(W, V)|V=0 y B(W, V)|V=1 contribuye como máximo con un rectángulo. De manera similar, su número total de puntos de evento es a lo sumo 2j + 4: los únicos puntos de evento W son 0 y 1, cada punto de evento V de B(W, V) es un punto de evento V de B(V, U), y hay a lo sumo 2j + 2 de ellos. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 para algún α ∈ R. En este caso, V es indiferente entre 0 y 1 si y solo si w = α, o B1 = 0 y u = −B0/B1 = −A0/A1. De manera similar al caso anterior, podemos mostrar que B(W, V)∩[0, 1]×(0, 1) consiste en el rectángulo {α}×[0, 1] y como máximo 2j + 2 rectángulos de la forma [0, 1]×IV, donde cada IV corresponde a un componente conectado de B(V, U)|U=−B0/B1. Además, V prefiere jugar 0 si B1u + B0 > 0 y w ≥ α o B1u + B0 < 0 y w ≤ α. Por lo tanto, si B1u∗ + B0 > 0 para algún u∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [α, +∞) ∩ [0, 1] y si B1u∗∗ + B0 < 0 para algún u∗∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [−∞, α] ∩ [0, 1]; si ambos u∗ y u∗∗ existen, B(W, V )|V =0 = [0, 1]. El conjunto B(W, V)|V=1 se puede describir de manera similar. Por la hipótesis inductiva, B(V, U) tiene a lo sumo 2j + 2 puntos de evento; dado que al menos dos de estos son puntos de evento U, tiene a lo sumo 2j puntos de evento V. Dado que cada punto de evento V de B(W, V) es un punto de evento V de B(V, U) y B(W, V) tiene como máximo 3 puntos de evento W (0, 1 y α), su número total de puntos de evento es como máximo 2j + 3 < 2j + 4. Además, de manera similar al caso anterior, se sigue que B(W, V) consiste en un máximo de 2j + 4 < (j + 4)2 rectángulos. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0. En este caso, se puede definir la función de indiferencia f(·) como f(u) = A(u) B(u) = A1u+A0 B1u+B0, donde A(u) y B(u) nunca se anulan simultáneamente. Observa que siempre que w = f(u) y u, w ∈ [0, 1], V es indiferente entre jugar 0 y 1. Para cualquier A ⊆ [0, 1]2, definimos una función ˆfV por ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; nota que ˆfV mapea subconjuntos de [0, 1]2 a subconjuntos de R×[0, 1]. A veces omitimos el subíndice V cuando es evidente por el contexto. LEMMA 1. \n\nLEMMA 1. Para cualquier (w, v) ∈ [0, 1]×(0, 1) tenemos que (w, v) ∈ B(W, V) si y solo si existe un u ∈ [0, 1] tal que (v, u) ∈ B(V, U) y w = f(u). PRUEBA. Fije un v arbitrario en (0, 1). Supongamos que U juega algún u ∈ pbrU (v), w = f(u) satisface w ∈ [0, 1], y W juega w. Existe un vector de estrategias v1, . . . , vj−1 = u, vj = v tal que para cada Vk, k < j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que w = f(u), V es indiferente entre jugar 0 y 1; en particular, puede jugar v. Por lo tanto, si definimos vj+1 = w, el vector de estrategias (v1, . . . , vj+1) cumplirá las condiciones en la definición de mejor respuesta potencial, es decir, tenemos v ∈ pbrV (w). Por el contrario, supongamos que v ∈ pbrV (w) para algún w ∈ [0, 1], v = 0, 1. Entonces existe un vector de estrategias v1, . . . , vj−1, vj = v, vj+1 = w tal que para cada Vk, k ≤ j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que v = 0, 1, V, de hecho, es indiferente entre jugar 0 y 1, lo cual solo es posible si w = f(vj−1). Elige u = vj−1; por construcción, u ∈ pbrU (v). El lema 1 describe las situaciones en las que V es indiferente entre jugar 0 y jugar 1. Sin embargo, para caracterizar completamente B(W, V), también necesitamos saber cuándo V prefiere una estrategia pura. Define ˆf(0) = ∪u∈pbrU (0)Ru, donde Ru = ´ [f(u), +∞)×{0} si B(u) > 0, (−∞, f(u)]×{0} si B(u) < 0. y ˆf(1) = ∪u∈pbrU (1)Ru, donde Ru = ´ [f(u), +∞)×{1} si B(u) < 0, (−∞, f(u)]×{1} si B(u) > 0. LEMMA 2. \n\nLEMMA 2. Para cualquier w ∈ [0, 1], tenemos que (w, 0) ∈ ˆf(0) si y solo si 0 ∈ pbrV (w) y (w, 1) ∈ ˆf(1) si y solo si 1 ∈ pbrV (w). PRUEBA. Considera un u0 arbitrario ∈ pbrU (0). Si B(u0) > 0, para u = u0 la desigualdad P0 ≥ P1 es equivalente a w ≥ f(u0). Por lo tanto, cuando U juega u0 y W juega w, w ≥ f(u0), V prefiere jugar 0; dado que u0 ∈ pbrU (u), se sigue que 0 ∈ pbrV (w). El argumento para el caso B(u0) < 0 es similar. Por el contrario, si 0 ∈ pbrV (w) para algún w ∈ [0, 1], existe un vector (v1, . . . , vj−1, vj = 0, vj+1 = w) tal que para cada Vk, k ≤ j, Vk juega vk, y esta estrategia es una mejor respuesta a las estrategias de los vecinos de Vk. Ten en cuenta que para cualquier vector de este tipo tenemos vj−1 ∈ pbrU (0). Por contradicción, asumimos que (w, 0) ∈ Ë u∈pbrU (0) Ru. Entonces debe ser el caso que para cualquier u0 ∈ pbrU (0) ya sea que f(u0) < w y Ru0 = (−∞, f(u0)]×{0} o f(u0) > w y Ru0 = [f(u0), +∞)×{0}. En ambos casos, cuando V juega 0, U juega u0, y V juega w, la desigualdad entre f(u0) y w es equivalente a P0 < P1, es decir, V se beneficiaría al cambiar a 1. El argumento para ˆf(1) es similar. Juntas, el Lema 1 y el Lema 2 describen completamente el conjunto B(W, V): tenemos B(W, V) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2. Queda por demostrar que B(W, V) puede representarse como una unión de como máximo (j + 4)2 rectángulos, tiene como máximo 2j + 4 puntos de evento, y puede ser calculado en tiempo O(j2). Sea u∗ = −B0/B1. Considera un rectángulo arbitrario R = [v1, v2]×[u1, u2] ⊆ B(V, U). Si u∗ ∈ [u1, u2], la función f(·) es continua en [u1, u2] y por lo tanto ˆf(R) = [fmin, fmax]×[v1, v2], donde fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste en un solo rectángulo. Ahora, supongamos que R es intersectado por la línea [0, 1]×{u∗}; como se mencionó anteriormente, hay a lo sumo 2j+2 rectángulos de este tipo. Se supone que limu→u∗− f(u) = +∞; dado que f(·) es una función lineal fraccional, esto implica que limu→u∗+ f(u) = −∞ y también f(u1) > f(u2). Dado que f(·) es continua en [u1, u∗ ) y (u∗ , u2], es fácil ver que ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2]. El caso B1 = 0 no causa problemas especiales. Para completitud, establezca u∗ como cualquier valor fuera de [0, 1] en este caso. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figura 4: f es creciente en (−∞, u∗ ) y (u∗ , +∞). y ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste de a lo sumo dos rectángulos. El caso limu→u∗− f(u) = −∞ es similar. Dado que ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), se sigue que ˆf(B(V, U)) consiste en un máximo de (j + 3)2 + 2j + 2 rectángulos. Además, es fácil ver que tanto ˆf(0) como ˆf(1) consisten en un máximo de 2 segmentos de línea cada uno. Concluimos que B(W, V) puede ser representado como una unión de a lo sumo (j + 3)2 + 2j + 6 < (j + 4)2 rectángulos. Además, si v es un punto de evento V de B(W, V), entonces v es un punto de evento V de B(V, U) (esto incluye los casos v = 0 y v = 1, ya que 0 y 1 son puntos de evento V de B(V, U)) y si w es un punto de evento W de B(W, V), entonces o bien w = 0 o w = 1 o existe algún u ∈ [0, 1] tal que w = f(u) y u es un punto de evento U de B(V, U). Por lo tanto, B(W, V) tiene como máximo 2j + 4 puntos de evento. El límite O(j2) en el tiempo de ejecución en el Teorema 5 se deriva de nuestra descripción del algoritmo. El límite de O(n3) en el tiempo total de ejecución para encontrar un equilibrio de Nash (y una representación de todos los equilibrios de Nash) se sigue. 4.1 Encontrar un solo equilibrio de Nash en tiempo O(n2) El límite superior en el tiempo de ejecución de nuestro algoritmo es ajustado, al menos asumiendo la implementación directa, en la que cada B(Vj+1, Vj) se almacena como una unión de rectángulos: no es difícil construir un ejemplo en el que el tamaño de B(Vj+1, Vj) sea Ω(j2). Sin embargo, en algunos casos no es necesario representar todos los equilibrios de Nash; más bien, el objetivo es encontrar un equilibrio arbitrario del juego. En esta sección, demostramos que este problema puede resolverse en tiempo cuadrático, obteniendo así una prueba del Teorema 1. Nuestra solución se basa en la idea de [9], es decir, trabajar con subconjuntos de las políticas de mejor respuesta en lugar de las políticas de mejor respuesta en sí mismas; siguiendo [9], nos referiremos a tales subconjuntos como políticas de punto de quiebre. Si bien no siempre es posible construir una política de puntos de interrupción según se define en [9], mostramos cómo modificar esta definición para garantizar que siempre exista una política de puntos de interrupción; además, demostramos que para un grafo de camino, la política de puntos de interrupción de cualquier vértice puede ser almacenada en una estructura de datos cuyo tamaño es lineal en el número de descendientes que tiene este vértice. Definición 3. Una política de puntos de quiebre ˆB(V, U) para un vértice U cuyo padre es V es una curva no auto-intersectante de la forma X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, donde Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] y ui, vi ∈ [0, 1] para i = 0, . . . , m. Decimos que una política de puntos de quiebre es válida si v0 = 0, vm = 1, y ˆB(V, U) ⊆ B(V, U). A veces abusaremos de la notación al referirnos a ˆB(V, U) como una colección de segmentos Xi, Yi en lugar de su unión. Se debe tener en cuenta que no requerimos que vi ≤ vi+1 o ui ≤ ui+1; por lo tanto, en cualquier argumento que involucre políticas de puntos de quiebre, todos los segmentos deben tratarse como segmentos dirigidos. Observe que cualquier política de puntos de quiebre válida ˆB(V, U) puede ser vista como un mapeo continuo 1-1 γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2, donde γ(0) = (0, u1), γ(1) = (1, um) y existen algunos t0 = 0, t1, . . . , t2m−2 = 1 tales que {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1. Como se explica en la Sección 3, podemos utilizar una política de punto de quiebre válida en lugar de la política de mejor respuesta durante el paso descendente, y aún así garantizar que al final, produciremos un equilibrio de Nash. El Teorema 6 muestra que se puede calcular de forma inductiva políticas de puntos de quiebre válidas para todos los vértices en el camino; la prueba de este teorema se puede encontrar en la versión completa de este artículo [6]. TEOREMA 6. Para cualquier V = Vj, se puede encontrar en tiempo polinómico una política de puntos de quiebre válida ˆB(W, V) que consiste en a lo sumo 2j + 1 segmentos. EQUILIBRIOS DE NASH EN GRÁFICOS CON GRADO MÁXIMO 2 En esta sección mostramos cómo el algoritmo para caminos puede aplicarse para resolver un juego en cualquier gráfico cuyos vértices tengan un grado de a lo sumo 2. Un grafo con grado máximo 2 es, por supuesto, una unión de caminos y ciclos. Dado que cada componente conectado puede ser manejado de forma independiente, para obtener una prueba del Teorema 2, solo necesitamos mostrar cómo tratar con los ciclos. Dado un ciclo con vértices V1, . . . , Vk (en orden cíclico), realizamos dos búsquedas separadas de un equilibrio de Nash: primero buscamos un equilibrio de Nash donde algún vértice juega una estrategia pura, luego buscamos un equilibrio de Nash completamente mixto, donde todos los vértices juegan estrategias mixtas. Para i ≤ k, dejemos que vi denote la probabilidad de que Vi juegue 1. La primera búsqueda se puede hacer de la siguiente manera. Para cada i ∈ {1, . . . , k} y cada b ∈ {0, 1}, haz lo siguiente. 1. Sea P el camino (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2. El pago a Vi+1 se basa en poner vi = b (por lo que depende solo de vi+1 y vi+2). 3. Aplica el pase ascendente a P 4. Pon vi = b; aplica el pase aguas abajo. Para cada vértice, Vj, lleva un registro de todas las posibles estrategias mixtas vj 5. Verificar si Vi+1 tiene alguna respuesta consistente con vi = b; si es así, tenemos un equilibrio de Nash. (De lo contrario, no hay un equilibrio de Nash del tipo deseado). Para la segunda búsqueda, hay que tener en cuenta que si Vi juega una estrategia mixta, entonces vi+1 y vi−1 satisfacen una ecuación de la forma vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1). Dado que todos los vértices en el ciclo juegan estrategias mixtas, tenemos vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1). Componiendo las dos transformaciones lineales fraccionarias, obtenemos vi+3 = (A0 + A1 vi−1)/(B0 + B1 vi−1), para algunas nuevas constantes A0, A1, B0, B1. Elige cualquier vértice Vi. Podemos expresar vi en términos de vi+2, luego vi+4, vi+6, etc. y finalmente vi mismo para obtener una ecuación cuadrática (para vi) que es fácil de derivar a partir de los pagos en el juego. Si la ecuación no es trivial, tiene como máximo 2 soluciones en (0, 1). Para un ciclo de longitud impar, todos los demás vj son derivables a partir de esas soluciones, y si existe un equilibrio de Nash completamente mezclado, todos los vj deberían resultar ser números reales en el rango (0, 1). Para un ciclo de longitud par, obtenemos dos ecuaciones cuadráticas, una para vi y otra para 105 vi+1, y de la misma manera podemos probar si alguna solución a estas ecuaciones produce valores para los otros vj, todos los cuales se encuentran en el intervalo (0, 1). Si la ecuación cuadrática es trivial, potencialmente hay un continuo de equilibrios completamente mezclados. Los valores de vi que pueden ocurrir en un equilibrio de Nash son aquellos para los cuales todos los valores dependientes vj se encuentran en el intervalo (0, 1); esta última condición es fácil de verificar calculando la imagen del intervalo (0, 1) bajo transformaciones lineales fraccionarias respectivas. 6. ENCONTRANDO EQUILIBRIOS EN UN ÁRBOL (ARBITRARIO) Para árboles arbitrarios, la estructura general del algoritmo permanece igual, es decir, se puede construir una política de mejor respuesta (o, alternativamente, una política de punto de quiebre) para cualquier vértice basada en las políticas de mejor respuesta de sus hijos. Suponemos que el grado de cada vértice está limitado por una constante K, es decir, la matriz de pagos para cada vértice es de tamaño O(2K). Consideremos un vértice V cuyos hijos son U1, . . . , Uk y cuyo padre es W; la política de mejor respuesta de cada Uj es B(V, Uj). De manera similar a la sección anterior, podemos calcular los pagos esperados V de jugar 0 o 1, respectivamente. Es decir, cuando cada uno de los Uj juega uj y W juega w, tenemos P0 = L0 (u1, . . . , uk, w), P1 = L1 (u1, . . . , uk, w), donde las funciones L0 (·, . . . , ·), L1 (·, . . . , ·) son lineales en todos sus argumentos. Por lo tanto, la desigualdad P0 > P1 se puede reescribir como wB(u1, . . . , uk) > A(u1, . . . , uk), donde tanto A(·, . . . , ·) como B(·, . . . , ·) son lineales en todos sus argumentos. Dado u = (u1, . . . , uk) y defina la función de indiferencia f : [0, 1]k → [0, 1] como f(u) = A(u)/B(u); claramente, si cada Uj juega uj, W juega w y w = f(u), V es indiferente entre jugar 0 y 1. Para cualquier X = X1 × · · · × Xk, donde Xi ⊆ [0, 1]2 se define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k}. Además, se establece ˆf(0) = {(w, 0) | ∃u tal que ui ∈ pbrUi (0) y wB(u) ≥ A(u)} y ˆf(1) = {(w, 1) | ∃u tal que ui ∈ pbrUi (1) y wB(u) ≤ A(u)}. Como en la sección anterior, podemos demostrar que B(W, V) es igual a ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2; además, cualquier camino de w = 0 a w = 1 que sea un subconjunto de B(W, V) constituye una política de puntos de quiebre válida. Política de Puntos de Quiebre de Tamaño Exponencial. Si bien el algoritmo de la Sección 4 se puede generalizar para árboles de grado acotado, su tiempo de ejecución ya no es polinomial. De hecho, la afirmación contraria es cierta: podemos construir una familia de árboles y matrices de pago para todos los jugadores de manera que las políticas de mejor respuesta para algunos de los jugadores consistan en un número exponencial de segmentos. Además, en nuestro ejemplo las políticas de puntos de quiebre coinciden con las políticas de mejor respuesta, lo que significa que incluso encontrar un solo equilibrio de Nash utilizando el enfoque de [8, 9] llevará un tiempo exponencialmente largo. De hecho, una afirmación más fuerte es cierta: para cualquier algoritmo de dos pasos de tiempo polinómico (definido más adelante) que funcione con subconjuntos de políticas de mejor respuesta para este grafo, podemos elegir las recompensas de los vértices de manera que el paso posterior de este algoritmo falle. La figura 5: El árbol Tn que corresponde a la política de puntos de quiebre de tamaño exponencial. En el resto de esta subsección, describimos esta construcción. Considera el árbol Tn dado por la Figura 5; sea Vn la raíz de este árbol. Para cada k = 1, . . . , n, permita que las ganancias de Sk y Tk sean las mismas que las de U y V descritas en la Sección 3; recuerde que las políticas de puntos de quiebre para U y V se muestran en la Figura 2. No es difícil ver que la función de indiferencia para Tk está dada por f(s) = .8s + .1. El pago de V0 es 1 si V1 selecciona la misma acción que V0 y 0 en caso contrario; la política de mejor respuesta de V0 está dada por la Figura 6. LEMMA 3. \n\nLEMMA 3. Dado k < n, y sean u, t, v y w las estrategias de Vk−1, Tk, Vk y Vk+1, respectivamente. Supongamos que Vk prefiere jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Entonces B(Vk+1, Vk) consta de al menos 3k segmentos. Además, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} y {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}. PRUEBA. La demostración procede por inducción en k. Para k = 0, la afirmación es obvia. Ahora, supongamos que es cierto para B(Vk, Vk−1). Se puede ver B(Vk+1, Vk) como una unión de siete componentes: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, y cinco componentes que corresponden a los segmentos de B(Vk, Tk). Examinémoslos uno por uno. Para describir ˆf(0)∩[0, 1]×{0}, observe que f(u, t) = .5t+.1u+.2 es monótona en t y u y cumple con f(0, 0) = .2. Además, tenemos pbrVk−1 (0) = {0} y pbrTk (0) = {0}. Para cualquier w ∈ [0, 1] tenemos f(0, 0) ≥ w si y solo si w ∈ [0, .2]. Concluimos que ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}. De manera similar, se sigue que ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}. Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; estos conjuntos corresponden a segmentos horizontales de B(Vk, Tk). Es fácil ver que S1, S2, S3 ⊂ B(Vk+1, Vk). Dado que f es una función continua, el número de segmentos en cada Si es al menos el número de segmentos en B(Vk, Vk−1)∩[.1, .9]×[0, 1], que es al menos 3k−1 por hipótesis de inducción. Además, dado que f es monótona en u y f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), todos los Si, i = 1, 2, 3, son disjuntos. Finalmente, el conjunto B(Vk+1, Vk) contiene dos segmentos que corresponden a los segmentos verticales de B(Vk, Tk), es decir, S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} y S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}. Claramente, S4 conecta S2 y S3, S5 conecta S1 y S2, y S4 y S5 no se intersectan entre sí. Concluimos que B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figura 6: Políticas de puntos de quiebre para V0 y V1, es una línea continua que consiste en al menos 3k segmentos y satisface la condición del lema. Para completar la construcción, necesitamos demostrar que podemos diseñar la matriz de pagos para Vk de manera que prefiera jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Con este fin, demostramos una afirmación más general, a saber, que la función de indiferencia de un vértice puede ser una función multilineal fraccional arbitraria de las estrategias de sus descendientes. Decimos que una función de k variables es multilineal si puede ser representada como una suma de monomios y cada uno de estos monomios es lineal en todas sus variables. Ten en cuenta que esta definición es diferente de una más estándar en el sentido de que no requerimos que todos los monomios tengan el mismo grado. Recuerde que las ganancias de un vértice con k + 1 vecinos están descritas por las matrices P0 y P1, donde Pj i0i1...ik es la ganancia que V obtiene cuando juega j, y sus vecinos juegan i0, . . . , ik, y j, i0, . . . , ik ∈ {0, 1}. Sea P[j] = P[j](w, u1, . . . , uk) la ganancia esperada obtenida por este vértice cuando juega j y las estrategias (mixtas) de sus vecinos están dadas por un vector (w, u1, . . . , uk), es decir, P[j] = E[P j i0i1...ik ] donde i0, . . . , ik son variables aleatorias de Bernoulli independientes, cada una de las cuales es 1 con las respectivas probabilidades w, u1, . . . , uk. LEMMA 4. \n\nLEMMA 4. Dado un vértice del árbol V cuyo padre es W y cuyos hijos son U1, . . . , Uk, para cualquier función f = f(u1, . . . , uk) que pueda representarse como una razón de dos funciones multilineales f1, f2, es decir, f = f1(u1,...,uk) f2(u1,...,uk), existen matrices de pago P0 y P1 para V tales que P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk). La prueba de este lema se basa en el hecho de que cada monomio de la forma as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, puede ser representado como t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk para algunos Ct, t ∈ {0, 1}k+1. Los detalles se pueden encontrar en la versión completa de este documento [6]. 6.2 Irreducibilidad de la Política de Mejor Respuesta para Tn Si bien la política de mejor respuesta construida en la subsección anterior tiene un tamaño exponencial, no está claro `a priori que sea necesario hacer un seguimiento de todos sus segmentos de línea en lugar de centrarse en un pequeño subconjunto de estos segmentos. Sin embargo, resulta que para algoritmos de dos pasadas como el algoritmo de [8], la política de mejor respuesta no se puede simplificar. Más precisamente, decimos que un algoritmo A es un algoritmo de dos pasadas si 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figura 7: Política de punto de quiebre para V2. • A consta de un paso ascendente y un paso descendente. • Durante el paso ascendente, para cada vértice V con padre W, A construye un conjunto BB(W, V) ⊆ B(W, V). Este conjunto se produce a partir de los conjuntos {BB(V, U) | U es un hijo de V} aplicando el procedimiento desde el principio de la Sección 6 (sustituyendo BB(V, Uj) por B(V, Uj) para todos los hijos Uj de V), y luego posiblemente omitiendo algunos de los puntos del conjunto resultante (que luego se almacena explícitamente). El paso aguas abajo es idéntico al paso aguas abajo de [8] como se describe en la Sección 2, excepto que opera en los conjuntos BB(W, V) en lugar de en los conjuntos B(W, V). El Teorema 7 demuestra que cualquier algoritmo de dos pasadas fallará durante la pasada aguas abajo en Tn si existe un índice j tal que el conjunto BB(Vj+1, Vj) omite algún punto interior de cualquiera de los (al menos 3j) segmentos de B(Vj+1, Vj). Esto implica el Teorema 3. TEOREMA 7. Para cualquier algoritmo de dos pasos A para el cual exista un índice j, j ∈ [1, n/4], un segmento S de B(Vj, Vj−1), y un punto interior (x, y) de S tal que BB(Vj, Vj−1) no contenga (x, y), podemos elegir matrices de pago de los vértices Vj, . . . , Vn para que el paso descendente de A falle, y, además, los pagos a V4j, . . . , Vn sean idénticamente 0. Esbozamos la demostración del Teorema 7; los detalles se pueden encontrar en la versión completa de este artículo [6]. Procedemos por inducción. Para j = 1, el argumento es similar al de la Sección 3. Para el paso inductivo, la idea principal es que podemos enfocarnos en cualquier parte de una política de mejor respuesta (¡incluyendo la parte que fue omitida!) utilizando una función de indiferencia apropiada; esto nos permite reducir el caso j = j0 a j = j0 − 1. En la sección anterior, demostramos que para juegos gráficos en árboles que son casi, pero no del todo, caminos, los algoritmos de dos pasos no logran encontrar equilibrios de Nash en tiempo polinómico. A continuación mostramos que una propiedad de grafo similar a un camino más suave nos permite construir juegos gráficos para los cuales es poco probable que cualquier algoritmo de tiempo polinómico encuentre equilibrios de Nash. 7.1 Ancho de camino Una descomposición de camino de un grafo G = (V, E) es una secuencia de subconjuntos Si(V) ⊆ V tal que para cada arista (v, v') ∈ E, v, v' ∈ Si(V) para algún i, y además, para cada v ∈ V, si v ∈ Si(V) y v ∈ Sj(V) para j > i, entonces v ∈ Sk(V) para todo i ≤ k ≤ j. La descomposición del camino tiene ancho k si todos los conjuntos Si(V) tienen una cardinalidad de a lo sumo k + 1. El ancho de camino de G es el ancho mínimo de cualquier descomposición de camino de G. 107 El ancho de camino es una restricción del ancho de árbol (en el cual se buscaría un árbol cuyos vértices fueran los conjuntos Si(V), y los conjuntos que contienen algún vértice tendrían que formar un subárbol). Para cualquier constante k, se puede decidir en tiempo polinómico si un grafo tiene un ancho de camino (o ancho de árbol) k. Además, muchos problemas de teoría de grafos parecen más fáciles de resolver en tiempo polinómico cuando se restringen a grafos con un ancho de árbol o un ancho de camino fijo, consulte [1] para obtener una visión general. Ten en cuenta que un camino tiene un ancho de camino de 1 y un ciclo tiene un ancho de camino de 2. 7.2 Completitud de PPAD Revisamos algunas definiciones básicas de la teoría de complejidad computacional de problemas de búsqueda. Un problema de búsqueda asocia cualquier entrada (aquí, un juego gráfico) con un conjunto de soluciones (aquí, los equilibrios de Nash del juego de entrada), donde la longitud de la descripción de cualquier solución debe estar acotada de forma polinómica en función de la longitud de la descripción de su entrada. En un problema de búsqueda total, hay una garantía de que al menos una solución existe para cualquier entrada. El teorema de Nash nos asegura que el problema de encontrar equilibrios de Nash es total. Una reducción del problema de búsqueda S al problema S es un mecanismo que muestra que cualquier algoritmo de tiempo polinómico para S implica un algoritmo de tiempo polinómico para S. Consiste en funciones f y g, computables en tiempo polinómico, donde f mapea entradas de S a entradas de S, y g mapea soluciones de S a soluciones de S, de tal manera que si IS es una entrada para S, y SS es una solución para f(IS), entonces g(SS) es una solución para IS. Observe que los problemas de búsqueda total no permiten las reducciones anteriores de problemas como CIRCUIT SAT (donde la entrada es un circuito booleano, y las soluciones son vectores de entrada que hacen que la salida sea verdadera) debido a que CIRCUIT SAT y otros problemas NP-completos tienen entradas con conjuntos de soluciones vacíos. En cambio, el trabajo reciente sobre la complejidad computacional de encontrar un equilibrio de Nash [7, 4, 5, 2, 3] lo ha relacionado con el siguiente problema. Definición 4. FIN DE LA LÍNEA. Circuitos booleanos S y P, cada uno con n bits de entrada y n bits de salida, donde P(0n) = 0n y S(0n) = 0n. Solución: x ∈ {0, 1}n tal que S(x) = x, o alternativamente x ∈ {0, 1}n tal que P(S(x)) = x. S y P pueden ser consideradas como representando sucesor y predecesor. Observe que al calcular Si (0n) (para i = 0, 1, 2, ...) y comparar con P(Si+1 (0n)), eventualmente debemos encontrar una solución para EL FIN DE LA LÍNEA. END OF THE LINE caracteriza la clase de complejidad PPAD (que significa argumento de paridad en un grafo, versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda S es PPAD-completo si END OF THE LINE se reduce a S. Otros problemas PPAD-completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para descripciones más detalladas de estos problemas). 3-GRAPHICAL NASH es el problema de encontrar un equilibrio de Nash para un juego gráfico cuyo grafo tiene grado 3. Daskalakis et al. [4] muestran la completitud de PPAD de NASH 3-GRÁFICO mediante una reducción de BROUWER TRIDIMENSIONAL, introducida en [4] y definida de la siguiente manera. Definición 5. BROUWER TRIDIMENSIONAL. Un circuito C que tiene 3n bits de entrada y 2 bits de salida. Los bits de entrada definen un cubilete del cubo unitario, compuesto por las 3 coordenadas de sus puntos, dadas con una precisión de n bits. La salida representa uno de los cuatro colores asignados por C a un cubito. C está restringido para asignar el color 1 a los cubitos adyacentes al plano (y, z), el color 2 a los cubitos restantes adyacentes al plano (x, z), el color 3 a los cubitos restantes en el plano (x, y), y el color 0 a todos los demás cubitos en la superficie del cubo unitario. Una solución es un vértice pancromático, un vértice adyacente a cubiletes que tienen 4 colores distintos. La razón por la que se garantiza la existencia de una solución es que se puede construir una función de Brouwer asociada φ, es decir, una función continua del cubo unitario a sí mismo, de modo que los vértices pancromáticos correspondan a los puntos fijos de φ. El Teorema del Punto Fijo de Brouwer promete la existencia de un punto fijo. La prueba del Teorema 4 utiliza una modificación de la reducción de [4] de 3-DIMENSIONAL BROUWER a 3-GRAPHICAL NASH. Para demostrar el teorema, comenzamos con algunos resultados preliminares de la siguiente manera. Cada jugador tiene 2 acciones, denominadas 0 y 1. Para un jugador en el vértice V, dejemos que p[V] denote la probabilidad de que el jugador juegue 1. LEMMA 5. [7] Existe un juego gráfico Gshift de tamaño fijo con vértices V, V donde p[V] es la parte fraccionaria de 2p[V]. COROLARIO 1. Existe un juego gráfico Gn−shift de tamaño Θ(n) de ancho de camino constante, con vértices V, Vn donde p[Vn] es la parte fraccionaria de 2n .p[V]. PRUEBA. Crear una cadena de n copias de Gshift en el Lema 5. Cada subconjunto de vértices en la descomposición del camino son los vértices en una copia de Gshift. Que In(x) denote el n-ésimo bit de la expansión binaria de x, donde interpretamos 1 como verdadero y 0 como falso. Lo siguiente utiliza dispositivos de [7, 4]. COROLARIO 2. Existe un valor k tal que para todo n, y para todo n1, n2, n3 ≤ n, existe un juego gráfico de tamaño O(n) con ancho de camino k, teniendo vértices V1, V2, V3 donde p[V3] = p[V1] + 2−n3 (En1 p[V1] ∧ En2 p[V2]). PRUEBA DEL TEOREMA 4. Sea C el circuito booleano que describe una instancia de BROUWER TRIDIMENSIONAL. Sean g1, . . . , gp(n) las compuertas de C indexadas de tal manera que la(s) entrada(s) de cualquier compuerta son la(s) salida(s) de las compuertas de índice inferior. g1, . . . , g3n serán las 3n entradas de C. Todos los jugadores en el juego gráfico G construido en [4] tienen 2 acciones denotadas como 0 y 1. La probabilidad de que V juegue 1 se denota como p[V]. G tiene 3 jugadores Vx, Vy y Vz para los cuales p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto en el cubo unitario. G está diseñado para incentivar a Vx, Vy y Vz a ajustar sus probabilidades en direcciones dadas por una función de Brouwer que está especificada por el circuito C. En un equilibrio de Nash, p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto fijo de una función que pertenece a la clase de funciones representadas por el BROUWER TRIDIMENSIONAL. Para 1 ≤ i ≤ p(n) introducimos un vértice V (i) C tal que para 1 ≤ j ≤ i, Ij(p[V (i) C ]) es la salida de la compuerta gj; para i < j ≤ p(n), Ij(p[V (i) C ]) es 0. Construye V (i) C a partir de V (i−1) C utilizando el Corolario 2. Sea G(i) el juego gráfico que hace esto. Sea S1(G(i)), . . . , Sn(G(i)) una descomposición de camino de longitud n de G(i), donde V(i−1) ⊂ S1(G(i)) y V(i) ⊂ Sn(G(i)). Luego, se obtiene una descomposición de camino de ∪1≤i≤p(n)G(i) tomando la unión de las descomposiciones de camino separadas, junto con Sn(G(i−1) ) ∪ S1(G(i) ) para 2 ≤ i ≤ p(n). Sea GC el juego gráfico anterior que simula C. GC tiene 3n entradas, que consisten en los primeros n bits de las expansiones binarias de p[Vx], p[Vy] y p[Vz]. De manera similar a [4], la salida de GC afecta a Vx, Vy y Vz de la siguiente manera. El color 0 incentiva a Vx, Vy y Vz 108 a ajustar sus probabilidades p[Vx], p[Vy] y p[Vz] en la dirección (−1, −1, −1); el color 2 los incentiva a moverse en la dirección (1, 0, 0); el color 2, dirección (0, 1, 0); el color 3, dirección (0, 0, 1). Necesitamos asegurarnos de que en los puntos en los límites de los cubitos adyacentes, el cambio de dirección será aproximadamente el promedio de las direcciones de los puntos circundantes. De esta manera, los cuatro colores/direcciones deben estar cerca para que puedan anularse entre sí (y estemos en un vértice pancromático). Esto se logra utilizando el mismo truco que [4], en el cual hacemos un número constante M de copias de GC, que difieren en que cada copia agrega un vector de desplazamiento pequeño a sus copias de p[Vx], p[Vy] y p[Vz] (que se derivan del original utilizando el dispositivo de adición de [7]). Usando los dispositivos de suma y multiplicación de [7], promediamos las direcciones y sumamos un pequeño múltiplo de este promedio a (p[Vx], p[Vy], p[Vz]). En un equilibrio de Nash, las salidas de cada copia se cancelarán mutuamente. El ancho de camino del juego completo es a lo sumo M veces el ancho de camino GC. 8. PROBLEMAS ABIERTOS El problema más importante que queda abierto en este artículo es si es posible encontrar un equilibrio de Nash de un juego gráfico en un árbol de grado acotado en tiempo polinómico. Nuestra construcción muestra que cualquier algoritmo de dos pasadas que almacene explícitamente políticas de puntos de quiebre necesita tiempo y espacio exponenciales. Sin embargo, esto no excluye la existencia de un algoritmo que se base en una idea similar, pero en lugar de calcular la política de punto de ruptura completa para cada vértice, utiliza un pequeño número de pasadas adicionales a través del grafo para decidir qué partes (de tamaño polinómico) de cada política de punto de ruptura deben ser calculadas. En particular, dicho algoritmo puede basarse en el algoritmo de aproximación de [8], donde el valor de es elegido de forma adaptativa. Otra pregunta intrigante está relacionada con el hecho de que el grafo para el cual construimos una política de puntos de quiebre de tamaño exponencial tiene un ancho de camino de 2, mientras que nuestros resultados positivos son para un camino, es decir, un grafo de ancho de camino 1. No está claro si para cualquier grafo de grado acotado con ancho de camino 1, el tiempo de ejecución de nuestro algoritmo (versión basada en política de puntos de interrupción) será polinomial. En particular, resulta instructivo considerar un grafo oruga, es decir, el grafo que se puede obtener a partir de Tn al eliminar los vértices S1, . . . , Sn. Para este gráfico, la mejor política de respuesta de un vértice Vk en la columna vertebral de la oruga se obtiene combinando la mejor política de respuesta de su predecesor en la columna vertebral Vk−1 y su otro hijo Tk; dado que este último es una hoja, su mejor política de respuesta es trivial (es decir, [0, 1]2, [0, 1]×{0} o [0, 1]×{1}) o consiste en dos segmentos horizontales y un segmento vertical de la forma {α}×[0, 1] que los conecta. Suponiendo, para mayor comodidad, que B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, y f es la función de indiferencia para Vk, observamos que la política de mejor respuesta para Vk consta de 5 componentes: ˆf(0), ˆf(1), y tres componentes que corresponden a [0, α]×{0}, {α}×[0, 1], y [α, 1]×{1}. Por lo tanto, se puede pensar en la construcción de B(Vk+1, Vk) como el siguiente proceso: girar B(Vk, Vk−1) en π/2, cortarlo a lo largo de la línea (ahora horizontal) vk = α, aplicar una transformación lineal fraccional a la coordenada horizontal de ambas partes y volver a conectarlas usando la imagen del segmento {α}×[0, 1] bajo f. Esto implica que el problema de acotar el tamaño de la política de mejor respuesta (o, alternativamente, la política de punto de quiebre) se puede ver como una generalización del siguiente problema de geometría computacional, que creemos puede ser de interés independiente: PROBLEMA 1. Dada una colección de segmentos paralelos a los ejes en R2, considera la siguiente operación: elige una línea paralela a los ejes li (ya sea vertical u horizontal), corta el plano a lo largo de esta línea y desplaza una de las dos partes resultantes por una cantidad arbitraria δi; como resultado, algunos segmentos se dividirán en dos partes. Reconecte estas partes, es decir, para cada segmento de la forma [a, b] × {c} que fue transformado en [a, t] × {c + δi} y [t, b] × {c}, introduzca un segmento {t} × [c, c+δi]. ¿Es posible comenzar con el segmento [0, 1] y después de n operaciones obtener un conjunto que no pueda representarse como una unión de poli(n) segmentos de línea? ¿En caso afirmativo, puede ser que en este conjunto no haya un camino con un número polinomial de giros que conecte los extremos del segmento original? Resulta que en general, la respuesta a la primera pregunta es positiva, es decir, después de n pasos, es posible obtener un conjunto que consiste en Θ(cn) segmentos para algún c > 0. Esto implica que incluso para una oruga, la mejor política de respuesta puede ser exponencialmente grande. Sin embargo, en nuestro ejemplo (que se omite en esta versión del documento debido a limitaciones de espacio), existe un camino de tamaño polinómico a través de la política de mejor respuesta, es decir, no demuestra que la política de punto de quiebre sea necesariamente exponencial en tamaño. Si se puede demostrar que esto siempre es cierto, puede ser posible adaptar esta prueba para mostrar que puede haber una brecha exponencial entre los tamaños de las políticas de mejor respuesta y las políticas de punto de quiebre. 9. REFERENCIAS [1] H. Bodlaender y T. Kloks. Algoritmos eficientes y constructivos para el ancho de camino y el ancho de árbol de grafos. Revista de Algoritmos, 21:358-402, 1996. [2] X. Chen y X. Deng. 3-NASH es PPAD-completo. Informe técnico TR-05-134, Coloquio Electrónico en Complejidad Computacional, 2005. [3] X. Chen y X. Deng. Resolviendo la complejidad del equilibrio de Nash de 2 jugadores. Informe técnico TR-05-140, Coloquio Electrónico en Complejidad Computacional, 2005. [4] C. Daskalakis, P. Goldberg y C. Papadimitriou. La complejidad de calcular un equilibrio de Nash. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [5] C. Daskalakis y C. Papadimitriou. Los juegos de tres jugadores son difíciles. Informe técnico TR-05-139, Coloquio Electrónico en Complejidad Computacional, 2005. [6] E. Elkind, L. Goldberg y P. Goldberg. Equilibrios de Nash en juegos gráficos en árboles revisados. Informe técnico TR-06-005, Coloquio Electrónico en Complejidad Computacional, 2006. [7] P. Goldberg y C. Papadimitriou. Reductibilidad entre problemas de equilibrio. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [8] M. Kearns, M. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, 2001. [9] M. Littman, M. Kearns y S. Singh. Un algoritmo exacto eficiente para juegos gráficos de conexión simple. En Actas de la 15ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2001. [10] L. Ortiz y M. Kearns. Propagación de Nash para juegos gráficos con bucles. En Actas de la 17ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2003. [11] C. Papadimitriou. Sobre la complejidad del argumento de paridad y otras demostraciones ineficientes de existencia. J. Comput. This is not a complete sentence. Please provide more context or the full sentence you would like me to translate. Cienc., 48(3):498-532, 1994. 109 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "ppad-completeness": {
            "translated_key": "completitud de PPAD",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent <br>ppad-completeness</br> results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "<br>ppad-completeness</br> OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 <br>ppad-completeness</br> We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show <br>ppad-completeness</br> of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "To prove Theorem 4, we use recent <br>ppad-completeness</br> results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "<br>ppad-completeness</br> OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 <br>ppad-completeness</br> We review some basic definitions from the computational complexity theory of search problems.",
                "Daskalakis et al. [4] show <br>ppad-completeness</br> of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows."
            ],
            "translated_annotated_samples": [
                "Para demostrar el Teorema 4, utilizamos resultados recientes de <br>completitud de PPAD</br> para juegos, en particular los artículos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de grado d (para d ≥ 3) es computacionalmente equivalente al problema de resolver juegos en forma normal de r jugadores (para r ≥ 4), ambos de los cuales son PPAD-completos.",
                "En la sección anterior, demostramos que para juegos gráficos en árboles que son casi, pero no del todo, caminos, los algoritmos de dos pasos no logran encontrar equilibrios de Nash en tiempo polinómico.",
                "Ten en cuenta que un camino tiene un ancho de camino de 1 y un ciclo tiene un ancho de camino de 2. 7.2 <br>Completitud de PPAD</br> Revisamos algunas definiciones básicas de la teoría de complejidad computacional de problemas de búsqueda.",
                "Daskalakis et al. [4] muestran la <br>completitud de PPAD</br> de NASH 3-GRÁFICO mediante una reducción de BROUWER TRIDIMENSIONAL, introducida en [4] y definida de la siguiente manera."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V. El algoritmo genérico no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente. En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta. La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2). Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del algoritmo genérico de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino). Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9]. En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un juego gráfico en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario). Obtenemos el siguiente teorema TEOREMA 1. Existe un algoritmo O(n2) que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un camino de n vértices. Existe un algoritmo O(n3) que calcula una representación de todos los equilibrios de Nash de dicho juego. En la Sección 5 extendemos los resultados de la Sección 4 a grafos de grado 2 en general, obteniendo el siguiente teorema. TEOREMA 2. Existe un algoritmo de tiempo polinómico que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un grafo con grado máximo 2. En la Sección 6 ampliamos nuestro algoritmo para que pueda ser utilizado para encontrar un equilibrio de Nash de un juego gráfico en un árbol arbitrario. Incluso cuando el árbol tiene grado acotado, el tiempo de ejecución puede ser exponencial. Mostramos que esto es inevitable construyendo una familia de juegos gráficos en árboles de grado acotado para los cuales las políticas de mejor respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de dos pasos (es decir, un algoritmo que es similar en espíritu al de [8]) tiene que almacenar casi todos los puntos de las políticas de mejor respuesta. En particular, mostramos lo siguiente. TEOREMA 3. Existe una familia infinita de juegos gráficos en árboles de grado acotado con ancho de camino 2, tal que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales. Es interesante notar que los árboles utilizados en la demostración del Teorema 3 tienen un ancho de camino de 2, es decir, están muy cerca de ser caminos. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico para grafos de ancho de camino 1. Esta pregunta puede ser vista como una generalización de un problema muy natural de geometría computacional; lo describimos con más detalle en la Sección 8. En la Sección 7, presentamos un resultado de intractabilidad teórica de complejidad para el problema de encontrar un equilibrio de Nash de un juego gráfico en un grafo con un ancho de camino pequeño. Demostramos el siguiente teorema. TEOREMA 4. Considera el problema de encontrar un equilibrio de Nash para un juego gráfico en el cual el grafo subyacente tiene un grado máximo de 3 y un ancho de camino k. Existe una constante k tal que este problema es PPAD-completo. El teorema 4 limita la medida en que podemos explotar las propiedades de tipo camino del grafo subyacente para encontrar equilibrios de Nash. Para demostrar el Teorema 4, utilizamos resultados recientes de <br>completitud de PPAD</br> para juegos, en particular los artículos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de grado d (para d ≥ 3) es computacionalmente equivalente al problema de resolver juegos en forma normal de r jugadores (para r ≥ 4), ambos de los cuales son PPAD-completos. CONSIDERACIONES PREVIAS Y NOTACIÓN Consideramos juegos gráficos en los que el grafo subyacente G es un árbol de n vértices. Cada vértice tiene dos acciones, que se denotan como 0 y 1. Una estrategia mixta se define por un único número x ∈ [0, 1], que indica la probabilidad de que el jugador seleccione la acción 1. Para los propósitos del algoritmo, el árbol está enraizado de manera arbitraria. Para mayor comodidad, asumimos sin pérdida de generalidad que la raíz tiene un solo hijo y que su recompensa es independiente de la acción elegida por el hijo. Esto se puede lograr primero eligiendo una raíz arbitraria del árbol, y luego agregando un padre ficticio de esta raíz, asignándole una función de pago constante. Dado un borde (V, W) del árbol G, y una estrategia mixta w para W, sea G(V,W), W=w la instancia obtenida de G mediante (1) eliminar todos los nodos Z que están separados de V por W (es decir, todos los nodos Z tales que el camino de Z a V pasa por W), y (2) restringir la instancia de modo que se requiera que W juegue la estrategia mixta w. Definición 1. Supongamos que (V, W) es un borde del árbol, que v es una estrategia mixta para V y que w es una estrategia mixta para W. Decimos que v es una mejor respuesta potencial para w (indicado por v ∈ pbrV(w)) si hay un equilibrio en la instancia G(V, W), W = w en el que V tiene la estrategia mixta v. Definimos la política de mejor respuesta para V, dada W, como B(W, V) = {(w, v) | v ∈ pbrV(w), w ∈ [0, 1]}. Normalmente, W es el padre de V, y esto se conoce simplemente como la política de mejor respuesta para V. La expresión B(W, V )|V =v se utiliza para denotar el conjunto B(W, V ) ∩ [0, 1]×{v}. El paso ascendente del algoritmo genérico de [8] calcula la política de mejor respuesta para V en cada nodo V que no sea la raíz. Con las suposiciones anteriores sobre la raíz, el paso aguas abajo es sencillo: Sea W la raíz y V su hijo. La raíz selecciona cualquier par (w, v) de B(W, V). Decide jugar con la estrategia mixta w e instruye a V a jugar con la estrategia mixta v. El resto del paso descendente es recursivo. Cuando un nodo V recibe instrucciones de su padre para adoptar la estrategia mixta v, hace lo siguiente para cada hijo U: encuentra un par (v, u) ∈ B(V, U) (con el mismo valor de v que le fue dado por su padre) e instruye a U a jugar u. ALGORITMO DE LITTMAN ET AL. El algoritmo de [9] se basa en la siguiente observación: para calcular un equilibrio de Nash único mediante un algoritmo de dos pasos, no es necesario construir la política de mejor respuesta completa para cada vértice. Si, en cada paso de la pasada descendente, el vértice en consideración puede seleccionar un vector de estrategias para todos sus hijos de manera que la estrategia de cada hijo sea una mejor respuesta potencial a la estrategia del padre, el algoritmo logra producir un equilibrio de Nash. Esto se puede lograr si, al comienzo del paso aguas abajo, tenemos una estructura de datos en la que cada vértice V con padre W almacena un conjunto ˆB(W, V ) ⊆ B(W, V ) (llamado una política de puntos de quiebre) que cubre cada posible w ∈ [0, 1]. Mostraremos más adelante que una condición suficiente para la construcción de una estructura de datos así es la invariante de que, en cada nivel del paso ascendente, ˆB(W, V) contiene un camino continuo desde w = 0 hasta w = 1. En [9], se sugiere que podemos seleccionar la política de punto de quiebre de una manera particular. Es decir, el documento utiliza la siguiente definición: Definición 2. (cf. [9]) Una política de puntos de ruptura para un nodo V con padre W consiste en un conjunto ordenado de puntos de ruptura de W, w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 y un conjunto asociado de valores de V, v1, . . . , vt. La interpretación es que para cualquier w ∈ [0, 1], si wi−1 < w < wi para algún índice i y W juega w, entonces V deberá jugar vi; y si w = wi para algún índice i, entonces V deberá jugar cualquier valor entre vi y vi+1. Decimos que una política de punto de quiebre tiene t - 1 puntos de quiebre. El artículo luego afirma que cualquier vértice V puede calcular su política de punto de interrupción con respecto a su padre W dadas las políticas de punto de interrupción de sus hijos U1, . . . , Uk. La prueba procede ordenando los puntos de quiebre de los niños (es decir, los valores respectivos de v) de izquierda a derecha (se puede asumir sin pérdida de generalidad que todos estos puntos de quiebre son distintos) y considerándolos sucesivamente; cada punto vl ∈ {v1, . . . , vL} corresponde a una elección fija de estrategias para k − 1 niños y un intervalo de estrategias admisibles para un niño. Supongamos, para mayor comodidad, que este niño es U1 y su intervalo de estrategias admisibles en vl es [a, b]; supongamos también que para Uj, j = 2, . . . , k, sus respectivas políticas de puntos de quiebre les prescriben jugar uj en respuesta a vl. Sea P i (u, w), i = 0, 1, el pago esperado para V cuando V juega i, U1 juega u, cada Uj, j = 2, . . . , k, juega uj, y W juega w, y considera el conjunto Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] tal que P 0 (u, w) = P1 (u, w)}; nota que para cualquier w ∈ Wl tenemos vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figura 1: LKS: Recorte para encontrar políticas de puntos de quiebre. Los autores muestran que para cualquier punto de quiebre vl, el conjunto Wl está vacío, es un solo intervalo, o es una unión de dos intervalos no flotantes (un intervalo es no flotante si uno de sus extremos es 0 o 1); además, la unión de todos los conjuntos Wl, l = 1, . . . , L, cubre el intervalo [0, 1]. Se sigue fácilmente que se puede cubrir [0, 1] con a lo sumo L+2 intervalos, cada uno de los cuales es un subconjunto de algún Wl. Los autores afirman entonces que cualquier cobertura de este tipo puede ser transformada en una política de puntos de ruptura para V. Es decir, afirman que para cualquier par de intervalos Wl1 y Wl2 en la cobertura, cualquier superposición entre Wl1 y Wl2 puede asignarse arbitrariamente a la cobertura por Wl1 y Wl2 recortados en consecuencia (cf. [9], p. 5). Ellos ilustran su enfoque en una figura, la cual se reproduce como Figura 1 aquí. En la figura, las líneas horizontales discontinuas representan los puntos de quiebre v1, v2, . . . , v7 y los intervalos sólidos a lo largo de estos puntos de quiebre son los conjuntos W1, W2, . . . , W7. El camino grueso conectado es la política de punto de quiebre correspondiente. Se elige de la siguiente manera: comenzar en la izquierda y siempre saltar al intervalo que permita el mayor avance hacia la derecha. Para entender por qué este enfoque no funciona en general, considera un camino de longitud 4 que consiste en una raíz indiferente R, su hijo W, el hijo de W V y el hijo de V U. Supongamos que U recibe un pago de 1 si juega de manera diferente a V y 0 en caso contrario. Así, si v denota la estrategia mixta de V (es decir, V juega 1 con probabilidad v), entonces la ganancia esperada que U obtiene al jugar 0 se da por P0(U) = v y la ganancia esperada que U obtiene al jugar 1 se da por P1(U) = 1 − v. Supongamos que V no obtiene ganancia al jugar 1 (por lo que P1(V) = 0) y que su matriz de ganancias al jugar 0 es 1 −9 9 −1, entonces si u denota la estrategia mixta de U y w denota la estrategia mixta de W, la ganancia esperada que V obtiene al jugar 0 se da por P0(V) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1). Usando las técnicas de [8] (o, alternativamente, las de la Sección 4), no es difícil verificar que las políticas de mejor respuesta para U y V (como en la Definición 1) están dadas por los gráficos en la Figura 2. La mejor política de respuesta para U es una política de punto de quiebre para U (como en la Definición 2) con puntos de quiebre V v0 = 0, v1 = 1/2 y v2 = 1 con valores asociados u1 = 1 y u2 = 0. La mejor política de respuesta para V no es una política de punto de quiebre (debido a cómo la curva de w = 0 a w = 1 retrocede). El algoritmo LKS recortaría para obtener una política de puntos de quiebre como la que se muestra en la Figura 3. Se observa que esta política de punto de quiebre ˆB(W, V) es inválida en el sentido de que no satisface ˆB(W, V) ⊆ B(W, V). El punto es que la matriz de pagos de W ahora puede ser elegida para evitar que el algoritmo LKS encuentre un equilibrio de Nash. Por ejemplo, supongamos que las ganancias se dan de tal manera que P0 (W) = v y P1 (W) = (1−v)2. La mejor política de respuesta para W es una línea horizontal en w = 0.1 (Este es el valor de w que permite v = 2/3 - ver Figura 2, lo que hace que P0 (W) = P1 (W).) En el paso descendente, los valores elegidos son w = .1, luego, a partir del recorte, v = 0 y u = 1, lo cual no es un equilibrio de Nash ya que W prefiere la acción 1. El fallo del algoritmo no se debe al hecho de que la política de recorte llegue tan lejos a la derecha como sea posible. Cualquier otro recorte sería igual de malo. Por ejemplo, supongamos que la política de punto de quiebre para V tiene v = 0 hasta algún punto w∗ < .9 y luego salta a v = 1. El algoritmo es entonces derrotado por la matriz de pagos con P0(W) = 2v y P1(W) = (1 − v) en la que la política de mejor respuesta para W es una línea horizontal en w = .9. El algoritmo luego da w = .9, v = 1, y u = 0, lo cual no es un equilibrio de Nash ya que W prefiere la acción 0. Concluimos que el algoritmo LKS no siempre encuentra un equilibrio de Nash. En las Secciones 4 y 6 mostramos cómo modificar el algoritmo para que siempre encuentre un equilibrio de Nash. Para el algoritmo modificado, debemos extender la definición de la política de punto de quiebre (ver Definición 3) para que incluya políticas de punto de quiebre como la política de mejor respuesta para V en la Figura 2. Desafortunadamente, una política de punto de interrupción de este tipo puede ser exponencial en tamaño (ver Figura 7), por lo que el algoritmo corregido no se ejecuta en tiempo polinómico en todos los árboles. En la siguiente sección, mostramos que se ejecuta en tiempo polinómico en un camino. 4. ENCONTRANDO EQUILIBRIOS EN UN CAMINO En esta sección, nos enfocamos en el caso en el que el grafo subyacente es un camino, es decir, su conjunto de vértices es {V1, . . . , Vn}, y su conjunto de aristas es {(Vj , Vj+1) | j = 1, . . . , n − 1}. Mostramos que en este caso la mejor política de respuesta para cada vértice puede ser representada como una unión de un número polinomial de rectángulos, donde un rectángulo está definido por un par de intervalos cerrados (IV, IU) y consiste en todos los puntos en IV × IU; puede ser el caso de que uno o ambos de los intervalos IV e IU consistan en un solo punto. TEOREMA 5. Para cualquier j = 1, . . . , n, el conjunto B(Vj , Vj−1) puede ser representado como una unión disjunta de a lo sumo (j + 4)2 rectángulos. Además, dado tal representación de B(Vj , Vj−1), se puede calcular una representación de B(Vj+1, Vj) en tiempo O(j2). PRUEBA. Para cualquier conjunto A ⊆ [0, 1]2 que esté representado como una unión de un número finito de rectángulos, decimos que un punto u ∈ [0, 1] en el eje U es un punto de evento U de A si u = 0 o u = 1 o A contiene un rectángulo de la forma IV × IU y u es un extremo de IU; los puntos de evento V se definen de manera similar. Observa que para cualquier u ∈ [0, 1], el número de componentes conectadas de [0, 1]×{u} ∩ A es a lo sumo el número de puntos de V-evento de A. Utilizamos inducción en j para demostrar que para cada Vj se cumple la afirmación del teorema y, además, cada B(Vj, Vj−1) tiene como máximo 2j + 4 puntos de evento. Para simplificar el caso base, modificamos el juego gráfico agregando un vértice ficticio V0 al principio del camino: el único vecino de V0 es V1, las ganancias de V0 siempre son iguales a 0, y las ganancias de todos los demás vértices (incluido V1) son las mismas que en el juego original. Para j = 0, tenemos B(V1, V0) = [0, 1]2, por lo que la afirmación del teorema es trivialmente verdadera. Ahora, supongamos que j > 0, establezca V = Vj y permita que U = Vj−1 y W = Vj+1 sean los vértices que preceden y siguen a V, respectivamente. Los pagos para V están descritos por una matriz 2×2×2 P: Pxyz es el pago que V recibe cuando U juega x, V juega y, y W juega z, donde x, y, z ∈ {0, 1}. Supongamos que U juega 1 con probabilidad u y W juega 1 con probabilidad w. Entonces la ganancia esperada de V al jugar 0 es P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, mientras que su ganancia esperada al jugar 1 es P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111. Si P0 > P1, V prefiere estrictamente jugar 0; si P0 < P1, V prefiere estrictamente jugar 1; y si P0 = P1, V es indiferente, es decir, puede jugar cualquier estrategia (mixta). Dado que P0 y P1 son lineales en w y u, existen algunas constantes A1, A0, B1 y B0 que dependen de la matriz P, pero no de u y w, de modo que P0 − P1 = w(B1u + B0) − (A1u + A0). Dependiendo de los valores de A1, A0, B1 y B0, subdividimos el resto de la prueba en los siguientes casos. • B1 = 0, B0 = 0. En este caso, P0 > P1 si y solo si A1u + A0 < 0. Si también A1 = 0, A0 = 0, claramente, B(W, V) = [0, 1]2, y la afirmación del teorema es trivialmente verdadera. De lo contrario, el vértice V es indiferente entre 0 y 1 si y solo si A1 = 0 y u = −A0/A1. Sea V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}. Por la hipótesis inductiva, V consiste en a lo sumo 2(j − 1) + 4 segmentos y puntos aislados. Para cualquier v ∈ V, tenemos B(W, V)|V = v = [0, 1]: no importa lo que juegue W, siempre y cuando U esté jugando −A0/A1, V está contento de jugar v. Por otro lado, para cualquier v ∈ (0, 1) \\ V tenemos B(W, V)|V = v = ∅: cuando V juega v, U solo puede responder con u = −A0/A1, en cuyo caso V puede beneficiarse cambiando a una de las estrategias puras. Para completar la descripción de B(W, V), queda por analizar los casos v = 0 y v = 1. El vértice V prefiere jugar 0 si A1 > 0 y u ≤ −A0/A1, o A1 < 0 y u ≥ −A0/A1, o 103 A1 = 0 y A0 < 0. Supongamos por ahora que A1 > 0; los otros dos casos pueden ser tratados de manera similar. En este caso, 0 ∈ pbrV (w) para algún w ∈ [0, 1] si y solo si existe un u ∈ pbrU (0) tal que u ≤ −A0/A1: si no existe tal u, cada vez que V juega 0, la respuesta de U no está en pbrU (0) o V puede mejorar su recompensa jugando 1. Por lo tanto, o bien B(W, V)|V=0 = [0, 1] o B(W, V)|V=0 = ∅. De manera similar, B(W, V)|V=1 es igual a [0, 1] o ∅, dependiendo de pbrU(1). Por lo tanto, el conjunto B(W, V) consiste en un máximo de 2j + 4 ≤ (j + 4)2 rectángulos: B(W, V) ∩ [0, 1]×(0, 1) = [0, 1]×V contribuye como máximo con 2j + 2 rectángulos, y cada uno de los conjuntos B(W, V)|V=0 y B(W, V)|V=1 contribuye como máximo con un rectángulo. De manera similar, su número total de puntos de evento es a lo sumo 2j + 4: los únicos puntos de evento W son 0 y 1, cada punto de evento V de B(W, V) es un punto de evento V de B(V, U), y hay a lo sumo 2j + 2 de ellos. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 para algún α ∈ R. En este caso, V es indiferente entre 0 y 1 si y solo si w = α, o B1 = 0 y u = −B0/B1 = −A0/A1. De manera similar al caso anterior, podemos mostrar que B(W, V)∩[0, 1]×(0, 1) consiste en el rectángulo {α}×[0, 1] y como máximo 2j + 2 rectángulos de la forma [0, 1]×IV, donde cada IV corresponde a un componente conectado de B(V, U)|U=−B0/B1. Además, V prefiere jugar 0 si B1u + B0 > 0 y w ≥ α o B1u + B0 < 0 y w ≤ α. Por lo tanto, si B1u∗ + B0 > 0 para algún u∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [α, +∞) ∩ [0, 1] y si B1u∗∗ + B0 < 0 para algún u∗∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [−∞, α] ∩ [0, 1]; si ambos u∗ y u∗∗ existen, B(W, V )|V =0 = [0, 1]. El conjunto B(W, V)|V=1 se puede describir de manera similar. Por la hipótesis inductiva, B(V, U) tiene a lo sumo 2j + 2 puntos de evento; dado que al menos dos de estos son puntos de evento U, tiene a lo sumo 2j puntos de evento V. Dado que cada punto de evento V de B(W, V) es un punto de evento V de B(V, U) y B(W, V) tiene como máximo 3 puntos de evento W (0, 1 y α), su número total de puntos de evento es como máximo 2j + 3 < 2j + 4. Además, de manera similar al caso anterior, se sigue que B(W, V) consiste en un máximo de 2j + 4 < (j + 4)2 rectángulos. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0. En este caso, se puede definir la función de indiferencia f(·) como f(u) = A(u) B(u) = A1u+A0 B1u+B0, donde A(u) y B(u) nunca se anulan simultáneamente. Observa que siempre que w = f(u) y u, w ∈ [0, 1], V es indiferente entre jugar 0 y 1. Para cualquier A ⊆ [0, 1]2, definimos una función ˆfV por ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; nota que ˆfV mapea subconjuntos de [0, 1]2 a subconjuntos de R×[0, 1]. A veces omitimos el subíndice V cuando es evidente por el contexto. LEMMA 1. \n\nLEMMA 1. Para cualquier (w, v) ∈ [0, 1]×(0, 1) tenemos que (w, v) ∈ B(W, V) si y solo si existe un u ∈ [0, 1] tal que (v, u) ∈ B(V, U) y w = f(u). PRUEBA. Fije un v arbitrario en (0, 1). Supongamos que U juega algún u ∈ pbrU (v), w = f(u) satisface w ∈ [0, 1], y W juega w. Existe un vector de estrategias v1, . . . , vj−1 = u, vj = v tal que para cada Vk, k < j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que w = f(u), V es indiferente entre jugar 0 y 1; en particular, puede jugar v. Por lo tanto, si definimos vj+1 = w, el vector de estrategias (v1, . . . , vj+1) cumplirá las condiciones en la definición de mejor respuesta potencial, es decir, tenemos v ∈ pbrV (w). Por el contrario, supongamos que v ∈ pbrV (w) para algún w ∈ [0, 1], v = 0, 1. Entonces existe un vector de estrategias v1, . . . , vj−1, vj = v, vj+1 = w tal que para cada Vk, k ≤ j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que v = 0, 1, V, de hecho, es indiferente entre jugar 0 y 1, lo cual solo es posible si w = f(vj−1). Elige u = vj−1; por construcción, u ∈ pbrU (v). El lema 1 describe las situaciones en las que V es indiferente entre jugar 0 y jugar 1. Sin embargo, para caracterizar completamente B(W, V), también necesitamos saber cuándo V prefiere una estrategia pura. Define ˆf(0) = ∪u∈pbrU (0)Ru, donde Ru = ´ [f(u), +∞)×{0} si B(u) > 0, (−∞, f(u)]×{0} si B(u) < 0. y ˆf(1) = ∪u∈pbrU (1)Ru, donde Ru = ´ [f(u), +∞)×{1} si B(u) < 0, (−∞, f(u)]×{1} si B(u) > 0. LEMMA 2. \n\nLEMMA 2. Para cualquier w ∈ [0, 1], tenemos que (w, 0) ∈ ˆf(0) si y solo si 0 ∈ pbrV (w) y (w, 1) ∈ ˆf(1) si y solo si 1 ∈ pbrV (w). PRUEBA. Considera un u0 arbitrario ∈ pbrU (0). Si B(u0) > 0, para u = u0 la desigualdad P0 ≥ P1 es equivalente a w ≥ f(u0). Por lo tanto, cuando U juega u0 y W juega w, w ≥ f(u0), V prefiere jugar 0; dado que u0 ∈ pbrU (u), se sigue que 0 ∈ pbrV (w). El argumento para el caso B(u0) < 0 es similar. Por el contrario, si 0 ∈ pbrV (w) para algún w ∈ [0, 1], existe un vector (v1, . . . , vj−1, vj = 0, vj+1 = w) tal que para cada Vk, k ≤ j, Vk juega vk, y esta estrategia es una mejor respuesta a las estrategias de los vecinos de Vk. Ten en cuenta que para cualquier vector de este tipo tenemos vj−1 ∈ pbrU (0). Por contradicción, asumimos que (w, 0) ∈ Ë u∈pbrU (0) Ru. Entonces debe ser el caso que para cualquier u0 ∈ pbrU (0) ya sea que f(u0) < w y Ru0 = (−∞, f(u0)]×{0} o f(u0) > w y Ru0 = [f(u0), +∞)×{0}. En ambos casos, cuando V juega 0, U juega u0, y V juega w, la desigualdad entre f(u0) y w es equivalente a P0 < P1, es decir, V se beneficiaría al cambiar a 1. El argumento para ˆf(1) es similar. Juntas, el Lema 1 y el Lema 2 describen completamente el conjunto B(W, V): tenemos B(W, V) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2. Queda por demostrar que B(W, V) puede representarse como una unión de como máximo (j + 4)2 rectángulos, tiene como máximo 2j + 4 puntos de evento, y puede ser calculado en tiempo O(j2). Sea u∗ = −B0/B1. Considera un rectángulo arbitrario R = [v1, v2]×[u1, u2] ⊆ B(V, U). Si u∗ ∈ [u1, u2], la función f(·) es continua en [u1, u2] y por lo tanto ˆf(R) = [fmin, fmax]×[v1, v2], donde fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste en un solo rectángulo. Ahora, supongamos que R es intersectado por la línea [0, 1]×{u∗}; como se mencionó anteriormente, hay a lo sumo 2j+2 rectángulos de este tipo. Se supone que limu→u∗− f(u) = +∞; dado que f(·) es una función lineal fraccional, esto implica que limu→u∗+ f(u) = −∞ y también f(u1) > f(u2). Dado que f(·) es continua en [u1, u∗ ) y (u∗ , u2], es fácil ver que ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2]. El caso B1 = 0 no causa problemas especiales. Para completitud, establezca u∗ como cualquier valor fuera de [0, 1] en este caso. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figura 4: f es creciente en (−∞, u∗ ) y (u∗ , +∞). y ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste de a lo sumo dos rectángulos. El caso limu→u∗− f(u) = −∞ es similar. Dado que ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), se sigue que ˆf(B(V, U)) consiste en un máximo de (j + 3)2 + 2j + 2 rectángulos. Además, es fácil ver que tanto ˆf(0) como ˆf(1) consisten en un máximo de 2 segmentos de línea cada uno. Concluimos que B(W, V) puede ser representado como una unión de a lo sumo (j + 3)2 + 2j + 6 < (j + 4)2 rectángulos. Además, si v es un punto de evento V de B(W, V), entonces v es un punto de evento V de B(V, U) (esto incluye los casos v = 0 y v = 1, ya que 0 y 1 son puntos de evento V de B(V, U)) y si w es un punto de evento W de B(W, V), entonces o bien w = 0 o w = 1 o existe algún u ∈ [0, 1] tal que w = f(u) y u es un punto de evento U de B(V, U). Por lo tanto, B(W, V) tiene como máximo 2j + 4 puntos de evento. El límite O(j2) en el tiempo de ejecución en el Teorema 5 se deriva de nuestra descripción del algoritmo. El límite de O(n3) en el tiempo total de ejecución para encontrar un equilibrio de Nash (y una representación de todos los equilibrios de Nash) se sigue. 4.1 Encontrar un solo equilibrio de Nash en tiempo O(n2) El límite superior en el tiempo de ejecución de nuestro algoritmo es ajustado, al menos asumiendo la implementación directa, en la que cada B(Vj+1, Vj) se almacena como una unión de rectángulos: no es difícil construir un ejemplo en el que el tamaño de B(Vj+1, Vj) sea Ω(j2). Sin embargo, en algunos casos no es necesario representar todos los equilibrios de Nash; más bien, el objetivo es encontrar un equilibrio arbitrario del juego. En esta sección, demostramos que este problema puede resolverse en tiempo cuadrático, obteniendo así una prueba del Teorema 1. Nuestra solución se basa en la idea de [9], es decir, trabajar con subconjuntos de las políticas de mejor respuesta en lugar de las políticas de mejor respuesta en sí mismas; siguiendo [9], nos referiremos a tales subconjuntos como políticas de punto de quiebre. Si bien no siempre es posible construir una política de puntos de interrupción según se define en [9], mostramos cómo modificar esta definición para garantizar que siempre exista una política de puntos de interrupción; además, demostramos que para un grafo de camino, la política de puntos de interrupción de cualquier vértice puede ser almacenada en una estructura de datos cuyo tamaño es lineal en el número de descendientes que tiene este vértice. Definición 3. Una política de puntos de quiebre ˆB(V, U) para un vértice U cuyo padre es V es una curva no auto-intersectante de la forma X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, donde Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] y ui, vi ∈ [0, 1] para i = 0, . . . , m. Decimos que una política de puntos de quiebre es válida si v0 = 0, vm = 1, y ˆB(V, U) ⊆ B(V, U). A veces abusaremos de la notación al referirnos a ˆB(V, U) como una colección de segmentos Xi, Yi en lugar de su unión. Se debe tener en cuenta que no requerimos que vi ≤ vi+1 o ui ≤ ui+1; por lo tanto, en cualquier argumento que involucre políticas de puntos de quiebre, todos los segmentos deben tratarse como segmentos dirigidos. Observe que cualquier política de puntos de quiebre válida ˆB(V, U) puede ser vista como un mapeo continuo 1-1 γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2, donde γ(0) = (0, u1), γ(1) = (1, um) y existen algunos t0 = 0, t1, . . . , t2m−2 = 1 tales que {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1. Como se explica en la Sección 3, podemos utilizar una política de punto de quiebre válida en lugar de la política de mejor respuesta durante el paso descendente, y aún así garantizar que al final, produciremos un equilibrio de Nash. El Teorema 6 muestra que se puede calcular de forma inductiva políticas de puntos de quiebre válidas para todos los vértices en el camino; la prueba de este teorema se puede encontrar en la versión completa de este artículo [6]. TEOREMA 6. Para cualquier V = Vj, se puede encontrar en tiempo polinómico una política de puntos de quiebre válida ˆB(W, V) que consiste en a lo sumo 2j + 1 segmentos. EQUILIBRIOS DE NASH EN GRÁFICOS CON GRADO MÁXIMO 2 En esta sección mostramos cómo el algoritmo para caminos puede aplicarse para resolver un juego en cualquier gráfico cuyos vértices tengan un grado de a lo sumo 2. Un grafo con grado máximo 2 es, por supuesto, una unión de caminos y ciclos. Dado que cada componente conectado puede ser manejado de forma independiente, para obtener una prueba del Teorema 2, solo necesitamos mostrar cómo tratar con los ciclos. Dado un ciclo con vértices V1, . . . , Vk (en orden cíclico), realizamos dos búsquedas separadas de un equilibrio de Nash: primero buscamos un equilibrio de Nash donde algún vértice juega una estrategia pura, luego buscamos un equilibrio de Nash completamente mixto, donde todos los vértices juegan estrategias mixtas. Para i ≤ k, dejemos que vi denote la probabilidad de que Vi juegue 1. La primera búsqueda se puede hacer de la siguiente manera. Para cada i ∈ {1, . . . , k} y cada b ∈ {0, 1}, haz lo siguiente. 1. Sea P el camino (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2. El pago a Vi+1 se basa en poner vi = b (por lo que depende solo de vi+1 y vi+2). 3. Aplica el pase ascendente a P 4. Pon vi = b; aplica el pase aguas abajo. Para cada vértice, Vj, lleva un registro de todas las posibles estrategias mixtas vj 5. Verificar si Vi+1 tiene alguna respuesta consistente con vi = b; si es así, tenemos un equilibrio de Nash. (De lo contrario, no hay un equilibrio de Nash del tipo deseado). Para la segunda búsqueda, hay que tener en cuenta que si Vi juega una estrategia mixta, entonces vi+1 y vi−1 satisfacen una ecuación de la forma vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1). Dado que todos los vértices en el ciclo juegan estrategias mixtas, tenemos vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1). Componiendo las dos transformaciones lineales fraccionarias, obtenemos vi+3 = (A0 + A1 vi−1)/(B0 + B1 vi−1), para algunas nuevas constantes A0, A1, B0, B1. Elige cualquier vértice Vi. Podemos expresar vi en términos de vi+2, luego vi+4, vi+6, etc. y finalmente vi mismo para obtener una ecuación cuadrática (para vi) que es fácil de derivar a partir de los pagos en el juego. Si la ecuación no es trivial, tiene como máximo 2 soluciones en (0, 1). Para un ciclo de longitud impar, todos los demás vj son derivables a partir de esas soluciones, y si existe un equilibrio de Nash completamente mezclado, todos los vj deberían resultar ser números reales en el rango (0, 1). Para un ciclo de longitud par, obtenemos dos ecuaciones cuadráticas, una para vi y otra para 105 vi+1, y de la misma manera podemos probar si alguna solución a estas ecuaciones produce valores para los otros vj, todos los cuales se encuentran en el intervalo (0, 1). Si la ecuación cuadrática es trivial, potencialmente hay un continuo de equilibrios completamente mezclados. Los valores de vi que pueden ocurrir en un equilibrio de Nash son aquellos para los cuales todos los valores dependientes vj se encuentran en el intervalo (0, 1); esta última condición es fácil de verificar calculando la imagen del intervalo (0, 1) bajo transformaciones lineales fraccionarias respectivas. 6. ENCONTRANDO EQUILIBRIOS EN UN ÁRBOL (ARBITRARIO) Para árboles arbitrarios, la estructura general del algoritmo permanece igual, es decir, se puede construir una política de mejor respuesta (o, alternativamente, una política de punto de quiebre) para cualquier vértice basada en las políticas de mejor respuesta de sus hijos. Suponemos que el grado de cada vértice está limitado por una constante K, es decir, la matriz de pagos para cada vértice es de tamaño O(2K). Consideremos un vértice V cuyos hijos son U1, . . . , Uk y cuyo padre es W; la política de mejor respuesta de cada Uj es B(V, Uj). De manera similar a la sección anterior, podemos calcular los pagos esperados V de jugar 0 o 1, respectivamente. Es decir, cuando cada uno de los Uj juega uj y W juega w, tenemos P0 = L0 (u1, . . . , uk, w), P1 = L1 (u1, . . . , uk, w), donde las funciones L0 (·, . . . , ·), L1 (·, . . . , ·) son lineales en todos sus argumentos. Por lo tanto, la desigualdad P0 > P1 se puede reescribir como wB(u1, . . . , uk) > A(u1, . . . , uk), donde tanto A(·, . . . , ·) como B(·, . . . , ·) son lineales en todos sus argumentos. Dado u = (u1, . . . , uk) y defina la función de indiferencia f : [0, 1]k → [0, 1] como f(u) = A(u)/B(u); claramente, si cada Uj juega uj, W juega w y w = f(u), V es indiferente entre jugar 0 y 1. Para cualquier X = X1 × · · · × Xk, donde Xi ⊆ [0, 1]2 se define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k}. Además, se establece ˆf(0) = {(w, 0) | ∃u tal que ui ∈ pbrUi (0) y wB(u) ≥ A(u)} y ˆf(1) = {(w, 1) | ∃u tal que ui ∈ pbrUi (1) y wB(u) ≤ A(u)}. Como en la sección anterior, podemos demostrar que B(W, V) es igual a ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2; además, cualquier camino de w = 0 a w = 1 que sea un subconjunto de B(W, V) constituye una política de puntos de quiebre válida. Política de Puntos de Quiebre de Tamaño Exponencial. Si bien el algoritmo de la Sección 4 se puede generalizar para árboles de grado acotado, su tiempo de ejecución ya no es polinomial. De hecho, la afirmación contraria es cierta: podemos construir una familia de árboles y matrices de pago para todos los jugadores de manera que las políticas de mejor respuesta para algunos de los jugadores consistan en un número exponencial de segmentos. Además, en nuestro ejemplo las políticas de puntos de quiebre coinciden con las políticas de mejor respuesta, lo que significa que incluso encontrar un solo equilibrio de Nash utilizando el enfoque de [8, 9] llevará un tiempo exponencialmente largo. De hecho, una afirmación más fuerte es cierta: para cualquier algoritmo de dos pasos de tiempo polinómico (definido más adelante) que funcione con subconjuntos de políticas de mejor respuesta para este grafo, podemos elegir las recompensas de los vértices de manera que el paso posterior de este algoritmo falle. La figura 5: El árbol Tn que corresponde a la política de puntos de quiebre de tamaño exponencial. En el resto de esta subsección, describimos esta construcción. Considera el árbol Tn dado por la Figura 5; sea Vn la raíz de este árbol. Para cada k = 1, . . . , n, permita que las ganancias de Sk y Tk sean las mismas que las de U y V descritas en la Sección 3; recuerde que las políticas de puntos de quiebre para U y V se muestran en la Figura 2. No es difícil ver que la función de indiferencia para Tk está dada por f(s) = .8s + .1. El pago de V0 es 1 si V1 selecciona la misma acción que V0 y 0 en caso contrario; la política de mejor respuesta de V0 está dada por la Figura 6. LEMMA 3. \n\nLEMMA 3. Dado k < n, y sean u, t, v y w las estrategias de Vk−1, Tk, Vk y Vk+1, respectivamente. Supongamos que Vk prefiere jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Entonces B(Vk+1, Vk) consta de al menos 3k segmentos. Además, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} y {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}. PRUEBA. La demostración procede por inducción en k. Para k = 0, la afirmación es obvia. Ahora, supongamos que es cierto para B(Vk, Vk−1). Se puede ver B(Vk+1, Vk) como una unión de siete componentes: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, y cinco componentes que corresponden a los segmentos de B(Vk, Tk). Examinémoslos uno por uno. Para describir ˆf(0)∩[0, 1]×{0}, observe que f(u, t) = .5t+.1u+.2 es monótona en t y u y cumple con f(0, 0) = .2. Además, tenemos pbrVk−1 (0) = {0} y pbrTk (0) = {0}. Para cualquier w ∈ [0, 1] tenemos f(0, 0) ≥ w si y solo si w ∈ [0, .2]. Concluimos que ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}. De manera similar, se sigue que ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}. Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; estos conjuntos corresponden a segmentos horizontales de B(Vk, Tk). Es fácil ver que S1, S2, S3 ⊂ B(Vk+1, Vk). Dado que f es una función continua, el número de segmentos en cada Si es al menos el número de segmentos en B(Vk, Vk−1)∩[.1, .9]×[0, 1], que es al menos 3k−1 por hipótesis de inducción. Además, dado que f es monótona en u y f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), todos los Si, i = 1, 2, 3, son disjuntos. Finalmente, el conjunto B(Vk+1, Vk) contiene dos segmentos que corresponden a los segmentos verticales de B(Vk, Tk), es decir, S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} y S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}. Claramente, S4 conecta S2 y S3, S5 conecta S1 y S2, y S4 y S5 no se intersectan entre sí. Concluimos que B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figura 6: Políticas de puntos de quiebre para V0 y V1, es una línea continua que consiste en al menos 3k segmentos y satisface la condición del lema. Para completar la construcción, necesitamos demostrar que podemos diseñar la matriz de pagos para Vk de manera que prefiera jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Con este fin, demostramos una afirmación más general, a saber, que la función de indiferencia de un vértice puede ser una función multilineal fraccional arbitraria de las estrategias de sus descendientes. Decimos que una función de k variables es multilineal si puede ser representada como una suma de monomios y cada uno de estos monomios es lineal en todas sus variables. Ten en cuenta que esta definición es diferente de una más estándar en el sentido de que no requerimos que todos los monomios tengan el mismo grado. Recuerde que las ganancias de un vértice con k + 1 vecinos están descritas por las matrices P0 y P1, donde Pj i0i1...ik es la ganancia que V obtiene cuando juega j, y sus vecinos juegan i0, . . . , ik, y j, i0, . . . , ik ∈ {0, 1}. Sea P[j] = P[j](w, u1, . . . , uk) la ganancia esperada obtenida por este vértice cuando juega j y las estrategias (mixtas) de sus vecinos están dadas por un vector (w, u1, . . . , uk), es decir, P[j] = E[P j i0i1...ik ] donde i0, . . . , ik son variables aleatorias de Bernoulli independientes, cada una de las cuales es 1 con las respectivas probabilidades w, u1, . . . , uk. LEMMA 4. \n\nLEMMA 4. Dado un vértice del árbol V cuyo padre es W y cuyos hijos son U1, . . . , Uk, para cualquier función f = f(u1, . . . , uk) que pueda representarse como una razón de dos funciones multilineales f1, f2, es decir, f = f1(u1,...,uk) f2(u1,...,uk), existen matrices de pago P0 y P1 para V tales que P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk). La prueba de este lema se basa en el hecho de que cada monomio de la forma as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, puede ser representado como t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk para algunos Ct, t ∈ {0, 1}k+1. Los detalles se pueden encontrar en la versión completa de este documento [6]. 6.2 Irreducibilidad de la Política de Mejor Respuesta para Tn Si bien la política de mejor respuesta construida en la subsección anterior tiene un tamaño exponencial, no está claro `a priori que sea necesario hacer un seguimiento de todos sus segmentos de línea en lugar de centrarse en un pequeño subconjunto de estos segmentos. Sin embargo, resulta que para algoritmos de dos pasadas como el algoritmo de [8], la política de mejor respuesta no se puede simplificar. Más precisamente, decimos que un algoritmo A es un algoritmo de dos pasadas si 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figura 7: Política de punto de quiebre para V2. • A consta de un paso ascendente y un paso descendente. • Durante el paso ascendente, para cada vértice V con padre W, A construye un conjunto BB(W, V) ⊆ B(W, V). Este conjunto se produce a partir de los conjuntos {BB(V, U) | U es un hijo de V} aplicando el procedimiento desde el principio de la Sección 6 (sustituyendo BB(V, Uj) por B(V, Uj) para todos los hijos Uj de V), y luego posiblemente omitiendo algunos de los puntos del conjunto resultante (que luego se almacena explícitamente). El paso aguas abajo es idéntico al paso aguas abajo de [8] como se describe en la Sección 2, excepto que opera en los conjuntos BB(W, V) en lugar de en los conjuntos B(W, V). El Teorema 7 demuestra que cualquier algoritmo de dos pasadas fallará durante la pasada aguas abajo en Tn si existe un índice j tal que el conjunto BB(Vj+1, Vj) omite algún punto interior de cualquiera de los (al menos 3j) segmentos de B(Vj+1, Vj). Esto implica el Teorema 3. TEOREMA 7. Para cualquier algoritmo de dos pasos A para el cual exista un índice j, j ∈ [1, n/4], un segmento S de B(Vj, Vj−1), y un punto interior (x, y) de S tal que BB(Vj, Vj−1) no contenga (x, y), podemos elegir matrices de pago de los vértices Vj, . . . , Vn para que el paso descendente de A falle, y, además, los pagos a V4j, . . . , Vn sean idénticamente 0. Esbozamos la demostración del Teorema 7; los detalles se pueden encontrar en la versión completa de este artículo [6]. Procedemos por inducción. Para j = 1, el argumento es similar al de la Sección 3. Para el paso inductivo, la idea principal es que podemos enfocarnos en cualquier parte de una política de mejor respuesta (¡incluyendo la parte que fue omitida!) utilizando una función de indiferencia apropiada; esto nos permite reducir el caso j = j0 a j = j0 − 1. En la sección anterior, demostramos que para juegos gráficos en árboles que son casi, pero no del todo, caminos, los algoritmos de dos pasos no logran encontrar equilibrios de Nash en tiempo polinómico. A continuación mostramos que una propiedad de grafo similar a un camino más suave nos permite construir juegos gráficos para los cuales es poco probable que cualquier algoritmo de tiempo polinómico encuentre equilibrios de Nash. 7.1 Ancho de camino Una descomposición de camino de un grafo G = (V, E) es una secuencia de subconjuntos Si(V) ⊆ V tal que para cada arista (v, v') ∈ E, v, v' ∈ Si(V) para algún i, y además, para cada v ∈ V, si v ∈ Si(V) y v ∈ Sj(V) para j > i, entonces v ∈ Sk(V) para todo i ≤ k ≤ j. La descomposición del camino tiene ancho k si todos los conjuntos Si(V) tienen una cardinalidad de a lo sumo k + 1. El ancho de camino de G es el ancho mínimo de cualquier descomposición de camino de G. 107 El ancho de camino es una restricción del ancho de árbol (en el cual se buscaría un árbol cuyos vértices fueran los conjuntos Si(V), y los conjuntos que contienen algún vértice tendrían que formar un subárbol). Para cualquier constante k, se puede decidir en tiempo polinómico si un grafo tiene un ancho de camino (o ancho de árbol) k. Además, muchos problemas de teoría de grafos parecen más fáciles de resolver en tiempo polinómico cuando se restringen a grafos con un ancho de árbol o un ancho de camino fijo, consulte [1] para obtener una visión general. Ten en cuenta que un camino tiene un ancho de camino de 1 y un ciclo tiene un ancho de camino de 2. 7.2 <br>Completitud de PPAD</br> Revisamos algunas definiciones básicas de la teoría de complejidad computacional de problemas de búsqueda. Un problema de búsqueda asocia cualquier entrada (aquí, un juego gráfico) con un conjunto de soluciones (aquí, los equilibrios de Nash del juego de entrada), donde la longitud de la descripción de cualquier solución debe estar acotada de forma polinómica en función de la longitud de la descripción de su entrada. En un problema de búsqueda total, hay una garantía de que al menos una solución existe para cualquier entrada. El teorema de Nash nos asegura que el problema de encontrar equilibrios de Nash es total. Una reducción del problema de búsqueda S al problema S es un mecanismo que muestra que cualquier algoritmo de tiempo polinómico para S implica un algoritmo de tiempo polinómico para S. Consiste en funciones f y g, computables en tiempo polinómico, donde f mapea entradas de S a entradas de S, y g mapea soluciones de S a soluciones de S, de tal manera que si IS es una entrada para S, y SS es una solución para f(IS), entonces g(SS) es una solución para IS. Observe que los problemas de búsqueda total no permiten las reducciones anteriores de problemas como CIRCUIT SAT (donde la entrada es un circuito booleano, y las soluciones son vectores de entrada que hacen que la salida sea verdadera) debido a que CIRCUIT SAT y otros problemas NP-completos tienen entradas con conjuntos de soluciones vacíos. En cambio, el trabajo reciente sobre la complejidad computacional de encontrar un equilibrio de Nash [7, 4, 5, 2, 3] lo ha relacionado con el siguiente problema. Definición 4. FIN DE LA LÍNEA. Circuitos booleanos S y P, cada uno con n bits de entrada y n bits de salida, donde P(0n) = 0n y S(0n) = 0n. Solución: x ∈ {0, 1}n tal que S(x) = x, o alternativamente x ∈ {0, 1}n tal que P(S(x)) = x. S y P pueden ser consideradas como representando sucesor y predecesor. Observe que al calcular Si (0n) (para i = 0, 1, 2, ...) y comparar con P(Si+1 (0n)), eventualmente debemos encontrar una solución para EL FIN DE LA LÍNEA. END OF THE LINE caracteriza la clase de complejidad PPAD (que significa argumento de paridad en un grafo, versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda S es PPAD-completo si END OF THE LINE se reduce a S. Otros problemas PPAD-completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para descripciones más detalladas de estos problemas). 3-GRAPHICAL NASH es el problema de encontrar un equilibrio de Nash para un juego gráfico cuyo grafo tiene grado 3. Daskalakis et al. [4] muestran la <br>completitud de PPAD</br> de NASH 3-GRÁFICO mediante una reducción de BROUWER TRIDIMENSIONAL, introducida en [4] y definida de la siguiente manera. Definición 5. BROUWER TRIDIMENSIONAL. Un circuito C que tiene 3n bits de entrada y 2 bits de salida. Los bits de entrada definen un cubilete del cubo unitario, compuesto por las 3 coordenadas de sus puntos, dadas con una precisión de n bits. La salida representa uno de los cuatro colores asignados por C a un cubito. C está restringido para asignar el color 1 a los cubitos adyacentes al plano (y, z), el color 2 a los cubitos restantes adyacentes al plano (x, z), el color 3 a los cubitos restantes en el plano (x, y), y el color 0 a todos los demás cubitos en la superficie del cubo unitario. Una solución es un vértice pancromático, un vértice adyacente a cubiletes que tienen 4 colores distintos. La razón por la que se garantiza la existencia de una solución es que se puede construir una función de Brouwer asociada φ, es decir, una función continua del cubo unitario a sí mismo, de modo que los vértices pancromáticos correspondan a los puntos fijos de φ. El Teorema del Punto Fijo de Brouwer promete la existencia de un punto fijo. La prueba del Teorema 4 utiliza una modificación de la reducción de [4] de 3-DIMENSIONAL BROUWER a 3-GRAPHICAL NASH. Para demostrar el teorema, comenzamos con algunos resultados preliminares de la siguiente manera. Cada jugador tiene 2 acciones, denominadas 0 y 1. Para un jugador en el vértice V, dejemos que p[V] denote la probabilidad de que el jugador juegue 1. LEMMA 5. [7] Existe un juego gráfico Gshift de tamaño fijo con vértices V, V donde p[V] es la parte fraccionaria de 2p[V]. COROLARIO 1. Existe un juego gráfico Gn−shift de tamaño Θ(n) de ancho de camino constante, con vértices V, Vn donde p[Vn] es la parte fraccionaria de 2n .p[V]. PRUEBA. Crear una cadena de n copias de Gshift en el Lema 5. Cada subconjunto de vértices en la descomposición del camino son los vértices en una copia de Gshift. Que In(x) denote el n-ésimo bit de la expansión binaria de x, donde interpretamos 1 como verdadero y 0 como falso. Lo siguiente utiliza dispositivos de [7, 4]. COROLARIO 2. Existe un valor k tal que para todo n, y para todo n1, n2, n3 ≤ n, existe un juego gráfico de tamaño O(n) con ancho de camino k, teniendo vértices V1, V2, V3 donde p[V3] = p[V1] + 2−n3 (En1 p[V1] ∧ En2 p[V2]). PRUEBA DEL TEOREMA 4. Sea C el circuito booleano que describe una instancia de BROUWER TRIDIMENSIONAL. Sean g1, . . . , gp(n) las compuertas de C indexadas de tal manera que la(s) entrada(s) de cualquier compuerta son la(s) salida(s) de las compuertas de índice inferior. g1, . . . , g3n serán las 3n entradas de C. Todos los jugadores en el juego gráfico G construido en [4] tienen 2 acciones denotadas como 0 y 1. La probabilidad de que V juegue 1 se denota como p[V]. G tiene 3 jugadores Vx, Vy y Vz para los cuales p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto en el cubo unitario. G está diseñado para incentivar a Vx, Vy y Vz a ajustar sus probabilidades en direcciones dadas por una función de Brouwer que está especificada por el circuito C. En un equilibrio de Nash, p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto fijo de una función que pertenece a la clase de funciones representadas por el BROUWER TRIDIMENSIONAL. Para 1 ≤ i ≤ p(n) introducimos un vértice V (i) C tal que para 1 ≤ j ≤ i, Ij(p[V (i) C ]) es la salida de la compuerta gj; para i < j ≤ p(n), Ij(p[V (i) C ]) es 0. Construye V (i) C a partir de V (i−1) C utilizando el Corolario 2. Sea G(i) el juego gráfico que hace esto. Sea S1(G(i)), . . . , Sn(G(i)) una descomposición de camino de longitud n de G(i), donde V(i−1) ⊂ S1(G(i)) y V(i) ⊂ Sn(G(i)). Luego, se obtiene una descomposición de camino de ∪1≤i≤p(n)G(i) tomando la unión de las descomposiciones de camino separadas, junto con Sn(G(i−1) ) ∪ S1(G(i) ) para 2 ≤ i ≤ p(n). Sea GC el juego gráfico anterior que simula C. GC tiene 3n entradas, que consisten en los primeros n bits de las expansiones binarias de p[Vx], p[Vy] y p[Vz]. De manera similar a [4], la salida de GC afecta a Vx, Vy y Vz de la siguiente manera. El color 0 incentiva a Vx, Vy y Vz 108 a ajustar sus probabilidades p[Vx], p[Vy] y p[Vz] en la dirección (−1, −1, −1); el color 2 los incentiva a moverse en la dirección (1, 0, 0); el color 2, dirección (0, 1, 0); el color 3, dirección (0, 0, 1). Necesitamos asegurarnos de que en los puntos en los límites de los cubitos adyacentes, el cambio de dirección será aproximadamente el promedio de las direcciones de los puntos circundantes. De esta manera, los cuatro colores/direcciones deben estar cerca para que puedan anularse entre sí (y estemos en un vértice pancromático). Esto se logra utilizando el mismo truco que [4], en el cual hacemos un número constante M de copias de GC, que difieren en que cada copia agrega un vector de desplazamiento pequeño a sus copias de p[Vx], p[Vy] y p[Vz] (que se derivan del original utilizando el dispositivo de adición de [7]). Usando los dispositivos de suma y multiplicación de [7], promediamos las direcciones y sumamos un pequeño múltiplo de este promedio a (p[Vx], p[Vy], p[Vz]). En un equilibrio de Nash, las salidas de cada copia se cancelarán mutuamente. El ancho de camino del juego completo es a lo sumo M veces el ancho de camino GC. 8. PROBLEMAS ABIERTOS El problema más importante que queda abierto en este artículo es si es posible encontrar un equilibrio de Nash de un juego gráfico en un árbol de grado acotado en tiempo polinómico. Nuestra construcción muestra que cualquier algoritmo de dos pasadas que almacene explícitamente políticas de puntos de quiebre necesita tiempo y espacio exponenciales. Sin embargo, esto no excluye la existencia de un algoritmo que se base en una idea similar, pero en lugar de calcular la política de punto de ruptura completa para cada vértice, utiliza un pequeño número de pasadas adicionales a través del grafo para decidir qué partes (de tamaño polinómico) de cada política de punto de ruptura deben ser calculadas. En particular, dicho algoritmo puede basarse en el algoritmo de aproximación de [8], donde el valor de es elegido de forma adaptativa. Otra pregunta intrigante está relacionada con el hecho de que el grafo para el cual construimos una política de puntos de quiebre de tamaño exponencial tiene un ancho de camino de 2, mientras que nuestros resultados positivos son para un camino, es decir, un grafo de ancho de camino 1. No está claro si para cualquier grafo de grado acotado con ancho de camino 1, el tiempo de ejecución de nuestro algoritmo (versión basada en política de puntos de interrupción) será polinomial. En particular, resulta instructivo considerar un grafo oruga, es decir, el grafo que se puede obtener a partir de Tn al eliminar los vértices S1, . . . , Sn. Para este gráfico, la mejor política de respuesta de un vértice Vk en la columna vertebral de la oruga se obtiene combinando la mejor política de respuesta de su predecesor en la columna vertebral Vk−1 y su otro hijo Tk; dado que este último es una hoja, su mejor política de respuesta es trivial (es decir, [0, 1]2, [0, 1]×{0} o [0, 1]×{1}) o consiste en dos segmentos horizontales y un segmento vertical de la forma {α}×[0, 1] que los conecta. Suponiendo, para mayor comodidad, que B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, y f es la función de indiferencia para Vk, observamos que la política de mejor respuesta para Vk consta de 5 componentes: ˆf(0), ˆf(1), y tres componentes que corresponden a [0, α]×{0}, {α}×[0, 1], y [α, 1]×{1}. Por lo tanto, se puede pensar en la construcción de B(Vk+1, Vk) como el siguiente proceso: girar B(Vk, Vk−1) en π/2, cortarlo a lo largo de la línea (ahora horizontal) vk = α, aplicar una transformación lineal fraccional a la coordenada horizontal de ambas partes y volver a conectarlas usando la imagen del segmento {α}×[0, 1] bajo f. Esto implica que el problema de acotar el tamaño de la política de mejor respuesta (o, alternativamente, la política de punto de quiebre) se puede ver como una generalización del siguiente problema de geometría computacional, que creemos puede ser de interés independiente: PROBLEMA 1. Dada una colección de segmentos paralelos a los ejes en R2, considera la siguiente operación: elige una línea paralela a los ejes li (ya sea vertical u horizontal), corta el plano a lo largo de esta línea y desplaza una de las dos partes resultantes por una cantidad arbitraria δi; como resultado, algunos segmentos se dividirán en dos partes. Reconecte estas partes, es decir, para cada segmento de la forma [a, b] × {c} que fue transformado en [a, t] × {c + δi} y [t, b] × {c}, introduzca un segmento {t} × [c, c+δi]. ¿Es posible comenzar con el segmento [0, 1] y después de n operaciones obtener un conjunto que no pueda representarse como una unión de poli(n) segmentos de línea? ¿En caso afirmativo, puede ser que en este conjunto no haya un camino con un número polinomial de giros que conecte los extremos del segmento original? Resulta que en general, la respuesta a la primera pregunta es positiva, es decir, después de n pasos, es posible obtener un conjunto que consiste en Θ(cn) segmentos para algún c > 0. Esto implica que incluso para una oruga, la mejor política de respuesta puede ser exponencialmente grande. Sin embargo, en nuestro ejemplo (que se omite en esta versión del documento debido a limitaciones de espacio), existe un camino de tamaño polinómico a través de la política de mejor respuesta, es decir, no demuestra que la política de punto de quiebre sea necesariamente exponencial en tamaño. Si se puede demostrar que esto siempre es cierto, puede ser posible adaptar esta prueba para mostrar que puede haber una brecha exponencial entre los tamaños de las políticas de mejor respuesta y las políticas de punto de quiebre. 9. REFERENCIAS [1] H. Bodlaender y T. Kloks. Algoritmos eficientes y constructivos para el ancho de camino y el ancho de árbol de grafos. Revista de Algoritmos, 21:358-402, 1996. [2] X. Chen y X. Deng. 3-NASH es PPAD-completo. Informe técnico TR-05-134, Coloquio Electrónico en Complejidad Computacional, 2005. [3] X. Chen y X. Deng. Resolviendo la complejidad del equilibrio de Nash de 2 jugadores. Informe técnico TR-05-140, Coloquio Electrónico en Complejidad Computacional, 2005. [4] C. Daskalakis, P. Goldberg y C. Papadimitriou. La complejidad de calcular un equilibrio de Nash. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [5] C. Daskalakis y C. Papadimitriou. Los juegos de tres jugadores son difíciles. Informe técnico TR-05-139, Coloquio Electrónico en Complejidad Computacional, 2005. [6] E. Elkind, L. Goldberg y P. Goldberg. Equilibrios de Nash en juegos gráficos en árboles revisados. Informe técnico TR-06-005, Coloquio Electrónico en Complejidad Computacional, 2006. [7] P. Goldberg y C. Papadimitriou. Reductibilidad entre problemas de equilibrio. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [8] M. Kearns, M. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, 2001. [9] M. Littman, M. Kearns y S. Singh. Un algoritmo exacto eficiente para juegos gráficos de conexión simple. En Actas de la 15ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2001. [10] L. Ortiz y M. Kearns. Propagación de Nash para juegos gráficos con bucles. En Actas de la 17ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2003. [11] C. Papadimitriou. Sobre la complejidad del argumento de paridad y otras demostraciones ineficientes de existencia. J. Comput. This is not a complete sentence. Please provide more context or the full sentence you would like me to translate. Cienc., 48(3):498-532, 1994. 109 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "bounded-degree tree": {
            "translated_key": "árbol de grado acotado",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a <br>bounded-degree tree</br> in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a <br>bounded-degree tree</br> in polynomial time."
            ],
            "translated_annotated_samples": [
                "PROBLEMAS ABIERTOS El problema más importante que queda abierto en este artículo es si es posible encontrar un equilibrio de Nash de un juego gráfico en un <br>árbol de grado acotado</br> en tiempo polinómico."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V. El algoritmo genérico no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente. En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta. La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2). Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del algoritmo genérico de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino). Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9]. En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un juego gráfico en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario). Obtenemos el siguiente teorema TEOREMA 1. Existe un algoritmo O(n2) que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un camino de n vértices. Existe un algoritmo O(n3) que calcula una representación de todos los equilibrios de Nash de dicho juego. En la Sección 5 extendemos los resultados de la Sección 4 a grafos de grado 2 en general, obteniendo el siguiente teorema. TEOREMA 2. Existe un algoritmo de tiempo polinómico que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un grafo con grado máximo 2. En la Sección 6 ampliamos nuestro algoritmo para que pueda ser utilizado para encontrar un equilibrio de Nash de un juego gráfico en un árbol arbitrario. Incluso cuando el árbol tiene grado acotado, el tiempo de ejecución puede ser exponencial. Mostramos que esto es inevitable construyendo una familia de juegos gráficos en árboles de grado acotado para los cuales las políticas de mejor respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de dos pasos (es decir, un algoritmo que es similar en espíritu al de [8]) tiene que almacenar casi todos los puntos de las políticas de mejor respuesta. En particular, mostramos lo siguiente. TEOREMA 3. Existe una familia infinita de juegos gráficos en árboles de grado acotado con ancho de camino 2, tal que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales. Es interesante notar que los árboles utilizados en la demostración del Teorema 3 tienen un ancho de camino de 2, es decir, están muy cerca de ser caminos. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico para grafos de ancho de camino 1. Esta pregunta puede ser vista como una generalización de un problema muy natural de geometría computacional; lo describimos con más detalle en la Sección 8. En la Sección 7, presentamos un resultado de intractabilidad teórica de complejidad para el problema de encontrar un equilibrio de Nash de un juego gráfico en un grafo con un ancho de camino pequeño. Demostramos el siguiente teorema. TEOREMA 4. Considera el problema de encontrar un equilibrio de Nash para un juego gráfico en el cual el grafo subyacente tiene un grado máximo de 3 y un ancho de camino k. Existe una constante k tal que este problema es PPAD-completo. El teorema 4 limita la medida en que podemos explotar las propiedades de tipo camino del grafo subyacente para encontrar equilibrios de Nash. Para demostrar el Teorema 4, utilizamos resultados recientes de completitud de PPAD para juegos, en particular los artículos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de grado d (para d ≥ 3) es computacionalmente equivalente al problema de resolver juegos en forma normal de r jugadores (para r ≥ 4), ambos de los cuales son PPAD-completos. CONSIDERACIONES PREVIAS Y NOTACIÓN Consideramos juegos gráficos en los que el grafo subyacente G es un árbol de n vértices. Cada vértice tiene dos acciones, que se denotan como 0 y 1. Una estrategia mixta se define por un único número x ∈ [0, 1], que indica la probabilidad de que el jugador seleccione la acción 1. Para los propósitos del algoritmo, el árbol está enraizado de manera arbitraria. Para mayor comodidad, asumimos sin pérdida de generalidad que la raíz tiene un solo hijo y que su recompensa es independiente de la acción elegida por el hijo. Esto se puede lograr primero eligiendo una raíz arbitraria del árbol, y luego agregando un padre ficticio de esta raíz, asignándole una función de pago constante. Dado un borde (V, W) del árbol G, y una estrategia mixta w para W, sea G(V,W), W=w la instancia obtenida de G mediante (1) eliminar todos los nodos Z que están separados de V por W (es decir, todos los nodos Z tales que el camino de Z a V pasa por W), y (2) restringir la instancia de modo que se requiera que W juegue la estrategia mixta w. Definición 1. Supongamos que (V, W) es un borde del árbol, que v es una estrategia mixta para V y que w es una estrategia mixta para W. Decimos que v es una mejor respuesta potencial para w (indicado por v ∈ pbrV(w)) si hay un equilibrio en la instancia G(V, W), W = w en el que V tiene la estrategia mixta v. Definimos la política de mejor respuesta para V, dada W, como B(W, V) = {(w, v) | v ∈ pbrV(w), w ∈ [0, 1]}. Normalmente, W es el padre de V, y esto se conoce simplemente como la política de mejor respuesta para V. La expresión B(W, V )|V =v se utiliza para denotar el conjunto B(W, V ) ∩ [0, 1]×{v}. El paso ascendente del algoritmo genérico de [8] calcula la política de mejor respuesta para V en cada nodo V que no sea la raíz. Con las suposiciones anteriores sobre la raíz, el paso aguas abajo es sencillo: Sea W la raíz y V su hijo. La raíz selecciona cualquier par (w, v) de B(W, V). Decide jugar con la estrategia mixta w e instruye a V a jugar con la estrategia mixta v. El resto del paso descendente es recursivo. Cuando un nodo V recibe instrucciones de su padre para adoptar la estrategia mixta v, hace lo siguiente para cada hijo U: encuentra un par (v, u) ∈ B(V, U) (con el mismo valor de v que le fue dado por su padre) e instruye a U a jugar u. ALGORITMO DE LITTMAN ET AL. El algoritmo de [9] se basa en la siguiente observación: para calcular un equilibrio de Nash único mediante un algoritmo de dos pasos, no es necesario construir la política de mejor respuesta completa para cada vértice. Si, en cada paso de la pasada descendente, el vértice en consideración puede seleccionar un vector de estrategias para todos sus hijos de manera que la estrategia de cada hijo sea una mejor respuesta potencial a la estrategia del padre, el algoritmo logra producir un equilibrio de Nash. Esto se puede lograr si, al comienzo del paso aguas abajo, tenemos una estructura de datos en la que cada vértice V con padre W almacena un conjunto ˆB(W, V ) ⊆ B(W, V ) (llamado una política de puntos de quiebre) que cubre cada posible w ∈ [0, 1]. Mostraremos más adelante que una condición suficiente para la construcción de una estructura de datos así es la invariante de que, en cada nivel del paso ascendente, ˆB(W, V) contiene un camino continuo desde w = 0 hasta w = 1. En [9], se sugiere que podemos seleccionar la política de punto de quiebre de una manera particular. Es decir, el documento utiliza la siguiente definición: Definición 2. (cf. [9]) Una política de puntos de ruptura para un nodo V con padre W consiste en un conjunto ordenado de puntos de ruptura de W, w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 y un conjunto asociado de valores de V, v1, . . . , vt. La interpretación es que para cualquier w ∈ [0, 1], si wi−1 < w < wi para algún índice i y W juega w, entonces V deberá jugar vi; y si w = wi para algún índice i, entonces V deberá jugar cualquier valor entre vi y vi+1. Decimos que una política de punto de quiebre tiene t - 1 puntos de quiebre. El artículo luego afirma que cualquier vértice V puede calcular su política de punto de interrupción con respecto a su padre W dadas las políticas de punto de interrupción de sus hijos U1, . . . , Uk. La prueba procede ordenando los puntos de quiebre de los niños (es decir, los valores respectivos de v) de izquierda a derecha (se puede asumir sin pérdida de generalidad que todos estos puntos de quiebre son distintos) y considerándolos sucesivamente; cada punto vl ∈ {v1, . . . , vL} corresponde a una elección fija de estrategias para k − 1 niños y un intervalo de estrategias admisibles para un niño. Supongamos, para mayor comodidad, que este niño es U1 y su intervalo de estrategias admisibles en vl es [a, b]; supongamos también que para Uj, j = 2, . . . , k, sus respectivas políticas de puntos de quiebre les prescriben jugar uj en respuesta a vl. Sea P i (u, w), i = 0, 1, el pago esperado para V cuando V juega i, U1 juega u, cada Uj, j = 2, . . . , k, juega uj, y W juega w, y considera el conjunto Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] tal que P 0 (u, w) = P1 (u, w)}; nota que para cualquier w ∈ Wl tenemos vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figura 1: LKS: Recorte para encontrar políticas de puntos de quiebre. Los autores muestran que para cualquier punto de quiebre vl, el conjunto Wl está vacío, es un solo intervalo, o es una unión de dos intervalos no flotantes (un intervalo es no flotante si uno de sus extremos es 0 o 1); además, la unión de todos los conjuntos Wl, l = 1, . . . , L, cubre el intervalo [0, 1]. Se sigue fácilmente que se puede cubrir [0, 1] con a lo sumo L+2 intervalos, cada uno de los cuales es un subconjunto de algún Wl. Los autores afirman entonces que cualquier cobertura de este tipo puede ser transformada en una política de puntos de ruptura para V. Es decir, afirman que para cualquier par de intervalos Wl1 y Wl2 en la cobertura, cualquier superposición entre Wl1 y Wl2 puede asignarse arbitrariamente a la cobertura por Wl1 y Wl2 recortados en consecuencia (cf. [9], p. 5). Ellos ilustran su enfoque en una figura, la cual se reproduce como Figura 1 aquí. En la figura, las líneas horizontales discontinuas representan los puntos de quiebre v1, v2, . . . , v7 y los intervalos sólidos a lo largo de estos puntos de quiebre son los conjuntos W1, W2, . . . , W7. El camino grueso conectado es la política de punto de quiebre correspondiente. Se elige de la siguiente manera: comenzar en la izquierda y siempre saltar al intervalo que permita el mayor avance hacia la derecha. Para entender por qué este enfoque no funciona en general, considera un camino de longitud 4 que consiste en una raíz indiferente R, su hijo W, el hijo de W V y el hijo de V U. Supongamos que U recibe un pago de 1 si juega de manera diferente a V y 0 en caso contrario. Así, si v denota la estrategia mixta de V (es decir, V juega 1 con probabilidad v), entonces la ganancia esperada que U obtiene al jugar 0 se da por P0(U) = v y la ganancia esperada que U obtiene al jugar 1 se da por P1(U) = 1 − v. Supongamos que V no obtiene ganancia al jugar 1 (por lo que P1(V) = 0) y que su matriz de ganancias al jugar 0 es 1 −9 9 −1, entonces si u denota la estrategia mixta de U y w denota la estrategia mixta de W, la ganancia esperada que V obtiene al jugar 0 se da por P0(V) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1). Usando las técnicas de [8] (o, alternativamente, las de la Sección 4), no es difícil verificar que las políticas de mejor respuesta para U y V (como en la Definición 1) están dadas por los gráficos en la Figura 2. La mejor política de respuesta para U es una política de punto de quiebre para U (como en la Definición 2) con puntos de quiebre V v0 = 0, v1 = 1/2 y v2 = 1 con valores asociados u1 = 1 y u2 = 0. La mejor política de respuesta para V no es una política de punto de quiebre (debido a cómo la curva de w = 0 a w = 1 retrocede). El algoritmo LKS recortaría para obtener una política de puntos de quiebre como la que se muestra en la Figura 3. Se observa que esta política de punto de quiebre ˆB(W, V) es inválida en el sentido de que no satisface ˆB(W, V) ⊆ B(W, V). El punto es que la matriz de pagos de W ahora puede ser elegida para evitar que el algoritmo LKS encuentre un equilibrio de Nash. Por ejemplo, supongamos que las ganancias se dan de tal manera que P0 (W) = v y P1 (W) = (1−v)2. La mejor política de respuesta para W es una línea horizontal en w = 0.1 (Este es el valor de w que permite v = 2/3 - ver Figura 2, lo que hace que P0 (W) = P1 (W).) En el paso descendente, los valores elegidos son w = .1, luego, a partir del recorte, v = 0 y u = 1, lo cual no es un equilibrio de Nash ya que W prefiere la acción 1. El fallo del algoritmo no se debe al hecho de que la política de recorte llegue tan lejos a la derecha como sea posible. Cualquier otro recorte sería igual de malo. Por ejemplo, supongamos que la política de punto de quiebre para V tiene v = 0 hasta algún punto w∗ < .9 y luego salta a v = 1. El algoritmo es entonces derrotado por la matriz de pagos con P0(W) = 2v y P1(W) = (1 − v) en la que la política de mejor respuesta para W es una línea horizontal en w = .9. El algoritmo luego da w = .9, v = 1, y u = 0, lo cual no es un equilibrio de Nash ya que W prefiere la acción 0. Concluimos que el algoritmo LKS no siempre encuentra un equilibrio de Nash. En las Secciones 4 y 6 mostramos cómo modificar el algoritmo para que siempre encuentre un equilibrio de Nash. Para el algoritmo modificado, debemos extender la definición de la política de punto de quiebre (ver Definición 3) para que incluya políticas de punto de quiebre como la política de mejor respuesta para V en la Figura 2. Desafortunadamente, una política de punto de interrupción de este tipo puede ser exponencial en tamaño (ver Figura 7), por lo que el algoritmo corregido no se ejecuta en tiempo polinómico en todos los árboles. En la siguiente sección, mostramos que se ejecuta en tiempo polinómico en un camino. 4. ENCONTRANDO EQUILIBRIOS EN UN CAMINO En esta sección, nos enfocamos en el caso en el que el grafo subyacente es un camino, es decir, su conjunto de vértices es {V1, . . . , Vn}, y su conjunto de aristas es {(Vj , Vj+1) | j = 1, . . . , n − 1}. Mostramos que en este caso la mejor política de respuesta para cada vértice puede ser representada como una unión de un número polinomial de rectángulos, donde un rectángulo está definido por un par de intervalos cerrados (IV, IU) y consiste en todos los puntos en IV × IU; puede ser el caso de que uno o ambos de los intervalos IV e IU consistan en un solo punto. TEOREMA 5. Para cualquier j = 1, . . . , n, el conjunto B(Vj , Vj−1) puede ser representado como una unión disjunta de a lo sumo (j + 4)2 rectángulos. Además, dado tal representación de B(Vj , Vj−1), se puede calcular una representación de B(Vj+1, Vj) en tiempo O(j2). PRUEBA. Para cualquier conjunto A ⊆ [0, 1]2 que esté representado como una unión de un número finito de rectángulos, decimos que un punto u ∈ [0, 1] en el eje U es un punto de evento U de A si u = 0 o u = 1 o A contiene un rectángulo de la forma IV × IU y u es un extremo de IU; los puntos de evento V se definen de manera similar. Observa que para cualquier u ∈ [0, 1], el número de componentes conectadas de [0, 1]×{u} ∩ A es a lo sumo el número de puntos de V-evento de A. Utilizamos inducción en j para demostrar que para cada Vj se cumple la afirmación del teorema y, además, cada B(Vj, Vj−1) tiene como máximo 2j + 4 puntos de evento. Para simplificar el caso base, modificamos el juego gráfico agregando un vértice ficticio V0 al principio del camino: el único vecino de V0 es V1, las ganancias de V0 siempre son iguales a 0, y las ganancias de todos los demás vértices (incluido V1) son las mismas que en el juego original. Para j = 0, tenemos B(V1, V0) = [0, 1]2, por lo que la afirmación del teorema es trivialmente verdadera. Ahora, supongamos que j > 0, establezca V = Vj y permita que U = Vj−1 y W = Vj+1 sean los vértices que preceden y siguen a V, respectivamente. Los pagos para V están descritos por una matriz 2×2×2 P: Pxyz es el pago que V recibe cuando U juega x, V juega y, y W juega z, donde x, y, z ∈ {0, 1}. Supongamos que U juega 1 con probabilidad u y W juega 1 con probabilidad w. Entonces la ganancia esperada de V al jugar 0 es P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, mientras que su ganancia esperada al jugar 1 es P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111. Si P0 > P1, V prefiere estrictamente jugar 0; si P0 < P1, V prefiere estrictamente jugar 1; y si P0 = P1, V es indiferente, es decir, puede jugar cualquier estrategia (mixta). Dado que P0 y P1 son lineales en w y u, existen algunas constantes A1, A0, B1 y B0 que dependen de la matriz P, pero no de u y w, de modo que P0 − P1 = w(B1u + B0) − (A1u + A0). Dependiendo de los valores de A1, A0, B1 y B0, subdividimos el resto de la prueba en los siguientes casos. • B1 = 0, B0 = 0. En este caso, P0 > P1 si y solo si A1u + A0 < 0. Si también A1 = 0, A0 = 0, claramente, B(W, V) = [0, 1]2, y la afirmación del teorema es trivialmente verdadera. De lo contrario, el vértice V es indiferente entre 0 y 1 si y solo si A1 = 0 y u = −A0/A1. Sea V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}. Por la hipótesis inductiva, V consiste en a lo sumo 2(j − 1) + 4 segmentos y puntos aislados. Para cualquier v ∈ V, tenemos B(W, V)|V = v = [0, 1]: no importa lo que juegue W, siempre y cuando U esté jugando −A0/A1, V está contento de jugar v. Por otro lado, para cualquier v ∈ (0, 1) \\ V tenemos B(W, V)|V = v = ∅: cuando V juega v, U solo puede responder con u = −A0/A1, en cuyo caso V puede beneficiarse cambiando a una de las estrategias puras. Para completar la descripción de B(W, V), queda por analizar los casos v = 0 y v = 1. El vértice V prefiere jugar 0 si A1 > 0 y u ≤ −A0/A1, o A1 < 0 y u ≥ −A0/A1, o 103 A1 = 0 y A0 < 0. Supongamos por ahora que A1 > 0; los otros dos casos pueden ser tratados de manera similar. En este caso, 0 ∈ pbrV (w) para algún w ∈ [0, 1] si y solo si existe un u ∈ pbrU (0) tal que u ≤ −A0/A1: si no existe tal u, cada vez que V juega 0, la respuesta de U no está en pbrU (0) o V puede mejorar su recompensa jugando 1. Por lo tanto, o bien B(W, V)|V=0 = [0, 1] o B(W, V)|V=0 = ∅. De manera similar, B(W, V)|V=1 es igual a [0, 1] o ∅, dependiendo de pbrU(1). Por lo tanto, el conjunto B(W, V) consiste en un máximo de 2j + 4 ≤ (j + 4)2 rectángulos: B(W, V) ∩ [0, 1]×(0, 1) = [0, 1]×V contribuye como máximo con 2j + 2 rectángulos, y cada uno de los conjuntos B(W, V)|V=0 y B(W, V)|V=1 contribuye como máximo con un rectángulo. De manera similar, su número total de puntos de evento es a lo sumo 2j + 4: los únicos puntos de evento W son 0 y 1, cada punto de evento V de B(W, V) es un punto de evento V de B(V, U), y hay a lo sumo 2j + 2 de ellos. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 para algún α ∈ R. En este caso, V es indiferente entre 0 y 1 si y solo si w = α, o B1 = 0 y u = −B0/B1 = −A0/A1. De manera similar al caso anterior, podemos mostrar que B(W, V)∩[0, 1]×(0, 1) consiste en el rectángulo {α}×[0, 1] y como máximo 2j + 2 rectángulos de la forma [0, 1]×IV, donde cada IV corresponde a un componente conectado de B(V, U)|U=−B0/B1. Además, V prefiere jugar 0 si B1u + B0 > 0 y w ≥ α o B1u + B0 < 0 y w ≤ α. Por lo tanto, si B1u∗ + B0 > 0 para algún u∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [α, +∞) ∩ [0, 1] y si B1u∗∗ + B0 < 0 para algún u∗∗ ∈ pbrU (0), entonces B(W, V )|V =0 contiene [−∞, α] ∩ [0, 1]; si ambos u∗ y u∗∗ existen, B(W, V )|V =0 = [0, 1]. El conjunto B(W, V)|V=1 se puede describir de manera similar. Por la hipótesis inductiva, B(V, U) tiene a lo sumo 2j + 2 puntos de evento; dado que al menos dos de estos son puntos de evento U, tiene a lo sumo 2j puntos de evento V. Dado que cada punto de evento V de B(W, V) es un punto de evento V de B(V, U) y B(W, V) tiene como máximo 3 puntos de evento W (0, 1 y α), su número total de puntos de evento es como máximo 2j + 3 < 2j + 4. Además, de manera similar al caso anterior, se sigue que B(W, V) consiste en un máximo de 2j + 4 < (j + 4)2 rectángulos. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0. En este caso, se puede definir la función de indiferencia f(·) como f(u) = A(u) B(u) = A1u+A0 B1u+B0, donde A(u) y B(u) nunca se anulan simultáneamente. Observa que siempre que w = f(u) y u, w ∈ [0, 1], V es indiferente entre jugar 0 y 1. Para cualquier A ⊆ [0, 1]2, definimos una función ˆfV por ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; nota que ˆfV mapea subconjuntos de [0, 1]2 a subconjuntos de R×[0, 1]. A veces omitimos el subíndice V cuando es evidente por el contexto. LEMMA 1. \n\nLEMMA 1. Para cualquier (w, v) ∈ [0, 1]×(0, 1) tenemos que (w, v) ∈ B(W, V) si y solo si existe un u ∈ [0, 1] tal que (v, u) ∈ B(V, U) y w = f(u). PRUEBA. Fije un v arbitrario en (0, 1). Supongamos que U juega algún u ∈ pbrU (v), w = f(u) satisface w ∈ [0, 1], y W juega w. Existe un vector de estrategias v1, . . . , vj−1 = u, vj = v tal que para cada Vk, k < j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que w = f(u), V es indiferente entre jugar 0 y 1; en particular, puede jugar v. Por lo tanto, si definimos vj+1 = w, el vector de estrategias (v1, . . . , vj+1) cumplirá las condiciones en la definición de mejor respuesta potencial, es decir, tenemos v ∈ pbrV (w). Por el contrario, supongamos que v ∈ pbrV (w) para algún w ∈ [0, 1], v = 0, 1. Entonces existe un vector de estrategias v1, . . . , vj−1, vj = v, vj+1 = w tal que para cada Vk, k ≤ j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Dado que v = 0, 1, V, de hecho, es indiferente entre jugar 0 y 1, lo cual solo es posible si w = f(vj−1). Elige u = vj−1; por construcción, u ∈ pbrU (v). El lema 1 describe las situaciones en las que V es indiferente entre jugar 0 y jugar 1. Sin embargo, para caracterizar completamente B(W, V), también necesitamos saber cuándo V prefiere una estrategia pura. Define ˆf(0) = ∪u∈pbrU (0)Ru, donde Ru = ´ [f(u), +∞)×{0} si B(u) > 0, (−∞, f(u)]×{0} si B(u) < 0. y ˆf(1) = ∪u∈pbrU (1)Ru, donde Ru = ´ [f(u), +∞)×{1} si B(u) < 0, (−∞, f(u)]×{1} si B(u) > 0. LEMMA 2. \n\nLEMMA 2. Para cualquier w ∈ [0, 1], tenemos que (w, 0) ∈ ˆf(0) si y solo si 0 ∈ pbrV (w) y (w, 1) ∈ ˆf(1) si y solo si 1 ∈ pbrV (w). PRUEBA. Considera un u0 arbitrario ∈ pbrU (0). Si B(u0) > 0, para u = u0 la desigualdad P0 ≥ P1 es equivalente a w ≥ f(u0). Por lo tanto, cuando U juega u0 y W juega w, w ≥ f(u0), V prefiere jugar 0; dado que u0 ∈ pbrU (u), se sigue que 0 ∈ pbrV (w). El argumento para el caso B(u0) < 0 es similar. Por el contrario, si 0 ∈ pbrV (w) para algún w ∈ [0, 1], existe un vector (v1, . . . , vj−1, vj = 0, vj+1 = w) tal que para cada Vk, k ≤ j, Vk juega vk, y esta estrategia es una mejor respuesta a las estrategias de los vecinos de Vk. Ten en cuenta que para cualquier vector de este tipo tenemos vj−1 ∈ pbrU (0). Por contradicción, asumimos que (w, 0) ∈ Ë u∈pbrU (0) Ru. Entonces debe ser el caso que para cualquier u0 ∈ pbrU (0) ya sea que f(u0) < w y Ru0 = (−∞, f(u0)]×{0} o f(u0) > w y Ru0 = [f(u0), +∞)×{0}. En ambos casos, cuando V juega 0, U juega u0, y V juega w, la desigualdad entre f(u0) y w es equivalente a P0 < P1, es decir, V se beneficiaría al cambiar a 1. El argumento para ˆf(1) es similar. Juntas, el Lema 1 y el Lema 2 describen completamente el conjunto B(W, V): tenemos B(W, V) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2. Queda por demostrar que B(W, V) puede representarse como una unión de como máximo (j + 4)2 rectángulos, tiene como máximo 2j + 4 puntos de evento, y puede ser calculado en tiempo O(j2). Sea u∗ = −B0/B1. Considera un rectángulo arbitrario R = [v1, v2]×[u1, u2] ⊆ B(V, U). Si u∗ ∈ [u1, u2], la función f(·) es continua en [u1, u2] y por lo tanto ˆf(R) = [fmin, fmax]×[v1, v2], donde fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste en un solo rectángulo. Ahora, supongamos que R es intersectado por la línea [0, 1]×{u∗}; como se mencionó anteriormente, hay a lo sumo 2j+2 rectángulos de este tipo. Se supone que limu→u∗− f(u) = +∞; dado que f(·) es una función lineal fraccional, esto implica que limu→u∗+ f(u) = −∞ y también f(u1) > f(u2). Dado que f(·) es continua en [u1, u∗ ) y (u∗ , u2], es fácil ver que ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2]. El caso B1 = 0 no causa problemas especiales. Para completitud, establezca u∗ como cualquier valor fuera de [0, 1] en este caso. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figura 4: f es creciente en (−∞, u∗ ) y (u∗ , +∞). y ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], es decir, en este caso ˆf(R) ∩ [0, 1]2 consiste de a lo sumo dos rectángulos. El caso limu→u∗− f(u) = −∞ es similar. Dado que ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), se sigue que ˆf(B(V, U)) consiste en un máximo de (j + 3)2 + 2j + 2 rectángulos. Además, es fácil ver que tanto ˆf(0) como ˆf(1) consisten en un máximo de 2 segmentos de línea cada uno. Concluimos que B(W, V) puede ser representado como una unión de a lo sumo (j + 3)2 + 2j + 6 < (j + 4)2 rectángulos. Además, si v es un punto de evento V de B(W, V), entonces v es un punto de evento V de B(V, U) (esto incluye los casos v = 0 y v = 1, ya que 0 y 1 son puntos de evento V de B(V, U)) y si w es un punto de evento W de B(W, V), entonces o bien w = 0 o w = 1 o existe algún u ∈ [0, 1] tal que w = f(u) y u es un punto de evento U de B(V, U). Por lo tanto, B(W, V) tiene como máximo 2j + 4 puntos de evento. El límite O(j2) en el tiempo de ejecución en el Teorema 5 se deriva de nuestra descripción del algoritmo. El límite de O(n3) en el tiempo total de ejecución para encontrar un equilibrio de Nash (y una representación de todos los equilibrios de Nash) se sigue. 4.1 Encontrar un solo equilibrio de Nash en tiempo O(n2) El límite superior en el tiempo de ejecución de nuestro algoritmo es ajustado, al menos asumiendo la implementación directa, en la que cada B(Vj+1, Vj) se almacena como una unión de rectángulos: no es difícil construir un ejemplo en el que el tamaño de B(Vj+1, Vj) sea Ω(j2). Sin embargo, en algunos casos no es necesario representar todos los equilibrios de Nash; más bien, el objetivo es encontrar un equilibrio arbitrario del juego. En esta sección, demostramos que este problema puede resolverse en tiempo cuadrático, obteniendo así una prueba del Teorema 1. Nuestra solución se basa en la idea de [9], es decir, trabajar con subconjuntos de las políticas de mejor respuesta en lugar de las políticas de mejor respuesta en sí mismas; siguiendo [9], nos referiremos a tales subconjuntos como políticas de punto de quiebre. Si bien no siempre es posible construir una política de puntos de interrupción según se define en [9], mostramos cómo modificar esta definición para garantizar que siempre exista una política de puntos de interrupción; además, demostramos que para un grafo de camino, la política de puntos de interrupción de cualquier vértice puede ser almacenada en una estructura de datos cuyo tamaño es lineal en el número de descendientes que tiene este vértice. Definición 3. Una política de puntos de quiebre ˆB(V, U) para un vértice U cuyo padre es V es una curva no auto-intersectante de la forma X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, donde Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] y ui, vi ∈ [0, 1] para i = 0, . . . , m. Decimos que una política de puntos de quiebre es válida si v0 = 0, vm = 1, y ˆB(V, U) ⊆ B(V, U). A veces abusaremos de la notación al referirnos a ˆB(V, U) como una colección de segmentos Xi, Yi en lugar de su unión. Se debe tener en cuenta que no requerimos que vi ≤ vi+1 o ui ≤ ui+1; por lo tanto, en cualquier argumento que involucre políticas de puntos de quiebre, todos los segmentos deben tratarse como segmentos dirigidos. Observe que cualquier política de puntos de quiebre válida ˆB(V, U) puede ser vista como un mapeo continuo 1-1 γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2, donde γ(0) = (0, u1), γ(1) = (1, um) y existen algunos t0 = 0, t1, . . . , t2m−2 = 1 tales que {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1. Como se explica en la Sección 3, podemos utilizar una política de punto de quiebre válida en lugar de la política de mejor respuesta durante el paso descendente, y aún así garantizar que al final, produciremos un equilibrio de Nash. El Teorema 6 muestra que se puede calcular de forma inductiva políticas de puntos de quiebre válidas para todos los vértices en el camino; la prueba de este teorema se puede encontrar en la versión completa de este artículo [6]. TEOREMA 6. Para cualquier V = Vj, se puede encontrar en tiempo polinómico una política de puntos de quiebre válida ˆB(W, V) que consiste en a lo sumo 2j + 1 segmentos. EQUILIBRIOS DE NASH EN GRÁFICOS CON GRADO MÁXIMO 2 En esta sección mostramos cómo el algoritmo para caminos puede aplicarse para resolver un juego en cualquier gráfico cuyos vértices tengan un grado de a lo sumo 2. Un grafo con grado máximo 2 es, por supuesto, una unión de caminos y ciclos. Dado que cada componente conectado puede ser manejado de forma independiente, para obtener una prueba del Teorema 2, solo necesitamos mostrar cómo tratar con los ciclos. Dado un ciclo con vértices V1, . . . , Vk (en orden cíclico), realizamos dos búsquedas separadas de un equilibrio de Nash: primero buscamos un equilibrio de Nash donde algún vértice juega una estrategia pura, luego buscamos un equilibrio de Nash completamente mixto, donde todos los vértices juegan estrategias mixtas. Para i ≤ k, dejemos que vi denote la probabilidad de que Vi juegue 1. La primera búsqueda se puede hacer de la siguiente manera. Para cada i ∈ {1, . . . , k} y cada b ∈ {0, 1}, haz lo siguiente. 1. Sea P el camino (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2. El pago a Vi+1 se basa en poner vi = b (por lo que depende solo de vi+1 y vi+2). 3. Aplica el pase ascendente a P 4. Pon vi = b; aplica el pase aguas abajo. Para cada vértice, Vj, lleva un registro de todas las posibles estrategias mixtas vj 5. Verificar si Vi+1 tiene alguna respuesta consistente con vi = b; si es así, tenemos un equilibrio de Nash. (De lo contrario, no hay un equilibrio de Nash del tipo deseado). Para la segunda búsqueda, hay que tener en cuenta que si Vi juega una estrategia mixta, entonces vi+1 y vi−1 satisfacen una ecuación de la forma vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1). Dado que todos los vértices en el ciclo juegan estrategias mixtas, tenemos vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1). Componiendo las dos transformaciones lineales fraccionarias, obtenemos vi+3 = (A0 + A1 vi−1)/(B0 + B1 vi−1), para algunas nuevas constantes A0, A1, B0, B1. Elige cualquier vértice Vi. Podemos expresar vi en términos de vi+2, luego vi+4, vi+6, etc. y finalmente vi mismo para obtener una ecuación cuadrática (para vi) que es fácil de derivar a partir de los pagos en el juego. Si la ecuación no es trivial, tiene como máximo 2 soluciones en (0, 1). Para un ciclo de longitud impar, todos los demás vj son derivables a partir de esas soluciones, y si existe un equilibrio de Nash completamente mezclado, todos los vj deberían resultar ser números reales en el rango (0, 1). Para un ciclo de longitud par, obtenemos dos ecuaciones cuadráticas, una para vi y otra para 105 vi+1, y de la misma manera podemos probar si alguna solución a estas ecuaciones produce valores para los otros vj, todos los cuales se encuentran en el intervalo (0, 1). Si la ecuación cuadrática es trivial, potencialmente hay un continuo de equilibrios completamente mezclados. Los valores de vi que pueden ocurrir en un equilibrio de Nash son aquellos para los cuales todos los valores dependientes vj se encuentran en el intervalo (0, 1); esta última condición es fácil de verificar calculando la imagen del intervalo (0, 1) bajo transformaciones lineales fraccionarias respectivas. 6. ENCONTRANDO EQUILIBRIOS EN UN ÁRBOL (ARBITRARIO) Para árboles arbitrarios, la estructura general del algoritmo permanece igual, es decir, se puede construir una política de mejor respuesta (o, alternativamente, una política de punto de quiebre) para cualquier vértice basada en las políticas de mejor respuesta de sus hijos. Suponemos que el grado de cada vértice está limitado por una constante K, es decir, la matriz de pagos para cada vértice es de tamaño O(2K). Consideremos un vértice V cuyos hijos son U1, . . . , Uk y cuyo padre es W; la política de mejor respuesta de cada Uj es B(V, Uj). De manera similar a la sección anterior, podemos calcular los pagos esperados V de jugar 0 o 1, respectivamente. Es decir, cuando cada uno de los Uj juega uj y W juega w, tenemos P0 = L0 (u1, . . . , uk, w), P1 = L1 (u1, . . . , uk, w), donde las funciones L0 (·, . . . , ·), L1 (·, . . . , ·) son lineales en todos sus argumentos. Por lo tanto, la desigualdad P0 > P1 se puede reescribir como wB(u1, . . . , uk) > A(u1, . . . , uk), donde tanto A(·, . . . , ·) como B(·, . . . , ·) son lineales en todos sus argumentos. Dado u = (u1, . . . , uk) y defina la función de indiferencia f : [0, 1]k → [0, 1] como f(u) = A(u)/B(u); claramente, si cada Uj juega uj, W juega w y w = f(u), V es indiferente entre jugar 0 y 1. Para cualquier X = X1 × · · · × Xk, donde Xi ⊆ [0, 1]2 se define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k}. Además, se establece ˆf(0) = {(w, 0) | ∃u tal que ui ∈ pbrUi (0) y wB(u) ≥ A(u)} y ˆf(1) = {(w, 1) | ∃u tal que ui ∈ pbrUi (1) y wB(u) ≤ A(u)}. Como en la sección anterior, podemos demostrar que B(W, V) es igual a ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2; además, cualquier camino de w = 0 a w = 1 que sea un subconjunto de B(W, V) constituye una política de puntos de quiebre válida. Política de Puntos de Quiebre de Tamaño Exponencial. Si bien el algoritmo de la Sección 4 se puede generalizar para árboles de grado acotado, su tiempo de ejecución ya no es polinomial. De hecho, la afirmación contraria es cierta: podemos construir una familia de árboles y matrices de pago para todos los jugadores de manera que las políticas de mejor respuesta para algunos de los jugadores consistan en un número exponencial de segmentos. Además, en nuestro ejemplo las políticas de puntos de quiebre coinciden con las políticas de mejor respuesta, lo que significa que incluso encontrar un solo equilibrio de Nash utilizando el enfoque de [8, 9] llevará un tiempo exponencialmente largo. De hecho, una afirmación más fuerte es cierta: para cualquier algoritmo de dos pasos de tiempo polinómico (definido más adelante) que funcione con subconjuntos de políticas de mejor respuesta para este grafo, podemos elegir las recompensas de los vértices de manera que el paso posterior de este algoritmo falle. La figura 5: El árbol Tn que corresponde a la política de puntos de quiebre de tamaño exponencial. En el resto de esta subsección, describimos esta construcción. Considera el árbol Tn dado por la Figura 5; sea Vn la raíz de este árbol. Para cada k = 1, . . . , n, permita que las ganancias de Sk y Tk sean las mismas que las de U y V descritas en la Sección 3; recuerde que las políticas de puntos de quiebre para U y V se muestran en la Figura 2. No es difícil ver que la función de indiferencia para Tk está dada por f(s) = .8s + .1. El pago de V0 es 1 si V1 selecciona la misma acción que V0 y 0 en caso contrario; la política de mejor respuesta de V0 está dada por la Figura 6. LEMMA 3. \n\nLEMMA 3. Dado k < n, y sean u, t, v y w las estrategias de Vk−1, Tk, Vk y Vk+1, respectivamente. Supongamos que Vk prefiere jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Entonces B(Vk+1, Vk) consta de al menos 3k segmentos. Además, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} y {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}. PRUEBA. La demostración procede por inducción en k. Para k = 0, la afirmación es obvia. Ahora, supongamos que es cierto para B(Vk, Vk−1). Se puede ver B(Vk+1, Vk) como una unión de siete componentes: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, y cinco componentes que corresponden a los segmentos de B(Vk, Tk). Examinémoslos uno por uno. Para describir ˆf(0)∩[0, 1]×{0}, observe que f(u, t) = .5t+.1u+.2 es monótona en t y u y cumple con f(0, 0) = .2. Además, tenemos pbrVk−1 (0) = {0} y pbrTk (0) = {0}. Para cualquier w ∈ [0, 1] tenemos f(0, 0) ≥ w si y solo si w ∈ [0, .2]. Concluimos que ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}. De manera similar, se sigue que ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}. Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; estos conjuntos corresponden a segmentos horizontales de B(Vk, Tk). Es fácil ver que S1, S2, S3 ⊂ B(Vk+1, Vk). Dado que f es una función continua, el número de segmentos en cada Si es al menos el número de segmentos en B(Vk, Vk−1)∩[.1, .9]×[0, 1], que es al menos 3k−1 por hipótesis de inducción. Además, dado que f es monótona en u y f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), todos los Si, i = 1, 2, 3, son disjuntos. Finalmente, el conjunto B(Vk+1, Vk) contiene dos segmentos que corresponden a los segmentos verticales de B(Vk, Tk), es decir, S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} y S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}. Claramente, S4 conecta S2 y S3, S5 conecta S1 y S2, y S4 y S5 no se intersectan entre sí. Concluimos que B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figura 6: Políticas de puntos de quiebre para V0 y V1, es una línea continua que consiste en al menos 3k segmentos y satisface la condición del lema. Para completar la construcción, necesitamos demostrar que podemos diseñar la matriz de pagos para Vk de manera que prefiera jugar 0 en lugar de jugar 1 si y solo si .5t + .1u + .2 > w. Con este fin, demostramos una afirmación más general, a saber, que la función de indiferencia de un vértice puede ser una función multilineal fraccional arbitraria de las estrategias de sus descendientes. Decimos que una función de k variables es multilineal si puede ser representada como una suma de monomios y cada uno de estos monomios es lineal en todas sus variables. Ten en cuenta que esta definición es diferente de una más estándar en el sentido de que no requerimos que todos los monomios tengan el mismo grado. Recuerde que las ganancias de un vértice con k + 1 vecinos están descritas por las matrices P0 y P1, donde Pj i0i1...ik es la ganancia que V obtiene cuando juega j, y sus vecinos juegan i0, . . . , ik, y j, i0, . . . , ik ∈ {0, 1}. Sea P[j] = P[j](w, u1, . . . , uk) la ganancia esperada obtenida por este vértice cuando juega j y las estrategias (mixtas) de sus vecinos están dadas por un vector (w, u1, . . . , uk), es decir, P[j] = E[P j i0i1...ik ] donde i0, . . . , ik son variables aleatorias de Bernoulli independientes, cada una de las cuales es 1 con las respectivas probabilidades w, u1, . . . , uk. LEMMA 4. \n\nLEMMA 4. Dado un vértice del árbol V cuyo padre es W y cuyos hijos son U1, . . . , Uk, para cualquier función f = f(u1, . . . , uk) que pueda representarse como una razón de dos funciones multilineales f1, f2, es decir, f = f1(u1,...,uk) f2(u1,...,uk), existen matrices de pago P0 y P1 para V tales que P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk). La prueba de este lema se basa en el hecho de que cada monomio de la forma as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, puede ser representado como t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk para algunos Ct, t ∈ {0, 1}k+1. Los detalles se pueden encontrar en la versión completa de este documento [6]. 6.2 Irreducibilidad de la Política de Mejor Respuesta para Tn Si bien la política de mejor respuesta construida en la subsección anterior tiene un tamaño exponencial, no está claro `a priori que sea necesario hacer un seguimiento de todos sus segmentos de línea en lugar de centrarse en un pequeño subconjunto de estos segmentos. Sin embargo, resulta que para algoritmos de dos pasadas como el algoritmo de [8], la política de mejor respuesta no se puede simplificar. Más precisamente, decimos que un algoritmo A es un algoritmo de dos pasadas si 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figura 7: Política de punto de quiebre para V2. • A consta de un paso ascendente y un paso descendente. • Durante el paso ascendente, para cada vértice V con padre W, A construye un conjunto BB(W, V) ⊆ B(W, V). Este conjunto se produce a partir de los conjuntos {BB(V, U) | U es un hijo de V} aplicando el procedimiento desde el principio de la Sección 6 (sustituyendo BB(V, Uj) por B(V, Uj) para todos los hijos Uj de V), y luego posiblemente omitiendo algunos de los puntos del conjunto resultante (que luego se almacena explícitamente). El paso aguas abajo es idéntico al paso aguas abajo de [8] como se describe en la Sección 2, excepto que opera en los conjuntos BB(W, V) en lugar de en los conjuntos B(W, V). El Teorema 7 demuestra que cualquier algoritmo de dos pasadas fallará durante la pasada aguas abajo en Tn si existe un índice j tal que el conjunto BB(Vj+1, Vj) omite algún punto interior de cualquiera de los (al menos 3j) segmentos de B(Vj+1, Vj). Esto implica el Teorema 3. TEOREMA 7. Para cualquier algoritmo de dos pasos A para el cual exista un índice j, j ∈ [1, n/4], un segmento S de B(Vj, Vj−1), y un punto interior (x, y) de S tal que BB(Vj, Vj−1) no contenga (x, y), podemos elegir matrices de pago de los vértices Vj, . . . , Vn para que el paso descendente de A falle, y, además, los pagos a V4j, . . . , Vn sean idénticamente 0. Esbozamos la demostración del Teorema 7; los detalles se pueden encontrar en la versión completa de este artículo [6]. Procedemos por inducción. Para j = 1, el argumento es similar al de la Sección 3. Para el paso inductivo, la idea principal es que podemos enfocarnos en cualquier parte de una política de mejor respuesta (¡incluyendo la parte que fue omitida!) utilizando una función de indiferencia apropiada; esto nos permite reducir el caso j = j0 a j = j0 − 1. En la sección anterior, demostramos que para juegos gráficos en árboles que son casi, pero no del todo, caminos, los algoritmos de dos pasos no logran encontrar equilibrios de Nash en tiempo polinómico. A continuación mostramos que una propiedad de grafo similar a un camino más suave nos permite construir juegos gráficos para los cuales es poco probable que cualquier algoritmo de tiempo polinómico encuentre equilibrios de Nash. 7.1 Ancho de camino Una descomposición de camino de un grafo G = (V, E) es una secuencia de subconjuntos Si(V) ⊆ V tal que para cada arista (v, v') ∈ E, v, v' ∈ Si(V) para algún i, y además, para cada v ∈ V, si v ∈ Si(V) y v ∈ Sj(V) para j > i, entonces v ∈ Sk(V) para todo i ≤ k ≤ j. La descomposición del camino tiene ancho k si todos los conjuntos Si(V) tienen una cardinalidad de a lo sumo k + 1. El ancho de camino de G es el ancho mínimo de cualquier descomposición de camino de G. 107 El ancho de camino es una restricción del ancho de árbol (en el cual se buscaría un árbol cuyos vértices fueran los conjuntos Si(V), y los conjuntos que contienen algún vértice tendrían que formar un subárbol). Para cualquier constante k, se puede decidir en tiempo polinómico si un grafo tiene un ancho de camino (o ancho de árbol) k. Además, muchos problemas de teoría de grafos parecen más fáciles de resolver en tiempo polinómico cuando se restringen a grafos con un ancho de árbol o un ancho de camino fijo, consulte [1] para obtener una visión general. Ten en cuenta que un camino tiene un ancho de camino de 1 y un ciclo tiene un ancho de camino de 2. 7.2 Completitud de PPAD Revisamos algunas definiciones básicas de la teoría de complejidad computacional de problemas de búsqueda. Un problema de búsqueda asocia cualquier entrada (aquí, un juego gráfico) con un conjunto de soluciones (aquí, los equilibrios de Nash del juego de entrada), donde la longitud de la descripción de cualquier solución debe estar acotada de forma polinómica en función de la longitud de la descripción de su entrada. En un problema de búsqueda total, hay una garantía de que al menos una solución existe para cualquier entrada. El teorema de Nash nos asegura que el problema de encontrar equilibrios de Nash es total. Una reducción del problema de búsqueda S al problema S es un mecanismo que muestra que cualquier algoritmo de tiempo polinómico para S implica un algoritmo de tiempo polinómico para S. Consiste en funciones f y g, computables en tiempo polinómico, donde f mapea entradas de S a entradas de S, y g mapea soluciones de S a soluciones de S, de tal manera que si IS es una entrada para S, y SS es una solución para f(IS), entonces g(SS) es una solución para IS. Observe que los problemas de búsqueda total no permiten las reducciones anteriores de problemas como CIRCUIT SAT (donde la entrada es un circuito booleano, y las soluciones son vectores de entrada que hacen que la salida sea verdadera) debido a que CIRCUIT SAT y otros problemas NP-completos tienen entradas con conjuntos de soluciones vacíos. En cambio, el trabajo reciente sobre la complejidad computacional de encontrar un equilibrio de Nash [7, 4, 5, 2, 3] lo ha relacionado con el siguiente problema. Definición 4. FIN DE LA LÍNEA. Circuitos booleanos S y P, cada uno con n bits de entrada y n bits de salida, donde P(0n) = 0n y S(0n) = 0n. Solución: x ∈ {0, 1}n tal que S(x) = x, o alternativamente x ∈ {0, 1}n tal que P(S(x)) = x. S y P pueden ser consideradas como representando sucesor y predecesor. Observe que al calcular Si (0n) (para i = 0, 1, 2, ...) y comparar con P(Si+1 (0n)), eventualmente debemos encontrar una solución para EL FIN DE LA LÍNEA. END OF THE LINE caracteriza la clase de complejidad PPAD (que significa argumento de paridad en un grafo, versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda S es PPAD-completo si END OF THE LINE se reduce a S. Otros problemas PPAD-completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para descripciones más detalladas de estos problemas). 3-GRAPHICAL NASH es el problema de encontrar un equilibrio de Nash para un juego gráfico cuyo grafo tiene grado 3. Daskalakis et al. [4] muestran la completitud de PPAD de NASH 3-GRÁFICO mediante una reducción de BROUWER TRIDIMENSIONAL, introducida en [4] y definida de la siguiente manera. Definición 5. BROUWER TRIDIMENSIONAL. Un circuito C que tiene 3n bits de entrada y 2 bits de salida. Los bits de entrada definen un cubilete del cubo unitario, compuesto por las 3 coordenadas de sus puntos, dadas con una precisión de n bits. La salida representa uno de los cuatro colores asignados por C a un cubito. C está restringido para asignar el color 1 a los cubitos adyacentes al plano (y, z), el color 2 a los cubitos restantes adyacentes al plano (x, z), el color 3 a los cubitos restantes en el plano (x, y), y el color 0 a todos los demás cubitos en la superficie del cubo unitario. Una solución es un vértice pancromático, un vértice adyacente a cubiletes que tienen 4 colores distintos. La razón por la que se garantiza la existencia de una solución es que se puede construir una función de Brouwer asociada φ, es decir, una función continua del cubo unitario a sí mismo, de modo que los vértices pancromáticos correspondan a los puntos fijos de φ. El Teorema del Punto Fijo de Brouwer promete la existencia de un punto fijo. La prueba del Teorema 4 utiliza una modificación de la reducción de [4] de 3-DIMENSIONAL BROUWER a 3-GRAPHICAL NASH. Para demostrar el teorema, comenzamos con algunos resultados preliminares de la siguiente manera. Cada jugador tiene 2 acciones, denominadas 0 y 1. Para un jugador en el vértice V, dejemos que p[V] denote la probabilidad de que el jugador juegue 1. LEMMA 5. [7] Existe un juego gráfico Gshift de tamaño fijo con vértices V, V donde p[V] es la parte fraccionaria de 2p[V]. COROLARIO 1. Existe un juego gráfico Gn−shift de tamaño Θ(n) de ancho de camino constante, con vértices V, Vn donde p[Vn] es la parte fraccionaria de 2n .p[V]. PRUEBA. Crear una cadena de n copias de Gshift en el Lema 5. Cada subconjunto de vértices en la descomposición del camino son los vértices en una copia de Gshift. Que In(x) denote el n-ésimo bit de la expansión binaria de x, donde interpretamos 1 como verdadero y 0 como falso. Lo siguiente utiliza dispositivos de [7, 4]. COROLARIO 2. Existe un valor k tal que para todo n, y para todo n1, n2, n3 ≤ n, existe un juego gráfico de tamaño O(n) con ancho de camino k, teniendo vértices V1, V2, V3 donde p[V3] = p[V1] + 2−n3 (En1 p[V1] ∧ En2 p[V2]). PRUEBA DEL TEOREMA 4. Sea C el circuito booleano que describe una instancia de BROUWER TRIDIMENSIONAL. Sean g1, . . . , gp(n) las compuertas de C indexadas de tal manera que la(s) entrada(s) de cualquier compuerta son la(s) salida(s) de las compuertas de índice inferior. g1, . . . , g3n serán las 3n entradas de C. Todos los jugadores en el juego gráfico G construido en [4] tienen 2 acciones denotadas como 0 y 1. La probabilidad de que V juegue 1 se denota como p[V]. G tiene 3 jugadores Vx, Vy y Vz para los cuales p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto en el cubo unitario. G está diseñado para incentivar a Vx, Vy y Vz a ajustar sus probabilidades en direcciones dadas por una función de Brouwer que está especificada por el circuito C. En un equilibrio de Nash, p[Vx], p[Vy] y p[Vz] representan las coordenadas de un punto fijo de una función que pertenece a la clase de funciones representadas por el BROUWER TRIDIMENSIONAL. Para 1 ≤ i ≤ p(n) introducimos un vértice V (i) C tal que para 1 ≤ j ≤ i, Ij(p[V (i) C ]) es la salida de la compuerta gj; para i < j ≤ p(n), Ij(p[V (i) C ]) es 0. Construye V (i) C a partir de V (i−1) C utilizando el Corolario 2. Sea G(i) el juego gráfico que hace esto. Sea S1(G(i)), . . . , Sn(G(i)) una descomposición de camino de longitud n de G(i), donde V(i−1) ⊂ S1(G(i)) y V(i) ⊂ Sn(G(i)). Luego, se obtiene una descomposición de camino de ∪1≤i≤p(n)G(i) tomando la unión de las descomposiciones de camino separadas, junto con Sn(G(i−1) ) ∪ S1(G(i) ) para 2 ≤ i ≤ p(n). Sea GC el juego gráfico anterior que simula C. GC tiene 3n entradas, que consisten en los primeros n bits de las expansiones binarias de p[Vx], p[Vy] y p[Vz]. De manera similar a [4], la salida de GC afecta a Vx, Vy y Vz de la siguiente manera. El color 0 incentiva a Vx, Vy y Vz 108 a ajustar sus probabilidades p[Vx], p[Vy] y p[Vz] en la dirección (−1, −1, −1); el color 2 los incentiva a moverse en la dirección (1, 0, 0); el color 2, dirección (0, 1, 0); el color 3, dirección (0, 0, 1). Necesitamos asegurarnos de que en los puntos en los límites de los cubitos adyacentes, el cambio de dirección será aproximadamente el promedio de las direcciones de los puntos circundantes. De esta manera, los cuatro colores/direcciones deben estar cerca para que puedan anularse entre sí (y estemos en un vértice pancromático). Esto se logra utilizando el mismo truco que [4], en el cual hacemos un número constante M de copias de GC, que difieren en que cada copia agrega un vector de desplazamiento pequeño a sus copias de p[Vx], p[Vy] y p[Vz] (que se derivan del original utilizando el dispositivo de adición de [7]). Usando los dispositivos de suma y multiplicación de [7], promediamos las direcciones y sumamos un pequeño múltiplo de este promedio a (p[Vx], p[Vy], p[Vz]). En un equilibrio de Nash, las salidas de cada copia se cancelarán mutuamente. El ancho de camino del juego completo es a lo sumo M veces el ancho de camino GC. 8. PROBLEMAS ABIERTOS El problema más importante que queda abierto en este artículo es si es posible encontrar un equilibrio de Nash de un juego gráfico en un <br>árbol de grado acotado</br> en tiempo polinómico. Nuestra construcción muestra que cualquier algoritmo de dos pasadas que almacene explícitamente políticas de puntos de quiebre necesita tiempo y espacio exponenciales. Sin embargo, esto no excluye la existencia de un algoritmo que se base en una idea similar, pero en lugar de calcular la política de punto de ruptura completa para cada vértice, utiliza un pequeño número de pasadas adicionales a través del grafo para decidir qué partes (de tamaño polinómico) de cada política de punto de ruptura deben ser calculadas. En particular, dicho algoritmo puede basarse en el algoritmo de aproximación de [8], donde el valor de es elegido de forma adaptativa. Otra pregunta intrigante está relacionada con el hecho de que el grafo para el cual construimos una política de puntos de quiebre de tamaño exponencial tiene un ancho de camino de 2, mientras que nuestros resultados positivos son para un camino, es decir, un grafo de ancho de camino 1. No está claro si para cualquier grafo de grado acotado con ancho de camino 1, el tiempo de ejecución de nuestro algoritmo (versión basada en política de puntos de interrupción) será polinomial. En particular, resulta instructivo considerar un grafo oruga, es decir, el grafo que se puede obtener a partir de Tn al eliminar los vértices S1, . . . , Sn. Para este gráfico, la mejor política de respuesta de un vértice Vk en la columna vertebral de la oruga se obtiene combinando la mejor política de respuesta de su predecesor en la columna vertebral Vk−1 y su otro hijo Tk; dado que este último es una hoja, su mejor política de respuesta es trivial (es decir, [0, 1]2, [0, 1]×{0} o [0, 1]×{1}) o consiste en dos segmentos horizontales y un segmento vertical de la forma {α}×[0, 1] que los conecta. Suponiendo, para mayor comodidad, que B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, y f es la función de indiferencia para Vk, observamos que la política de mejor respuesta para Vk consta de 5 componentes: ˆf(0), ˆf(1), y tres componentes que corresponden a [0, α]×{0}, {α}×[0, 1], y [α, 1]×{1}. Por lo tanto, se puede pensar en la construcción de B(Vk+1, Vk) como el siguiente proceso: girar B(Vk, Vk−1) en π/2, cortarlo a lo largo de la línea (ahora horizontal) vk = α, aplicar una transformación lineal fraccional a la coordenada horizontal de ambas partes y volver a conectarlas usando la imagen del segmento {α}×[0, 1] bajo f. Esto implica que el problema de acotar el tamaño de la política de mejor respuesta (o, alternativamente, la política de punto de quiebre) se puede ver como una generalización del siguiente problema de geometría computacional, que creemos puede ser de interés independiente: PROBLEMA 1. Dada una colección de segmentos paralelos a los ejes en R2, considera la siguiente operación: elige una línea paralela a los ejes li (ya sea vertical u horizontal), corta el plano a lo largo de esta línea y desplaza una de las dos partes resultantes por una cantidad arbitraria δi; como resultado, algunos segmentos se dividirán en dos partes. Reconecte estas partes, es decir, para cada segmento de la forma [a, b] × {c} que fue transformado en [a, t] × {c + δi} y [t, b] × {c}, introduzca un segmento {t} × [c, c+δi]. ¿Es posible comenzar con el segmento [0, 1] y después de n operaciones obtener un conjunto que no pueda representarse como una unión de poli(n) segmentos de línea? ¿En caso afirmativo, puede ser que en este conjunto no haya un camino con un número polinomial de giros que conecte los extremos del segmento original? Resulta que en general, la respuesta a la primera pregunta es positiva, es decir, después de n pasos, es posible obtener un conjunto que consiste en Θ(cn) segmentos para algún c > 0. Esto implica que incluso para una oruga, la mejor política de respuesta puede ser exponencialmente grande. Sin embargo, en nuestro ejemplo (que se omite en esta versión del documento debido a limitaciones de espacio), existe un camino de tamaño polinómico a través de la política de mejor respuesta, es decir, no demuestra que la política de punto de quiebre sea necesariamente exponencial en tamaño. Si se puede demostrar que esto siempre es cierto, puede ser posible adaptar esta prueba para mostrar que puede haber una brecha exponencial entre los tamaños de las políticas de mejor respuesta y las políticas de punto de quiebre. 9. REFERENCIAS [1] H. Bodlaender y T. Kloks. Algoritmos eficientes y constructivos para el ancho de camino y el ancho de árbol de grafos. Revista de Algoritmos, 21:358-402, 1996. [2] X. Chen y X. Deng. 3-NASH es PPAD-completo. Informe técnico TR-05-134, Coloquio Electrónico en Complejidad Computacional, 2005. [3] X. Chen y X. Deng. Resolviendo la complejidad del equilibrio de Nash de 2 jugadores. Informe técnico TR-05-140, Coloquio Electrónico en Complejidad Computacional, 2005. [4] C. Daskalakis, P. Goldberg y C. Papadimitriou. La complejidad de calcular un equilibrio de Nash. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [5] C. Daskalakis y C. Papadimitriou. Los juegos de tres jugadores son difíciles. Informe técnico TR-05-139, Coloquio Electrónico en Complejidad Computacional, 2005. [6] E. Elkind, L. Goldberg y P. Goldberg. Equilibrios de Nash en juegos gráficos en árboles revisados. Informe técnico TR-06-005, Coloquio Electrónico en Complejidad Computacional, 2006. [7] P. Goldberg y C. Papadimitriou. Reductibilidad entre problemas de equilibrio. En Actas del 38º Simposio de la ACM sobre Teoría de la Computación, 2006. [8] M. Kearns, M. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, 2001. [9] M. Littman, M. Kearns y S. Singh. Un algoritmo exacto eficiente para juegos gráficos de conexión simple. En Actas de la 15ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2001. [10] L. Ortiz y M. Kearns. Propagación de Nash para juegos gráficos con bucles. En Actas de la 17ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2003. [11] C. Papadimitriou. Sobre la complejidad del argumento de paridad y otras demostraciones ineficientes de existencia. J. Comput. This is not a complete sentence. Please provide more context or the full sentence you would like me to translate. Cienc., 48(3):498-532, 1994. 109 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "generic algorithm": {
            "translated_key": "algoritmo genérico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a <br>generic algorithm</br> for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The <br>generic algorithm</br> of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The <br>generic algorithm</br> does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the <br>generic algorithm</br> described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the <br>generic algorithm</br> of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the <br>generic algorithm</br> using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the <br>generic algorithm</br> of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "The first of these papers describes a <br>generic algorithm</br> for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The <br>generic algorithm</br> of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "The <br>generic algorithm</br> does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the <br>generic algorithm</br> described in [8] is in their approach to this issue.",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the <br>generic algorithm</br> of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the <br>generic algorithm</br> using the ideas of [9]."
            ],
            "translated_annotated_samples": [
                "El primero de estos documentos describe un <br>algoritmo genérico</br> para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico.",
                "Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El <br>algoritmo genérico</br> de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas.",
                "El <br>algoritmo genérico</br> no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del <br>algoritmo genérico</br> descritas en [8] radica en su enfoque sobre este tema.",
                "Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del <br>algoritmo genérico</br> de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino).",
                "Podemos mejorar el tiempo de ejecución del <br>algoritmo genérico</br> utilizando las ideas de [9]."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un <br>algoritmo genérico</br> para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El <br>algoritmo genérico</br> de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V. El <br>algoritmo genérico</br> no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del <br>algoritmo genérico</br> descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente. En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta. La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2). Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del <br>algoritmo genérico</br> de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino). Podemos mejorar el tiempo de ejecución del <br>algoritmo genérico</br> utilizando las ideas de [9]. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "response policy": {
            "translated_key": "política de mejor respuesta",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best <br>response policy</br> for V .",
                "The generic algorithm does not address the problem of representing the best <br>response policy</br>; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best <br>response policy</br> for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best <br>response policy</br> can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best <br>response policy</br> for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best <br>response policy</br> for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best <br>response policy</br> for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best <br>response policy</br> for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best <br>response policy</br> for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best <br>response policy</br> for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best <br>response policy</br> for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best <br>response policy</br> for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best <br>response policy</br> for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best <br>response policy</br> for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best <br>response policy</br> for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best <br>response policy</br> during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best <br>response policy</br> (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best <br>response policy</br> of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best <br>response policy</br> is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best <br>response policy</br> for Tn While the best <br>response policy</br> constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best <br>response policy</br> cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best <br>response policy</br> (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best <br>response policy</br> of a vertex Vk in the spine of the caterpillar is obtained by combining the best <br>response policy</br> of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best <br>response policy</br> for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best <br>response policy</br> (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best <br>response policy</br> can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best <br>response policy</br>, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best <br>response policy</br> for V .",
                "The generic algorithm does not address the problem of representing the best <br>response policy</br>; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best <br>response policy</br> for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "To bound the running time of this algorithm, the paper [8] shows that any best <br>response policy</br> can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best <br>response policy</br> for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect."
            ],
            "translated_annotated_samples": [
                "La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la <br>política de mejor respuesta</br> para V.",
                "El algoritmo genérico no aborda el problema de representar la mejor <br>política de respuesta</br>; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema.",
                "El cálculo se realiza de forma inductiva: la <br>política de mejor respuesta</br> para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk.",
                "Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier <br>política de mejor respuesta</br> puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico.",
                "La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la <br>política de mejor respuesta</br> para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la <br>política de mejor respuesta</br> para V. El algoritmo genérico no aborda el problema de representar la mejor <br>política de respuesta</br>; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la <br>política de mejor respuesta</br> para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier <br>política de mejor respuesta</br> puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la <br>política de mejor respuesta</br> para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. ",
            "candidates": [],
            "error": [
                [
                    "política de mejor respuesta",
                    "política de respuesta",
                    "política de mejor respuesta",
                    "política de mejor respuesta",
                    "política de mejor respuesta"
                ]
            ]
        },
        "downstream pass": {
            "translated_key": "paso aguas abajo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the <br>downstream pass</br>; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the <br>downstream pass</br>, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the <br>downstream pass</br> can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the <br>downstream pass</br> is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the <br>downstream pass</br>, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the <br>downstream pass</br>, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the <br>downstream pass</br>, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the <br>downstream pass</br> For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the <br>downstream pass</br> of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a <br>downstream pass</br>. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The <br>downstream pass</br> is identical to the <br>downstream pass</br> of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the <br>downstream pass</br> on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the <br>downstream pass</br> of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the <br>downstream pass</br>; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "In the beginning of the <br>downstream pass</br>, the root selects its strategy and informs its children about its choice.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the <br>downstream pass</br> can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "With the above assumptions about the root, the <br>downstream pass</br> is straightforward: Let W denote the root and V denote its child.",
                "As long as, at each step of the <br>downstream pass</br>, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium."
            ],
            "translated_annotated_samples": [
                "Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el <br>paso descendente</br>; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas.",
                "Al comienzo del <br>paso aguas abajo</br>, la raíz selecciona su estrategia e informa a sus hijos sobre su elección.",
                "La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el <br>pase descendente</br> pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto.",
                "Con las suposiciones anteriores sobre la raíz, el <br>paso aguas abajo</br> es sencillo: Sea W la raíz y V su hijo.",
                "Si, en cada paso de la <br>pasada descendente</br>, el vértice en consideración puede seleccionar un vector de estrategias para todos sus hijos de manera que la estrategia de cada hijo sea una mejor respuesta potencial a la estrategia del padre, el algoritmo logra producir un equilibrio de Nash."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el <br>paso descendente</br>; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V. El algoritmo genérico no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del <br>paso aguas abajo</br>, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama política de puntos de quiebre), y aún así garantizar que el <br>pase descendente</br> pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente. En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta. La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2). Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del algoritmo genérico de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino). Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9]. En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un juego gráfico en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario). Obtenemos el siguiente teorema TEOREMA 1. Existe un algoritmo O(n2) que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un camino de n vértices. Existe un algoritmo O(n3) que calcula una representación de todos los equilibrios de Nash de dicho juego. En la Sección 5 extendemos los resultados de la Sección 4 a grafos de grado 2 en general, obteniendo el siguiente teorema. TEOREMA 2. Existe un algoritmo de tiempo polinómico que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un grafo con grado máximo 2. En la Sección 6 ampliamos nuestro algoritmo para que pueda ser utilizado para encontrar un equilibrio de Nash de un juego gráfico en un árbol arbitrario. Incluso cuando el árbol tiene grado acotado, el tiempo de ejecución puede ser exponencial. Mostramos que esto es inevitable construyendo una familia de juegos gráficos en árboles de grado acotado para los cuales las políticas de mejor respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de dos pasos (es decir, un algoritmo que es similar en espíritu al de [8]) tiene que almacenar casi todos los puntos de las políticas de mejor respuesta. En particular, mostramos lo siguiente. TEOREMA 3. Existe una familia infinita de juegos gráficos en árboles de grado acotado con ancho de camino 2, tal que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales. Es interesante notar que los árboles utilizados en la demostración del Teorema 3 tienen un ancho de camino de 2, es decir, están muy cerca de ser caminos. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico para grafos de ancho de camino 1. Esta pregunta puede ser vista como una generalización de un problema muy natural de geometría computacional; lo describimos con más detalle en la Sección 8. En la Sección 7, presentamos un resultado de intractabilidad teórica de complejidad para el problema de encontrar un equilibrio de Nash de un juego gráfico en un grafo con un ancho de camino pequeño. Demostramos el siguiente teorema. TEOREMA 4. Considera el problema de encontrar un equilibrio de Nash para un juego gráfico en el cual el grafo subyacente tiene un grado máximo de 3 y un ancho de camino k. Existe una constante k tal que este problema es PPAD-completo. El teorema 4 limita la medida en que podemos explotar las propiedades de tipo camino del grafo subyacente para encontrar equilibrios de Nash. Para demostrar el Teorema 4, utilizamos resultados recientes de completitud de PPAD para juegos, en particular los artículos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de grado d (para d ≥ 3) es computacionalmente equivalente al problema de resolver juegos en forma normal de r jugadores (para r ≥ 4), ambos de los cuales son PPAD-completos. CONSIDERACIONES PREVIAS Y NOTACIÓN Consideramos juegos gráficos en los que el grafo subyacente G es un árbol de n vértices. Cada vértice tiene dos acciones, que se denotan como 0 y 1. Una estrategia mixta se define por un único número x ∈ [0, 1], que indica la probabilidad de que el jugador seleccione la acción 1. Para los propósitos del algoritmo, el árbol está enraizado de manera arbitraria. Para mayor comodidad, asumimos sin pérdida de generalidad que la raíz tiene un solo hijo y que su recompensa es independiente de la acción elegida por el hijo. Esto se puede lograr primero eligiendo una raíz arbitraria del árbol, y luego agregando un padre ficticio de esta raíz, asignándole una función de pago constante. Dado un borde (V, W) del árbol G, y una estrategia mixta w para W, sea G(V,W), W=w la instancia obtenida de G mediante (1) eliminar todos los nodos Z que están separados de V por W (es decir, todos los nodos Z tales que el camino de Z a V pasa por W), y (2) restringir la instancia de modo que se requiera que W juegue la estrategia mixta w. Definición 1. Supongamos que (V, W) es un borde del árbol, que v es una estrategia mixta para V y que w es una estrategia mixta para W. Decimos que v es una mejor respuesta potencial para w (indicado por v ∈ pbrV(w)) si hay un equilibrio en la instancia G(V, W), W = w en el que V tiene la estrategia mixta v. Definimos la política de mejor respuesta para V, dada W, como B(W, V) = {(w, v) | v ∈ pbrV(w), w ∈ [0, 1]}. Normalmente, W es el padre de V, y esto se conoce simplemente como la política de mejor respuesta para V. La expresión B(W, V )|V =v se utiliza para denotar el conjunto B(W, V ) ∩ [0, 1]×{v}. El paso ascendente del algoritmo genérico de [8] calcula la política de mejor respuesta para V en cada nodo V que no sea la raíz. Con las suposiciones anteriores sobre la raíz, el <br>paso aguas abajo</br> es sencillo: Sea W la raíz y V su hijo. La raíz selecciona cualquier par (w, v) de B(W, V). Decide jugar con la estrategia mixta w e instruye a V a jugar con la estrategia mixta v. El resto del paso descendente es recursivo. Cuando un nodo V recibe instrucciones de su padre para adoptar la estrategia mixta v, hace lo siguiente para cada hijo U: encuentra un par (v, u) ∈ B(V, U) (con el mismo valor de v que le fue dado por su padre) e instruye a U a jugar u. ALGORITMO DE LITTMAN ET AL. El algoritmo de [9] se basa en la siguiente observación: para calcular un equilibrio de Nash único mediante un algoritmo de dos pasos, no es necesario construir la política de mejor respuesta completa para cada vértice. Si, en cada paso de la <br>pasada descendente</br>, el vértice en consideración puede seleccionar un vector de estrategias para todos sus hijos de manera que la estrategia de cada hijo sea una mejor respuesta potencial a la estrategia del padre, el algoritmo logra producir un equilibrio de Nash. ",
            "candidates": [],
            "error": [
                [
                    "paso descendente",
                    "paso aguas abajo",
                    "pase descendente",
                    "paso aguas abajo",
                    "pasada descendente"
                ]
            ]
        },
        "breakpoint policy": {
            "translated_key": "política de puntos de quiebre",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a <br>breakpoint policy</br>), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a <br>breakpoint policy</br>) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the <br>breakpoint policy</br> in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A <br>breakpoint policy</br> for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a <br>breakpoint policy</br> has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its <br>breakpoint policy</br> with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a <br>breakpoint policy</br> for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding <br>breakpoint policy</br>.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a <br>breakpoint policy</br> for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a <br>breakpoint policy</br> (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a <br>breakpoint policy</br> such as the one in Figure 3.",
                "Note that this <br>breakpoint policy</br> ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the <br>breakpoint policy</br> for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of <br>breakpoint policy</br> (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a <br>breakpoint policy</br> may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a <br>breakpoint policy</br> as defined in [9], we show how to modify this definition so as to ensure that a <br>breakpoint policy</br> always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A <br>breakpoint policy</br> ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a <br>breakpoint policy</br> is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid <br>breakpoint policy</br> ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid <br>breakpoint policy</br> instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid <br>breakpoint policy</br> ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a <br>breakpoint policy</br>) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid <br>breakpoint policy</br>. 6.1 Exponential Size <br>breakpoint policy</br> While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size <br>breakpoint policy</br>.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: <br>breakpoint policy</br> for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire <br>breakpoint policy</br> for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each <br>breakpoint policy</br> should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized <br>breakpoint policy</br> has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the <br>breakpoint policy</br>), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the <br>breakpoint policy</br> is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a <br>breakpoint policy</br>), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a <br>breakpoint policy</br>) which covers every possible w ∈ [0, 1].",
                "In [9], it is suggested that we can select the <br>breakpoint policy</br> in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A <br>breakpoint policy</br> for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "We say such a <br>breakpoint policy</br> has t − 1 breakpoints."
            ],
            "translated_annotated_samples": [
                "La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama <br>política de puntos de quiebre</br>), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto.",
                "Esto se puede lograr si, al comienzo del paso aguas abajo, tenemos una estructura de datos en la que cada vértice V con padre W almacena un conjunto ˆB(W, V ) ⊆ B(W, V ) (llamado una <br>política de puntos de quiebre</br>) que cubre cada posible w ∈ [0, 1].",
                "En [9], se sugiere que podemos seleccionar la <br>política de punto de quiebre</br> de una manera particular.",
                "Es decir, el documento utiliza la siguiente definición: Definición 2. (cf. [9]) Una <br>política de puntos de ruptura</br> para un nodo V con padre W consiste en un conjunto ordenado de puntos de ruptura de W, w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 y un conjunto asociado de valores de V, v1, . . . , vt.",
                "Decimos que una <br>política de punto de quiebre</br> tiene t - 1 puntos de quiebre."
            ],
            "translated_text": "Equilibrios de Nash en Juegos Gráficos en Árboles Revisitados ∗ Edith Elkind Universidad de Warwick Coventry, CV4 7AL, Reino Unido Leslie Ann Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido Paul Goldberg Universidad de Warwick Coventry, CV4 7AL, Reino Unido RESUMEN Los juegos gráficos han sido propuestos como un modelo teórico de juegos de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande y el grafo subyacente tiene un bajo grado, proporcionan una forma concisa de representar las ganancias de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico de grado-3 con dos acciones por jugador es completo para la clase de complejidad PPAD, lo que indica que es poco probable que exista algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de juegos gráficos con dos acciones por jugador en árboles de grado acotado. Este escenario fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo basado en programación dinámica que calcula todos los equilibrios de Nash de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular eficientemente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en tiempo polinómico. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns y otros, y calcula todos los equilibrios de Nash en tiempo cuadrático si el grafo de entrada es un camino, y en tiempo polinómico si es un grafo arbitrario de grado máximo 2. Además, nuestro algoritmo se puede utilizar para calcular equilibrios de Nash de juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol tiene grado acotado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará tiempo exponencial, incluso en árboles de grado acotado con un ancho de camino de 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en grafos con ancho de camino 1, pero demostramos que encontrar un equilibrio de Nash para un juego gráfico de 2 acciones en el que el grafo subyacente tiene grado máximo 3 y ancho de camino constante es PPAD-completo (por lo que es poco probable que sea tratable). Categorías y Descriptores de Asignaturas F.2 [Teoría de la Computación]: Análisis de Algoritmos y Complejidad de Problemas; J.4 [Aplicaciones Informáticas]: Ciencias Sociales y del Comportamiento - Economía Términos Generales Algoritmos, Economía, Teoría 1. INTRODUCCIÓN Los juegos gráficos fueron introducidos en los artículos de Kearns et al. [8] y Littman et al. [9] como una representación concisa de juegos con un gran número de jugadores. La forma normal clásica (o forma matricial) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un grafo subyacente G, y la ganancia para ese jugador es una función de las acciones elegidas por él mismo y sus vecinos en G; si G tiene un grado bajo, esta es una forma concisa de representar un juego con muchos jugadores. Los artículos [8, 9] presentan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula aproximaciones a todos los equilibrios de Nash en tiempo polinómico en el tamaño de la entrada y la calidad de la aproximación, o como un algoritmo de tiempo exponencial que permite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en tiempo polinómico. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil. 1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el paso ascendente y el paso descendente; el primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se asume que cada jugador tiene dos estrategias puras (acciones), que se denotan como 0 y 1; se sigue que cualquier estrategia mixta puede ser representada como un único número x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el paso ascendente, cada vértice V calcula el conjunto de sus posibles mejores respuestas a cada estrategia mixta w de su padre W; una estrategia v es una posible mejor respuesta a w si 1. Cabe destacar que la terminología ascendente y descendente está invertida en [8, 9] - nuestros árboles tienen la raíz en la parte superior. 100 hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega w (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una tabla (continua) T(w, v), donde T(w, v) = 1 si y solo si v es una mejor respuesta potencial a w; nos referimos a esta tabla como la política de mejor respuesta para V. El algoritmo genérico no aborda el problema de representar la mejor política de respuesta; de hecho, la diferencia más importante entre las dos instanciaciones del algoritmo genérico descritas en [8] radica en su enfoque sobre este tema. El cálculo se realiza de forma inductiva: la política de mejor respuesta para V se calcula en función de las políticas de mejor respuesta de los hijos de V, U1, . . . , Uk. Al final del paso ascendente, todos los hijos de la raíz han calculado sus políticas de mejor respuesta. Al comienzo del paso aguas abajo, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo avance es que la estrategia de la raíz sea una mejor respuesta a las estrategias de sus hijos y, para cada hijo, la estrategia elegida sea una de las mejores respuestas potenciales precalculadas a la estrategia elegida de la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando las acciones de sus hijos. La acción del niño se elige como cualquier estrategia de las mejores respuestas potenciales precalculadas a la estrategia elegida por el padre. Para acotar el tiempo de ejecución de este algoritmo, el artículo [8] muestra que cualquier política de mejor respuesta puede ser representada como una unión de un número exponencial de rectángulos; el algoritmo de aproximación de tiempo polinómico se obtiene combinando esta representación con una cuadrícula de tamaño polinómico. La idea principal de [9] es que no es necesario hacer un seguimiento de todos los rectángulos en las políticas de mejor respuesta; en cambio, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinómico de la política correspondiente (en [9], este subconjunto se llama <br>política de puntos de quiebre</br>), y aún así garantizar que el pase descendente pueda proceder con éxito (una condición suficiente para esto es que el subconjunto de la política de mejor respuesta para V almacenada por el algoritmo contenga un camino continuo desde w = 0 hasta w = 1). 1.2 Nuestros Resultados Una de las principales contribuciones de nuestro artículo es demostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] produce un vector de estrategias que no constituye un equilibrio de Nash del juego subyacente. En las Secciones 4, 5 y 6 mostramos cómo corregir el algoritmo de [9] para que siempre produzca la salida correcta. La sección 4 considera el caso en el que el grafo subyacente es un camino de longitud n. Para este caso, demostramos que el número de rectángulos en cada una de las políticas de mejor respuesta es O(n2). Esto nos proporciona un algoritmo O(n3) para encontrar un equilibrio de Nash y para calcular una representación de todos los equilibrios de Nash. (Este algoritmo es un caso especial del algoritmo genérico de [8] - demostramos que se ejecuta en tiempo polinómico cuando el grafo subyacente es un camino). Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9]. En particular, presentamos un algoritmo O(n2) para encontrar un equilibrio de Nash de un juego gráfico en un camino de longitud n. En lugar de almacenar políticas de mejor respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, siguiendo [9], llamamos políticas de puntos de quiebre (modificando la definición según sea necesario). Obtenemos el siguiente teorema TEOREMA 1. Existe un algoritmo O(n2) que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un camino de n vértices. Existe un algoritmo O(n3) que calcula una representación de todos los equilibrios de Nash de dicho juego. En la Sección 5 extendemos los resultados de la Sección 4 a grafos de grado 2 en general, obteniendo el siguiente teorema. TEOREMA 2. Existe un algoritmo de tiempo polinómico que encuentra un equilibrio de Nash de un juego gráfico con dos acciones por jugador en un grafo con grado máximo 2. En la Sección 6 ampliamos nuestro algoritmo para que pueda ser utilizado para encontrar un equilibrio de Nash de un juego gráfico en un árbol arbitrario. Incluso cuando el árbol tiene grado acotado, el tiempo de ejecución puede ser exponencial. Mostramos que esto es inevitable construyendo una familia de juegos gráficos en árboles de grado acotado para los cuales las políticas de mejor respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de dos pasos (es decir, un algoritmo que es similar en espíritu al de [8]) tiene que almacenar casi todos los puntos de las políticas de mejor respuesta. En particular, mostramos lo siguiente. TEOREMA 3. Existe una familia infinita de juegos gráficos en árboles de grado acotado con ancho de camino 2, tal que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales. Es interesante notar que los árboles utilizados en la demostración del Teorema 3 tienen un ancho de camino de 2, es decir, están muy cerca de ser caminos. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico para grafos de ancho de camino 1. Esta pregunta puede ser vista como una generalización de un problema muy natural de geometría computacional; lo describimos con más detalle en la Sección 8. En la Sección 7, presentamos un resultado de intractabilidad teórica de complejidad para el problema de encontrar un equilibrio de Nash de un juego gráfico en un grafo con un ancho de camino pequeño. Demostramos el siguiente teorema. TEOREMA 4. Considera el problema de encontrar un equilibrio de Nash para un juego gráfico en el cual el grafo subyacente tiene un grado máximo de 3 y un ancho de camino k. Existe una constante k tal que este problema es PPAD-completo. El teorema 4 limita la medida en que podemos explotar las propiedades de tipo camino del grafo subyacente para encontrar equilibrios de Nash. Para demostrar el Teorema 4, utilizamos resultados recientes de completitud de PPAD para juegos, en particular los artículos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de grado d (para d ≥ 3) es computacionalmente equivalente al problema de resolver juegos en forma normal de r jugadores (para r ≥ 4), ambos de los cuales son PPAD-completos. CONSIDERACIONES PREVIAS Y NOTACIÓN Consideramos juegos gráficos en los que el grafo subyacente G es un árbol de n vértices. Cada vértice tiene dos acciones, que se denotan como 0 y 1. Una estrategia mixta se define por un único número x ∈ [0, 1], que indica la probabilidad de que el jugador seleccione la acción 1. Para los propósitos del algoritmo, el árbol está enraizado de manera arbitraria. Para mayor comodidad, asumimos sin pérdida de generalidad que la raíz tiene un solo hijo y que su recompensa es independiente de la acción elegida por el hijo. Esto se puede lograr primero eligiendo una raíz arbitraria del árbol, y luego agregando un padre ficticio de esta raíz, asignándole una función de pago constante. Dado un borde (V, W) del árbol G, y una estrategia mixta w para W, sea G(V,W), W=w la instancia obtenida de G mediante (1) eliminar todos los nodos Z que están separados de V por W (es decir, todos los nodos Z tales que el camino de Z a V pasa por W), y (2) restringir la instancia de modo que se requiera que W juegue la estrategia mixta w. Definición 1. Supongamos que (V, W) es un borde del árbol, que v es una estrategia mixta para V y que w es una estrategia mixta para W. Decimos que v es una mejor respuesta potencial para w (indicado por v ∈ pbrV(w)) si hay un equilibrio en la instancia G(V, W), W = w en el que V tiene la estrategia mixta v. Definimos la política de mejor respuesta para V, dada W, como B(W, V) = {(w, v) | v ∈ pbrV(w), w ∈ [0, 1]}. Normalmente, W es el padre de V, y esto se conoce simplemente como la política de mejor respuesta para V. La expresión B(W, V )|V =v se utiliza para denotar el conjunto B(W, V ) ∩ [0, 1]×{v}. El paso ascendente del algoritmo genérico de [8] calcula la política de mejor respuesta para V en cada nodo V que no sea la raíz. Con las suposiciones anteriores sobre la raíz, el paso aguas abajo es sencillo: Sea W la raíz y V su hijo. La raíz selecciona cualquier par (w, v) de B(W, V). Decide jugar con la estrategia mixta w e instruye a V a jugar con la estrategia mixta v. El resto del paso descendente es recursivo. Cuando un nodo V recibe instrucciones de su padre para adoptar la estrategia mixta v, hace lo siguiente para cada hijo U: encuentra un par (v, u) ∈ B(V, U) (con el mismo valor de v que le fue dado por su padre) e instruye a U a jugar u. ALGORITMO DE LITTMAN ET AL. El algoritmo de [9] se basa en la siguiente observación: para calcular un equilibrio de Nash único mediante un algoritmo de dos pasos, no es necesario construir la política de mejor respuesta completa para cada vértice. Si, en cada paso de la pasada descendente, el vértice en consideración puede seleccionar un vector de estrategias para todos sus hijos de manera que la estrategia de cada hijo sea una mejor respuesta potencial a la estrategia del padre, el algoritmo logra producir un equilibrio de Nash. Esto se puede lograr si, al comienzo del paso aguas abajo, tenemos una estructura de datos en la que cada vértice V con padre W almacena un conjunto ˆB(W, V ) ⊆ B(W, V ) (llamado una <br>política de puntos de quiebre</br>) que cubre cada posible w ∈ [0, 1]. Mostraremos más adelante que una condición suficiente para la construcción de una estructura de datos así es la invariante de que, en cada nivel del paso ascendente, ˆB(W, V) contiene un camino continuo desde w = 0 hasta w = 1. En [9], se sugiere que podemos seleccionar la <br>política de punto de quiebre</br> de una manera particular. Es decir, el documento utiliza la siguiente definición: Definición 2. (cf. [9]) Una <br>política de puntos de ruptura</br> para un nodo V con padre W consiste en un conjunto ordenado de puntos de ruptura de W, w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 y un conjunto asociado de valores de V, v1, . . . , vt. La interpretación es que para cualquier w ∈ [0, 1], si wi−1 < w < wi para algún índice i y W juega w, entonces V deberá jugar vi; y si w = wi para algún índice i, entonces V deberá jugar cualquier valor entre vi y vi+1. Decimos que una <br>política de punto de quiebre</br> tiene t - 1 puntos de quiebre. ",
            "candidates": [],
            "error": [
                [
                    "política de puntos de quiebre",
                    "política de puntos de quiebre",
                    "política de punto de quiebre",
                    "política de puntos de ruptura",
                    "política de punto de quiebre"
                ]
            ]
        }
    }
}