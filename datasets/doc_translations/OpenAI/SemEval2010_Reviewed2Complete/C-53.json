{
    "id": "C-53",
    "original_text": "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R. China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG). Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG. However, DR cannot maintain high consistency, and this constrains its application in highly interactive games. With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency. In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented. Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications. General Terms Algorithms, Performance, Experimentation. 1. INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures. In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2]. These games are referred to as Continuous Distributed Multiplayer Games (CDMG). Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay. Although new network techniques (e.g. QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3]. There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7]. In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc. In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches. Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications. It synchronizes the physical clocks of all sites in a system. After an operation is issued at local site, it delays the execution of the operation for a short time. During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time. In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state. Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites. Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited. DR is based on state transmission mechanism. In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities). After each update of its own entities, a site compares the accurate state with the estimated one. If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected. Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates. Compared with aforementioned local lag, DR cannot maintain high consistency. Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update. In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates. Detailed description of GS-DR can be found in Section 3. When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure. Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8]. In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR. The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2. CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain. Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g. DR). Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well. Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t). DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites. Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent. Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites. De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point. If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2. If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period. If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4. If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities). Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3. INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update. The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency. Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8]. After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system. By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency. Before inconsistency is caused by two reasons. The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold. The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update. Figure 1. The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity. To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity. Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0. Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same. At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0. Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold. At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j. The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp. At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity. Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again. From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2. D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4. GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency. In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency. In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity. In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site. At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters). Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate. Remote site keep only one state Sremote, which is the real state of the entity at remote site. Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0). In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock). Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time. Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time. After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time. At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal. Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote. After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold. If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate. Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps. At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates. If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote. After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal. That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago. Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately. The aforementioned is the basic mechanism of GS-DR-LL. In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites. Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL. All conditions are the same with the conditions used in the aforementioned example describing GS-DR. Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description. At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0. By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j. At time point t2, the state update is received by remote site j. Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately. The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL. Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR. If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0). In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used. Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency. Figure 2. The paths of a shared entity by using GS-DR and GS-DR-LL. To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered. According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task. For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5]. Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value. Else n can be set in terms of the effects of local lag on the interaction of a system [14]. In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag. In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency. Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system. However GS-DR-LL allows n to be smaller than typical network transmission delay. In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5. PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1]. Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams. If a spaceship is hit by a laser beam, its life points decrease one. If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game. In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site. In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value. The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays. Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees. Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories. In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used. In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used. Therefore the total number of settings used in the evaluation was 12 (2 × 6). The procedure of performance evaluation was composed of three steps. In the first step, two participants were employed to play the game, and the operation sequences were recorded. Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected. In the second step, the physical clocks of the two computers were synchronized first. Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move. Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple. Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24. In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel. Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple. The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)). In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results. Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms. It can been seen that inconsistency does exist, but in most of the time it is 0. Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold. Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0. With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency. It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3. Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4. Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5. Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms. Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms. It can be seen that with GS-DR-LL before inconsistency decreases with the lag. In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system. From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay. The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6. Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7. Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8. Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6. CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game. In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene. Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. GS-DR-LL has significant implications to consistency maintenance approaches. First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency. As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games). Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used. As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g. Internet based games). 7. REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications. IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W. Supporting Continuous Consistency in Multiplayer Online Games. In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games. In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment. Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C. On the Impact of Delay on RealTime Multiplayer Games. In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P. Effect of Latency on Presence in Stressful Virtual Environments. In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W. Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization. In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A. Accuracy in Dead-Reckoning based Distributed Multi-Player Games. In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A. From Causal Consistency to Sequential Consistency in Shared Memory Systems. In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory. In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects. ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems. ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V. Is 100 Milliseconds too Fast. In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C. Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System. Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C. Echo: a Method to Improve the Interaction Quality of CVEs. In Proc. of IEEE VR, 2005, 269-270. The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7",
    "original_translation": "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la distorsión temporal para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada. DR se basa en el mecanismo de transmisión del estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado. Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres. A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas. Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia. Debido al retraso en la transmisión de la red, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado. Para mantener una alta consistencia en la replicación distribuida (DR), Aggarwal et al [8] propusieron la Replicación Distribuida Globalmente Sincronizada (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega marcas de tiempo a las actualizaciones de estado transmitidas. La descripción detallada de GS-DR se puede encontrar en la Sección 3. Cuando hay una actualización de estado disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización de estado a los sitios remotos, lo que provoca que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión. Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar la inconsistencia anterior [8]. En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, GS-DR-LL puede lograr una mayor consistencia que GS-DR. El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona GS-DR-LL; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento. DEFINICIONES Y MÉTRICAS DE CONSISTENCIA La consistencia de aplicaciones replicadas ya ha sido bien definida en el dominio discreto [9, 10, 11, 12], pero se ha realizado poco trabajo relacionado en el dominio continuo. Mauve et al [1] han proporcionado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operaciones y resulta difícil que describa métodos basados en la transmisión de estado (por ejemplo, Lo siento, pero no puedo traducir \"DR).\" ya que no es una oración completa en inglés. ¿Hay algo más en lo que pueda ayudarte a traducir al español? Aquí presentamos una definición alternativa de consistencia en un dominio continuo, que se adapta bien a los métodos basados en la transmisión de estado. Dado dos sitios distintos i y j, que han replicado una entidad compartida e, en un tiempo dado t, los estados de e en los sitios i y j son Si(t) y Sj(t). DEFINICIÓN 1: los estados de e en los sitios i y j son consistentes en el tiempo t, si: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINICIÓN 2: los estados de e en los sitios i y j son consistentes entre los tiempos t1 y t2 (t1 < t2), si: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) En este artículo, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre sitios locales y remotos. Debido al retraso en la transmisión de la red, es difícil mantener los estados de las entidades compartidas absolutamente consistentes. Se necesitan métricas correspondientes para medir la consistencia de las entidades compartidas entre sitios locales y remotos. De(i, j, t) se puede utilizar como una métrica para medir el grado de consistencia en un momento específico. Si De(i, j, t1) > De(i, j, t2), se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e en el punto de tiempo t1 es menor que en el punto de tiempo t2. Si De(i, j, t) > De(l, k, t), se puede afirmar que, en el momento t, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. De manera similar, De(i, j, t1, t2) puede ser utilizada como una métrica para medir el grado de consistencia en un cierto período de tiempo. Si De(i, j, t1, t2) > De(i, j, t3, t4) y |t1 - t2| = |t3 - t4|, se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e entre los puntos temporales t1 y t2 es menor que entre los puntos temporales t3 y t4. Si De(i, j, t1, t2) > De(l, k, t1, t2), se puede afirmar que entre los puntos temporales t1 y t2, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. En DR, los estados de las entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades). Dadas dos ubicaciones distintas i y j, que han replicado una entidad compartida e, en un momento dado t, las posiciones de e en los sitios i y j son (xit, yit, zit) y (xjt, yjt, zjt), De(i, j, t) y D(i, j, t1, t2) podrían calcularse como: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se utilizan como métricas para medir la consistencia de las entidades compartidas entre sitios locales y remotos. 3. La inconsistencia en DR se puede dividir en dos secciones según el momento en que un sitio remoto recibe una actualización de estado. La inconsistencia antes de que un sitio remoto reciba una actualización de estado se conoce como inconsistencia antes, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se conoce como inconsistencia después. Antes de la inconsistencia y después de la inconsistencia son similares a los términos antes del error de exportación y después del error de exportación [8]. La inconsistencia se produce por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema. Al emplear la sincronización de relojes físicos, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior. La inconsistencia se produce por dos razones. La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el estado preciso y el estimado sea mayor que un umbral predefinido. La segunda razón es el retraso en la transmisión de la red, ya que una entidad compartida solo puede sincronizarse después de que los sitios remotos reciban la actualización de estado correspondiente. Figura 1. Los caminos de una entidad compartida mediante el uso de GS-DR. Por ejemplo, se asume que la velocidad de una entidad compartida es el único parámetro para predecir la posición de la entidad, y la posición actual de la entidad se puede calcular a partir de su última posición y la velocidad actual. Para simplificar la descripción, también se asume que solo hay dos sitios i y j en una sesión de juego, donde el sitio i actúa como sitio local del 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 y el sitio j actúa como sitio remoto, y t1 es el momento en que el sitio local actualiza el estado de la entidad compartida. La Figura 1 ilustra los caminos de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR. Al principio, las posiciones de la entidad compartida son las mismas en los sitios i y j y la velocidad de la entidad compartida es 0. Antes del momento t0, los caminos de la entidad compartida en los sitios i y j en la coordenada x son exactamente iguales. En el instante t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad en el eje x a v0. El sitio primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, que en este caso es 0, es mayor que un umbral predefinido. En el momento t1, el sitio i encuentra que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j. La actualización del estado contiene la posición y la velocidad de la entidad compartida en el momento t1 y el momento t1 también se adjunta como una marca de tiempo. En el instante de tiempo t2, la actualización del estado llega al sitio j, y el estado recibido y la desviación de tiempo entre los instantes t1 y t2 se utilizan para calcular la posición actual de la entidad compartida. Luego, el sitio j actualiza la posición y la velocidad de su entidad replicada, y las trayectorias de la entidad compartida en los sitios i y j se superponen nuevamente. A partir de la Figura 1, se puede observar que la inconsistencia posterior es 0, y la consistencia anterior está compuesta por dos partes, D1 y D2. D1 es De(i, j, t0, t1) y es causado por el mecanismo de filtrado de estado de DR. D2 es De(i, j, t1, t2) y es causado por el retraso de transmisión de red. 4. SINCRONIZACIÓN GLOBAL DE DR CON RETRASO LOCAL. A partir del análisis en la Sección 3, se puede observar que GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar eficazmente la inconsistencia anterior. Para disminuir la inconsistencia previa, proponemos GS-DR-LL, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa. En GS-DR-LL, el estado de una entidad compartida en un cierto momento t se nota como S = (t, pos, par 1, par 2, ……, par n), en el que pos significa la posición de la entidad y par 1 a par n significa los parámetros para calcular la posición de la entidad. Para simplificar la descripción de GS-DR-LL, se asume que solo hay una entidad compartida y un sitio remoto. Al comienzo de una sesión de juego, los estados de la entidad compartida son iguales en los sitios locales y remotos, con la misma posición p0 y parámetros pars0 (pars representa todos los parámetros). El sitio local mantiene tres estados: el estado real de la entidad Sreal, el estado predicho en el sitio remoto Sp-remote, y el estado más reciente actualizado en el sitio remoto Slate. El sitio remoto mantiene solo un estado Sremoto, que es el estado real de la entidad en el sitio remoto. Por lo tanto, al comienzo de una sesión de juego Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0). En GS-DR-LL, se asume que los relojes físicos de todos los sitios están sincronizados con una desviación de menos de 50 ms (utilizando NTP o reloj GPS). Además, es necesario hacer correcciones a un reloj físico de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo. Además, se asume que la escena del juego se actualiza a una frecuencia fija y T representa el intervalo de tiempo entre dos actualizaciones consecutivas, por ejemplo, si la frecuencia de actualización de la escena es de 50 Hz, T sería de 20 ms. n representa el valor de retraso utilizado por el retraso local, y t representa el tiempo físico actual. Después de actualizar la escena, el sitio local espera durante un tiempo constante T. Durante este período de tiempo, el sitio local recibe las operaciones del jugador y las almacena en una lista L. Todas las operaciones en L están ordenadas por su tiempo de emisión. Al final del período de tiempo T, el sitio local ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - T y t, en Slate para obtener el nuevo Slate, y también ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - (n + T) y t - n, en Sreal para obtener el nuevo Sreal. Además, el sitio local utiliza Sp-remote y métodos de predicción correspondientes para estimar el nuevo Sp-remote. Después de calcular los nuevos Slate, Sreal y Sp-remote, el sitio local compara si la diferencia entre el nuevo Slate y Spremote supera el umbral predefinido. Si SÍ, el sitio local envía un nuevo Slate al sitio remoto y Sp-remote se actualiza con el nuevo Slate. Ten en cuenta que la marca de tiempo de la actualización de estado enviada es t. Después de eso, el sitio local utiliza Sreal para actualizar la escena local y elimina las operaciones cuyo tiempo de emisión sea menor que t - n, de L. Después de actualizar la escena, el sitio remoto espera una cantidad constante de tiempo T. Durante este período de tiempo, el sitio remoto almacena las actualizaciones de estado recibidas en una lista R. Todas las actualizaciones de estado en R están ordenadas por sus marcas de tiempo. Al final del período de tiempo T, el sitio remoto verifica si R contiene actualizaciones de estado cuyas marcas de tiempo son menores que t - n. Tenga en cuenta que t es el tiempo físico actual y aumenta durante la transmisión de las actualizaciones de estado. Si es afirmativo, utiliza estas actualizaciones de estado y los métodos de predicción correspondientes para calcular el nuevo Sremoto; de lo contrario, utilizan Sremoto y los métodos de predicción correspondientes para estimar el nuevo Sremoto. Después de eso, el sitio local utiliza Sremote para actualizar la escena local y elimina las actualizaciones de estado cuyas marcas de tiempo son menores que t - n, de R. A partir de la descripción anterior, se puede ver que la principal diferencia entre GS-DR y GS-DR-LL es que GS-DR-LL utiliza las operaciones cuyo tiempo de emisión es menor que t - n para calcular Sreal. Eso significa que la escena vista por el jugador local es el resultado de las operaciones emitidas un período de tiempo (es decir, n) atrás. Mientras tanto, si los resultados de las operaciones emitidas hacen que la diferencia entre Slate y Sp-remote exceda un umbral predefinido, las actualizaciones de estado correspondientes se envían a los sitios remotos de inmediato. Lo mencionado es el mecanismo básico de GS-DR-LL. En el caso de múltiples entidades compartidas y sitios remotos, el sitio local calcula Slate, Sreal y Sp-remote para diferentes entidades compartidas respectivamente. Si hay varios Slate que deben ser transmitidos, el sitio local los empaqueta en una actualización de estado y luego los envía a todos los sitios remotos. La Figura 2 ilustra los caminos de una entidad compartida en el sitio local y en el sitio remoto al utilizar GS-DR y GS-DR-LL. Todas las condiciones son las mismas que las condiciones utilizadas en el ejemplo mencionado que describe GS-DR. Comparado con t1, t2 y n, T (es decir, el intervalo de tiempo entre dos actualizaciones consecutivas) es bastante pequeño y se ignora en la siguiente descripción. En el momento t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad de la entidad compartida de 0 a v0. Al utilizar GS-DR-LL, los resultados de la operación se actualizan en la escena local en el momento t0 + n. Sin embargo, la operación se utiliza inmediatamente para calcular Slate, por lo tanto, a pesar de GS-DR o GS-DR-LL, en el momento t1 el sitio i encuentra que la diferencia entre la posición precisa y la estimada es mayor que el umbral y envía una actualización de estado al sitio j. En el momento t2, la actualización del estado es recibida por el sitio remoto j. Suponiendo que la marca de tiempo de la actualización del estado es menor que t - n, el sitio j la utiliza para actualizar la escena local inmediatamente. En el 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006, con GS-DR, el período de tiempo antes de la inconsistencia es (t2 - t1) + (t1 - t0), mientras que disminuye a (t2 - t1 - n) + (t1 - t0) con la ayuda de GS-DR-LL. Ten en cuenta que t2 - t1 es causado por el retraso de transmisión de la red y t1 - t0 es causado por el mecanismo de filtrado de estado de DR. Si n es mayor que t2 - t1, GS-DR-LL puede eliminar la inconsistencia anterior causada por el retraso de transmisión de red, pero no puede eliminar la inconsistencia anterior causada por el mecanismo de filtrado de estado de DR (a menos que el umbral se establezca en 0). En juegos altamente interactivos, que requieren alta consistencia y podrían emplear GS-DR-LL, los resultados de las operaciones son bastante difíciles de estimar y se debe usar un umbral pequeño. Por lo tanto, en la práctica, la mayoría de las inconsistencias anteriores son causadas por el retraso en la transmisión de la red y GS-DR-LL tiene la capacidad de eliminar dichas inconsistencias anteriores. Figura 2. Los caminos de una entidad compartida utilizando GS-DR y GS-DR-LL. Para GS-DR-LL, la selección del valor de retardo n es muy importante, y tanto el retardo de transmisión de red como los efectos del retardo local en la interacción deben ser considerados. Según los resultados de investigaciones relacionadas con la Interacción Humano-Computadora (HCI), los humanos no pueden percibir el retraso impuesto en un sistema cuando es menor que un valor específico, y este valor específico depende tanto del sistema como de la tarea. Por ejemplo, en una interfaz gráfica de usuario, un retraso de aproximadamente 150 ms no puede ser percibido para la interacción con el teclado y el umbral se incrementa a 195 ms para la interacción con el ratón [13], y un retraso de hasta 50 ms es poco crítico para un juego de carreras de coches [5]. Por lo tanto, si el retraso de transmisión de la red es menor que el valor específico de un sistema de juego, n puede establecerse en el valor específico. La variable n puede ser establecida en términos de los efectos del rezago local en la interacción de un sistema [14]. En el caso de que se deba utilizar un n grande, algunos métodos de HCI (por ejemplo, eco [15]) pueden ser utilizados para aliviar los efectos negativos del gran retardo. En el caso de que n sea mayor que el retraso de transmisión de la red, GS-DR-LL puede eliminar la mayoría de las inconsistencias antes. La solicitud de retraso local tradicional requiere que el valor de retraso sea mayor que el retraso típico de transmisión de red, de lo contrario las reparaciones del estado inundarían el sistema. Sin embargo, GS-DR-LL permite que n sea menor que el retraso de transmisión de red típico. En este caso, la inconsistencia previa causada por el retraso en la transmisión de la red todavía existe, pero puede ser disminuida. 5. EVALUACIÓN DEL RENDIMIENTO Para evaluar GS-DR-LL y compararlo con GS-DR en una aplicación real, implementamos ambos métodos en un juego en red llamado spaceship [1]. Spaceship es un juego de computadora en red muy simple, en el cual los jugadores pueden controlar sus naves espaciales para acelerar, desacelerar, girar y disparar a las naves espaciales controladas por otros jugadores remotos con rayos láser. Si una nave espacial es alcanzada por un rayo láser, sus puntos de vida disminuyen en uno. Si los puntos de vida de una nave espacial disminuyen a 0, la nave espacial se elimina del juego y el jugador que la controla pierde el juego. En nuestra implementación práctica, GS-DR-LL y GS-DR coexistieron en el sistema de juego, y el banco de pruebas estaba compuesto por dos computadoras conectadas por Ethernet conmutado de 100 M, siendo una computadora el sitio local y la otra el sitio remoto. Para simular el retraso de transmisión de red, se desarrolló un módulo específico para retrasar todos los paquetes transmitidos entre las dos computadoras en función de un valor de retraso predefinido. El propósito principal de la evaluación del rendimiento es estudiar los efectos de GS-DR-LL en la disminución de la inconsistencia antes en un sistema de juego particular bajo diferentes umbrales, retardos y retrasos en la transmisión de red. Se utilizaron dos umbrales diferentes en la evaluación, uno es una desviación de 10 píxeles en posición o 15 grados en orientación, y el otro es de 4 píxeles o 5 grados. Se utilizaron seis combinaciones diferentes de retardo de lag y de transmisión de red en la evaluación, las cuales podían dividirse en dos categorías. En una categoría, el retardo se fijó en 300 ms y se utilizaron tres retardos de transmisión de red diferentes (100 ms, 300 ms y 500 ms). En la otra categoría, el retraso de transmisión de red se fijó en 800 ms y se utilizaron tres retrasos diferentes (100 ms, 300 ms y 500 ms). Por lo tanto, el número total de configuraciones utilizadas en la evaluación fue de 12 (2 × 6). El procedimiento de evaluación del desempeño estaba compuesto por tres pasos. En el primer paso, se emplearon dos participantes para jugar el juego, y se registraron las secuencias de operación. Basándose en los registros, se seleccionó una secuencia de suboperaciones que duró aproximadamente un minuto e incluyó diferentes operaciones (por ejemplo, acelerar, desacelerar y girar). En el segundo paso, primero se sincronizaron los relojes físicos de las dos computadoras. Bajo diferentes configuraciones y enfoques de mantenimiento de consistencia, la secuencia de suboperaciones seleccionada se reprodujo en una computadora, y esta hizo mover las dos naves espaciales, una local y la otra remota. Mientras tanto, las trayectorias de las naves espaciales en las dos computadoras fueron registradas por separado y se les llamó un par de trayectorias. Dado que hay 12 ajustes y 2 enfoques de mantenimiento de consistencia, el número total de parejas de pistas registradas fue de 24. En el último paso, a cada par de pistas se calculó la inconsistencia entre ellas, y la unidad de inconsistencia fue el píxel. Dado que los relojes físicos de las dos computadoras estaban sincronizados, el cálculo de la inconsistencia fue bastante simple. La inconsistencia en un momento particular fue la distancia entre las posiciones de las dos naves espaciales en ese momento (es decir, fórmula (3)). Para mostrar los resultados de la inconsistencia de manera clara, solo se utilizan partes de los resultados, que duran aproximadamente 7 segundos, en las siguientes figuras, y las figuras muestran casi las mismas partes de los resultados. Las figuras 3, 4 y 5 muestran los resultados de la inconsistencia cuando el retardo está fijo en 300 ms y los retrasos de transmisión de red son de 100, 300 y 500 ms. Se puede observar que la inconsistencia existe, pero la mayoría del tiempo es 0. Además, la inconsistencia aumenta con el retraso de transmisión de la red, pero disminuye con el umbral. Comparado con GS-DR, GS-DR-LL puede disminuir más la inconsistencia, y elimina la mayoría de la inconsistencia cuando la demora de transmisión de red es de 100 ms y el umbral es de 4 píxeles o 5 grados. Según los mecanismos de predicción y filtrado de estado de DR, la inconsistencia no puede ser completamente eliminada si el umbral no es 0. Con las definiciones de inconsistencia anterior e inconsistencia posterior, se puede indicar que GS-DR y GS-DR-LL pueden eliminar la inconsistencia posterior, y GS-DR-LL puede disminuir efectivamente la inconsistencia anterior. Se puede prever que con un retraso y umbral adecuados (por ejemplo, el retraso es mayor que la demora de transmisión de red y el umbral es 0), GS-DR-LL incluso puede eliminar la inconsistencia antes. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 3. Inconsistencia cuando el retraso de transmisión de red es de 100 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 4. Inconsistencia cuando el retraso de transmisión de red es de 300 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 5. Inconsistencia cuando el retraso de transmisión de red es de 500 ms y el retardo es de 300 ms. Las figuras 6, 7 y 8 muestran los resultados de la inconsistencia cuando el retraso de transmisión de la red está fijo en 800 ms y los retardos son de 100, 300 y 500 ms. Se puede observar que con GS-DR-LL antes de la inconsistencia disminuye con el rezago. En el retraso local tradicional, el retraso debe establecerse en un valor mayor que el retraso típico de transmisión de red, de lo contrario, las reparaciones de estado inundarían el sistema. A partir de los resultados anteriores, se puede ver que no existe ninguna restricción en la selección del retardo, con GS-DR-LL un sistema funcionaría bien incluso si el retardo es mucho menor que la demora de transmisión de la red. Del total de resultados anteriores, se puede indicar que tanto GS-DR como GSDR-LL pueden eliminarse después de la inconsistencia, y GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retardo. La cifra 6. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 7. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el lag es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 8. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 500 ms. 6. CONCLUSIONES En comparación con el DR tradicional, el GS-DR puede eliminar la inconsistencia posterior a través de la sincronización de relojes físicos, pero no puede abordar la inconsistencia anterior, lo que podría influir significativamente en la usabilidad y equidad de un juego. En este artículo, propusimos un método llamado GS-DR-LL, que combina el retraso local y GS-DR, para disminuir la inconsistencia previa mediante el retraso en la actualización de los resultados de ejecución de operaciones locales en la escena local. La evaluación del rendimiento indica que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. GS-DR-LL tiene implicaciones significativas para los enfoques de mantenimiento de consistencia. Primero, GS-DR-LL muestra que una mejora en DR no solo puede eliminar la inconsistencia posterior, sino también disminuir la inconsistencia anterior, con un retraso y umbral adecuados, incluso podría eliminarla antes de que ocurra. Como resultado, la aplicación de DR puede ser ampliamente expandida y podría ser utilizada en sistemas que requieran alta consistencia (por ejemplo, juegos altamente interactivos). Segundo, GS-DR-LL muestra que al combinar el retardo local y GSDR, se elimina la restricción en la selección del valor de retardo y se puede utilizar un retardo menor que el retraso típico de transmisión de red. Como resultado, la aplicación del retraso local puede ser ampliamente ampliada y podría ser utilizada en los sistemas que tienen un gran retraso de transmisión de red típico (por ejemplo,). Juegos basados en internet. REFERENCIAS [1] Mauve, M., Vogel, J., Hilt, V., y Effelsberg, W. Local-Lag y Timewarp: Proporcionando Consistencia para Aplicaciones Continuas Replicadas. IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.\n\nIEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., y Lau, R.W. Apoyando la coherencia continua en juegos en línea multijugador. En Proc. de ACM Multimedia, 2004, 388-391. [3] Pantel, L. y Wolf, L. Sobre la idoneidad de los esquemas de navegación inercial para juegos. En Proc. de NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., y Kunifuji, S. Un estudio experimental sobre los efectos del retardo de red en un entorno virtual háptico compartido cooperativo. Computadoras y Gráficos, Vol. 27, Núm. 2, 2003, 205-213. [5] Pantel, L. y Wolf, L.C. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En Proc. de NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., y Brooks, F.P. Efecto de la latencia en la presencia en entornos virtuales estresantes. En Proc. de IEEE VR, 2003, 141-148. [7] Bernier, Y.W. Métodos de Compensación de Latencia en el Diseño y Optimización del Protocolo de Juego Cliente/Servidor. En Proc. de la Conferencia de Desarrolladores de Juegos, 2001. [8] Aggarwal, S., Banavar, H., y Khandelwal, A. Precisión en juegos multijugador distribuidos basados en la navegación a ojo muerto. En Proc. de NetGames, 2004, 161-165. [9] Raynal, M. y Schiper, A. De la Consistencia Causal a la Consistencia Secuencial en Sistemas de Memoria Compartida. En Proc. de la Conferencia sobre Fundamentos de Tecnología del Software y Ciencias de la Computación Teórica, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., y Neiger, G. Memoria Causal. En Proc. del Taller Internacional sobre Algoritmos Distribuidos, 1991, 9-30. [11] Herlihy, M. y Wing, J. Linearizabilidad: una Condición de Corrección para Objetos Concurrentes. ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.\nTraducción: ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axiomas para el acceso a la memoria en sistemas de hardware asíncronos. ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. y Munson, E.V. ¿Es 100 milisegundos demasiado rápido? En Proc. de la Conferencia SIGCHI sobre Factores Humanos en Sistemas Informáticos, 2001, 317-318. [14] Chen, H., Chen, L., y Chen, G.C. Efectos del mecanismo de retraso local en el rendimiento de la cooperación en un sistema CVE de escritorio. Revista de Ciencias de la Computación y Tecnología, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., y Chen, G.C. Echo: un método para mejorar la calidad de interacción de CVEs. En Proc. de IEEE VR, 2005, 269-270. El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 7",
    "original_sentences": [
        "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
        "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
        "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
        "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
        "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
        "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
        "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
        "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
        "General Terms Algorithms, Performance, Experimentation. 1.",
        "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
        "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
        "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
        "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
        "Although new network techniques (e.g.",
        "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
        "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
        "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
        "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
        "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
        "It synchronizes the physical clocks of all sites in a system.",
        "After an operation is issued at local site, it delays the execution of the operation for a short time.",
        "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
        "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
        "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
        "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
        "DR is based on state transmission mechanism.",
        "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
        "After each update of its own entities, a site compares the accurate state with the estimated one.",
        "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
        "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
        "Compared with aforementioned local lag, DR cannot maintain high consistency.",
        "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
        "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
        "Detailed description of GS-DR can be found in Section 3.",
        "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
        "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
        "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
        "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
        "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
        "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
        "DR).",
        "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
        "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
        "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
        "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
        "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
        "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
        "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
        "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
        "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
        "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
        "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
        "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
        "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
        "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
        "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
        "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
        "Before inconsistency is caused by two reasons.",
        "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
        "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
        "Figure 1.",
        "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
        "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
        "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
        "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
        "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
        "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
        "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
        "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
        "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
        "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
        "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
        "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
        "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
        "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
        "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
        "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
        "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
        "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
        "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
        "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
        "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
        "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
        "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
        "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
        "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
        "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
        "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
        "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
        "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
        "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
        "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
        "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
        "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
        "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
        "The aforementioned is the basic mechanism of GS-DR-LL.",
        "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
        "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
        "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
        "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
        "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
        "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
        "At time point t2, the state update is received by remote site j.",
        "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
        "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
        "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
        "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
        "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
        "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
        "Figure 2.",
        "The paths of a shared entity by using GS-DR and GS-DR-LL.",
        "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
        "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
        "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
        "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
        "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
        "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
        "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
        "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
        "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
        "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
        "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
        "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
        "If a spaceship is hit by a laser beam, its life points decrease one.",
        "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
        "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
        "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
        "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
        "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
        "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
        "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
        "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
        "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
        "The procedure of performance evaluation was composed of three steps.",
        "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
        "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
        "In the second step, the physical clocks of the two computers were synchronized first.",
        "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
        "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
        "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
        "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
        "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
        "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
        "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
        "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
        "It can been seen that inconsistency does exist, but in most of the time it is 0.",
        "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
        "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
        "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
        "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
        "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
        "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
        "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
        "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
        "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
        "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
        "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
        "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
        "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
        "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
        "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
        "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
        "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
        "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
        "GS-DR-LL has significant implications to consistency maintenance approaches.",
        "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
        "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
        "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
        "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
        "Internet based games). 7.",
        "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
        "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
        "Supporting Continuous Consistency in Multiplayer Online Games.",
        "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
        "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
        "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
        "On the Impact of Delay on RealTime Multiplayer Games.",
        "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
        "Effect of Latency on Presence in Stressful Virtual Environments.",
        "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
        "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
        "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
        "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
        "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
        "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
        "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
        "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
        "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
        "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
        "Is 100 Milliseconds too Fast.",
        "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
        "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
        "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
        "Echo: a Method to Improve the Interaction Quality of CVEs.",
        "In Proc. of IEEE VR, 2005, 269-270.",
        "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
    ],
    "translated_text_sentences": [
        "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China.",
        "La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG).",
        "Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial.",
        "Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos.",
        "Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa.",
        "En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR).",
        "La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo.",
        "Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas.",
        "Términos generales Algoritmos, Rendimiento, Experimentación. 1.",
        "INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas.",
        "En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2].",
        "Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG).",
        "Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red.",
        "Aunque las nuevas técnicas de red (por ejemplo,",
        "La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3].",
        "Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7].",
        "En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc.",
        "Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos.",
        "Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas.",
        "Sincroniza los relojes físicos de todos los sitios en un sistema.",
        "Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo.",
        "Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico.",
        "Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la distorsión temporal para reparar el estado.",
        "La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos.",
        "Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada.",
        "DR se basa en el mecanismo de transmisión del estado.",
        "Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades).",
        "Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado.",
        "Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres.",
        "A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas.",
        "Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia.",
        "Debido al retraso en la transmisión de la red, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado.",
        "Para mantener una alta consistencia en la replicación distribuida (DR), Aggarwal et al [8] propusieron la Replicación Distribuida Globalmente Sincronizada (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega marcas de tiempo a las actualizaciones de estado transmitidas.",
        "La descripción detallada de GS-DR se puede encontrar en la Sección 3.",
        "Cuando hay una actualización de estado disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización de estado a los sitios remotos, lo que provoca que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión.",
        "Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar la inconsistencia anterior [8].",
        "En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, GS-DR-LL puede lograr una mayor consistencia que GS-DR.",
        "El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona GS-DR-LL; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento.",
        "DEFINICIONES Y MÉTRICAS DE CONSISTENCIA La consistencia de aplicaciones replicadas ya ha sido bien definida en el dominio discreto [9, 10, 11, 12], pero se ha realizado poco trabajo relacionado en el dominio continuo.",
        "Mauve et al [1] han proporcionado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operaciones y resulta difícil que describa métodos basados en la transmisión de estado (por ejemplo,",
        "Lo siento, pero no puedo traducir \"DR).\" ya que no es una oración completa en inglés. ¿Hay algo más en lo que pueda ayudarte a traducir al español?",
        "Aquí presentamos una definición alternativa de consistencia en un dominio continuo, que se adapta bien a los métodos basados en la transmisión de estado.",
        "Dado dos sitios distintos i y j, que han replicado una entidad compartida e, en un tiempo dado t, los estados de e en los sitios i y j son Si(t) y Sj(t).",
        "DEFINICIÓN 1: los estados de e en los sitios i y j son consistentes en el tiempo t, si: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINICIÓN 2: los estados de e en los sitios i y j son consistentes entre los tiempos t1 y t2 (t1 < t2), si: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) En este artículo, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre sitios locales y remotos.",
        "Debido al retraso en la transmisión de la red, es difícil mantener los estados de las entidades compartidas absolutamente consistentes.",
        "Se necesitan métricas correspondientes para medir la consistencia de las entidades compartidas entre sitios locales y remotos.",
        "De(i, j, t) se puede utilizar como una métrica para medir el grado de consistencia en un momento específico.",
        "Si De(i, j, t1) > De(i, j, t2), se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e en el punto de tiempo t1 es menor que en el punto de tiempo t2.",
        "Si De(i, j, t) > De(l, k, t), se puede afirmar que, en el momento t, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. De manera similar, De(i, j, t1, t2) puede ser utilizada como una métrica para medir el grado de consistencia en un cierto período de tiempo.",
        "Si De(i, j, t1, t2) > De(i, j, t3, t4) y |t1 - t2| = |t3 - t4|, se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e entre los puntos temporales t1 y t2 es menor que entre los puntos temporales t3 y t4.",
        "Si De(i, j, t1, t2) > De(l, k, t1, t2), se puede afirmar que entre los puntos temporales t1 y t2, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. En DR, los estados de las entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades).",
        "Dadas dos ubicaciones distintas i y j, que han replicado una entidad compartida e, en un momento dado t, las posiciones de e en los sitios i y j son (xit, yit, zit) y (xjt, yjt, zjt), De(i, j, t) y D(i, j, t1, t2) podrían calcularse como: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se utilizan como métricas para medir la consistencia de las entidades compartidas entre sitios locales y remotos. 3.",
        "La inconsistencia en DR se puede dividir en dos secciones según el momento en que un sitio remoto recibe una actualización de estado.",
        "La inconsistencia antes de que un sitio remoto reciba una actualización de estado se conoce como inconsistencia antes, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se conoce como inconsistencia después.",
        "Antes de la inconsistencia y después de la inconsistencia son similares a los términos antes del error de exportación y después del error de exportación [8].",
        "La inconsistencia se produce por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema.",
        "Al emplear la sincronización de relojes físicos, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior.",
        "La inconsistencia se produce por dos razones.",
        "La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el estado preciso y el estimado sea mayor que un umbral predefinido.",
        "La segunda razón es el retraso en la transmisión de la red, ya que una entidad compartida solo puede sincronizarse después de que los sitios remotos reciban la actualización de estado correspondiente.",
        "Figura 1.",
        "Los caminos de una entidad compartida mediante el uso de GS-DR. Por ejemplo, se asume que la velocidad de una entidad compartida es el único parámetro para predecir la posición de la entidad, y la posición actual de la entidad se puede calcular a partir de su última posición y la velocidad actual.",
        "Para simplificar la descripción, también se asume que solo hay dos sitios i y j en una sesión de juego, donde el sitio i actúa como sitio local del 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 y el sitio j actúa como sitio remoto, y t1 es el momento en que el sitio local actualiza el estado de la entidad compartida.",
        "La Figura 1 ilustra los caminos de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR. Al principio, las posiciones de la entidad compartida son las mismas en los sitios i y j y la velocidad de la entidad compartida es 0.",
        "Antes del momento t0, los caminos de la entidad compartida en los sitios i y j en la coordenada x son exactamente iguales.",
        "En el instante t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad en el eje x a v0.",
        "El sitio primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, que en este caso es 0, es mayor que un umbral predefinido.",
        "En el momento t1, el sitio i encuentra que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j.",
        "La actualización del estado contiene la posición y la velocidad de la entidad compartida en el momento t1 y el momento t1 también se adjunta como una marca de tiempo.",
        "En el instante de tiempo t2, la actualización del estado llega al sitio j, y el estado recibido y la desviación de tiempo entre los instantes t1 y t2 se utilizan para calcular la posición actual de la entidad compartida.",
        "Luego, el sitio j actualiza la posición y la velocidad de su entidad replicada, y las trayectorias de la entidad compartida en los sitios i y j se superponen nuevamente.",
        "A partir de la Figura 1, se puede observar que la inconsistencia posterior es 0, y la consistencia anterior está compuesta por dos partes, D1 y D2.",
        "D1 es De(i, j, t0, t1) y es causado por el mecanismo de filtrado de estado de DR. D2 es De(i, j, t1, t2) y es causado por el retraso de transmisión de red. 4.",
        "SINCRONIZACIÓN GLOBAL DE DR CON RETRASO LOCAL. A partir del análisis en la Sección 3, se puede observar que GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar eficazmente la inconsistencia anterior.",
        "Para disminuir la inconsistencia previa, proponemos GS-DR-LL, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa.",
        "En GS-DR-LL, el estado de una entidad compartida en un cierto momento t se nota como S = (t, pos, par 1, par 2, ……, par n), en el que pos significa la posición de la entidad y par 1 a par n significa los parámetros para calcular la posición de la entidad.",
        "Para simplificar la descripción de GS-DR-LL, se asume que solo hay una entidad compartida y un sitio remoto.",
        "Al comienzo de una sesión de juego, los estados de la entidad compartida son iguales en los sitios locales y remotos, con la misma posición p0 y parámetros pars0 (pars representa todos los parámetros).",
        "El sitio local mantiene tres estados: el estado real de la entidad Sreal, el estado predicho en el sitio remoto Sp-remote, y el estado más reciente actualizado en el sitio remoto Slate.",
        "El sitio remoto mantiene solo un estado Sremoto, que es el estado real de la entidad en el sitio remoto.",
        "Por lo tanto, al comienzo de una sesión de juego Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
        "En GS-DR-LL, se asume que los relojes físicos de todos los sitios están sincronizados con una desviación de menos de 50 ms (utilizando NTP o reloj GPS).",
        "Además, es necesario hacer correcciones a un reloj físico de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo.",
        "Además, se asume que la escena del juego se actualiza a una frecuencia fija y T representa el intervalo de tiempo entre dos actualizaciones consecutivas, por ejemplo, si la frecuencia de actualización de la escena es de 50 Hz, T sería de 20 ms. n representa el valor de retraso utilizado por el retraso local, y t representa el tiempo físico actual.",
        "Después de actualizar la escena, el sitio local espera durante un tiempo constante T. Durante este período de tiempo, el sitio local recibe las operaciones del jugador y las almacena en una lista L. Todas las operaciones en L están ordenadas por su tiempo de emisión.",
        "Al final del período de tiempo T, el sitio local ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - T y t, en Slate para obtener el nuevo Slate, y también ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - (n + T) y t - n, en Sreal para obtener el nuevo Sreal.",
        "Además, el sitio local utiliza Sp-remote y métodos de predicción correspondientes para estimar el nuevo Sp-remote.",
        "Después de calcular los nuevos Slate, Sreal y Sp-remote, el sitio local compara si la diferencia entre el nuevo Slate y Spremote supera el umbral predefinido.",
        "Si SÍ, el sitio local envía un nuevo Slate al sitio remoto y Sp-remote se actualiza con el nuevo Slate.",
        "Ten en cuenta que la marca de tiempo de la actualización de estado enviada es t. Después de eso, el sitio local utiliza Sreal para actualizar la escena local y elimina las operaciones cuyo tiempo de emisión sea menor que t - n, de L. Después de actualizar la escena, el sitio remoto espera una cantidad constante de tiempo T. Durante este período de tiempo, el sitio remoto almacena las actualizaciones de estado recibidas en una lista R. Todas las actualizaciones de estado en R están ordenadas por sus marcas de tiempo.",
        "Al final del período de tiempo T, el sitio remoto verifica si R contiene actualizaciones de estado cuyas marcas de tiempo son menores que t - n. Tenga en cuenta que t es el tiempo físico actual y aumenta durante la transmisión de las actualizaciones de estado.",
        "Si es afirmativo, utiliza estas actualizaciones de estado y los métodos de predicción correspondientes para calcular el nuevo Sremoto; de lo contrario, utilizan Sremoto y los métodos de predicción correspondientes para estimar el nuevo Sremoto.",
        "Después de eso, el sitio local utiliza Sremote para actualizar la escena local y elimina las actualizaciones de estado cuyas marcas de tiempo son menores que t - n, de R. A partir de la descripción anterior, se puede ver que la principal diferencia entre GS-DR y GS-DR-LL es que GS-DR-LL utiliza las operaciones cuyo tiempo de emisión es menor que t - n para calcular Sreal.",
        "Eso significa que la escena vista por el jugador local es el resultado de las operaciones emitidas un período de tiempo (es decir, n) atrás.",
        "Mientras tanto, si los resultados de las operaciones emitidas hacen que la diferencia entre Slate y Sp-remote exceda un umbral predefinido, las actualizaciones de estado correspondientes se envían a los sitios remotos de inmediato.",
        "Lo mencionado es el mecanismo básico de GS-DR-LL.",
        "En el caso de múltiples entidades compartidas y sitios remotos, el sitio local calcula Slate, Sreal y Sp-remote para diferentes entidades compartidas respectivamente. Si hay varios Slate que deben ser transmitidos, el sitio local los empaqueta en una actualización de estado y luego los envía a todos los sitios remotos.",
        "La Figura 2 ilustra los caminos de una entidad compartida en el sitio local y en el sitio remoto al utilizar GS-DR y GS-DR-LL.",
        "Todas las condiciones son las mismas que las condiciones utilizadas en el ejemplo mencionado que describe GS-DR.",
        "Comparado con t1, t2 y n, T (es decir, el intervalo de tiempo entre dos actualizaciones consecutivas) es bastante pequeño y se ignora en la siguiente descripción.",
        "En el momento t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad de la entidad compartida de 0 a v0.",
        "Al utilizar GS-DR-LL, los resultados de la operación se actualizan en la escena local en el momento t0 + n. Sin embargo, la operación se utiliza inmediatamente para calcular Slate, por lo tanto, a pesar de GS-DR o GS-DR-LL, en el momento t1 el sitio i encuentra que la diferencia entre la posición precisa y la estimada es mayor que el umbral y envía una actualización de estado al sitio j.",
        "En el momento t2, la actualización del estado es recibida por el sitio remoto j.",
        "Suponiendo que la marca de tiempo de la actualización del estado es menor que t - n, el sitio j la utiliza para actualizar la escena local inmediatamente.",
        "En el 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006, con GS-DR, el período de tiempo antes de la inconsistencia es (t2 - t1) + (t1 - t0), mientras que disminuye a (t2 - t1 - n) + (t1 - t0) con la ayuda de GS-DR-LL.",
        "Ten en cuenta que t2 - t1 es causado por el retraso de transmisión de la red y t1 - t0 es causado por el mecanismo de filtrado de estado de DR.",
        "Si n es mayor que t2 - t1, GS-DR-LL puede eliminar la inconsistencia anterior causada por el retraso de transmisión de red, pero no puede eliminar la inconsistencia anterior causada por el mecanismo de filtrado de estado de DR (a menos que el umbral se establezca en 0).",
        "En juegos altamente interactivos, que requieren alta consistencia y podrían emplear GS-DR-LL, los resultados de las operaciones son bastante difíciles de estimar y se debe usar un umbral pequeño.",
        "Por lo tanto, en la práctica, la mayoría de las inconsistencias anteriores son causadas por el retraso en la transmisión de la red y GS-DR-LL tiene la capacidad de eliminar dichas inconsistencias anteriores.",
        "Figura 2.",
        "Los caminos de una entidad compartida utilizando GS-DR y GS-DR-LL.",
        "Para GS-DR-LL, la selección del valor de retardo n es muy importante, y tanto el retardo de transmisión de red como los efectos del retardo local en la interacción deben ser considerados.",
        "Según los resultados de investigaciones relacionadas con la Interacción Humano-Computadora (HCI), los humanos no pueden percibir el retraso impuesto en un sistema cuando es menor que un valor específico, y este valor específico depende tanto del sistema como de la tarea.",
        "Por ejemplo, en una interfaz gráfica de usuario, un retraso de aproximadamente 150 ms no puede ser percibido para la interacción con el teclado y el umbral se incrementa a 195 ms para la interacción con el ratón [13], y un retraso de hasta 50 ms es poco crítico para un juego de carreras de coches [5].",
        "Por lo tanto, si el retraso de transmisión de la red es menor que el valor específico de un sistema de juego, n puede establecerse en el valor específico.",
        "La variable n puede ser establecida en términos de los efectos del rezago local en la interacción de un sistema [14].",
        "En el caso de que se deba utilizar un n grande, algunos métodos de HCI (por ejemplo, eco [15]) pueden ser utilizados para aliviar los efectos negativos del gran retardo.",
        "En el caso de que n sea mayor que el retraso de transmisión de la red, GS-DR-LL puede eliminar la mayoría de las inconsistencias antes.",
        "La solicitud de retraso local tradicional requiere que el valor de retraso sea mayor que el retraso típico de transmisión de red, de lo contrario las reparaciones del estado inundarían el sistema.",
        "Sin embargo, GS-DR-LL permite que n sea menor que el retraso de transmisión de red típico.",
        "En este caso, la inconsistencia previa causada por el retraso en la transmisión de la red todavía existe, pero puede ser disminuida. 5.",
        "EVALUACIÓN DEL RENDIMIENTO Para evaluar GS-DR-LL y compararlo con GS-DR en una aplicación real, implementamos ambos métodos en un juego en red llamado spaceship [1].",
        "Spaceship es un juego de computadora en red muy simple, en el cual los jugadores pueden controlar sus naves espaciales para acelerar, desacelerar, girar y disparar a las naves espaciales controladas por otros jugadores remotos con rayos láser.",
        "Si una nave espacial es alcanzada por un rayo láser, sus puntos de vida disminuyen en uno.",
        "Si los puntos de vida de una nave espacial disminuyen a 0, la nave espacial se elimina del juego y el jugador que la controla pierde el juego.",
        "En nuestra implementación práctica, GS-DR-LL y GS-DR coexistieron en el sistema de juego, y el banco de pruebas estaba compuesto por dos computadoras conectadas por Ethernet conmutado de 100 M, siendo una computadora el sitio local y la otra el sitio remoto.",
        "Para simular el retraso de transmisión de red, se desarrolló un módulo específico para retrasar todos los paquetes transmitidos entre las dos computadoras en función de un valor de retraso predefinido.",
        "El propósito principal de la evaluación del rendimiento es estudiar los efectos de GS-DR-LL en la disminución de la inconsistencia antes en un sistema de juego particular bajo diferentes umbrales, retardos y retrasos en la transmisión de red.",
        "Se utilizaron dos umbrales diferentes en la evaluación, uno es una desviación de 10 píxeles en posición o 15 grados en orientación, y el otro es de 4 píxeles o 5 grados.",
        "Se utilizaron seis combinaciones diferentes de retardo de lag y de transmisión de red en la evaluación, las cuales podían dividirse en dos categorías.",
        "En una categoría, el retardo se fijó en 300 ms y se utilizaron tres retardos de transmisión de red diferentes (100 ms, 300 ms y 500 ms).",
        "En la otra categoría, el retraso de transmisión de red se fijó en 800 ms y se utilizaron tres retrasos diferentes (100 ms, 300 ms y 500 ms).",
        "Por lo tanto, el número total de configuraciones utilizadas en la evaluación fue de 12 (2 × 6).",
        "El procedimiento de evaluación del desempeño estaba compuesto por tres pasos.",
        "En el primer paso, se emplearon dos participantes para jugar el juego, y se registraron las secuencias de operación.",
        "Basándose en los registros, se seleccionó una secuencia de suboperaciones que duró aproximadamente un minuto e incluyó diferentes operaciones (por ejemplo, acelerar, desacelerar y girar).",
        "En el segundo paso, primero se sincronizaron los relojes físicos de las dos computadoras.",
        "Bajo diferentes configuraciones y enfoques de mantenimiento de consistencia, la secuencia de suboperaciones seleccionada se reprodujo en una computadora, y esta hizo mover las dos naves espaciales, una local y la otra remota.",
        "Mientras tanto, las trayectorias de las naves espaciales en las dos computadoras fueron registradas por separado y se les llamó un par de trayectorias.",
        "Dado que hay 12 ajustes y 2 enfoques de mantenimiento de consistencia, el número total de parejas de pistas registradas fue de 24.",
        "En el último paso, a cada par de pistas se calculó la inconsistencia entre ellas, y la unidad de inconsistencia fue el píxel.",
        "Dado que los relojes físicos de las dos computadoras estaban sincronizados, el cálculo de la inconsistencia fue bastante simple.",
        "La inconsistencia en un momento particular fue la distancia entre las posiciones de las dos naves espaciales en ese momento (es decir, fórmula (3)).",
        "Para mostrar los resultados de la inconsistencia de manera clara, solo se utilizan partes de los resultados, que duran aproximadamente 7 segundos, en las siguientes figuras, y las figuras muestran casi las mismas partes de los resultados.",
        "Las figuras 3, 4 y 5 muestran los resultados de la inconsistencia cuando el retardo está fijo en 300 ms y los retrasos de transmisión de red son de 100, 300 y 500 ms.",
        "Se puede observar que la inconsistencia existe, pero la mayoría del tiempo es 0.",
        "Además, la inconsistencia aumenta con el retraso de transmisión de la red, pero disminuye con el umbral.",
        "Comparado con GS-DR, GS-DR-LL puede disminuir más la inconsistencia, y elimina la mayoría de la inconsistencia cuando la demora de transmisión de red es de 100 ms y el umbral es de 4 píxeles o 5 grados. Según los mecanismos de predicción y filtrado de estado de DR, la inconsistencia no puede ser completamente eliminada si el umbral no es 0.",
        "Con las definiciones de inconsistencia anterior e inconsistencia posterior, se puede indicar que GS-DR y GS-DR-LL pueden eliminar la inconsistencia posterior, y GS-DR-LL puede disminuir efectivamente la inconsistencia anterior.",
        "Se puede prever que con un retraso y umbral adecuados (por ejemplo, el retraso es mayor que la demora de transmisión de red y el umbral es 0), GS-DR-LL incluso puede eliminar la inconsistencia antes. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 3.",
        "Inconsistencia cuando el retraso de transmisión de red es de 100 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 4.",
        "Inconsistencia cuando el retraso de transmisión de red es de 300 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 5.",
        "Inconsistencia cuando el retraso de transmisión de red es de 500 ms y el retardo es de 300 ms.",
        "Las figuras 6, 7 y 8 muestran los resultados de la inconsistencia cuando el retraso de transmisión de la red está fijo en 800 ms y los retardos son de 100, 300 y 500 ms.",
        "Se puede observar que con GS-DR-LL antes de la inconsistencia disminuye con el rezago.",
        "En el retraso local tradicional, el retraso debe establecerse en un valor mayor que el retraso típico de transmisión de red, de lo contrario, las reparaciones de estado inundarían el sistema.",
        "A partir de los resultados anteriores, se puede ver que no existe ninguna restricción en la selección del retardo, con GS-DR-LL un sistema funcionaría bien incluso si el retardo es mucho menor que la demora de transmisión de la red.",
        "Del total de resultados anteriores, se puede indicar que tanto GS-DR como GSDR-LL pueden eliminarse después de la inconsistencia, y GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retardo. La cifra 6.",
        "Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 7.",
        "Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el lag es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 8.",
        "Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 500 ms. 6.",
        "CONCLUSIONES En comparación con el DR tradicional, el GS-DR puede eliminar la inconsistencia posterior a través de la sincronización de relojes físicos, pero no puede abordar la inconsistencia anterior, lo que podría influir significativamente en la usabilidad y equidad de un juego.",
        "En este artículo, propusimos un método llamado GS-DR-LL, que combina el retraso local y GS-DR, para disminuir la inconsistencia previa mediante el retraso en la actualización de los resultados de ejecución de operaciones locales en la escena local.",
        "La evaluación del rendimiento indica que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo.",
        "GS-DR-LL tiene implicaciones significativas para los enfoques de mantenimiento de consistencia.",
        "Primero, GS-DR-LL muestra que una mejora en DR no solo puede eliminar la inconsistencia posterior, sino también disminuir la inconsistencia anterior, con un retraso y umbral adecuados, incluso podría eliminarla antes de que ocurra.",
        "Como resultado, la aplicación de DR puede ser ampliamente expandida y podría ser utilizada en sistemas que requieran alta consistencia (por ejemplo, juegos altamente interactivos).",
        "Segundo, GS-DR-LL muestra que al combinar el retardo local y GSDR, se elimina la restricción en la selección del valor de retardo y se puede utilizar un retardo menor que el retraso típico de transmisión de red.",
        "Como resultado, la aplicación del retraso local puede ser ampliamente ampliada y podría ser utilizada en los sistemas que tienen un gran retraso de transmisión de red típico (por ejemplo,).",
        "Juegos basados en internet.",
        "REFERENCIAS [1] Mauve, M., Vogel, J., Hilt, V., y Effelsberg, W. Local-Lag y Timewarp: Proporcionando Consistencia para Aplicaciones Continuas Replicadas.",
        "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.\n\nIEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., y Lau, R.W.",
        "Apoyando la coherencia continua en juegos en línea multijugador.",
        "En Proc. de ACM Multimedia, 2004, 388-391. [3] Pantel, L. y Wolf, L. Sobre la idoneidad de los esquemas de navegación inercial para juegos.",
        "En Proc. de NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., y Kunifuji, S. Un estudio experimental sobre los efectos del retardo de red en un entorno virtual háptico compartido cooperativo.",
        "Computadoras y Gráficos, Vol. 27, Núm. 2, 2003, 205-213. [5] Pantel, L. y Wolf, L.C.",
        "Sobre el impacto del retraso en los juegos multijugador en tiempo real.",
        "En Proc. de NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., y Brooks, F.P.",
        "Efecto de la latencia en la presencia en entornos virtuales estresantes.",
        "En Proc. de IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
        "Métodos de Compensación de Latencia en el Diseño y Optimización del Protocolo de Juego Cliente/Servidor.",
        "En Proc. de la Conferencia de Desarrolladores de Juegos, 2001. [8] Aggarwal, S., Banavar, H., y Khandelwal, A.",
        "Precisión en juegos multijugador distribuidos basados en la navegación a ojo muerto.",
        "En Proc. de NetGames, 2004, 161-165. [9] Raynal, M. y Schiper, A.",
        "De la Consistencia Causal a la Consistencia Secuencial en Sistemas de Memoria Compartida.",
        "En Proc. de la Conferencia sobre Fundamentos de Tecnología del Software y Ciencias de la Computación Teórica, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., y Neiger, G. Memoria Causal.",
        "En Proc. del Taller Internacional sobre Algoritmos Distribuidos, 1991, 9-30. [11] Herlihy, M. y Wing, J. Linearizabilidad: una Condición de Corrección para Objetos Concurrentes.",
        "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.\nTraducción: ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axiomas para el acceso a la memoria en sistemas de hardware asíncronos.",
        "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. y Munson, E.V.",
        "¿Es 100 milisegundos demasiado rápido?",
        "En Proc. de la Conferencia SIGCHI sobre Factores Humanos en Sistemas Informáticos, 2001, 317-318. [14] Chen, H., Chen, L., y Chen, G.C.",
        "Efectos del mecanismo de retraso local en el rendimiento de la cooperación en un sistema CVE de escritorio.",
        "Revista de Ciencias de la Computación y Tecnología, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., y Chen, G.C.",
        "Echo: un método para mejorar la calidad de interacción de CVEs.",
        "En Proc. de IEEE VR, 2005, 269-270.",
        "El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 7"
    ],
    "error_count": 3,
    "keys": {
        "local lag": {
            "translated_key": "retraso local",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with <br>local lag</br> for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with <br>local lag</br> (GS-DR-LL), which combines <br>local lag</br> and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which <br>local lag</br> and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed <br>local lag</br> to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "<br>local lag</br> can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned <br>local lag</br>, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with <br>local lag</br> (GS-DR-LL), which combines <br>local lag</br> and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH <br>local lag</br> From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with <br>local lag</br> and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by <br>local lag</br>, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of <br>local lag</br> on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of <br>local lag</br> on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional <br>local lag</br> requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional <br>local lag</br>, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines <br>local lag</br> and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining <br>local lag</br> and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of <br>local lag</br> can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [
                "Globally Synchronized Dead-Reckoning with <br>local lag</br> for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "In this paper, a method named Globally Synchronized DR with <br>local lag</br> (GS-DR-LL), which combines <br>local lag</br> and Globally Synchronized DR (GS-DR), is presented.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which <br>local lag</br> and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed <br>local lag</br> to maintain high consistency for replicated continuous applications.",
                "<br>local lag</br> can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites."
            ],
            "translated_annotated_samples": [
                "Reconocimiento de rumbo muerto globalmente sincronizado con <br>retraso local</br> para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China.",
                "En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el <br>retardo local</br> y el DR Globalmente Sincronizado (GS-DR).",
                "Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el <br>retraso local</br> y el Dead-Reckoning (DR) son dos enfoques representativos.",
                "Mauve et al [1] propusieron el <br>retraso local</br> para mantener una alta consistencia en aplicaciones continuas replicadas.",
                "La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos."
            ],
            "translated_text": "Reconocimiento de rumbo muerto globalmente sincronizado con <br>retraso local</br> para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el <br>retardo local</br> y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el <br>retraso local</br> y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el <br>retraso local</br> para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la distorsión temporal para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. ",
            "candidates": [],
            "error": [
                [
                    "retraso local",
                    "retardo local",
                    "retraso local",
                    "retraso local"
                ]
            ]
        },
        "multiplayer game": {
            "translated_key": "juegos multijugador",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed <br>multiplayer game</br>s adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [
                "INTRODUCTION Nowadays, many distributed <br>multiplayer game</br>s adopt replicated architectures."
            ],
            "translated_annotated_samples": [
                "INTRODUCCIÓN En la actualidad, muchos <br>juegos multijugador</br> distribuidos adoptan arquitecturas replicadas."
            ],
            "translated_text": "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos <br>juegos multijugador</br> distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la distorsión temporal para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada. DR se basa en el mecanismo de transmisión del estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado. Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres. A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas. Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia. Debido al retraso en la transmisión de la red, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado. Para mantener una alta consistencia en la replicación distribuida (DR), Aggarwal et al [8] propusieron la Replicación Distribuida Globalmente Sincronizada (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega marcas de tiempo a las actualizaciones de estado transmitidas. La descripción detallada de GS-DR se puede encontrar en la Sección 3. Cuando hay una actualización de estado disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización de estado a los sitios remotos, lo que provoca que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión. Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar la inconsistencia anterior [8]. En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, GS-DR-LL puede lograr una mayor consistencia que GS-DR. El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona GS-DR-LL; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento. DEFINICIONES Y MÉTRICAS DE CONSISTENCIA La consistencia de aplicaciones replicadas ya ha sido bien definida en el dominio discreto [9, 10, 11, 12], pero se ha realizado poco trabajo relacionado en el dominio continuo. Mauve et al [1] han proporcionado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operaciones y resulta difícil que describa métodos basados en la transmisión de estado (por ejemplo, Lo siento, pero no puedo traducir \"DR).\" ya que no es una oración completa en inglés. ¿Hay algo más en lo que pueda ayudarte a traducir al español? Aquí presentamos una definición alternativa de consistencia en un dominio continuo, que se adapta bien a los métodos basados en la transmisión de estado. Dado dos sitios distintos i y j, que han replicado una entidad compartida e, en un tiempo dado t, los estados de e en los sitios i y j son Si(t) y Sj(t). DEFINICIÓN 1: los estados de e en los sitios i y j son consistentes en el tiempo t, si: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINICIÓN 2: los estados de e en los sitios i y j son consistentes entre los tiempos t1 y t2 (t1 < t2), si: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) En este artículo, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre sitios locales y remotos. Debido al retraso en la transmisión de la red, es difícil mantener los estados de las entidades compartidas absolutamente consistentes. Se necesitan métricas correspondientes para medir la consistencia de las entidades compartidas entre sitios locales y remotos. De(i, j, t) se puede utilizar como una métrica para medir el grado de consistencia en un momento específico. Si De(i, j, t1) > De(i, j, t2), se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e en el punto de tiempo t1 es menor que en el punto de tiempo t2. Si De(i, j, t) > De(l, k, t), se puede afirmar que, en el momento t, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. De manera similar, De(i, j, t1, t2) puede ser utilizada como una métrica para medir el grado de consistencia en un cierto período de tiempo. Si De(i, j, t1, t2) > De(i, j, t3, t4) y |t1 - t2| = |t3 - t4|, se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e entre los puntos temporales t1 y t2 es menor que entre los puntos temporales t3 y t4. Si De(i, j, t1, t2) > De(l, k, t1, t2), se puede afirmar que entre los puntos temporales t1 y t2, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. En DR, los estados de las entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades). Dadas dos ubicaciones distintas i y j, que han replicado una entidad compartida e, en un momento dado t, las posiciones de e en los sitios i y j son (xit, yit, zit) y (xjt, yjt, zjt), De(i, j, t) y D(i, j, t1, t2) podrían calcularse como: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se utilizan como métricas para medir la consistencia de las entidades compartidas entre sitios locales y remotos. 3. La inconsistencia en DR se puede dividir en dos secciones según el momento en que un sitio remoto recibe una actualización de estado. La inconsistencia antes de que un sitio remoto reciba una actualización de estado se conoce como inconsistencia antes, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se conoce como inconsistencia después. Antes de la inconsistencia y después de la inconsistencia son similares a los términos antes del error de exportación y después del error de exportación [8]. La inconsistencia se produce por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema. Al emplear la sincronización de relojes físicos, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior. La inconsistencia se produce por dos razones. La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el estado preciso y el estimado sea mayor que un umbral predefinido. La segunda razón es el retraso en la transmisión de la red, ya que una entidad compartida solo puede sincronizarse después de que los sitios remotos reciban la actualización de estado correspondiente. Figura 1. Los caminos de una entidad compartida mediante el uso de GS-DR. Por ejemplo, se asume que la velocidad de una entidad compartida es el único parámetro para predecir la posición de la entidad, y la posición actual de la entidad se puede calcular a partir de su última posición y la velocidad actual. Para simplificar la descripción, también se asume que solo hay dos sitios i y j en una sesión de juego, donde el sitio i actúa como sitio local del 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 y el sitio j actúa como sitio remoto, y t1 es el momento en que el sitio local actualiza el estado de la entidad compartida. La Figura 1 ilustra los caminos de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR. Al principio, las posiciones de la entidad compartida son las mismas en los sitios i y j y la velocidad de la entidad compartida es 0. Antes del momento t0, los caminos de la entidad compartida en los sitios i y j en la coordenada x son exactamente iguales. En el instante t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad en el eje x a v0. El sitio primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, que en este caso es 0, es mayor que un umbral predefinido. En el momento t1, el sitio i encuentra que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j. La actualización del estado contiene la posición y la velocidad de la entidad compartida en el momento t1 y el momento t1 también se adjunta como una marca de tiempo. En el instante de tiempo t2, la actualización del estado llega al sitio j, y el estado recibido y la desviación de tiempo entre los instantes t1 y t2 se utilizan para calcular la posición actual de la entidad compartida. Luego, el sitio j actualiza la posición y la velocidad de su entidad replicada, y las trayectorias de la entidad compartida en los sitios i y j se superponen nuevamente. A partir de la Figura 1, se puede observar que la inconsistencia posterior es 0, y la consistencia anterior está compuesta por dos partes, D1 y D2. D1 es De(i, j, t0, t1) y es causado por el mecanismo de filtrado de estado de DR. D2 es De(i, j, t1, t2) y es causado por el retraso de transmisión de red. 4. SINCRONIZACIÓN GLOBAL DE DR CON RETRASO LOCAL. A partir del análisis en la Sección 3, se puede observar que GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar eficazmente la inconsistencia anterior. Para disminuir la inconsistencia previa, proponemos GS-DR-LL, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa. En GS-DR-LL, el estado de una entidad compartida en un cierto momento t se nota como S = (t, pos, par 1, par 2, ……, par n), en el que pos significa la posición de la entidad y par 1 a par n significa los parámetros para calcular la posición de la entidad. Para simplificar la descripción de GS-DR-LL, se asume que solo hay una entidad compartida y un sitio remoto. Al comienzo de una sesión de juego, los estados de la entidad compartida son iguales en los sitios locales y remotos, con la misma posición p0 y parámetros pars0 (pars representa todos los parámetros). El sitio local mantiene tres estados: el estado real de la entidad Sreal, el estado predicho en el sitio remoto Sp-remote, y el estado más reciente actualizado en el sitio remoto Slate. El sitio remoto mantiene solo un estado Sremoto, que es el estado real de la entidad en el sitio remoto. Por lo tanto, al comienzo de una sesión de juego Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0). En GS-DR-LL, se asume que los relojes físicos de todos los sitios están sincronizados con una desviación de menos de 50 ms (utilizando NTP o reloj GPS). Además, es necesario hacer correcciones a un reloj físico de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo. Además, se asume que la escena del juego se actualiza a una frecuencia fija y T representa el intervalo de tiempo entre dos actualizaciones consecutivas, por ejemplo, si la frecuencia de actualización de la escena es de 50 Hz, T sería de 20 ms. n representa el valor de retraso utilizado por el retraso local, y t representa el tiempo físico actual. Después de actualizar la escena, el sitio local espera durante un tiempo constante T. Durante este período de tiempo, el sitio local recibe las operaciones del jugador y las almacena en una lista L. Todas las operaciones en L están ordenadas por su tiempo de emisión. Al final del período de tiempo T, el sitio local ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - T y t, en Slate para obtener el nuevo Slate, y también ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - (n + T) y t - n, en Sreal para obtener el nuevo Sreal. Además, el sitio local utiliza Sp-remote y métodos de predicción correspondientes para estimar el nuevo Sp-remote. Después de calcular los nuevos Slate, Sreal y Sp-remote, el sitio local compara si la diferencia entre el nuevo Slate y Spremote supera el umbral predefinido. Si SÍ, el sitio local envía un nuevo Slate al sitio remoto y Sp-remote se actualiza con el nuevo Slate. Ten en cuenta que la marca de tiempo de la actualización de estado enviada es t. Después de eso, el sitio local utiliza Sreal para actualizar la escena local y elimina las operaciones cuyo tiempo de emisión sea menor que t - n, de L. Después de actualizar la escena, el sitio remoto espera una cantidad constante de tiempo T. Durante este período de tiempo, el sitio remoto almacena las actualizaciones de estado recibidas en una lista R. Todas las actualizaciones de estado en R están ordenadas por sus marcas de tiempo. Al final del período de tiempo T, el sitio remoto verifica si R contiene actualizaciones de estado cuyas marcas de tiempo son menores que t - n. Tenga en cuenta que t es el tiempo físico actual y aumenta durante la transmisión de las actualizaciones de estado. Si es afirmativo, utiliza estas actualizaciones de estado y los métodos de predicción correspondientes para calcular el nuevo Sremoto; de lo contrario, utilizan Sremoto y los métodos de predicción correspondientes para estimar el nuevo Sremoto. Después de eso, el sitio local utiliza Sremote para actualizar la escena local y elimina las actualizaciones de estado cuyas marcas de tiempo son menores que t - n, de R. A partir de la descripción anterior, se puede ver que la principal diferencia entre GS-DR y GS-DR-LL es que GS-DR-LL utiliza las operaciones cuyo tiempo de emisión es menor que t - n para calcular Sreal. Eso significa que la escena vista por el jugador local es el resultado de las operaciones emitidas un período de tiempo (es decir, n) atrás. Mientras tanto, si los resultados de las operaciones emitidas hacen que la diferencia entre Slate y Sp-remote exceda un umbral predefinido, las actualizaciones de estado correspondientes se envían a los sitios remotos de inmediato. Lo mencionado es el mecanismo básico de GS-DR-LL. En el caso de múltiples entidades compartidas y sitios remotos, el sitio local calcula Slate, Sreal y Sp-remote para diferentes entidades compartidas respectivamente. Si hay varios Slate que deben ser transmitidos, el sitio local los empaqueta en una actualización de estado y luego los envía a todos los sitios remotos. La Figura 2 ilustra los caminos de una entidad compartida en el sitio local y en el sitio remoto al utilizar GS-DR y GS-DR-LL. Todas las condiciones son las mismas que las condiciones utilizadas en el ejemplo mencionado que describe GS-DR. Comparado con t1, t2 y n, T (es decir, el intervalo de tiempo entre dos actualizaciones consecutivas) es bastante pequeño y se ignora en la siguiente descripción. En el momento t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad de la entidad compartida de 0 a v0. Al utilizar GS-DR-LL, los resultados de la operación se actualizan en la escena local en el momento t0 + n. Sin embargo, la operación se utiliza inmediatamente para calcular Slate, por lo tanto, a pesar de GS-DR o GS-DR-LL, en el momento t1 el sitio i encuentra que la diferencia entre la posición precisa y la estimada es mayor que el umbral y envía una actualización de estado al sitio j. En el momento t2, la actualización del estado es recibida por el sitio remoto j. Suponiendo que la marca de tiempo de la actualización del estado es menor que t - n, el sitio j la utiliza para actualizar la escena local inmediatamente. En el 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006, con GS-DR, el período de tiempo antes de la inconsistencia es (t2 - t1) + (t1 - t0), mientras que disminuye a (t2 - t1 - n) + (t1 - t0) con la ayuda de GS-DR-LL. Ten en cuenta que t2 - t1 es causado por el retraso de transmisión de la red y t1 - t0 es causado por el mecanismo de filtrado de estado de DR. Si n es mayor que t2 - t1, GS-DR-LL puede eliminar la inconsistencia anterior causada por el retraso de transmisión de red, pero no puede eliminar la inconsistencia anterior causada por el mecanismo de filtrado de estado de DR (a menos que el umbral se establezca en 0). En juegos altamente interactivos, que requieren alta consistencia y podrían emplear GS-DR-LL, los resultados de las operaciones son bastante difíciles de estimar y se debe usar un umbral pequeño. Por lo tanto, en la práctica, la mayoría de las inconsistencias anteriores son causadas por el retraso en la transmisión de la red y GS-DR-LL tiene la capacidad de eliminar dichas inconsistencias anteriores. Figura 2. Los caminos de una entidad compartida utilizando GS-DR y GS-DR-LL. Para GS-DR-LL, la selección del valor de retardo n es muy importante, y tanto el retardo de transmisión de red como los efectos del retardo local en la interacción deben ser considerados. Según los resultados de investigaciones relacionadas con la Interacción Humano-Computadora (HCI), los humanos no pueden percibir el retraso impuesto en un sistema cuando es menor que un valor específico, y este valor específico depende tanto del sistema como de la tarea. Por ejemplo, en una interfaz gráfica de usuario, un retraso de aproximadamente 150 ms no puede ser percibido para la interacción con el teclado y el umbral se incrementa a 195 ms para la interacción con el ratón [13], y un retraso de hasta 50 ms es poco crítico para un juego de carreras de coches [5]. Por lo tanto, si el retraso de transmisión de la red es menor que el valor específico de un sistema de juego, n puede establecerse en el valor específico. La variable n puede ser establecida en términos de los efectos del rezago local en la interacción de un sistema [14]. En el caso de que se deba utilizar un n grande, algunos métodos de HCI (por ejemplo, eco [15]) pueden ser utilizados para aliviar los efectos negativos del gran retardo. En el caso de que n sea mayor que el retraso de transmisión de la red, GS-DR-LL puede eliminar la mayoría de las inconsistencias antes. La solicitud de retraso local tradicional requiere que el valor de retraso sea mayor que el retraso típico de transmisión de red, de lo contrario las reparaciones del estado inundarían el sistema. Sin embargo, GS-DR-LL permite que n sea menor que el retraso de transmisión de red típico. En este caso, la inconsistencia previa causada por el retraso en la transmisión de la red todavía existe, pero puede ser disminuida. 5. EVALUACIÓN DEL RENDIMIENTO Para evaluar GS-DR-LL y compararlo con GS-DR en una aplicación real, implementamos ambos métodos en un juego en red llamado spaceship [1]. Spaceship es un juego de computadora en red muy simple, en el cual los jugadores pueden controlar sus naves espaciales para acelerar, desacelerar, girar y disparar a las naves espaciales controladas por otros jugadores remotos con rayos láser. Si una nave espacial es alcanzada por un rayo láser, sus puntos de vida disminuyen en uno. Si los puntos de vida de una nave espacial disminuyen a 0, la nave espacial se elimina del juego y el jugador que la controla pierde el juego. En nuestra implementación práctica, GS-DR-LL y GS-DR coexistieron en el sistema de juego, y el banco de pruebas estaba compuesto por dos computadoras conectadas por Ethernet conmutado de 100 M, siendo una computadora el sitio local y la otra el sitio remoto. Para simular el retraso de transmisión de red, se desarrolló un módulo específico para retrasar todos los paquetes transmitidos entre las dos computadoras en función de un valor de retraso predefinido. El propósito principal de la evaluación del rendimiento es estudiar los efectos de GS-DR-LL en la disminución de la inconsistencia antes en un sistema de juego particular bajo diferentes umbrales, retardos y retrasos en la transmisión de red. Se utilizaron dos umbrales diferentes en la evaluación, uno es una desviación de 10 píxeles en posición o 15 grados en orientación, y el otro es de 4 píxeles o 5 grados. Se utilizaron seis combinaciones diferentes de retardo de lag y de transmisión de red en la evaluación, las cuales podían dividirse en dos categorías. En una categoría, el retardo se fijó en 300 ms y se utilizaron tres retardos de transmisión de red diferentes (100 ms, 300 ms y 500 ms). En la otra categoría, el retraso de transmisión de red se fijó en 800 ms y se utilizaron tres retrasos diferentes (100 ms, 300 ms y 500 ms). Por lo tanto, el número total de configuraciones utilizadas en la evaluación fue de 12 (2 × 6). El procedimiento de evaluación del desempeño estaba compuesto por tres pasos. En el primer paso, se emplearon dos participantes para jugar el juego, y se registraron las secuencias de operación. Basándose en los registros, se seleccionó una secuencia de suboperaciones que duró aproximadamente un minuto e incluyó diferentes operaciones (por ejemplo, acelerar, desacelerar y girar). En el segundo paso, primero se sincronizaron los relojes físicos de las dos computadoras. Bajo diferentes configuraciones y enfoques de mantenimiento de consistencia, la secuencia de suboperaciones seleccionada se reprodujo en una computadora, y esta hizo mover las dos naves espaciales, una local y la otra remota. Mientras tanto, las trayectorias de las naves espaciales en las dos computadoras fueron registradas por separado y se les llamó un par de trayectorias. Dado que hay 12 ajustes y 2 enfoques de mantenimiento de consistencia, el número total de parejas de pistas registradas fue de 24. En el último paso, a cada par de pistas se calculó la inconsistencia entre ellas, y la unidad de inconsistencia fue el píxel. Dado que los relojes físicos de las dos computadoras estaban sincronizados, el cálculo de la inconsistencia fue bastante simple. La inconsistencia en un momento particular fue la distancia entre las posiciones de las dos naves espaciales en ese momento (es decir, fórmula (3)). Para mostrar los resultados de la inconsistencia de manera clara, solo se utilizan partes de los resultados, que duran aproximadamente 7 segundos, en las siguientes figuras, y las figuras muestran casi las mismas partes de los resultados. Las figuras 3, 4 y 5 muestran los resultados de la inconsistencia cuando el retardo está fijo en 300 ms y los retrasos de transmisión de red son de 100, 300 y 500 ms. Se puede observar que la inconsistencia existe, pero la mayoría del tiempo es 0. Además, la inconsistencia aumenta con el retraso de transmisión de la red, pero disminuye con el umbral. Comparado con GS-DR, GS-DR-LL puede disminuir más la inconsistencia, y elimina la mayoría de la inconsistencia cuando la demora de transmisión de red es de 100 ms y el umbral es de 4 píxeles o 5 grados. Según los mecanismos de predicción y filtrado de estado de DR, la inconsistencia no puede ser completamente eliminada si el umbral no es 0. Con las definiciones de inconsistencia anterior e inconsistencia posterior, se puede indicar que GS-DR y GS-DR-LL pueden eliminar la inconsistencia posterior, y GS-DR-LL puede disminuir efectivamente la inconsistencia anterior. Se puede prever que con un retraso y umbral adecuados (por ejemplo, el retraso es mayor que la demora de transmisión de red y el umbral es 0), GS-DR-LL incluso puede eliminar la inconsistencia antes. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 3. Inconsistencia cuando el retraso de transmisión de red es de 100 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 4. Inconsistencia cuando el retraso de transmisión de red es de 300 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 5. Inconsistencia cuando el retraso de transmisión de red es de 500 ms y el retardo es de 300 ms. Las figuras 6, 7 y 8 muestran los resultados de la inconsistencia cuando el retraso de transmisión de la red está fijo en 800 ms y los retardos son de 100, 300 y 500 ms. Se puede observar que con GS-DR-LL antes de la inconsistencia disminuye con el rezago. En el retraso local tradicional, el retraso debe establecerse en un valor mayor que el retraso típico de transmisión de red, de lo contrario, las reparaciones de estado inundarían el sistema. A partir de los resultados anteriores, se puede ver que no existe ninguna restricción en la selección del retardo, con GS-DR-LL un sistema funcionaría bien incluso si el retardo es mucho menor que la demora de transmisión de la red. Del total de resultados anteriores, se puede indicar que tanto GS-DR como GSDR-LL pueden eliminarse después de la inconsistencia, y GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retardo. La cifra 6. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 7. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el lag es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 8. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 500 ms. 6. CONCLUSIONES En comparación con el DR tradicional, el GS-DR puede eliminar la inconsistencia posterior a través de la sincronización de relojes físicos, pero no puede abordar la inconsistencia anterior, lo que podría influir significativamente en la usabilidad y equidad de un juego. En este artículo, propusimos un método llamado GS-DR-LL, que combina el retraso local y GS-DR, para disminuir la inconsistencia previa mediante el retraso en la actualización de los resultados de ejecución de operaciones locales en la escena local. La evaluación del rendimiento indica que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. GS-DR-LL tiene implicaciones significativas para los enfoques de mantenimiento de consistencia. Primero, GS-DR-LL muestra que una mejora en DR no solo puede eliminar la inconsistencia posterior, sino también disminuir la inconsistencia anterior, con un retraso y umbral adecuados, incluso podría eliminarla antes de que ocurra. Como resultado, la aplicación de DR puede ser ampliamente expandida y podría ser utilizada en sistemas que requieran alta consistencia (por ejemplo, juegos altamente interactivos). Segundo, GS-DR-LL muestra que al combinar el retardo local y GSDR, se elimina la restricción en la selección del valor de retardo y se puede utilizar un retardo menor que el retraso típico de transmisión de red. Como resultado, la aplicación del retraso local puede ser ampliamente ampliada y podría ser utilizada en los sistemas que tienen un gran retraso de transmisión de red típico (por ejemplo,). Juegos basados en internet. REFERENCIAS [1] Mauve, M., Vogel, J., Hilt, V., y Effelsberg, W. Local-Lag y Timewarp: Proporcionando Consistencia para Aplicaciones Continuas Replicadas. IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.\n\nIEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., y Lau, R.W. Apoyando la coherencia continua en juegos en línea multijugador. En Proc. de ACM Multimedia, 2004, 388-391. [3] Pantel, L. y Wolf, L. Sobre la idoneidad de los esquemas de navegación inercial para juegos. En Proc. de NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., y Kunifuji, S. Un estudio experimental sobre los efectos del retardo de red en un entorno virtual háptico compartido cooperativo. Computadoras y Gráficos, Vol. 27, Núm. 2, 2003, 205-213. [5] Pantel, L. y Wolf, L.C. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En Proc. de NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., y Brooks, F.P. Efecto de la latencia en la presencia en entornos virtuales estresantes. En Proc. de IEEE VR, 2003, 141-148. [7] Bernier, Y.W. Métodos de Compensación de Latencia en el Diseño y Optimización del Protocolo de Juego Cliente/Servidor. En Proc. de la Conferencia de Desarrolladores de Juegos, 2001. [8] Aggarwal, S., Banavar, H., y Khandelwal, A. Precisión en juegos multijugador distribuidos basados en la navegación a ojo muerto. En Proc. de NetGames, 2004, 161-165. [9] Raynal, M. y Schiper, A. De la Consistencia Causal a la Consistencia Secuencial en Sistemas de Memoria Compartida. En Proc. de la Conferencia sobre Fundamentos de Tecnología del Software y Ciencias de la Computación Teórica, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., y Neiger, G. Memoria Causal. En Proc. del Taller Internacional sobre Algoritmos Distribuidos, 1991, 9-30. [11] Herlihy, M. y Wing, J. Linearizabilidad: una Condición de Corrección para Objetos Concurrentes. ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.\nTraducción: ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axiomas para el acceso a la memoria en sistemas de hardware asíncronos. ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. y Munson, E.V. ¿Es 100 milisegundos demasiado rápido? En Proc. de la Conferencia SIGCHI sobre Factores Humanos en Sistemas Informáticos, 2001, 317-318. [14] Chen, H., Chen, L., y Chen, G.C. Efectos del mecanismo de retraso local en el rendimiento de la cooperación en un sistema CVE de escritorio. Revista de Ciencias de la Computación y Tecnología, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., y Chen, G.C. Echo: un método para mejorar la calidad de interacción de CVEs. En Proc. de IEEE VR, 2005, 269-270. El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 7 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "consistency": {
            "translated_key": "consistencia",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain <br>consistency</br> for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high <br>consistency</br>, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher <br>consistency</br>, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the <br>consistency</br> problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain <br>consistency</br> for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high <br>consistency</br> for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high <br>consistency</br>, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain <br>consistency</br> but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high <br>consistency</br>.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high <br>consistency</br>, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher <br>consistency</br> than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of <br>consistency</br> and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "<br>consistency</br> DEFINITIONS AND METRICS The <br>consistency</br> of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of <br>consistency</br> for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of <br>consistency</br> in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the <br>consistency</br> of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of <br>consistency</br> at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the <br>consistency</br> of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the <br>consistency</br> of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of <br>consistency</br> in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the <br>consistency</br> of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the <br>consistency</br> of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the <br>consistency</br> of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before <br>consistency</br> is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high <br>consistency</br> and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and <br>consistency</br> maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 <br>consistency</br> maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to <br>consistency</br> maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high <br>consistency</br> (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing <br>consistency</br> for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous <br>consistency</br> in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal <br>consistency</br> to Sequential <br>consistency</br> in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain <br>consistency</br> for Continuous Distributed Multiplayer Games (CDMG).",
                "However, DR cannot maintain high <br>consistency</br>, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher <br>consistency</br>, but it still cannot eliminate before inconsistency.",
                "Like other distributed applications, CDMG also suffer from the <br>consistency</br> problem caused by network transmission delay.",
                "In order to maintain <br>consistency</br> for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches."
            ],
            "translated_annotated_samples": [
                "La navegación inercial (DR) es un método efectivo para mantener la <br>consistencia</br> en los Juegos Multijugador Distribuidos Continuos (CDMG).",
                "Sin embargo, DR no puede mantener una alta <br>consistencia</br>, lo que limita su aplicación en juegos altamente interactivos.",
                "Con la ayuda de la sincronización global, DR puede lograr una mayor <br>consistencia</br>, pero aún no puede eliminar por completo la in<br>consistencia</br> previa.",
                "Como otras aplicaciones distribuidas, CDMG también sufren del problema de <br>consistencia</br> causado por el retraso en la transmisión de la red.",
                "Para mantener la <br>consistencia</br> en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos."
            ],
            "translated_text": "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la <br>consistencia</br> en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta <br>consistencia</br>, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor <br>consistencia</br>, pero aún no puede eliminar por completo la in<br>consistencia</br> previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de <br>consistencia</br> causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la <br>consistencia</br> en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "network transmission delay": {
            "translated_key": "retraso en la transmisión de la red",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by <br>network transmission delay</br>.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of <br>network transmission delay</br> in different applications [4, 5, 6, 7].",
                "In replication based games, <br>network transmission delay</br> makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional <br>network transmission delay</br>, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to <br>network transmission delay</br>, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to <br>network transmission delay</br>, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is <br>network transmission delay</br>, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by <br>network transmission delay</br>. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by <br>network transmission delay</br> and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by <br>network transmission delay</br>, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by <br>network transmission delay</br> and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both <br>network transmission delay</br> and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if <br>network transmission delay</br> is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the <br>network transmission delay</br>, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical <br>network transmission delay</br>, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical <br>network transmission delay</br>.",
                "In this case, the before inconsistency caused by <br>network transmission delay</br> still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate <br>network transmission delay</br>, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and <br>network transmission delay</br> were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the <br>network transmission delay</br> was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the <br>network transmission delay</br>, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the <br>network transmission delay</br> is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the <br>network transmission delay</br> and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the <br>network transmission delay</br> is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the <br>network transmission delay</br> is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the <br>network transmission delay</br> is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the <br>network transmission delay</br> is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical <br>network transmission delay</br>, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the <br>network transmission delay</br>.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the <br>network transmission delay</br> is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the <br>network transmission delay</br> is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the <br>network transmission delay</br> is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical <br>network transmission delay</br>, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical <br>network transmission delay</br> (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by <br>network transmission delay</br>.",
                "There are many studies about the effects of <br>network transmission delay</br> in different applications [4, 5, 6, 7].",
                "In replication based games, <br>network transmission delay</br> makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to tackle the inconsistency caused by exceptional <br>network transmission delay</br>, a time warp based mechanism is proposed to repair the state.",
                "Due to <br>network transmission delay</br>, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update."
            ],
            "translated_annotated_samples": [
                "Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el <br>retraso en la transmisión de la red</br>.",
                "Hay muchos estudios sobre los efectos del <br>retraso en la transmisión de red</br> en diferentes aplicaciones [4, 5, 6, 7].",
                "En los juegos basados en replicación, la <br>demora en la transmisión de la red</br> hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc.",
                "Para abordar la inconsistencia causada por la excepcional <br>demora en la transmisión de la red</br>, se propone un mecanismo basado en la distorsión temporal para reparar el estado.",
                "Debido al <br>retraso en la transmisión de la red</br>, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado."
            ],
            "translated_text": "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el <br>retraso en la transmisión de la red</br>. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del <br>retraso en la transmisión de red</br> en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la <br>demora en la transmisión de la red</br> hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional <br>demora en la transmisión de la red</br>, se propone un mecanismo basado en la distorsión temporal para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada. DR se basa en el mecanismo de transmisión del estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado. Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres. A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas. Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia. Debido al <br>retraso en la transmisión de la red</br>, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado. ",
            "candidates": [],
            "error": [
                [
                    "retraso en la transmisión de la red",
                    "retraso en la transmisión de red",
                    "demora en la transmisión de la red",
                    "demora en la transmisión de la red",
                    "retraso en la transmisión de la red"
                ]
            ]
        },
        "time warp": {
            "translated_key": "distorsión temporal",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a <br>time warp</br> based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a <br>time warp</br> based mechanism is proposed to repair the state."
            ],
            "translated_annotated_samples": [
                "Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la <br>distorsión temporal</br> para reparar el estado."
            ],
            "translated_text": "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la <br>distorsión temporal</br> para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada. DR se basa en el mecanismo de transmisión del estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado. Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres. A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas. Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia. Debido al retraso en la transmisión de la red, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado. Para mantener una alta consistencia en la replicación distribuida (DR), Aggarwal et al [8] propusieron la Replicación Distribuida Globalmente Sincronizada (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega marcas de tiempo a las actualizaciones de estado transmitidas. La descripción detallada de GS-DR se puede encontrar en la Sección 3. Cuando hay una actualización de estado disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización de estado a los sitios remotos, lo que provoca que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión. Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar la inconsistencia anterior [8]. En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, GS-DR-LL puede lograr una mayor consistencia que GS-DR. El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona GS-DR-LL; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento. DEFINICIONES Y MÉTRICAS DE CONSISTENCIA La consistencia de aplicaciones replicadas ya ha sido bien definida en el dominio discreto [9, 10, 11, 12], pero se ha realizado poco trabajo relacionado en el dominio continuo. Mauve et al [1] han proporcionado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operaciones y resulta difícil que describa métodos basados en la transmisión de estado (por ejemplo, Lo siento, pero no puedo traducir \"DR).\" ya que no es una oración completa en inglés. ¿Hay algo más en lo que pueda ayudarte a traducir al español? Aquí presentamos una definición alternativa de consistencia en un dominio continuo, que se adapta bien a los métodos basados en la transmisión de estado. Dado dos sitios distintos i y j, que han replicado una entidad compartida e, en un tiempo dado t, los estados de e en los sitios i y j son Si(t) y Sj(t). DEFINICIÓN 1: los estados de e en los sitios i y j son consistentes en el tiempo t, si: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINICIÓN 2: los estados de e en los sitios i y j son consistentes entre los tiempos t1 y t2 (t1 < t2), si: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) En este artículo, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre sitios locales y remotos. Debido al retraso en la transmisión de la red, es difícil mantener los estados de las entidades compartidas absolutamente consistentes. Se necesitan métricas correspondientes para medir la consistencia de las entidades compartidas entre sitios locales y remotos. De(i, j, t) se puede utilizar como una métrica para medir el grado de consistencia en un momento específico. Si De(i, j, t1) > De(i, j, t2), se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e en el punto de tiempo t1 es menor que en el punto de tiempo t2. Si De(i, j, t) > De(l, k, t), se puede afirmar que, en el momento t, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. De manera similar, De(i, j, t1, t2) puede ser utilizada como una métrica para medir el grado de consistencia en un cierto período de tiempo. Si De(i, j, t1, t2) > De(i, j, t3, t4) y |t1 - t2| = |t3 - t4|, se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e entre los puntos temporales t1 y t2 es menor que entre los puntos temporales t3 y t4. Si De(i, j, t1, t2) > De(l, k, t1, t2), se puede afirmar que entre los puntos temporales t1 y t2, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. En DR, los estados de las entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades). Dadas dos ubicaciones distintas i y j, que han replicado una entidad compartida e, en un momento dado t, las posiciones de e en los sitios i y j son (xit, yit, zit) y (xjt, yjt, zjt), De(i, j, t) y D(i, j, t1, t2) podrían calcularse como: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se utilizan como métricas para medir la consistencia de las entidades compartidas entre sitios locales y remotos. 3. La inconsistencia en DR se puede dividir en dos secciones según el momento en que un sitio remoto recibe una actualización de estado. La inconsistencia antes de que un sitio remoto reciba una actualización de estado se conoce como inconsistencia antes, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se conoce como inconsistencia después. Antes de la inconsistencia y después de la inconsistencia son similares a los términos antes del error de exportación y después del error de exportación [8]. La inconsistencia se produce por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema. Al emplear la sincronización de relojes físicos, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior. La inconsistencia se produce por dos razones. La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el estado preciso y el estimado sea mayor que un umbral predefinido. La segunda razón es el retraso en la transmisión de la red, ya que una entidad compartida solo puede sincronizarse después de que los sitios remotos reciban la actualización de estado correspondiente. Figura 1. Los caminos de una entidad compartida mediante el uso de GS-DR. Por ejemplo, se asume que la velocidad de una entidad compartida es el único parámetro para predecir la posición de la entidad, y la posición actual de la entidad se puede calcular a partir de su última posición y la velocidad actual. Para simplificar la descripción, también se asume que solo hay dos sitios i y j en una sesión de juego, donde el sitio i actúa como sitio local del 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 y el sitio j actúa como sitio remoto, y t1 es el momento en que el sitio local actualiza el estado de la entidad compartida. La Figura 1 ilustra los caminos de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR. Al principio, las posiciones de la entidad compartida son las mismas en los sitios i y j y la velocidad de la entidad compartida es 0. Antes del momento t0, los caminos de la entidad compartida en los sitios i y j en la coordenada x son exactamente iguales. En el instante t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad en el eje x a v0. El sitio primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, que en este caso es 0, es mayor que un umbral predefinido. En el momento t1, el sitio i encuentra que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j. La actualización del estado contiene la posición y la velocidad de la entidad compartida en el momento t1 y el momento t1 también se adjunta como una marca de tiempo. En el instante de tiempo t2, la actualización del estado llega al sitio j, y el estado recibido y la desviación de tiempo entre los instantes t1 y t2 se utilizan para calcular la posición actual de la entidad compartida. Luego, el sitio j actualiza la posición y la velocidad de su entidad replicada, y las trayectorias de la entidad compartida en los sitios i y j se superponen nuevamente. A partir de la Figura 1, se puede observar que la inconsistencia posterior es 0, y la consistencia anterior está compuesta por dos partes, D1 y D2. D1 es De(i, j, t0, t1) y es causado por el mecanismo de filtrado de estado de DR. D2 es De(i, j, t1, t2) y es causado por el retraso de transmisión de red. 4. SINCRONIZACIÓN GLOBAL DE DR CON RETRASO LOCAL. A partir del análisis en la Sección 3, se puede observar que GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar eficazmente la inconsistencia anterior. Para disminuir la inconsistencia previa, proponemos GS-DR-LL, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa. En GS-DR-LL, el estado de una entidad compartida en un cierto momento t se nota como S = (t, pos, par 1, par 2, ……, par n), en el que pos significa la posición de la entidad y par 1 a par n significa los parámetros para calcular la posición de la entidad. Para simplificar la descripción de GS-DR-LL, se asume que solo hay una entidad compartida y un sitio remoto. Al comienzo de una sesión de juego, los estados de la entidad compartida son iguales en los sitios locales y remotos, con la misma posición p0 y parámetros pars0 (pars representa todos los parámetros). El sitio local mantiene tres estados: el estado real de la entidad Sreal, el estado predicho en el sitio remoto Sp-remote, y el estado más reciente actualizado en el sitio remoto Slate. El sitio remoto mantiene solo un estado Sremoto, que es el estado real de la entidad en el sitio remoto. Por lo tanto, al comienzo de una sesión de juego Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0). En GS-DR-LL, se asume que los relojes físicos de todos los sitios están sincronizados con una desviación de menos de 50 ms (utilizando NTP o reloj GPS). Además, es necesario hacer correcciones a un reloj físico de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo. Además, se asume que la escena del juego se actualiza a una frecuencia fija y T representa el intervalo de tiempo entre dos actualizaciones consecutivas, por ejemplo, si la frecuencia de actualización de la escena es de 50 Hz, T sería de 20 ms. n representa el valor de retraso utilizado por el retraso local, y t representa el tiempo físico actual. Después de actualizar la escena, el sitio local espera durante un tiempo constante T. Durante este período de tiempo, el sitio local recibe las operaciones del jugador y las almacena en una lista L. Todas las operaciones en L están ordenadas por su tiempo de emisión. Al final del período de tiempo T, el sitio local ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - T y t, en Slate para obtener el nuevo Slate, y también ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - (n + T) y t - n, en Sreal para obtener el nuevo Sreal. Además, el sitio local utiliza Sp-remote y métodos de predicción correspondientes para estimar el nuevo Sp-remote. Después de calcular los nuevos Slate, Sreal y Sp-remote, el sitio local compara si la diferencia entre el nuevo Slate y Spremote supera el umbral predefinido. Si SÍ, el sitio local envía un nuevo Slate al sitio remoto y Sp-remote se actualiza con el nuevo Slate. Ten en cuenta que la marca de tiempo de la actualización de estado enviada es t. Después de eso, el sitio local utiliza Sreal para actualizar la escena local y elimina las operaciones cuyo tiempo de emisión sea menor que t - n, de L. Después de actualizar la escena, el sitio remoto espera una cantidad constante de tiempo T. Durante este período de tiempo, el sitio remoto almacena las actualizaciones de estado recibidas en una lista R. Todas las actualizaciones de estado en R están ordenadas por sus marcas de tiempo. Al final del período de tiempo T, el sitio remoto verifica si R contiene actualizaciones de estado cuyas marcas de tiempo son menores que t - n. Tenga en cuenta que t es el tiempo físico actual y aumenta durante la transmisión de las actualizaciones de estado. Si es afirmativo, utiliza estas actualizaciones de estado y los métodos de predicción correspondientes para calcular el nuevo Sremoto; de lo contrario, utilizan Sremoto y los métodos de predicción correspondientes para estimar el nuevo Sremoto. Después de eso, el sitio local utiliza Sremote para actualizar la escena local y elimina las actualizaciones de estado cuyas marcas de tiempo son menores que t - n, de R. A partir de la descripción anterior, se puede ver que la principal diferencia entre GS-DR y GS-DR-LL es que GS-DR-LL utiliza las operaciones cuyo tiempo de emisión es menor que t - n para calcular Sreal. Eso significa que la escena vista por el jugador local es el resultado de las operaciones emitidas un período de tiempo (es decir, n) atrás. Mientras tanto, si los resultados de las operaciones emitidas hacen que la diferencia entre Slate y Sp-remote exceda un umbral predefinido, las actualizaciones de estado correspondientes se envían a los sitios remotos de inmediato. Lo mencionado es el mecanismo básico de GS-DR-LL. En el caso de múltiples entidades compartidas y sitios remotos, el sitio local calcula Slate, Sreal y Sp-remote para diferentes entidades compartidas respectivamente. Si hay varios Slate que deben ser transmitidos, el sitio local los empaqueta en una actualización de estado y luego los envía a todos los sitios remotos. La Figura 2 ilustra los caminos de una entidad compartida en el sitio local y en el sitio remoto al utilizar GS-DR y GS-DR-LL. Todas las condiciones son las mismas que las condiciones utilizadas en el ejemplo mencionado que describe GS-DR. Comparado con t1, t2 y n, T (es decir, el intervalo de tiempo entre dos actualizaciones consecutivas) es bastante pequeño y se ignora en la siguiente descripción. En el momento t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad de la entidad compartida de 0 a v0. Al utilizar GS-DR-LL, los resultados de la operación se actualizan en la escena local en el momento t0 + n. Sin embargo, la operación se utiliza inmediatamente para calcular Slate, por lo tanto, a pesar de GS-DR o GS-DR-LL, en el momento t1 el sitio i encuentra que la diferencia entre la posición precisa y la estimada es mayor que el umbral y envía una actualización de estado al sitio j. En el momento t2, la actualización del estado es recibida por el sitio remoto j. Suponiendo que la marca de tiempo de la actualización del estado es menor que t - n, el sitio j la utiliza para actualizar la escena local inmediatamente. En el 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006, con GS-DR, el período de tiempo antes de la inconsistencia es (t2 - t1) + (t1 - t0), mientras que disminuye a (t2 - t1 - n) + (t1 - t0) con la ayuda de GS-DR-LL. Ten en cuenta que t2 - t1 es causado por el retraso de transmisión de la red y t1 - t0 es causado por el mecanismo de filtrado de estado de DR. Si n es mayor que t2 - t1, GS-DR-LL puede eliminar la inconsistencia anterior causada por el retraso de transmisión de red, pero no puede eliminar la inconsistencia anterior causada por el mecanismo de filtrado de estado de DR (a menos que el umbral se establezca en 0). En juegos altamente interactivos, que requieren alta consistencia y podrían emplear GS-DR-LL, los resultados de las operaciones son bastante difíciles de estimar y se debe usar un umbral pequeño. Por lo tanto, en la práctica, la mayoría de las inconsistencias anteriores son causadas por el retraso en la transmisión de la red y GS-DR-LL tiene la capacidad de eliminar dichas inconsistencias anteriores. Figura 2. Los caminos de una entidad compartida utilizando GS-DR y GS-DR-LL. Para GS-DR-LL, la selección del valor de retardo n es muy importante, y tanto el retardo de transmisión de red como los efectos del retardo local en la interacción deben ser considerados. Según los resultados de investigaciones relacionadas con la Interacción Humano-Computadora (HCI), los humanos no pueden percibir el retraso impuesto en un sistema cuando es menor que un valor específico, y este valor específico depende tanto del sistema como de la tarea. Por ejemplo, en una interfaz gráfica de usuario, un retraso de aproximadamente 150 ms no puede ser percibido para la interacción con el teclado y el umbral se incrementa a 195 ms para la interacción con el ratón [13], y un retraso de hasta 50 ms es poco crítico para un juego de carreras de coches [5]. Por lo tanto, si el retraso de transmisión de la red es menor que el valor específico de un sistema de juego, n puede establecerse en el valor específico. La variable n puede ser establecida en términos de los efectos del rezago local en la interacción de un sistema [14]. En el caso de que se deba utilizar un n grande, algunos métodos de HCI (por ejemplo, eco [15]) pueden ser utilizados para aliviar los efectos negativos del gran retardo. En el caso de que n sea mayor que el retraso de transmisión de la red, GS-DR-LL puede eliminar la mayoría de las inconsistencias antes. La solicitud de retraso local tradicional requiere que el valor de retraso sea mayor que el retraso típico de transmisión de red, de lo contrario las reparaciones del estado inundarían el sistema. Sin embargo, GS-DR-LL permite que n sea menor que el retraso de transmisión de red típico. En este caso, la inconsistencia previa causada por el retraso en la transmisión de la red todavía existe, pero puede ser disminuida. 5. EVALUACIÓN DEL RENDIMIENTO Para evaluar GS-DR-LL y compararlo con GS-DR en una aplicación real, implementamos ambos métodos en un juego en red llamado spaceship [1]. Spaceship es un juego de computadora en red muy simple, en el cual los jugadores pueden controlar sus naves espaciales para acelerar, desacelerar, girar y disparar a las naves espaciales controladas por otros jugadores remotos con rayos láser. Si una nave espacial es alcanzada por un rayo láser, sus puntos de vida disminuyen en uno. Si los puntos de vida de una nave espacial disminuyen a 0, la nave espacial se elimina del juego y el jugador que la controla pierde el juego. En nuestra implementación práctica, GS-DR-LL y GS-DR coexistieron en el sistema de juego, y el banco de pruebas estaba compuesto por dos computadoras conectadas por Ethernet conmutado de 100 M, siendo una computadora el sitio local y la otra el sitio remoto. Para simular el retraso de transmisión de red, se desarrolló un módulo específico para retrasar todos los paquetes transmitidos entre las dos computadoras en función de un valor de retraso predefinido. El propósito principal de la evaluación del rendimiento es estudiar los efectos de GS-DR-LL en la disminución de la inconsistencia antes en un sistema de juego particular bajo diferentes umbrales, retardos y retrasos en la transmisión de red. Se utilizaron dos umbrales diferentes en la evaluación, uno es una desviación de 10 píxeles en posición o 15 grados en orientación, y el otro es de 4 píxeles o 5 grados. Se utilizaron seis combinaciones diferentes de retardo de lag y de transmisión de red en la evaluación, las cuales podían dividirse en dos categorías. En una categoría, el retardo se fijó en 300 ms y se utilizaron tres retardos de transmisión de red diferentes (100 ms, 300 ms y 500 ms). En la otra categoría, el retraso de transmisión de red se fijó en 800 ms y se utilizaron tres retrasos diferentes (100 ms, 300 ms y 500 ms). Por lo tanto, el número total de configuraciones utilizadas en la evaluación fue de 12 (2 × 6). El procedimiento de evaluación del desempeño estaba compuesto por tres pasos. En el primer paso, se emplearon dos participantes para jugar el juego, y se registraron las secuencias de operación. Basándose en los registros, se seleccionó una secuencia de suboperaciones que duró aproximadamente un minuto e incluyó diferentes operaciones (por ejemplo, acelerar, desacelerar y girar). En el segundo paso, primero se sincronizaron los relojes físicos de las dos computadoras. Bajo diferentes configuraciones y enfoques de mantenimiento de consistencia, la secuencia de suboperaciones seleccionada se reprodujo en una computadora, y esta hizo mover las dos naves espaciales, una local y la otra remota. Mientras tanto, las trayectorias de las naves espaciales en las dos computadoras fueron registradas por separado y se les llamó un par de trayectorias. Dado que hay 12 ajustes y 2 enfoques de mantenimiento de consistencia, el número total de parejas de pistas registradas fue de 24. En el último paso, a cada par de pistas se calculó la inconsistencia entre ellas, y la unidad de inconsistencia fue el píxel. Dado que los relojes físicos de las dos computadoras estaban sincronizados, el cálculo de la inconsistencia fue bastante simple. La inconsistencia en un momento particular fue la distancia entre las posiciones de las dos naves espaciales en ese momento (es decir, fórmula (3)). Para mostrar los resultados de la inconsistencia de manera clara, solo se utilizan partes de los resultados, que duran aproximadamente 7 segundos, en las siguientes figuras, y las figuras muestran casi las mismas partes de los resultados. Las figuras 3, 4 y 5 muestran los resultados de la inconsistencia cuando el retardo está fijo en 300 ms y los retrasos de transmisión de red son de 100, 300 y 500 ms. Se puede observar que la inconsistencia existe, pero la mayoría del tiempo es 0. Además, la inconsistencia aumenta con el retraso de transmisión de la red, pero disminuye con el umbral. Comparado con GS-DR, GS-DR-LL puede disminuir más la inconsistencia, y elimina la mayoría de la inconsistencia cuando la demora de transmisión de red es de 100 ms y el umbral es de 4 píxeles o 5 grados. Según los mecanismos de predicción y filtrado de estado de DR, la inconsistencia no puede ser completamente eliminada si el umbral no es 0. Con las definiciones de inconsistencia anterior e inconsistencia posterior, se puede indicar que GS-DR y GS-DR-LL pueden eliminar la inconsistencia posterior, y GS-DR-LL puede disminuir efectivamente la inconsistencia anterior. Se puede prever que con un retraso y umbral adecuados (por ejemplo, el retraso es mayor que la demora de transmisión de red y el umbral es 0), GS-DR-LL incluso puede eliminar la inconsistencia antes. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 3. Inconsistencia cuando el retraso de transmisión de red es de 100 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 4. Inconsistencia cuando el retraso de transmisión de red es de 300 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 5. Inconsistencia cuando el retraso de transmisión de red es de 500 ms y el retardo es de 300 ms. Las figuras 6, 7 y 8 muestran los resultados de la inconsistencia cuando el retraso de transmisión de la red está fijo en 800 ms y los retardos son de 100, 300 y 500 ms. Se puede observar que con GS-DR-LL antes de la inconsistencia disminuye con el rezago. En el retraso local tradicional, el retraso debe establecerse en un valor mayor que el retraso típico de transmisión de red, de lo contrario, las reparaciones de estado inundarían el sistema. A partir de los resultados anteriores, se puede ver que no existe ninguna restricción en la selección del retardo, con GS-DR-LL un sistema funcionaría bien incluso si el retardo es mucho menor que la demora de transmisión de la red. Del total de resultados anteriores, se puede indicar que tanto GS-DR como GSDR-LL pueden eliminarse después de la inconsistencia, y GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retardo. La cifra 6. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 7. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el lag es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 8. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 500 ms. 6. CONCLUSIONES En comparación con el DR tradicional, el GS-DR puede eliminar la inconsistencia posterior a través de la sincronización de relojes físicos, pero no puede abordar la inconsistencia anterior, lo que podría influir significativamente en la usabilidad y equidad de un juego. En este artículo, propusimos un método llamado GS-DR-LL, que combina el retraso local y GS-DR, para disminuir la inconsistencia previa mediante el retraso en la actualización de los resultados de ejecución de operaciones locales en la escena local. La evaluación del rendimiento indica que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. GS-DR-LL tiene implicaciones significativas para los enfoques de mantenimiento de consistencia. Primero, GS-DR-LL muestra que una mejora en DR no solo puede eliminar la inconsistencia posterior, sino también disminuir la inconsistencia anterior, con un retraso y umbral adecuados, incluso podría eliminarla antes de que ocurra. Como resultado, la aplicación de DR puede ser ampliamente expandida y podría ser utilizada en sistemas que requieran alta consistencia (por ejemplo, juegos altamente interactivos). Segundo, GS-DR-LL muestra que al combinar el retardo local y GSDR, se elimina la restricción en la selección del valor de retardo y se puede utilizar un retardo menor que el retraso típico de transmisión de red. Como resultado, la aplicación del retraso local puede ser ampliamente ampliada y podría ser utilizada en los sistemas que tienen un gran retraso de transmisión de red típico (por ejemplo,). Juegos basados en internet. REFERENCIAS [1] Mauve, M., Vogel, J., Hilt, V., y Effelsberg, W. Local-Lag y Timewarp: Proporcionando Consistencia para Aplicaciones Continuas Replicadas. IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.\n\nIEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., y Lau, R.W. Apoyando la coherencia continua en juegos en línea multijugador. En Proc. de ACM Multimedia, 2004, 388-391. [3] Pantel, L. y Wolf, L. Sobre la idoneidad de los esquemas de navegación inercial para juegos. En Proc. de NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., y Kunifuji, S. Un estudio experimental sobre los efectos del retardo de red en un entorno virtual háptico compartido cooperativo. Computadoras y Gráficos, Vol. 27, Núm. 2, 2003, 205-213. [5] Pantel, L. y Wolf, L.C. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En Proc. de NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., y Brooks, F.P. Efecto de la latencia en la presencia en entornos virtuales estresantes. En Proc. de IEEE VR, 2003, 141-148. [7] Bernier, Y.W. Métodos de Compensación de Latencia en el Diseño y Optimización del Protocolo de Juego Cliente/Servidor. En Proc. de la Conferencia de Desarrolladores de Juegos, 2001. [8] Aggarwal, S., Banavar, H., y Khandelwal, A. Precisión en juegos multijugador distribuidos basados en la navegación a ojo muerto. En Proc. de NetGames, 2004, 161-165. [9] Raynal, M. y Schiper, A. De la Consistencia Causal a la Consistencia Secuencial en Sistemas de Memoria Compartida. En Proc. de la Conferencia sobre Fundamentos de Tecnología del Software y Ciencias de la Computación Teórica, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., y Neiger, G. Memoria Causal. En Proc. del Taller Internacional sobre Algoritmos Distribuidos, 1991, 9-30. [11] Herlihy, M. y Wing, J. Linearizabilidad: una Condición de Corrección para Objetos Concurrentes. ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.\nTraducción: ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axiomas para el acceso a la memoria en sistemas de hardware asíncronos. ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. y Munson, E.V. ¿Es 100 milisegundos demasiado rápido? En Proc. de la Conferencia SIGCHI sobre Factores Humanos en Sistemas Informáticos, 2001, 317-318. [14] Chen, H., Chen, L., y Chen, G.C. Efectos del mecanismo de retraso local en el rendimiento de la cooperación en un sistema CVE de escritorio. Revista de Ciencias de la Computación y Tecnología, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., y Chen, G.C. Echo: un método para mejorar la calidad de interacción de CVEs. En Proc. de IEEE VR, 2005, 269-270. El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 7 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "accurate state": {
            "translated_key": "estado preciso",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the <br>accurate state</br> with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between <br>accurate state</br> and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [
                "After each update of its own entities, a site compares the <br>accurate state</br> with the estimated one.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between <br>accurate state</br> and the estimated one is larger than a predefined threshold."
            ],
            "translated_annotated_samples": [
                "Después de cada actualización de sus propias entidades, un sitio compara el <br>estado preciso</br> con el estimado.",
                "La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el <br>estado preciso</br> y el estimado sea mayor que un umbral predefinido."
            ],
            "translated_text": "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la distorsión temporal para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada. DR se basa en el mecanismo de transmisión del estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el <br>estado preciso</br> con el estimado. Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres. A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas. Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia. Debido al retraso en la transmisión de la red, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado. Para mantener una alta consistencia en la replicación distribuida (DR), Aggarwal et al [8] propusieron la Replicación Distribuida Globalmente Sincronizada (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega marcas de tiempo a las actualizaciones de estado transmitidas. La descripción detallada de GS-DR se puede encontrar en la Sección 3. Cuando hay una actualización de estado disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización de estado a los sitios remotos, lo que provoca que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión. Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar la inconsistencia anterior [8]. En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, GS-DR-LL puede lograr una mayor consistencia que GS-DR. El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona GS-DR-LL; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento. DEFINICIONES Y MÉTRICAS DE CONSISTENCIA La consistencia de aplicaciones replicadas ya ha sido bien definida en el dominio discreto [9, 10, 11, 12], pero se ha realizado poco trabajo relacionado en el dominio continuo. Mauve et al [1] han proporcionado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operaciones y resulta difícil que describa métodos basados en la transmisión de estado (por ejemplo, Lo siento, pero no puedo traducir \"DR).\" ya que no es una oración completa en inglés. ¿Hay algo más en lo que pueda ayudarte a traducir al español? Aquí presentamos una definición alternativa de consistencia en un dominio continuo, que se adapta bien a los métodos basados en la transmisión de estado. Dado dos sitios distintos i y j, que han replicado una entidad compartida e, en un tiempo dado t, los estados de e en los sitios i y j son Si(t) y Sj(t). DEFINICIÓN 1: los estados de e en los sitios i y j son consistentes en el tiempo t, si: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINICIÓN 2: los estados de e en los sitios i y j son consistentes entre los tiempos t1 y t2 (t1 < t2), si: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) En este artículo, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre sitios locales y remotos. Debido al retraso en la transmisión de la red, es difícil mantener los estados de las entidades compartidas absolutamente consistentes. Se necesitan métricas correspondientes para medir la consistencia de las entidades compartidas entre sitios locales y remotos. De(i, j, t) se puede utilizar como una métrica para medir el grado de consistencia en un momento específico. Si De(i, j, t1) > De(i, j, t2), se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e en el punto de tiempo t1 es menor que en el punto de tiempo t2. Si De(i, j, t) > De(l, k, t), se puede afirmar que, en el momento t, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. De manera similar, De(i, j, t1, t2) puede ser utilizada como una métrica para medir el grado de consistencia en un cierto período de tiempo. Si De(i, j, t1, t2) > De(i, j, t3, t4) y |t1 - t2| = |t3 - t4|, se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e entre los puntos temporales t1 y t2 es menor que entre los puntos temporales t3 y t4. Si De(i, j, t1, t2) > De(l, k, t1, t2), se puede afirmar que entre los puntos temporales t1 y t2, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. En DR, los estados de las entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades). Dadas dos ubicaciones distintas i y j, que han replicado una entidad compartida e, en un momento dado t, las posiciones de e en los sitios i y j son (xit, yit, zit) y (xjt, yjt, zjt), De(i, j, t) y D(i, j, t1, t2) podrían calcularse como: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se utilizan como métricas para medir la consistencia de las entidades compartidas entre sitios locales y remotos. 3. La inconsistencia en DR se puede dividir en dos secciones según el momento en que un sitio remoto recibe una actualización de estado. La inconsistencia antes de que un sitio remoto reciba una actualización de estado se conoce como inconsistencia antes, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se conoce como inconsistencia después. Antes de la inconsistencia y después de la inconsistencia son similares a los términos antes del error de exportación y después del error de exportación [8]. La inconsistencia se produce por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema. Al emplear la sincronización de relojes físicos, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior. La inconsistencia se produce por dos razones. La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el <br>estado preciso</br> y el estimado sea mayor que un umbral predefinido. La segunda razón es el retraso en la transmisión de la red, ya que una entidad compartida solo puede sincronizarse después de que los sitios remotos reciban la actualización de estado correspondiente. Figura 1. Los caminos de una entidad compartida mediante el uso de GS-DR. Por ejemplo, se asume que la velocidad de una entidad compartida es el único parámetro para predecir la posición de la entidad, y la posición actual de la entidad se puede calcular a partir de su última posición y la velocidad actual. Para simplificar la descripción, también se asume que solo hay dos sitios i y j en una sesión de juego, donde el sitio i actúa como sitio local del 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 y el sitio j actúa como sitio remoto, y t1 es el momento en que el sitio local actualiza el estado de la entidad compartida. La Figura 1 ilustra los caminos de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR. Al principio, las posiciones de la entidad compartida son las mismas en los sitios i y j y la velocidad de la entidad compartida es 0. Antes del momento t0, los caminos de la entidad compartida en los sitios i y j en la coordenada x son exactamente iguales. En el instante t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad en el eje x a v0. El sitio primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, que en este caso es 0, es mayor que un umbral predefinido. En el momento t1, el sitio i encuentra que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j. La actualización del estado contiene la posición y la velocidad de la entidad compartida en el momento t1 y el momento t1 también se adjunta como una marca de tiempo. En el instante de tiempo t2, la actualización del estado llega al sitio j, y el estado recibido y la desviación de tiempo entre los instantes t1 y t2 se utilizan para calcular la posición actual de la entidad compartida. Luego, el sitio j actualiza la posición y la velocidad de su entidad replicada, y las trayectorias de la entidad compartida en los sitios i y j se superponen nuevamente. A partir de la Figura 1, se puede observar que la inconsistencia posterior es 0, y la consistencia anterior está compuesta por dos partes, D1 y D2. D1 es De(i, j, t0, t1) y es causado por el mecanismo de filtrado de estado de DR. D2 es De(i, j, t1, t2) y es causado por el retraso de transmisión de red. 4. SINCRONIZACIÓN GLOBAL DE DR CON RETRASO LOCAL. A partir del análisis en la Sección 3, se puede observar que GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar eficazmente la inconsistencia anterior. Para disminuir la inconsistencia previa, proponemos GS-DR-LL, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa. En GS-DR-LL, el estado de una entidad compartida en un cierto momento t se nota como S = (t, pos, par 1, par 2, ……, par n), en el que pos significa la posición de la entidad y par 1 a par n significa los parámetros para calcular la posición de la entidad. Para simplificar la descripción de GS-DR-LL, se asume que solo hay una entidad compartida y un sitio remoto. Al comienzo de una sesión de juego, los estados de la entidad compartida son iguales en los sitios locales y remotos, con la misma posición p0 y parámetros pars0 (pars representa todos los parámetros). El sitio local mantiene tres estados: el estado real de la entidad Sreal, el estado predicho en el sitio remoto Sp-remote, y el estado más reciente actualizado en el sitio remoto Slate. El sitio remoto mantiene solo un estado Sremoto, que es el estado real de la entidad en el sitio remoto. Por lo tanto, al comienzo de una sesión de juego Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0). En GS-DR-LL, se asume que los relojes físicos de todos los sitios están sincronizados con una desviación de menos de 50 ms (utilizando NTP o reloj GPS). Además, es necesario hacer correcciones a un reloj físico de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo. Además, se asume que la escena del juego se actualiza a una frecuencia fija y T representa el intervalo de tiempo entre dos actualizaciones consecutivas, por ejemplo, si la frecuencia de actualización de la escena es de 50 Hz, T sería de 20 ms. n representa el valor de retraso utilizado por el retraso local, y t representa el tiempo físico actual. Después de actualizar la escena, el sitio local espera durante un tiempo constante T. Durante este período de tiempo, el sitio local recibe las operaciones del jugador y las almacena en una lista L. Todas las operaciones en L están ordenadas por su tiempo de emisión. Al final del período de tiempo T, el sitio local ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - T y t, en Slate para obtener el nuevo Slate, y también ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - (n + T) y t - n, en Sreal para obtener el nuevo Sreal. Además, el sitio local utiliza Sp-remote y métodos de predicción correspondientes para estimar el nuevo Sp-remote. Después de calcular los nuevos Slate, Sreal y Sp-remote, el sitio local compara si la diferencia entre el nuevo Slate y Spremote supera el umbral predefinido. Si SÍ, el sitio local envía un nuevo Slate al sitio remoto y Sp-remote se actualiza con el nuevo Slate. Ten en cuenta que la marca de tiempo de la actualización de estado enviada es t. Después de eso, el sitio local utiliza Sreal para actualizar la escena local y elimina las operaciones cuyo tiempo de emisión sea menor que t - n, de L. Después de actualizar la escena, el sitio remoto espera una cantidad constante de tiempo T. Durante este período de tiempo, el sitio remoto almacena las actualizaciones de estado recibidas en una lista R. Todas las actualizaciones de estado en R están ordenadas por sus marcas de tiempo. Al final del período de tiempo T, el sitio remoto verifica si R contiene actualizaciones de estado cuyas marcas de tiempo son menores que t - n. Tenga en cuenta que t es el tiempo físico actual y aumenta durante la transmisión de las actualizaciones de estado. Si es afirmativo, utiliza estas actualizaciones de estado y los métodos de predicción correspondientes para calcular el nuevo Sremoto; de lo contrario, utilizan Sremoto y los métodos de predicción correspondientes para estimar el nuevo Sremoto. Después de eso, el sitio local utiliza Sremote para actualizar la escena local y elimina las actualizaciones de estado cuyas marcas de tiempo son menores que t - n, de R. A partir de la descripción anterior, se puede ver que la principal diferencia entre GS-DR y GS-DR-LL es que GS-DR-LL utiliza las operaciones cuyo tiempo de emisión es menor que t - n para calcular Sreal. Eso significa que la escena vista por el jugador local es el resultado de las operaciones emitidas un período de tiempo (es decir, n) atrás. Mientras tanto, si los resultados de las operaciones emitidas hacen que la diferencia entre Slate y Sp-remote exceda un umbral predefinido, las actualizaciones de estado correspondientes se envían a los sitios remotos de inmediato. Lo mencionado es el mecanismo básico de GS-DR-LL. En el caso de múltiples entidades compartidas y sitios remotos, el sitio local calcula Slate, Sreal y Sp-remote para diferentes entidades compartidas respectivamente. Si hay varios Slate que deben ser transmitidos, el sitio local los empaqueta en una actualización de estado y luego los envía a todos los sitios remotos. La Figura 2 ilustra los caminos de una entidad compartida en el sitio local y en el sitio remoto al utilizar GS-DR y GS-DR-LL. Todas las condiciones son las mismas que las condiciones utilizadas en el ejemplo mencionado que describe GS-DR. Comparado con t1, t2 y n, T (es decir, el intervalo de tiempo entre dos actualizaciones consecutivas) es bastante pequeño y se ignora en la siguiente descripción. En el momento t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad de la entidad compartida de 0 a v0. Al utilizar GS-DR-LL, los resultados de la operación se actualizan en la escena local en el momento t0 + n. Sin embargo, la operación se utiliza inmediatamente para calcular Slate, por lo tanto, a pesar de GS-DR o GS-DR-LL, en el momento t1 el sitio i encuentra que la diferencia entre la posición precisa y la estimada es mayor que el umbral y envía una actualización de estado al sitio j. En el momento t2, la actualización del estado es recibida por el sitio remoto j. Suponiendo que la marca de tiempo de la actualización del estado es menor que t - n, el sitio j la utiliza para actualizar la escena local inmediatamente. En el 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006, con GS-DR, el período de tiempo antes de la inconsistencia es (t2 - t1) + (t1 - t0), mientras que disminuye a (t2 - t1 - n) + (t1 - t0) con la ayuda de GS-DR-LL. Ten en cuenta que t2 - t1 es causado por el retraso de transmisión de la red y t1 - t0 es causado por el mecanismo de filtrado de estado de DR. Si n es mayor que t2 - t1, GS-DR-LL puede eliminar la inconsistencia anterior causada por el retraso de transmisión de red, pero no puede eliminar la inconsistencia anterior causada por el mecanismo de filtrado de estado de DR (a menos que el umbral se establezca en 0). En juegos altamente interactivos, que requieren alta consistencia y podrían emplear GS-DR-LL, los resultados de las operaciones son bastante difíciles de estimar y se debe usar un umbral pequeño. Por lo tanto, en la práctica, la mayoría de las inconsistencias anteriores son causadas por el retraso en la transmisión de la red y GS-DR-LL tiene la capacidad de eliminar dichas inconsistencias anteriores. Figura 2. Los caminos de una entidad compartida utilizando GS-DR y GS-DR-LL. Para GS-DR-LL, la selección del valor de retardo n es muy importante, y tanto el retardo de transmisión de red como los efectos del retardo local en la interacción deben ser considerados. Según los resultados de investigaciones relacionadas con la Interacción Humano-Computadora (HCI), los humanos no pueden percibir el retraso impuesto en un sistema cuando es menor que un valor específico, y este valor específico depende tanto del sistema como de la tarea. Por ejemplo, en una interfaz gráfica de usuario, un retraso de aproximadamente 150 ms no puede ser percibido para la interacción con el teclado y el umbral se incrementa a 195 ms para la interacción con el ratón [13], y un retraso de hasta 50 ms es poco crítico para un juego de carreras de coches [5]. Por lo tanto, si el retraso de transmisión de la red es menor que el valor específico de un sistema de juego, n puede establecerse en el valor específico. La variable n puede ser establecida en términos de los efectos del rezago local en la interacción de un sistema [14]. En el caso de que se deba utilizar un n grande, algunos métodos de HCI (por ejemplo, eco [15]) pueden ser utilizados para aliviar los efectos negativos del gran retardo. En el caso de que n sea mayor que el retraso de transmisión de la red, GS-DR-LL puede eliminar la mayoría de las inconsistencias antes. La solicitud de retraso local tradicional requiere que el valor de retraso sea mayor que el retraso típico de transmisión de red, de lo contrario las reparaciones del estado inundarían el sistema. Sin embargo, GS-DR-LL permite que n sea menor que el retraso de transmisión de red típico. En este caso, la inconsistencia previa causada por el retraso en la transmisión de la red todavía existe, pero puede ser disminuida. 5. EVALUACIÓN DEL RENDIMIENTO Para evaluar GS-DR-LL y compararlo con GS-DR en una aplicación real, implementamos ambos métodos en un juego en red llamado spaceship [1]. Spaceship es un juego de computadora en red muy simple, en el cual los jugadores pueden controlar sus naves espaciales para acelerar, desacelerar, girar y disparar a las naves espaciales controladas por otros jugadores remotos con rayos láser. Si una nave espacial es alcanzada por un rayo láser, sus puntos de vida disminuyen en uno. Si los puntos de vida de una nave espacial disminuyen a 0, la nave espacial se elimina del juego y el jugador que la controla pierde el juego. En nuestra implementación práctica, GS-DR-LL y GS-DR coexistieron en el sistema de juego, y el banco de pruebas estaba compuesto por dos computadoras conectadas por Ethernet conmutado de 100 M, siendo una computadora el sitio local y la otra el sitio remoto. Para simular el retraso de transmisión de red, se desarrolló un módulo específico para retrasar todos los paquetes transmitidos entre las dos computadoras en función de un valor de retraso predefinido. El propósito principal de la evaluación del rendimiento es estudiar los efectos de GS-DR-LL en la disminución de la inconsistencia antes en un sistema de juego particular bajo diferentes umbrales, retardos y retrasos en la transmisión de red. Se utilizaron dos umbrales diferentes en la evaluación, uno es una desviación de 10 píxeles en posición o 15 grados en orientación, y el otro es de 4 píxeles o 5 grados. Se utilizaron seis combinaciones diferentes de retardo de lag y de transmisión de red en la evaluación, las cuales podían dividirse en dos categorías. En una categoría, el retardo se fijó en 300 ms y se utilizaron tres retardos de transmisión de red diferentes (100 ms, 300 ms y 500 ms). En la otra categoría, el retraso de transmisión de red se fijó en 800 ms y se utilizaron tres retrasos diferentes (100 ms, 300 ms y 500 ms). Por lo tanto, el número total de configuraciones utilizadas en la evaluación fue de 12 (2 × 6). El procedimiento de evaluación del desempeño estaba compuesto por tres pasos. En el primer paso, se emplearon dos participantes para jugar el juego, y se registraron las secuencias de operación. Basándose en los registros, se seleccionó una secuencia de suboperaciones que duró aproximadamente un minuto e incluyó diferentes operaciones (por ejemplo, acelerar, desacelerar y girar). En el segundo paso, primero se sincronizaron los relojes físicos de las dos computadoras. Bajo diferentes configuraciones y enfoques de mantenimiento de consistencia, la secuencia de suboperaciones seleccionada se reprodujo en una computadora, y esta hizo mover las dos naves espaciales, una local y la otra remota. Mientras tanto, las trayectorias de las naves espaciales en las dos computadoras fueron registradas por separado y se les llamó un par de trayectorias. Dado que hay 12 ajustes y 2 enfoques de mantenimiento de consistencia, el número total de parejas de pistas registradas fue de 24. En el último paso, a cada par de pistas se calculó la inconsistencia entre ellas, y la unidad de inconsistencia fue el píxel. Dado que los relojes físicos de las dos computadoras estaban sincronizados, el cálculo de la inconsistencia fue bastante simple. La inconsistencia en un momento particular fue la distancia entre las posiciones de las dos naves espaciales en ese momento (es decir, fórmula (3)). Para mostrar los resultados de la inconsistencia de manera clara, solo se utilizan partes de los resultados, que duran aproximadamente 7 segundos, en las siguientes figuras, y las figuras muestran casi las mismas partes de los resultados. Las figuras 3, 4 y 5 muestran los resultados de la inconsistencia cuando el retardo está fijo en 300 ms y los retrasos de transmisión de red son de 100, 300 y 500 ms. Se puede observar que la inconsistencia existe, pero la mayoría del tiempo es 0. Además, la inconsistencia aumenta con el retraso de transmisión de la red, pero disminuye con el umbral. Comparado con GS-DR, GS-DR-LL puede disminuir más la inconsistencia, y elimina la mayoría de la inconsistencia cuando la demora de transmisión de red es de 100 ms y el umbral es de 4 píxeles o 5 grados. Según los mecanismos de predicción y filtrado de estado de DR, la inconsistencia no puede ser completamente eliminada si el umbral no es 0. Con las definiciones de inconsistencia anterior e inconsistencia posterior, se puede indicar que GS-DR y GS-DR-LL pueden eliminar la inconsistencia posterior, y GS-DR-LL puede disminuir efectivamente la inconsistencia anterior. Se puede prever que con un retraso y umbral adecuados (por ejemplo, el retraso es mayor que la demora de transmisión de red y el umbral es 0), GS-DR-LL incluso puede eliminar la inconsistencia antes. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 3. Inconsistencia cuando el retraso de transmisión de red es de 100 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 4. Inconsistencia cuando el retraso de transmisión de red es de 300 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 5. Inconsistencia cuando el retraso de transmisión de red es de 500 ms y el retardo es de 300 ms. Las figuras 6, 7 y 8 muestran los resultados de la inconsistencia cuando el retraso de transmisión de la red está fijo en 800 ms y los retardos son de 100, 300 y 500 ms. Se puede observar que con GS-DR-LL antes de la inconsistencia disminuye con el rezago. En el retraso local tradicional, el retraso debe establecerse en un valor mayor que el retraso típico de transmisión de red, de lo contrario, las reparaciones de estado inundarían el sistema. A partir de los resultados anteriores, se puede ver que no existe ninguna restricción en la selección del retardo, con GS-DR-LL un sistema funcionaría bien incluso si el retardo es mucho menor que la demora de transmisión de la red. Del total de resultados anteriores, se puede indicar que tanto GS-DR como GSDR-LL pueden eliminarse después de la inconsistencia, y GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retardo. La cifra 6. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 7. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el lag es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 8. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 500 ms. 6. CONCLUSIONES En comparación con el DR tradicional, el GS-DR puede eliminar la inconsistencia posterior a través de la sincronización de relojes físicos, pero no puede abordar la inconsistencia anterior, lo que podría influir significativamente en la usabilidad y equidad de un juego. En este artículo, propusimos un método llamado GS-DR-LL, que combina el retraso local y GS-DR, para disminuir la inconsistencia previa mediante el retraso en la actualización de los resultados de ejecución de operaciones locales en la escena local. La evaluación del rendimiento indica que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. GS-DR-LL tiene implicaciones significativas para los enfoques de mantenimiento de consistencia. Primero, GS-DR-LL muestra que una mejora en DR no solo puede eliminar la inconsistencia posterior, sino también disminuir la inconsistencia anterior, con un retraso y umbral adecuados, incluso podría eliminarla antes de que ocurra. Como resultado, la aplicación de DR puede ser ampliamente expandida y podría ser utilizada en sistemas que requieran alta consistencia (por ejemplo, juegos altamente interactivos). Segundo, GS-DR-LL muestra que al combinar el retardo local y GSDR, se elimina la restricción en la selección del valor de retardo y se puede utilizar un retardo menor que el retraso típico de transmisión de red. Como resultado, la aplicación del retraso local puede ser ampliamente ampliada y podría ser utilizada en los sistemas que tienen un gran retraso de transmisión de red típico (por ejemplo,). Juegos basados en internet. REFERENCIAS [1] Mauve, M., Vogel, J., Hilt, V., y Effelsberg, W. Local-Lag y Timewarp: Proporcionando Consistencia para Aplicaciones Continuas Replicadas. IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.\n\nIEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., y Lau, R.W. Apoyando la coherencia continua en juegos en línea multijugador. En Proc. de ACM Multimedia, 2004, 388-391. [3] Pantel, L. y Wolf, L. Sobre la idoneidad de los esquemas de navegación inercial para juegos. En Proc. de NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., y Kunifuji, S. Un estudio experimental sobre los efectos del retardo de red en un entorno virtual háptico compartido cooperativo. Computadoras y Gráficos, Vol. 27, Núm. 2, 2003, 205-213. [5] Pantel, L. y Wolf, L.C. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En Proc. de NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., y Brooks, F.P. Efecto de la latencia en la presencia en entornos virtuales estresantes. En Proc. de IEEE VR, 2003, 141-148. [7] Bernier, Y.W. Métodos de Compensación de Latencia en el Diseño y Optimización del Protocolo de Juego Cliente/Servidor. En Proc. de la Conferencia de Desarrolladores de Juegos, 2001. [8] Aggarwal, S., Banavar, H., y Khandelwal, A. Precisión en juegos multijugador distribuidos basados en la navegación a ojo muerto. En Proc. de NetGames, 2004, 161-165. [9] Raynal, M. y Schiper, A. De la Consistencia Causal a la Consistencia Secuencial en Sistemas de Memoria Compartida. En Proc. de la Conferencia sobre Fundamentos de Tecnología del Software y Ciencias de la Computación Teórica, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., y Neiger, G. Memoria Causal. En Proc. del Taller Internacional sobre Algoritmos Distribuidos, 1991, 9-30. [11] Herlihy, M. y Wing, J. Linearizabilidad: una Condición de Corrección para Objetos Concurrentes. ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.\nTraducción: ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axiomas para el acceso a la memoria en sistemas de hardware asíncronos. ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. y Munson, E.V. ¿Es 100 milisegundos demasiado rápido? En Proc. de la Conferencia SIGCHI sobre Factores Humanos en Sistemas Informáticos, 2001, 317-318. [14] Chen, H., Chen, L., y Chen, G.C. Efectos del mecanismo de retraso local en el rendimiento de la cooperación en un sistema CVE de escritorio. Revista de Ciencias de la Computación y Tecnología, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., y Chen, G.C. Echo: un método para mejorar la calidad de interacción de CVEs. En Proc. de IEEE VR, 2005, 269-270. El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 7 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "correction": {
            "translated_key": "correcciones",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make <br>correction</br>s to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [
                "Furthermore, it is necessary to make <br>correction</br>s to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time."
            ],
            "translated_annotated_samples": [
                "Además, es necesario hacer <br>correcciones</br> a un reloj físico de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo."
            ],
            "translated_text": "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la distorsión temporal para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada. DR se basa en el mecanismo de transmisión del estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado. Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres. A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas. Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia. Debido al retraso en la transmisión de la red, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado. Para mantener una alta consistencia en la replicación distribuida (DR), Aggarwal et al [8] propusieron la Replicación Distribuida Globalmente Sincronizada (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega marcas de tiempo a las actualizaciones de estado transmitidas. La descripción detallada de GS-DR se puede encontrar en la Sección 3. Cuando hay una actualización de estado disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización de estado a los sitios remotos, lo que provoca que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión. Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar la inconsistencia anterior [8]. En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, GS-DR-LL puede lograr una mayor consistencia que GS-DR. El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona GS-DR-LL; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento. DEFINICIONES Y MÉTRICAS DE CONSISTENCIA La consistencia de aplicaciones replicadas ya ha sido bien definida en el dominio discreto [9, 10, 11, 12], pero se ha realizado poco trabajo relacionado en el dominio continuo. Mauve et al [1] han proporcionado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operaciones y resulta difícil que describa métodos basados en la transmisión de estado (por ejemplo, Lo siento, pero no puedo traducir \"DR).\" ya que no es una oración completa en inglés. ¿Hay algo más en lo que pueda ayudarte a traducir al español? Aquí presentamos una definición alternativa de consistencia en un dominio continuo, que se adapta bien a los métodos basados en la transmisión de estado. Dado dos sitios distintos i y j, que han replicado una entidad compartida e, en un tiempo dado t, los estados de e en los sitios i y j son Si(t) y Sj(t). DEFINICIÓN 1: los estados de e en los sitios i y j son consistentes en el tiempo t, si: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINICIÓN 2: los estados de e en los sitios i y j son consistentes entre los tiempos t1 y t2 (t1 < t2), si: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) En este artículo, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre sitios locales y remotos. Debido al retraso en la transmisión de la red, es difícil mantener los estados de las entidades compartidas absolutamente consistentes. Se necesitan métricas correspondientes para medir la consistencia de las entidades compartidas entre sitios locales y remotos. De(i, j, t) se puede utilizar como una métrica para medir el grado de consistencia en un momento específico. Si De(i, j, t1) > De(i, j, t2), se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e en el punto de tiempo t1 es menor que en el punto de tiempo t2. Si De(i, j, t) > De(l, k, t), se puede afirmar que, en el momento t, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. De manera similar, De(i, j, t1, t2) puede ser utilizada como una métrica para medir el grado de consistencia en un cierto período de tiempo. Si De(i, j, t1, t2) > De(i, j, t3, t4) y |t1 - t2| = |t3 - t4|, se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e entre los puntos temporales t1 y t2 es menor que entre los puntos temporales t3 y t4. Si De(i, j, t1, t2) > De(l, k, t1, t2), se puede afirmar que entre los puntos temporales t1 y t2, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. En DR, los estados de las entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades). Dadas dos ubicaciones distintas i y j, que han replicado una entidad compartida e, en un momento dado t, las posiciones de e en los sitios i y j son (xit, yit, zit) y (xjt, yjt, zjt), De(i, j, t) y D(i, j, t1, t2) podrían calcularse como: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se utilizan como métricas para medir la consistencia de las entidades compartidas entre sitios locales y remotos. 3. La inconsistencia en DR se puede dividir en dos secciones según el momento en que un sitio remoto recibe una actualización de estado. La inconsistencia antes de que un sitio remoto reciba una actualización de estado se conoce como inconsistencia antes, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se conoce como inconsistencia después. Antes de la inconsistencia y después de la inconsistencia son similares a los términos antes del error de exportación y después del error de exportación [8]. La inconsistencia se produce por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema. Al emplear la sincronización de relojes físicos, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior. La inconsistencia se produce por dos razones. La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el estado preciso y el estimado sea mayor que un umbral predefinido. La segunda razón es el retraso en la transmisión de la red, ya que una entidad compartida solo puede sincronizarse después de que los sitios remotos reciban la actualización de estado correspondiente. Figura 1. Los caminos de una entidad compartida mediante el uso de GS-DR. Por ejemplo, se asume que la velocidad de una entidad compartida es el único parámetro para predecir la posición de la entidad, y la posición actual de la entidad se puede calcular a partir de su última posición y la velocidad actual. Para simplificar la descripción, también se asume que solo hay dos sitios i y j en una sesión de juego, donde el sitio i actúa como sitio local del 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 y el sitio j actúa como sitio remoto, y t1 es el momento en que el sitio local actualiza el estado de la entidad compartida. La Figura 1 ilustra los caminos de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR. Al principio, las posiciones de la entidad compartida son las mismas en los sitios i y j y la velocidad de la entidad compartida es 0. Antes del momento t0, los caminos de la entidad compartida en los sitios i y j en la coordenada x son exactamente iguales. En el instante t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad en el eje x a v0. El sitio primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, que en este caso es 0, es mayor que un umbral predefinido. En el momento t1, el sitio i encuentra que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j. La actualización del estado contiene la posición y la velocidad de la entidad compartida en el momento t1 y el momento t1 también se adjunta como una marca de tiempo. En el instante de tiempo t2, la actualización del estado llega al sitio j, y el estado recibido y la desviación de tiempo entre los instantes t1 y t2 se utilizan para calcular la posición actual de la entidad compartida. Luego, el sitio j actualiza la posición y la velocidad de su entidad replicada, y las trayectorias de la entidad compartida en los sitios i y j se superponen nuevamente. A partir de la Figura 1, se puede observar que la inconsistencia posterior es 0, y la consistencia anterior está compuesta por dos partes, D1 y D2. D1 es De(i, j, t0, t1) y es causado por el mecanismo de filtrado de estado de DR. D2 es De(i, j, t1, t2) y es causado por el retraso de transmisión de red. 4. SINCRONIZACIÓN GLOBAL DE DR CON RETRASO LOCAL. A partir del análisis en la Sección 3, se puede observar que GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar eficazmente la inconsistencia anterior. Para disminuir la inconsistencia previa, proponemos GS-DR-LL, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa. En GS-DR-LL, el estado de una entidad compartida en un cierto momento t se nota como S = (t, pos, par 1, par 2, ……, par n), en el que pos significa la posición de la entidad y par 1 a par n significa los parámetros para calcular la posición de la entidad. Para simplificar la descripción de GS-DR-LL, se asume que solo hay una entidad compartida y un sitio remoto. Al comienzo de una sesión de juego, los estados de la entidad compartida son iguales en los sitios locales y remotos, con la misma posición p0 y parámetros pars0 (pars representa todos los parámetros). El sitio local mantiene tres estados: el estado real de la entidad Sreal, el estado predicho en el sitio remoto Sp-remote, y el estado más reciente actualizado en el sitio remoto Slate. El sitio remoto mantiene solo un estado Sremoto, que es el estado real de la entidad en el sitio remoto. Por lo tanto, al comienzo de una sesión de juego Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0). En GS-DR-LL, se asume que los relojes físicos de todos los sitios están sincronizados con una desviación de menos de 50 ms (utilizando NTP o reloj GPS). Además, es necesario hacer <br>correcciones</br> a un reloj físico de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo. Además, se asume que la escena del juego se actualiza a una frecuencia fija y T representa el intervalo de tiempo entre dos actualizaciones consecutivas, por ejemplo, si la frecuencia de actualización de la escena es de 50 Hz, T sería de 20 ms. n representa el valor de retraso utilizado por el retraso local, y t representa el tiempo físico actual. Después de actualizar la escena, el sitio local espera durante un tiempo constante T. Durante este período de tiempo, el sitio local recibe las operaciones del jugador y las almacena en una lista L. Todas las operaciones en L están ordenadas por su tiempo de emisión. Al final del período de tiempo T, el sitio local ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - T y t, en Slate para obtener el nuevo Slate, y también ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - (n + T) y t - n, en Sreal para obtener el nuevo Sreal. Además, el sitio local utiliza Sp-remote y métodos de predicción correspondientes para estimar el nuevo Sp-remote. Después de calcular los nuevos Slate, Sreal y Sp-remote, el sitio local compara si la diferencia entre el nuevo Slate y Spremote supera el umbral predefinido. Si SÍ, el sitio local envía un nuevo Slate al sitio remoto y Sp-remote se actualiza con el nuevo Slate. Ten en cuenta que la marca de tiempo de la actualización de estado enviada es t. Después de eso, el sitio local utiliza Sreal para actualizar la escena local y elimina las operaciones cuyo tiempo de emisión sea menor que t - n, de L. Después de actualizar la escena, el sitio remoto espera una cantidad constante de tiempo T. Durante este período de tiempo, el sitio remoto almacena las actualizaciones de estado recibidas en una lista R. Todas las actualizaciones de estado en R están ordenadas por sus marcas de tiempo. Al final del período de tiempo T, el sitio remoto verifica si R contiene actualizaciones de estado cuyas marcas de tiempo son menores que t - n. Tenga en cuenta que t es el tiempo físico actual y aumenta durante la transmisión de las actualizaciones de estado. Si es afirmativo, utiliza estas actualizaciones de estado y los métodos de predicción correspondientes para calcular el nuevo Sremoto; de lo contrario, utilizan Sremoto y los métodos de predicción correspondientes para estimar el nuevo Sremoto. Después de eso, el sitio local utiliza Sremote para actualizar la escena local y elimina las actualizaciones de estado cuyas marcas de tiempo son menores que t - n, de R. A partir de la descripción anterior, se puede ver que la principal diferencia entre GS-DR y GS-DR-LL es que GS-DR-LL utiliza las operaciones cuyo tiempo de emisión es menor que t - n para calcular Sreal. Eso significa que la escena vista por el jugador local es el resultado de las operaciones emitidas un período de tiempo (es decir, n) atrás. Mientras tanto, si los resultados de las operaciones emitidas hacen que la diferencia entre Slate y Sp-remote exceda un umbral predefinido, las actualizaciones de estado correspondientes se envían a los sitios remotos de inmediato. Lo mencionado es el mecanismo básico de GS-DR-LL. En el caso de múltiples entidades compartidas y sitios remotos, el sitio local calcula Slate, Sreal y Sp-remote para diferentes entidades compartidas respectivamente. Si hay varios Slate que deben ser transmitidos, el sitio local los empaqueta en una actualización de estado y luego los envía a todos los sitios remotos. La Figura 2 ilustra los caminos de una entidad compartida en el sitio local y en el sitio remoto al utilizar GS-DR y GS-DR-LL. Todas las condiciones son las mismas que las condiciones utilizadas en el ejemplo mencionado que describe GS-DR. Comparado con t1, t2 y n, T (es decir, el intervalo de tiempo entre dos actualizaciones consecutivas) es bastante pequeño y se ignora en la siguiente descripción. En el momento t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad de la entidad compartida de 0 a v0. Al utilizar GS-DR-LL, los resultados de la operación se actualizan en la escena local en el momento t0 + n. Sin embargo, la operación se utiliza inmediatamente para calcular Slate, por lo tanto, a pesar de GS-DR o GS-DR-LL, en el momento t1 el sitio i encuentra que la diferencia entre la posición precisa y la estimada es mayor que el umbral y envía una actualización de estado al sitio j. En el momento t2, la actualización del estado es recibida por el sitio remoto j. Suponiendo que la marca de tiempo de la actualización del estado es menor que t - n, el sitio j la utiliza para actualizar la escena local inmediatamente. En el 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006, con GS-DR, el período de tiempo antes de la inconsistencia es (t2 - t1) + (t1 - t0), mientras que disminuye a (t2 - t1 - n) + (t1 - t0) con la ayuda de GS-DR-LL. Ten en cuenta que t2 - t1 es causado por el retraso de transmisión de la red y t1 - t0 es causado por el mecanismo de filtrado de estado de DR. Si n es mayor que t2 - t1, GS-DR-LL puede eliminar la inconsistencia anterior causada por el retraso de transmisión de red, pero no puede eliminar la inconsistencia anterior causada por el mecanismo de filtrado de estado de DR (a menos que el umbral se establezca en 0). En juegos altamente interactivos, que requieren alta consistencia y podrían emplear GS-DR-LL, los resultados de las operaciones son bastante difíciles de estimar y se debe usar un umbral pequeño. Por lo tanto, en la práctica, la mayoría de las inconsistencias anteriores son causadas por el retraso en la transmisión de la red y GS-DR-LL tiene la capacidad de eliminar dichas inconsistencias anteriores. Figura 2. Los caminos de una entidad compartida utilizando GS-DR y GS-DR-LL. Para GS-DR-LL, la selección del valor de retardo n es muy importante, y tanto el retardo de transmisión de red como los efectos del retardo local en la interacción deben ser considerados. Según los resultados de investigaciones relacionadas con la Interacción Humano-Computadora (HCI), los humanos no pueden percibir el retraso impuesto en un sistema cuando es menor que un valor específico, y este valor específico depende tanto del sistema como de la tarea. Por ejemplo, en una interfaz gráfica de usuario, un retraso de aproximadamente 150 ms no puede ser percibido para la interacción con el teclado y el umbral se incrementa a 195 ms para la interacción con el ratón [13], y un retraso de hasta 50 ms es poco crítico para un juego de carreras de coches [5]. Por lo tanto, si el retraso de transmisión de la red es menor que el valor específico de un sistema de juego, n puede establecerse en el valor específico. La variable n puede ser establecida en términos de los efectos del rezago local en la interacción de un sistema [14]. En el caso de que se deba utilizar un n grande, algunos métodos de HCI (por ejemplo, eco [15]) pueden ser utilizados para aliviar los efectos negativos del gran retardo. En el caso de que n sea mayor que el retraso de transmisión de la red, GS-DR-LL puede eliminar la mayoría de las inconsistencias antes. La solicitud de retraso local tradicional requiere que el valor de retraso sea mayor que el retraso típico de transmisión de red, de lo contrario las reparaciones del estado inundarían el sistema. Sin embargo, GS-DR-LL permite que n sea menor que el retraso de transmisión de red típico. En este caso, la inconsistencia previa causada por el retraso en la transmisión de la red todavía existe, pero puede ser disminuida. 5. EVALUACIÓN DEL RENDIMIENTO Para evaluar GS-DR-LL y compararlo con GS-DR en una aplicación real, implementamos ambos métodos en un juego en red llamado spaceship [1]. Spaceship es un juego de computadora en red muy simple, en el cual los jugadores pueden controlar sus naves espaciales para acelerar, desacelerar, girar y disparar a las naves espaciales controladas por otros jugadores remotos con rayos láser. Si una nave espacial es alcanzada por un rayo láser, sus puntos de vida disminuyen en uno. Si los puntos de vida de una nave espacial disminuyen a 0, la nave espacial se elimina del juego y el jugador que la controla pierde el juego. En nuestra implementación práctica, GS-DR-LL y GS-DR coexistieron en el sistema de juego, y el banco de pruebas estaba compuesto por dos computadoras conectadas por Ethernet conmutado de 100 M, siendo una computadora el sitio local y la otra el sitio remoto. Para simular el retraso de transmisión de red, se desarrolló un módulo específico para retrasar todos los paquetes transmitidos entre las dos computadoras en función de un valor de retraso predefinido. El propósito principal de la evaluación del rendimiento es estudiar los efectos de GS-DR-LL en la disminución de la inconsistencia antes en un sistema de juego particular bajo diferentes umbrales, retardos y retrasos en la transmisión de red. Se utilizaron dos umbrales diferentes en la evaluación, uno es una desviación de 10 píxeles en posición o 15 grados en orientación, y el otro es de 4 píxeles o 5 grados. Se utilizaron seis combinaciones diferentes de retardo de lag y de transmisión de red en la evaluación, las cuales podían dividirse en dos categorías. En una categoría, el retardo se fijó en 300 ms y se utilizaron tres retardos de transmisión de red diferentes (100 ms, 300 ms y 500 ms). En la otra categoría, el retraso de transmisión de red se fijó en 800 ms y se utilizaron tres retrasos diferentes (100 ms, 300 ms y 500 ms). Por lo tanto, el número total de configuraciones utilizadas en la evaluación fue de 12 (2 × 6). El procedimiento de evaluación del desempeño estaba compuesto por tres pasos. En el primer paso, se emplearon dos participantes para jugar el juego, y se registraron las secuencias de operación. Basándose en los registros, se seleccionó una secuencia de suboperaciones que duró aproximadamente un minuto e incluyó diferentes operaciones (por ejemplo, acelerar, desacelerar y girar). En el segundo paso, primero se sincronizaron los relojes físicos de las dos computadoras. Bajo diferentes configuraciones y enfoques de mantenimiento de consistencia, la secuencia de suboperaciones seleccionada se reprodujo en una computadora, y esta hizo mover las dos naves espaciales, una local y la otra remota. Mientras tanto, las trayectorias de las naves espaciales en las dos computadoras fueron registradas por separado y se les llamó un par de trayectorias. Dado que hay 12 ajustes y 2 enfoques de mantenimiento de consistencia, el número total de parejas de pistas registradas fue de 24. En el último paso, a cada par de pistas se calculó la inconsistencia entre ellas, y la unidad de inconsistencia fue el píxel. Dado que los relojes físicos de las dos computadoras estaban sincronizados, el cálculo de la inconsistencia fue bastante simple. La inconsistencia en un momento particular fue la distancia entre las posiciones de las dos naves espaciales en ese momento (es decir, fórmula (3)). Para mostrar los resultados de la inconsistencia de manera clara, solo se utilizan partes de los resultados, que duran aproximadamente 7 segundos, en las siguientes figuras, y las figuras muestran casi las mismas partes de los resultados. Las figuras 3, 4 y 5 muestran los resultados de la inconsistencia cuando el retardo está fijo en 300 ms y los retrasos de transmisión de red son de 100, 300 y 500 ms. Se puede observar que la inconsistencia existe, pero la mayoría del tiempo es 0. Además, la inconsistencia aumenta con el retraso de transmisión de la red, pero disminuye con el umbral. Comparado con GS-DR, GS-DR-LL puede disminuir más la inconsistencia, y elimina la mayoría de la inconsistencia cuando la demora de transmisión de red es de 100 ms y el umbral es de 4 píxeles o 5 grados. Según los mecanismos de predicción y filtrado de estado de DR, la inconsistencia no puede ser completamente eliminada si el umbral no es 0. Con las definiciones de inconsistencia anterior e inconsistencia posterior, se puede indicar que GS-DR y GS-DR-LL pueden eliminar la inconsistencia posterior, y GS-DR-LL puede disminuir efectivamente la inconsistencia anterior. Se puede prever que con un retraso y umbral adecuados (por ejemplo, el retraso es mayor que la demora de transmisión de red y el umbral es 0), GS-DR-LL incluso puede eliminar la inconsistencia antes. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 3. Inconsistencia cuando el retraso de transmisión de red es de 100 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 4. Inconsistencia cuando el retraso de transmisión de red es de 300 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 5. Inconsistencia cuando el retraso de transmisión de red es de 500 ms y el retardo es de 300 ms. Las figuras 6, 7 y 8 muestran los resultados de la inconsistencia cuando el retraso de transmisión de la red está fijo en 800 ms y los retardos son de 100, 300 y 500 ms. Se puede observar que con GS-DR-LL antes de la inconsistencia disminuye con el rezago. En el retraso local tradicional, el retraso debe establecerse en un valor mayor que el retraso típico de transmisión de red, de lo contrario, las reparaciones de estado inundarían el sistema. A partir de los resultados anteriores, se puede ver que no existe ninguna restricción en la selección del retardo, con GS-DR-LL un sistema funcionaría bien incluso si el retardo es mucho menor que la demora de transmisión de la red. Del total de resultados anteriores, se puede indicar que tanto GS-DR como GSDR-LL pueden eliminarse después de la inconsistencia, y GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retardo. La cifra 6. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 7. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el lag es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 8. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 500 ms. 6. CONCLUSIONES En comparación con el DR tradicional, el GS-DR puede eliminar la inconsistencia posterior a través de la sincronización de relojes físicos, pero no puede abordar la inconsistencia anterior, lo que podría influir significativamente en la usabilidad y equidad de un juego. En este artículo, propusimos un método llamado GS-DR-LL, que combina el retraso local y GS-DR, para disminuir la inconsistencia previa mediante el retraso en la actualización de los resultados de ejecución de operaciones locales en la escena local. La evaluación del rendimiento indica que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. GS-DR-LL tiene implicaciones significativas para los enfoques de mantenimiento de consistencia. Primero, GS-DR-LL muestra que una mejora en DR no solo puede eliminar la inconsistencia posterior, sino también disminuir la inconsistencia anterior, con un retraso y umbral adecuados, incluso podría eliminarla antes de que ocurra. Como resultado, la aplicación de DR puede ser ampliamente expandida y podría ser utilizada en sistemas que requieran alta consistencia (por ejemplo, juegos altamente interactivos). Segundo, GS-DR-LL muestra que al combinar el retardo local y GSDR, se elimina la restricción en la selección del valor de retardo y se puede utilizar un retardo menor que el retraso típico de transmisión de red. Como resultado, la aplicación del retraso local puede ser ampliamente ampliada y podría ser utilizada en los sistemas que tienen un gran retraso de transmisión de red típico (por ejemplo,). Juegos basados en internet. REFERENCIAS [1] Mauve, M., Vogel, J., Hilt, V., y Effelsberg, W. Local-Lag y Timewarp: Proporcionando Consistencia para Aplicaciones Continuas Replicadas. IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.\n\nIEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., y Lau, R.W. Apoyando la coherencia continua en juegos en línea multijugador. En Proc. de ACM Multimedia, 2004, 388-391. [3] Pantel, L. y Wolf, L. Sobre la idoneidad de los esquemas de navegación inercial para juegos. En Proc. de NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., y Kunifuji, S. Un estudio experimental sobre los efectos del retardo de red en un entorno virtual háptico compartido cooperativo. Computadoras y Gráficos, Vol. 27, Núm. 2, 2003, 205-213. [5] Pantel, L. y Wolf, L.C. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En Proc. de NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., y Brooks, F.P. Efecto de la latencia en la presencia en entornos virtuales estresantes. En Proc. de IEEE VR, 2003, 141-148. [7] Bernier, Y.W. Métodos de Compensación de Latencia en el Diseño y Optimización del Protocolo de Juego Cliente/Servidor. En Proc. de la Conferencia de Desarrolladores de Juegos, 2001. [8] Aggarwal, S., Banavar, H., y Khandelwal, A. Precisión en juegos multijugador distribuidos basados en la navegación a ojo muerto. En Proc. de NetGames, 2004, 161-165. [9] Raynal, M. y Schiper, A. De la Consistencia Causal a la Consistencia Secuencial en Sistemas de Memoria Compartida. En Proc. de la Conferencia sobre Fundamentos de Tecnología del Software y Ciencias de la Computación Teórica, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., y Neiger, G. Memoria Causal. En Proc. del Taller Internacional sobre Algoritmos Distribuidos, 1991, 9-30. [11] Herlihy, M. y Wing, J. Linearizabilidad: una Condición de Corrección para Objetos Concurrentes. ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.\nTraducción: ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axiomas para el acceso a la memoria en sistemas de hardware asíncronos. ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. y Munson, E.V. ¿Es 100 milisegundos demasiado rápido? En Proc. de la Conferencia SIGCHI sobre Factores Humanos en Sistemas Informáticos, 2001, 317-318. [14] Chen, H., Chen, L., y Chen, G.C. Efectos del mecanismo de retraso local en el rendimiento de la cooperación en un sistema CVE de escritorio. Revista de Ciencias de la Computación y Tecnología, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., y Chen, G.C. Echo: un método para mejorar la calidad de interacción de CVEs. En Proc. de IEEE VR, 2005, 269-270. El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 7 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "physical clock": {
            "translated_key": "relojes físicos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing <br>physical clock</br> synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a <br>physical clock</br> in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [
                "By employing <br>physical clock</br> synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Furthermore, it is necessary to make corrections to a <br>physical clock</br> in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time."
            ],
            "translated_annotated_samples": [
                "Al emplear la sincronización de <br>relojes físicos</br>, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior.",
                "Además, es necesario hacer correcciones a un <br>reloj físico</br> de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo."
            ],
            "translated_text": "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la distorsión temporal para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada. DR se basa en el mecanismo de transmisión del estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado. Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres. A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas. Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia. Debido al retraso en la transmisión de la red, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado. Para mantener una alta consistencia en la replicación distribuida (DR), Aggarwal et al [8] propusieron la Replicación Distribuida Globalmente Sincronizada (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega marcas de tiempo a las actualizaciones de estado transmitidas. La descripción detallada de GS-DR se puede encontrar en la Sección 3. Cuando hay una actualización de estado disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización de estado a los sitios remotos, lo que provoca que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión. Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar la inconsistencia anterior [8]. En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, GS-DR-LL puede lograr una mayor consistencia que GS-DR. El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona GS-DR-LL; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento. DEFINICIONES Y MÉTRICAS DE CONSISTENCIA La consistencia de aplicaciones replicadas ya ha sido bien definida en el dominio discreto [9, 10, 11, 12], pero se ha realizado poco trabajo relacionado en el dominio continuo. Mauve et al [1] han proporcionado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operaciones y resulta difícil que describa métodos basados en la transmisión de estado (por ejemplo, Lo siento, pero no puedo traducir \"DR).\" ya que no es una oración completa en inglés. ¿Hay algo más en lo que pueda ayudarte a traducir al español? Aquí presentamos una definición alternativa de consistencia en un dominio continuo, que se adapta bien a los métodos basados en la transmisión de estado. Dado dos sitios distintos i y j, que han replicado una entidad compartida e, en un tiempo dado t, los estados de e en los sitios i y j son Si(t) y Sj(t). DEFINICIÓN 1: los estados de e en los sitios i y j son consistentes en el tiempo t, si: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINICIÓN 2: los estados de e en los sitios i y j son consistentes entre los tiempos t1 y t2 (t1 < t2), si: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) En este artículo, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre sitios locales y remotos. Debido al retraso en la transmisión de la red, es difícil mantener los estados de las entidades compartidas absolutamente consistentes. Se necesitan métricas correspondientes para medir la consistencia de las entidades compartidas entre sitios locales y remotos. De(i, j, t) se puede utilizar como una métrica para medir el grado de consistencia en un momento específico. Si De(i, j, t1) > De(i, j, t2), se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e en el punto de tiempo t1 es menor que en el punto de tiempo t2. Si De(i, j, t) > De(l, k, t), se puede afirmar que, en el momento t, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. De manera similar, De(i, j, t1, t2) puede ser utilizada como una métrica para medir el grado de consistencia en un cierto período de tiempo. Si De(i, j, t1, t2) > De(i, j, t3, t4) y |t1 - t2| = |t3 - t4|, se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e entre los puntos temporales t1 y t2 es menor que entre los puntos temporales t3 y t4. Si De(i, j, t1, t2) > De(l, k, t1, t2), se puede afirmar que entre los puntos temporales t1 y t2, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. En DR, los estados de las entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades). Dadas dos ubicaciones distintas i y j, que han replicado una entidad compartida e, en un momento dado t, las posiciones de e en los sitios i y j son (xit, yit, zit) y (xjt, yjt, zjt), De(i, j, t) y D(i, j, t1, t2) podrían calcularse como: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se utilizan como métricas para medir la consistencia de las entidades compartidas entre sitios locales y remotos. 3. La inconsistencia en DR se puede dividir en dos secciones según el momento en que un sitio remoto recibe una actualización de estado. La inconsistencia antes de que un sitio remoto reciba una actualización de estado se conoce como inconsistencia antes, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se conoce como inconsistencia después. Antes de la inconsistencia y después de la inconsistencia son similares a los términos antes del error de exportación y después del error de exportación [8]. La inconsistencia se produce por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema. Al emplear la sincronización de <br>relojes físicos</br>, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior. La inconsistencia se produce por dos razones. La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el estado preciso y el estimado sea mayor que un umbral predefinido. La segunda razón es el retraso en la transmisión de la red, ya que una entidad compartida solo puede sincronizarse después de que los sitios remotos reciban la actualización de estado correspondiente. Figura 1. Los caminos de una entidad compartida mediante el uso de GS-DR. Por ejemplo, se asume que la velocidad de una entidad compartida es el único parámetro para predecir la posición de la entidad, y la posición actual de la entidad se puede calcular a partir de su última posición y la velocidad actual. Para simplificar la descripción, también se asume que solo hay dos sitios i y j en una sesión de juego, donde el sitio i actúa como sitio local del 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 y el sitio j actúa como sitio remoto, y t1 es el momento en que el sitio local actualiza el estado de la entidad compartida. La Figura 1 ilustra los caminos de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR. Al principio, las posiciones de la entidad compartida son las mismas en los sitios i y j y la velocidad de la entidad compartida es 0. Antes del momento t0, los caminos de la entidad compartida en los sitios i y j en la coordenada x son exactamente iguales. En el instante t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad en el eje x a v0. El sitio primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, que en este caso es 0, es mayor que un umbral predefinido. En el momento t1, el sitio i encuentra que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j. La actualización del estado contiene la posición y la velocidad de la entidad compartida en el momento t1 y el momento t1 también se adjunta como una marca de tiempo. En el instante de tiempo t2, la actualización del estado llega al sitio j, y el estado recibido y la desviación de tiempo entre los instantes t1 y t2 se utilizan para calcular la posición actual de la entidad compartida. Luego, el sitio j actualiza la posición y la velocidad de su entidad replicada, y las trayectorias de la entidad compartida en los sitios i y j se superponen nuevamente. A partir de la Figura 1, se puede observar que la inconsistencia posterior es 0, y la consistencia anterior está compuesta por dos partes, D1 y D2. D1 es De(i, j, t0, t1) y es causado por el mecanismo de filtrado de estado de DR. D2 es De(i, j, t1, t2) y es causado por el retraso de transmisión de red. 4. SINCRONIZACIÓN GLOBAL DE DR CON RETRASO LOCAL. A partir del análisis en la Sección 3, se puede observar que GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar eficazmente la inconsistencia anterior. Para disminuir la inconsistencia previa, proponemos GS-DR-LL, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa. En GS-DR-LL, el estado de una entidad compartida en un cierto momento t se nota como S = (t, pos, par 1, par 2, ……, par n), en el que pos significa la posición de la entidad y par 1 a par n significa los parámetros para calcular la posición de la entidad. Para simplificar la descripción de GS-DR-LL, se asume que solo hay una entidad compartida y un sitio remoto. Al comienzo de una sesión de juego, los estados de la entidad compartida son iguales en los sitios locales y remotos, con la misma posición p0 y parámetros pars0 (pars representa todos los parámetros). El sitio local mantiene tres estados: el estado real de la entidad Sreal, el estado predicho en el sitio remoto Sp-remote, y el estado más reciente actualizado en el sitio remoto Slate. El sitio remoto mantiene solo un estado Sremoto, que es el estado real de la entidad en el sitio remoto. Por lo tanto, al comienzo de una sesión de juego Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0). En GS-DR-LL, se asume que los relojes físicos de todos los sitios están sincronizados con una desviación de menos de 50 ms (utilizando NTP o reloj GPS). Además, es necesario hacer correcciones a un <br>reloj físico</br> de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo. Además, se asume que la escena del juego se actualiza a una frecuencia fija y T representa el intervalo de tiempo entre dos actualizaciones consecutivas, por ejemplo, si la frecuencia de actualización de la escena es de 50 Hz, T sería de 20 ms. n representa el valor de retraso utilizado por el retraso local, y t representa el tiempo físico actual. Después de actualizar la escena, el sitio local espera durante un tiempo constante T. Durante este período de tiempo, el sitio local recibe las operaciones del jugador y las almacena en una lista L. Todas las operaciones en L están ordenadas por su tiempo de emisión. Al final del período de tiempo T, el sitio local ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - T y t, en Slate para obtener el nuevo Slate, y también ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - (n + T) y t - n, en Sreal para obtener el nuevo Sreal. Además, el sitio local utiliza Sp-remote y métodos de predicción correspondientes para estimar el nuevo Sp-remote. Después de calcular los nuevos Slate, Sreal y Sp-remote, el sitio local compara si la diferencia entre el nuevo Slate y Spremote supera el umbral predefinido. Si SÍ, el sitio local envía un nuevo Slate al sitio remoto y Sp-remote se actualiza con el nuevo Slate. Ten en cuenta que la marca de tiempo de la actualización de estado enviada es t. Después de eso, el sitio local utiliza Sreal para actualizar la escena local y elimina las operaciones cuyo tiempo de emisión sea menor que t - n, de L. Después de actualizar la escena, el sitio remoto espera una cantidad constante de tiempo T. Durante este período de tiempo, el sitio remoto almacena las actualizaciones de estado recibidas en una lista R. Todas las actualizaciones de estado en R están ordenadas por sus marcas de tiempo. Al final del período de tiempo T, el sitio remoto verifica si R contiene actualizaciones de estado cuyas marcas de tiempo son menores que t - n. Tenga en cuenta que t es el tiempo físico actual y aumenta durante la transmisión de las actualizaciones de estado. Si es afirmativo, utiliza estas actualizaciones de estado y los métodos de predicción correspondientes para calcular el nuevo Sremoto; de lo contrario, utilizan Sremoto y los métodos de predicción correspondientes para estimar el nuevo Sremoto. Después de eso, el sitio local utiliza Sremote para actualizar la escena local y elimina las actualizaciones de estado cuyas marcas de tiempo son menores que t - n, de R. A partir de la descripción anterior, se puede ver que la principal diferencia entre GS-DR y GS-DR-LL es que GS-DR-LL utiliza las operaciones cuyo tiempo de emisión es menor que t - n para calcular Sreal. Eso significa que la escena vista por el jugador local es el resultado de las operaciones emitidas un período de tiempo (es decir, n) atrás. Mientras tanto, si los resultados de las operaciones emitidas hacen que la diferencia entre Slate y Sp-remote exceda un umbral predefinido, las actualizaciones de estado correspondientes se envían a los sitios remotos de inmediato. Lo mencionado es el mecanismo básico de GS-DR-LL. En el caso de múltiples entidades compartidas y sitios remotos, el sitio local calcula Slate, Sreal y Sp-remote para diferentes entidades compartidas respectivamente. Si hay varios Slate que deben ser transmitidos, el sitio local los empaqueta en una actualización de estado y luego los envía a todos los sitios remotos. La Figura 2 ilustra los caminos de una entidad compartida en el sitio local y en el sitio remoto al utilizar GS-DR y GS-DR-LL. Todas las condiciones son las mismas que las condiciones utilizadas en el ejemplo mencionado que describe GS-DR. Comparado con t1, t2 y n, T (es decir, el intervalo de tiempo entre dos actualizaciones consecutivas) es bastante pequeño y se ignora en la siguiente descripción. En el momento t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad de la entidad compartida de 0 a v0. Al utilizar GS-DR-LL, los resultados de la operación se actualizan en la escena local en el momento t0 + n. Sin embargo, la operación se utiliza inmediatamente para calcular Slate, por lo tanto, a pesar de GS-DR o GS-DR-LL, en el momento t1 el sitio i encuentra que la diferencia entre la posición precisa y la estimada es mayor que el umbral y envía una actualización de estado al sitio j. En el momento t2, la actualización del estado es recibida por el sitio remoto j. Suponiendo que la marca de tiempo de la actualización del estado es menor que t - n, el sitio j la utiliza para actualizar la escena local inmediatamente. En el 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006, con GS-DR, el período de tiempo antes de la inconsistencia es (t2 - t1) + (t1 - t0), mientras que disminuye a (t2 - t1 - n) + (t1 - t0) con la ayuda de GS-DR-LL. Ten en cuenta que t2 - t1 es causado por el retraso de transmisión de la red y t1 - t0 es causado por el mecanismo de filtrado de estado de DR. Si n es mayor que t2 - t1, GS-DR-LL puede eliminar la inconsistencia anterior causada por el retraso de transmisión de red, pero no puede eliminar la inconsistencia anterior causada por el mecanismo de filtrado de estado de DR (a menos que el umbral se establezca en 0). En juegos altamente interactivos, que requieren alta consistencia y podrían emplear GS-DR-LL, los resultados de las operaciones son bastante difíciles de estimar y se debe usar un umbral pequeño. Por lo tanto, en la práctica, la mayoría de las inconsistencias anteriores son causadas por el retraso en la transmisión de la red y GS-DR-LL tiene la capacidad de eliminar dichas inconsistencias anteriores. Figura 2. Los caminos de una entidad compartida utilizando GS-DR y GS-DR-LL. Para GS-DR-LL, la selección del valor de retardo n es muy importante, y tanto el retardo de transmisión de red como los efectos del retardo local en la interacción deben ser considerados. Según los resultados de investigaciones relacionadas con la Interacción Humano-Computadora (HCI), los humanos no pueden percibir el retraso impuesto en un sistema cuando es menor que un valor específico, y este valor específico depende tanto del sistema como de la tarea. Por ejemplo, en una interfaz gráfica de usuario, un retraso de aproximadamente 150 ms no puede ser percibido para la interacción con el teclado y el umbral se incrementa a 195 ms para la interacción con el ratón [13], y un retraso de hasta 50 ms es poco crítico para un juego de carreras de coches [5]. Por lo tanto, si el retraso de transmisión de la red es menor que el valor específico de un sistema de juego, n puede establecerse en el valor específico. La variable n puede ser establecida en términos de los efectos del rezago local en la interacción de un sistema [14]. En el caso de que se deba utilizar un n grande, algunos métodos de HCI (por ejemplo, eco [15]) pueden ser utilizados para aliviar los efectos negativos del gran retardo. En el caso de que n sea mayor que el retraso de transmisión de la red, GS-DR-LL puede eliminar la mayoría de las inconsistencias antes. La solicitud de retraso local tradicional requiere que el valor de retraso sea mayor que el retraso típico de transmisión de red, de lo contrario las reparaciones del estado inundarían el sistema. Sin embargo, GS-DR-LL permite que n sea menor que el retraso de transmisión de red típico. En este caso, la inconsistencia previa causada por el retraso en la transmisión de la red todavía existe, pero puede ser disminuida. 5. EVALUACIÓN DEL RENDIMIENTO Para evaluar GS-DR-LL y compararlo con GS-DR en una aplicación real, implementamos ambos métodos en un juego en red llamado spaceship [1]. Spaceship es un juego de computadora en red muy simple, en el cual los jugadores pueden controlar sus naves espaciales para acelerar, desacelerar, girar y disparar a las naves espaciales controladas por otros jugadores remotos con rayos láser. Si una nave espacial es alcanzada por un rayo láser, sus puntos de vida disminuyen en uno. Si los puntos de vida de una nave espacial disminuyen a 0, la nave espacial se elimina del juego y el jugador que la controla pierde el juego. En nuestra implementación práctica, GS-DR-LL y GS-DR coexistieron en el sistema de juego, y el banco de pruebas estaba compuesto por dos computadoras conectadas por Ethernet conmutado de 100 M, siendo una computadora el sitio local y la otra el sitio remoto. Para simular el retraso de transmisión de red, se desarrolló un módulo específico para retrasar todos los paquetes transmitidos entre las dos computadoras en función de un valor de retraso predefinido. El propósito principal de la evaluación del rendimiento es estudiar los efectos de GS-DR-LL en la disminución de la inconsistencia antes en un sistema de juego particular bajo diferentes umbrales, retardos y retrasos en la transmisión de red. Se utilizaron dos umbrales diferentes en la evaluación, uno es una desviación de 10 píxeles en posición o 15 grados en orientación, y el otro es de 4 píxeles o 5 grados. Se utilizaron seis combinaciones diferentes de retardo de lag y de transmisión de red en la evaluación, las cuales podían dividirse en dos categorías. En una categoría, el retardo se fijó en 300 ms y se utilizaron tres retardos de transmisión de red diferentes (100 ms, 300 ms y 500 ms). En la otra categoría, el retraso de transmisión de red se fijó en 800 ms y se utilizaron tres retrasos diferentes (100 ms, 300 ms y 500 ms). Por lo tanto, el número total de configuraciones utilizadas en la evaluación fue de 12 (2 × 6). El procedimiento de evaluación del desempeño estaba compuesto por tres pasos. En el primer paso, se emplearon dos participantes para jugar el juego, y se registraron las secuencias de operación. Basándose en los registros, se seleccionó una secuencia de suboperaciones que duró aproximadamente un minuto e incluyó diferentes operaciones (por ejemplo, acelerar, desacelerar y girar). En el segundo paso, primero se sincronizaron los relojes físicos de las dos computadoras. Bajo diferentes configuraciones y enfoques de mantenimiento de consistencia, la secuencia de suboperaciones seleccionada se reprodujo en una computadora, y esta hizo mover las dos naves espaciales, una local y la otra remota. Mientras tanto, las trayectorias de las naves espaciales en las dos computadoras fueron registradas por separado y se les llamó un par de trayectorias. Dado que hay 12 ajustes y 2 enfoques de mantenimiento de consistencia, el número total de parejas de pistas registradas fue de 24. En el último paso, a cada par de pistas se calculó la inconsistencia entre ellas, y la unidad de inconsistencia fue el píxel. Dado que los relojes físicos de las dos computadoras estaban sincronizados, el cálculo de la inconsistencia fue bastante simple. La inconsistencia en un momento particular fue la distancia entre las posiciones de las dos naves espaciales en ese momento (es decir, fórmula (3)). Para mostrar los resultados de la inconsistencia de manera clara, solo se utilizan partes de los resultados, que duran aproximadamente 7 segundos, en las siguientes figuras, y las figuras muestran casi las mismas partes de los resultados. Las figuras 3, 4 y 5 muestran los resultados de la inconsistencia cuando el retardo está fijo en 300 ms y los retrasos de transmisión de red son de 100, 300 y 500 ms. Se puede observar que la inconsistencia existe, pero la mayoría del tiempo es 0. Además, la inconsistencia aumenta con el retraso de transmisión de la red, pero disminuye con el umbral. Comparado con GS-DR, GS-DR-LL puede disminuir más la inconsistencia, y elimina la mayoría de la inconsistencia cuando la demora de transmisión de red es de 100 ms y el umbral es de 4 píxeles o 5 grados. Según los mecanismos de predicción y filtrado de estado de DR, la inconsistencia no puede ser completamente eliminada si el umbral no es 0. Con las definiciones de inconsistencia anterior e inconsistencia posterior, se puede indicar que GS-DR y GS-DR-LL pueden eliminar la inconsistencia posterior, y GS-DR-LL puede disminuir efectivamente la inconsistencia anterior. Se puede prever que con un retraso y umbral adecuados (por ejemplo, el retraso es mayor que la demora de transmisión de red y el umbral es 0), GS-DR-LL incluso puede eliminar la inconsistencia antes. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 3. Inconsistencia cuando el retraso de transmisión de red es de 100 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 4. Inconsistencia cuando el retraso de transmisión de red es de 300 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 5. Inconsistencia cuando el retraso de transmisión de red es de 500 ms y el retardo es de 300 ms. Las figuras 6, 7 y 8 muestran los resultados de la inconsistencia cuando el retraso de transmisión de la red está fijo en 800 ms y los retardos son de 100, 300 y 500 ms. Se puede observar que con GS-DR-LL antes de la inconsistencia disminuye con el rezago. En el retraso local tradicional, el retraso debe establecerse en un valor mayor que el retraso típico de transmisión de red, de lo contrario, las reparaciones de estado inundarían el sistema. A partir de los resultados anteriores, se puede ver que no existe ninguna restricción en la selección del retardo, con GS-DR-LL un sistema funcionaría bien incluso si el retardo es mucho menor que la demora de transmisión de la red. Del total de resultados anteriores, se puede indicar que tanto GS-DR como GSDR-LL pueden eliminarse después de la inconsistencia, y GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retardo. La cifra 6. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 7. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el lag es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 8. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 500 ms. 6. CONCLUSIONES En comparación con el DR tradicional, el GS-DR puede eliminar la inconsistencia posterior a través de la sincronización de relojes físicos, pero no puede abordar la inconsistencia anterior, lo que podría influir significativamente en la usabilidad y equidad de un juego. En este artículo, propusimos un método llamado GS-DR-LL, que combina el retraso local y GS-DR, para disminuir la inconsistencia previa mediante el retraso en la actualización de los resultados de ejecución de operaciones locales en la escena local. La evaluación del rendimiento indica que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. GS-DR-LL tiene implicaciones significativas para los enfoques de mantenimiento de consistencia. Primero, GS-DR-LL muestra que una mejora en DR no solo puede eliminar la inconsistencia posterior, sino también disminuir la inconsistencia anterior, con un retraso y umbral adecuados, incluso podría eliminarla antes de que ocurra. Como resultado, la aplicación de DR puede ser ampliamente expandida y podría ser utilizada en sistemas que requieran alta consistencia (por ejemplo, juegos altamente interactivos). Segundo, GS-DR-LL muestra que al combinar el retardo local y GSDR, se elimina la restricción en la selección del valor de retardo y se puede utilizar un retardo menor que el retraso típico de transmisión de red. Como resultado, la aplicación del retraso local puede ser ampliamente ampliada y podría ser utilizada en los sistemas que tienen un gran retraso de transmisión de red típico (por ejemplo,). Juegos basados en internet. REFERENCIAS [1] Mauve, M., Vogel, J., Hilt, V., y Effelsberg, W. Local-Lag y Timewarp: Proporcionando Consistencia para Aplicaciones Continuas Replicadas. IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.\n\nIEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., y Lau, R.W. Apoyando la coherencia continua en juegos en línea multijugador. En Proc. de ACM Multimedia, 2004, 388-391. [3] Pantel, L. y Wolf, L. Sobre la idoneidad de los esquemas de navegación inercial para juegos. En Proc. de NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., y Kunifuji, S. Un estudio experimental sobre los efectos del retardo de red en un entorno virtual háptico compartido cooperativo. Computadoras y Gráficos, Vol. 27, Núm. 2, 2003, 205-213. [5] Pantel, L. y Wolf, L.C. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En Proc. de NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., y Brooks, F.P. Efecto de la latencia en la presencia en entornos virtuales estresantes. En Proc. de IEEE VR, 2003, 141-148. [7] Bernier, Y.W. Métodos de Compensación de Latencia en el Diseño y Optimización del Protocolo de Juego Cliente/Servidor. En Proc. de la Conferencia de Desarrolladores de Juegos, 2001. [8] Aggarwal, S., Banavar, H., y Khandelwal, A. Precisión en juegos multijugador distribuidos basados en la navegación a ojo muerto. En Proc. de NetGames, 2004, 161-165. [9] Raynal, M. y Schiper, A. De la Consistencia Causal a la Consistencia Secuencial en Sistemas de Memoria Compartida. En Proc. de la Conferencia sobre Fundamentos de Tecnología del Software y Ciencias de la Computación Teórica, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., y Neiger, G. Memoria Causal. En Proc. del Taller Internacional sobre Algoritmos Distribuidos, 1991, 9-30. [11] Herlihy, M. y Wing, J. Linearizabilidad: una Condición de Corrección para Objetos Concurrentes. ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.\nTraducción: ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axiomas para el acceso a la memoria en sistemas de hardware asíncronos. ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. y Munson, E.V. ¿Es 100 milisegundos demasiado rápido? En Proc. de la Conferencia SIGCHI sobre Factores Humanos en Sistemas Informáticos, 2001, 317-318. [14] Chen, H., Chen, L., y Chen, G.C. Efectos del mecanismo de retraso local en el rendimiento de la cooperación en un sistema CVE de escritorio. Revista de Ciencias de la Computación y Tecnología, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., y Chen, G.C. Echo: un método para mejorar la calidad de interacción de CVEs. En Proc. de IEEE VR, 2005, 269-270. El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 7 ",
            "candidates": [],
            "error": [
                [
                    "relojes físicos",
                    "reloj físico"
                ]
            ]
        },
        "usability and fairness": {
            "translated_key": "usabilidad y equidad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the <br>usability and fairness</br> of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the <br>usability and fairness</br> of a game."
            ],
            "translated_annotated_samples": [
                "CONCLUSIONES En comparación con el DR tradicional, el GS-DR puede eliminar la inconsistencia posterior a través de la sincronización de relojes físicos, pero no puede abordar la inconsistencia anterior, lo que podría influir significativamente en la <br>usabilidad y equidad</br> de un juego."
            ],
            "translated_text": "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado DR Globalmente Sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la distorsión temporal para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada. DR se basa en el mecanismo de transmisión del estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado. Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres. A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas. Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia. Debido al retraso en la transmisión de la red, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado. Para mantener una alta consistencia en la replicación distribuida (DR), Aggarwal et al [8] propusieron la Replicación Distribuida Globalmente Sincronizada (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega marcas de tiempo a las actualizaciones de estado transmitidas. La descripción detallada de GS-DR se puede encontrar en la Sección 3. Cuando hay una actualización de estado disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización de estado a los sitios remotos, lo que provoca que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión. Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar la inconsistencia anterior [8]. En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (GS-DR-LL), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, GS-DR-LL puede lograr una mayor consistencia que GS-DR. El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona GS-DR-LL; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento. DEFINICIONES Y MÉTRICAS DE CONSISTENCIA La consistencia de aplicaciones replicadas ya ha sido bien definida en el dominio discreto [9, 10, 11, 12], pero se ha realizado poco trabajo relacionado en el dominio continuo. Mauve et al [1] han proporcionado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operaciones y resulta difícil que describa métodos basados en la transmisión de estado (por ejemplo, Lo siento, pero no puedo traducir \"DR).\" ya que no es una oración completa en inglés. ¿Hay algo más en lo que pueda ayudarte a traducir al español? Aquí presentamos una definición alternativa de consistencia en un dominio continuo, que se adapta bien a los métodos basados en la transmisión de estado. Dado dos sitios distintos i y j, que han replicado una entidad compartida e, en un tiempo dado t, los estados de e en los sitios i y j son Si(t) y Sj(t). DEFINICIÓN 1: los estados de e en los sitios i y j son consistentes en el tiempo t, si: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINICIÓN 2: los estados de e en los sitios i y j son consistentes entre los tiempos t1 y t2 (t1 < t2), si: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) En este artículo, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre sitios locales y remotos. Debido al retraso en la transmisión de la red, es difícil mantener los estados de las entidades compartidas absolutamente consistentes. Se necesitan métricas correspondientes para medir la consistencia de las entidades compartidas entre sitios locales y remotos. De(i, j, t) se puede utilizar como una métrica para medir el grado de consistencia en un momento específico. Si De(i, j, t1) > De(i, j, t2), se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e en el punto de tiempo t1 es menor que en el punto de tiempo t2. Si De(i, j, t) > De(l, k, t), se puede afirmar que, en el momento t, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. De manera similar, De(i, j, t1, t2) puede ser utilizada como una métrica para medir el grado de consistencia en un cierto período de tiempo. Si De(i, j, t1, t2) > De(i, j, t3, t4) y |t1 - t2| = |t3 - t4|, se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e entre los puntos temporales t1 y t2 es menor que entre los puntos temporales t3 y t4. Si De(i, j, t1, t2) > De(l, k, t1, t2), se puede afirmar que entre los puntos temporales t1 y t2, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. En DR, los estados de las entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades). Dadas dos ubicaciones distintas i y j, que han replicado una entidad compartida e, en un momento dado t, las posiciones de e en los sitios i y j son (xit, yit, zit) y (xjt, yjt, zjt), De(i, j, t) y D(i, j, t1, t2) podrían calcularse como: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se utilizan como métricas para medir la consistencia de las entidades compartidas entre sitios locales y remotos. 3. La inconsistencia en DR se puede dividir en dos secciones según el momento en que un sitio remoto recibe una actualización de estado. La inconsistencia antes de que un sitio remoto reciba una actualización de estado se conoce como inconsistencia antes, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se conoce como inconsistencia después. Antes de la inconsistencia y después de la inconsistencia son similares a los términos antes del error de exportación y después del error de exportación [8]. La inconsistencia se produce por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema. Al emplear la sincronización de relojes físicos, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior. La inconsistencia se produce por dos razones. La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el estado preciso y el estimado sea mayor que un umbral predefinido. La segunda razón es el retraso en la transmisión de la red, ya que una entidad compartida solo puede sincronizarse después de que los sitios remotos reciban la actualización de estado correspondiente. Figura 1. Los caminos de una entidad compartida mediante el uso de GS-DR. Por ejemplo, se asume que la velocidad de una entidad compartida es el único parámetro para predecir la posición de la entidad, y la posición actual de la entidad se puede calcular a partir de su última posición y la velocidad actual. Para simplificar la descripción, también se asume que solo hay dos sitios i y j en una sesión de juego, donde el sitio i actúa como sitio local del 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 y el sitio j actúa como sitio remoto, y t1 es el momento en que el sitio local actualiza el estado de la entidad compartida. La Figura 1 ilustra los caminos de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR. Al principio, las posiciones de la entidad compartida son las mismas en los sitios i y j y la velocidad de la entidad compartida es 0. Antes del momento t0, los caminos de la entidad compartida en los sitios i y j en la coordenada x son exactamente iguales. En el instante t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad en el eje x a v0. El sitio primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, que en este caso es 0, es mayor que un umbral predefinido. En el momento t1, el sitio i encuentra que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j. La actualización del estado contiene la posición y la velocidad de la entidad compartida en el momento t1 y el momento t1 también se adjunta como una marca de tiempo. En el instante de tiempo t2, la actualización del estado llega al sitio j, y el estado recibido y la desviación de tiempo entre los instantes t1 y t2 se utilizan para calcular la posición actual de la entidad compartida. Luego, el sitio j actualiza la posición y la velocidad de su entidad replicada, y las trayectorias de la entidad compartida en los sitios i y j se superponen nuevamente. A partir de la Figura 1, se puede observar que la inconsistencia posterior es 0, y la consistencia anterior está compuesta por dos partes, D1 y D2. D1 es De(i, j, t0, t1) y es causado por el mecanismo de filtrado de estado de DR. D2 es De(i, j, t1, t2) y es causado por el retraso de transmisión de red. 4. SINCRONIZACIÓN GLOBAL DE DR CON RETRASO LOCAL. A partir del análisis en la Sección 3, se puede observar que GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar eficazmente la inconsistencia anterior. Para disminuir la inconsistencia previa, proponemos GS-DR-LL, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa. En GS-DR-LL, el estado de una entidad compartida en un cierto momento t se nota como S = (t, pos, par 1, par 2, ……, par n), en el que pos significa la posición de la entidad y par 1 a par n significa los parámetros para calcular la posición de la entidad. Para simplificar la descripción de GS-DR-LL, se asume que solo hay una entidad compartida y un sitio remoto. Al comienzo de una sesión de juego, los estados de la entidad compartida son iguales en los sitios locales y remotos, con la misma posición p0 y parámetros pars0 (pars representa todos los parámetros). El sitio local mantiene tres estados: el estado real de la entidad Sreal, el estado predicho en el sitio remoto Sp-remote, y el estado más reciente actualizado en el sitio remoto Slate. El sitio remoto mantiene solo un estado Sremoto, que es el estado real de la entidad en el sitio remoto. Por lo tanto, al comienzo de una sesión de juego Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0). En GS-DR-LL, se asume que los relojes físicos de todos los sitios están sincronizados con una desviación de menos de 50 ms (utilizando NTP o reloj GPS). Además, es necesario hacer correcciones a un reloj físico de manera que no resulte en disminuir el valor del reloj, por ejemplo, ralentizando o deteniendo el reloj por un período de tiempo. Además, se asume que la escena del juego se actualiza a una frecuencia fija y T representa el intervalo de tiempo entre dos actualizaciones consecutivas, por ejemplo, si la frecuencia de actualización de la escena es de 50 Hz, T sería de 20 ms. n representa el valor de retraso utilizado por el retraso local, y t representa el tiempo físico actual. Después de actualizar la escena, el sitio local espera durante un tiempo constante T. Durante este período de tiempo, el sitio local recibe las operaciones del jugador y las almacena en una lista L. Todas las operaciones en L están ordenadas por su tiempo de emisión. Al final del período de tiempo T, el sitio local ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - T y t, en Slate para obtener el nuevo Slate, y también ejecuta todas las operaciones almacenadas, cuyo tiempo de emisión está entre t - (n + T) y t - n, en Sreal para obtener el nuevo Sreal. Además, el sitio local utiliza Sp-remote y métodos de predicción correspondientes para estimar el nuevo Sp-remote. Después de calcular los nuevos Slate, Sreal y Sp-remote, el sitio local compara si la diferencia entre el nuevo Slate y Spremote supera el umbral predefinido. Si SÍ, el sitio local envía un nuevo Slate al sitio remoto y Sp-remote se actualiza con el nuevo Slate. Ten en cuenta que la marca de tiempo de la actualización de estado enviada es t. Después de eso, el sitio local utiliza Sreal para actualizar la escena local y elimina las operaciones cuyo tiempo de emisión sea menor que t - n, de L. Después de actualizar la escena, el sitio remoto espera una cantidad constante de tiempo T. Durante este período de tiempo, el sitio remoto almacena las actualizaciones de estado recibidas en una lista R. Todas las actualizaciones de estado en R están ordenadas por sus marcas de tiempo. Al final del período de tiempo T, el sitio remoto verifica si R contiene actualizaciones de estado cuyas marcas de tiempo son menores que t - n. Tenga en cuenta que t es el tiempo físico actual y aumenta durante la transmisión de las actualizaciones de estado. Si es afirmativo, utiliza estas actualizaciones de estado y los métodos de predicción correspondientes para calcular el nuevo Sremoto; de lo contrario, utilizan Sremoto y los métodos de predicción correspondientes para estimar el nuevo Sremoto. Después de eso, el sitio local utiliza Sremote para actualizar la escena local y elimina las actualizaciones de estado cuyas marcas de tiempo son menores que t - n, de R. A partir de la descripción anterior, se puede ver que la principal diferencia entre GS-DR y GS-DR-LL es que GS-DR-LL utiliza las operaciones cuyo tiempo de emisión es menor que t - n para calcular Sreal. Eso significa que la escena vista por el jugador local es el resultado de las operaciones emitidas un período de tiempo (es decir, n) atrás. Mientras tanto, si los resultados de las operaciones emitidas hacen que la diferencia entre Slate y Sp-remote exceda un umbral predefinido, las actualizaciones de estado correspondientes se envían a los sitios remotos de inmediato. Lo mencionado es el mecanismo básico de GS-DR-LL. En el caso de múltiples entidades compartidas y sitios remotos, el sitio local calcula Slate, Sreal y Sp-remote para diferentes entidades compartidas respectivamente. Si hay varios Slate que deben ser transmitidos, el sitio local los empaqueta en una actualización de estado y luego los envía a todos los sitios remotos. La Figura 2 ilustra los caminos de una entidad compartida en el sitio local y en el sitio remoto al utilizar GS-DR y GS-DR-LL. Todas las condiciones son las mismas que las condiciones utilizadas en el ejemplo mencionado que describe GS-DR. Comparado con t1, t2 y n, T (es decir, el intervalo de tiempo entre dos actualizaciones consecutivas) es bastante pequeño y se ignora en la siguiente descripción. En el momento t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad de la entidad compartida de 0 a v0. Al utilizar GS-DR-LL, los resultados de la operación se actualizan en la escena local en el momento t0 + n. Sin embargo, la operación se utiliza inmediatamente para calcular Slate, por lo tanto, a pesar de GS-DR o GS-DR-LL, en el momento t1 el sitio i encuentra que la diferencia entre la posición precisa y la estimada es mayor que el umbral y envía una actualización de estado al sitio j. En el momento t2, la actualización del estado es recibida por el sitio remoto j. Suponiendo que la marca de tiempo de la actualización del estado es menor que t - n, el sitio j la utiliza para actualizar la escena local inmediatamente. En el 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006, con GS-DR, el período de tiempo antes de la inconsistencia es (t2 - t1) + (t1 - t0), mientras que disminuye a (t2 - t1 - n) + (t1 - t0) con la ayuda de GS-DR-LL. Ten en cuenta que t2 - t1 es causado por el retraso de transmisión de la red y t1 - t0 es causado por el mecanismo de filtrado de estado de DR. Si n es mayor que t2 - t1, GS-DR-LL puede eliminar la inconsistencia anterior causada por el retraso de transmisión de red, pero no puede eliminar la inconsistencia anterior causada por el mecanismo de filtrado de estado de DR (a menos que el umbral se establezca en 0). En juegos altamente interactivos, que requieren alta consistencia y podrían emplear GS-DR-LL, los resultados de las operaciones son bastante difíciles de estimar y se debe usar un umbral pequeño. Por lo tanto, en la práctica, la mayoría de las inconsistencias anteriores son causadas por el retraso en la transmisión de la red y GS-DR-LL tiene la capacidad de eliminar dichas inconsistencias anteriores. Figura 2. Los caminos de una entidad compartida utilizando GS-DR y GS-DR-LL. Para GS-DR-LL, la selección del valor de retardo n es muy importante, y tanto el retardo de transmisión de red como los efectos del retardo local en la interacción deben ser considerados. Según los resultados de investigaciones relacionadas con la Interacción Humano-Computadora (HCI), los humanos no pueden percibir el retraso impuesto en un sistema cuando es menor que un valor específico, y este valor específico depende tanto del sistema como de la tarea. Por ejemplo, en una interfaz gráfica de usuario, un retraso de aproximadamente 150 ms no puede ser percibido para la interacción con el teclado y el umbral se incrementa a 195 ms para la interacción con el ratón [13], y un retraso de hasta 50 ms es poco crítico para un juego de carreras de coches [5]. Por lo tanto, si el retraso de transmisión de la red es menor que el valor específico de un sistema de juego, n puede establecerse en el valor específico. La variable n puede ser establecida en términos de los efectos del rezago local en la interacción de un sistema [14]. En el caso de que se deba utilizar un n grande, algunos métodos de HCI (por ejemplo, eco [15]) pueden ser utilizados para aliviar los efectos negativos del gran retardo. En el caso de que n sea mayor que el retraso de transmisión de la red, GS-DR-LL puede eliminar la mayoría de las inconsistencias antes. La solicitud de retraso local tradicional requiere que el valor de retraso sea mayor que el retraso típico de transmisión de red, de lo contrario las reparaciones del estado inundarían el sistema. Sin embargo, GS-DR-LL permite que n sea menor que el retraso de transmisión de red típico. En este caso, la inconsistencia previa causada por el retraso en la transmisión de la red todavía existe, pero puede ser disminuida. 5. EVALUACIÓN DEL RENDIMIENTO Para evaluar GS-DR-LL y compararlo con GS-DR en una aplicación real, implementamos ambos métodos en un juego en red llamado spaceship [1]. Spaceship es un juego de computadora en red muy simple, en el cual los jugadores pueden controlar sus naves espaciales para acelerar, desacelerar, girar y disparar a las naves espaciales controladas por otros jugadores remotos con rayos láser. Si una nave espacial es alcanzada por un rayo láser, sus puntos de vida disminuyen en uno. Si los puntos de vida de una nave espacial disminuyen a 0, la nave espacial se elimina del juego y el jugador que la controla pierde el juego. En nuestra implementación práctica, GS-DR-LL y GS-DR coexistieron en el sistema de juego, y el banco de pruebas estaba compuesto por dos computadoras conectadas por Ethernet conmutado de 100 M, siendo una computadora el sitio local y la otra el sitio remoto. Para simular el retraso de transmisión de red, se desarrolló un módulo específico para retrasar todos los paquetes transmitidos entre las dos computadoras en función de un valor de retraso predefinido. El propósito principal de la evaluación del rendimiento es estudiar los efectos de GS-DR-LL en la disminución de la inconsistencia antes en un sistema de juego particular bajo diferentes umbrales, retardos y retrasos en la transmisión de red. Se utilizaron dos umbrales diferentes en la evaluación, uno es una desviación de 10 píxeles en posición o 15 grados en orientación, y el otro es de 4 píxeles o 5 grados. Se utilizaron seis combinaciones diferentes de retardo de lag y de transmisión de red en la evaluación, las cuales podían dividirse en dos categorías. En una categoría, el retardo se fijó en 300 ms y se utilizaron tres retardos de transmisión de red diferentes (100 ms, 300 ms y 500 ms). En la otra categoría, el retraso de transmisión de red se fijó en 800 ms y se utilizaron tres retrasos diferentes (100 ms, 300 ms y 500 ms). Por lo tanto, el número total de configuraciones utilizadas en la evaluación fue de 12 (2 × 6). El procedimiento de evaluación del desempeño estaba compuesto por tres pasos. En el primer paso, se emplearon dos participantes para jugar el juego, y se registraron las secuencias de operación. Basándose en los registros, se seleccionó una secuencia de suboperaciones que duró aproximadamente un minuto e incluyó diferentes operaciones (por ejemplo, acelerar, desacelerar y girar). En el segundo paso, primero se sincronizaron los relojes físicos de las dos computadoras. Bajo diferentes configuraciones y enfoques de mantenimiento de consistencia, la secuencia de suboperaciones seleccionada se reprodujo en una computadora, y esta hizo mover las dos naves espaciales, una local y la otra remota. Mientras tanto, las trayectorias de las naves espaciales en las dos computadoras fueron registradas por separado y se les llamó un par de trayectorias. Dado que hay 12 ajustes y 2 enfoques de mantenimiento de consistencia, el número total de parejas de pistas registradas fue de 24. En el último paso, a cada par de pistas se calculó la inconsistencia entre ellas, y la unidad de inconsistencia fue el píxel. Dado que los relojes físicos de las dos computadoras estaban sincronizados, el cálculo de la inconsistencia fue bastante simple. La inconsistencia en un momento particular fue la distancia entre las posiciones de las dos naves espaciales en ese momento (es decir, fórmula (3)). Para mostrar los resultados de la inconsistencia de manera clara, solo se utilizan partes de los resultados, que duran aproximadamente 7 segundos, en las siguientes figuras, y las figuras muestran casi las mismas partes de los resultados. Las figuras 3, 4 y 5 muestran los resultados de la inconsistencia cuando el retardo está fijo en 300 ms y los retrasos de transmisión de red son de 100, 300 y 500 ms. Se puede observar que la inconsistencia existe, pero la mayoría del tiempo es 0. Además, la inconsistencia aumenta con el retraso de transmisión de la red, pero disminuye con el umbral. Comparado con GS-DR, GS-DR-LL puede disminuir más la inconsistencia, y elimina la mayoría de la inconsistencia cuando la demora de transmisión de red es de 100 ms y el umbral es de 4 píxeles o 5 grados. Según los mecanismos de predicción y filtrado de estado de DR, la inconsistencia no puede ser completamente eliminada si el umbral no es 0. Con las definiciones de inconsistencia anterior e inconsistencia posterior, se puede indicar que GS-DR y GS-DR-LL pueden eliminar la inconsistencia posterior, y GS-DR-LL puede disminuir efectivamente la inconsistencia anterior. Se puede prever que con un retraso y umbral adecuados (por ejemplo, el retraso es mayor que la demora de transmisión de red y el umbral es 0), GS-DR-LL incluso puede eliminar la inconsistencia antes. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 3. Inconsistencia cuando el retraso de transmisión de red es de 100 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 4. Inconsistencia cuando el retraso de transmisión de red es de 300 ms y el retardo es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 5. Inconsistencia cuando el retraso de transmisión de red es de 500 ms y el retardo es de 300 ms. Las figuras 6, 7 y 8 muestran los resultados de la inconsistencia cuando el retraso de transmisión de la red está fijo en 800 ms y los retardos son de 100, 300 y 500 ms. Se puede observar que con GS-DR-LL antes de la inconsistencia disminuye con el rezago. En el retraso local tradicional, el retraso debe establecerse en un valor mayor que el retraso típico de transmisión de red, de lo contrario, las reparaciones de estado inundarían el sistema. A partir de los resultados anteriores, se puede ver que no existe ninguna restricción en la selección del retardo, con GS-DR-LL un sistema funcionaría bien incluso si el retardo es mucho menor que la demora de transmisión de la red. Del total de resultados anteriores, se puede indicar que tanto GS-DR como GSDR-LL pueden eliminarse después de la inconsistencia, y GS-DR-LL puede disminuir efectivamente antes de la inconsistencia, y los efectos aumentan con el retardo. La cifra 6. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 7. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el lag es de 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 10 píxeles o 15 grados 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Tiempo (segundos) Inconsistencia (píxeles) GS-DR-LL GS-DR El umbral es de 4 píxeles o 5 grados Figura 8. Inconsistencia cuando el retraso de transmisión de red es de 800 ms y el retardo es de 500 ms. 6. CONCLUSIONES En comparación con el DR tradicional, el GS-DR puede eliminar la inconsistencia posterior a través de la sincronización de relojes físicos, pero no puede abordar la inconsistencia anterior, lo que podría influir significativamente en la <br>usabilidad y equidad</br> de un juego. En este artículo, propusimos un método llamado GS-DR-LL, que combina el retraso local y GS-DR, para disminuir la inconsistencia previa mediante el retraso en la actualización de los resultados de ejecución de operaciones locales en la escena local. La evaluación del rendimiento indica que GS-DR-LL puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. GS-DR-LL tiene implicaciones significativas para los enfoques de mantenimiento de consistencia. Primero, GS-DR-LL muestra que una mejora en DR no solo puede eliminar la inconsistencia posterior, sino también disminuir la inconsistencia anterior, con un retraso y umbral adecuados, incluso podría eliminarla antes de que ocurra. Como resultado, la aplicación de DR puede ser ampliamente expandida y podría ser utilizada en sistemas que requieran alta consistencia (por ejemplo, juegos altamente interactivos). Segundo, GS-DR-LL muestra que al combinar el retardo local y GSDR, se elimina la restricción en la selección del valor de retardo y se puede utilizar un retardo menor que el retraso típico de transmisión de red. Como resultado, la aplicación del retraso local puede ser ampliamente ampliada y podría ser utilizada en los sistemas que tienen un gran retraso de transmisión de red típico (por ejemplo,). Juegos basados en internet. REFERENCIAS [1] Mauve, M., Vogel, J., Hilt, V., y Effelsberg, W. Local-Lag y Timewarp: Proporcionando Consistencia para Aplicaciones Continuas Replicadas. IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.\n\nIEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., y Lau, R.W. Apoyando la coherencia continua en juegos en línea multijugador. En Proc. de ACM Multimedia, 2004, 388-391. [3] Pantel, L. y Wolf, L. Sobre la idoneidad de los esquemas de navegación inercial para juegos. En Proc. de NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., y Kunifuji, S. Un estudio experimental sobre los efectos del retardo de red en un entorno virtual háptico compartido cooperativo. Computadoras y Gráficos, Vol. 27, Núm. 2, 2003, 205-213. [5] Pantel, L. y Wolf, L.C. Sobre el impacto del retraso en los juegos multijugador en tiempo real. En Proc. de NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., y Brooks, F.P. Efecto de la latencia en la presencia en entornos virtuales estresantes. En Proc. de IEEE VR, 2003, 141-148. [7] Bernier, Y.W. Métodos de Compensación de Latencia en el Diseño y Optimización del Protocolo de Juego Cliente/Servidor. En Proc. de la Conferencia de Desarrolladores de Juegos, 2001. [8] Aggarwal, S., Banavar, H., y Khandelwal, A. Precisión en juegos multijugador distribuidos basados en la navegación a ojo muerto. En Proc. de NetGames, 2004, 161-165. [9] Raynal, M. y Schiper, A. De la Consistencia Causal a la Consistencia Secuencial en Sistemas de Memoria Compartida. En Proc. de la Conferencia sobre Fundamentos de Tecnología del Software y Ciencias de la Computación Teórica, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., y Neiger, G. Memoria Causal. En Proc. del Taller Internacional sobre Algoritmos Distribuidos, 1991, 9-30. [11] Herlihy, M. y Wing, J. Linearizabilidad: una Condición de Corrección para Objetos Concurrentes. ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.\nTraducción: ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axiomas para el acceso a la memoria en sistemas de hardware asíncronos. ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. y Munson, E.V. ¿Es 100 milisegundos demasiado rápido? En Proc. de la Conferencia SIGCHI sobre Factores Humanos en Sistemas Informáticos, 2001, 317-318. [14] Chen, H., Chen, L., y Chen, G.C. Efectos del mecanismo de retraso local en el rendimiento de la cooperación en un sistema CVE de escritorio. Revista de Ciencias de la Computación y Tecnología, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., y Chen, G.C. Echo: un método para mejorar la calidad de interacción de CVEs. En Proc. de IEEE VR, 2005, 269-270. El 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 7 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "gs-dr-ll": {
            "translated_key": "GS-DR-LL",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (<br>gs-dr-ll</br>), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that <br>gs-dr-ll</br> can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (<br>gs-dr-ll</br>), which combines local lag and GS-DR. By delaying the update to local site, <br>gs-dr-ll</br> can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how <br>gs-dr-ll</br> works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose <br>gs-dr-ll</br>, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In <br>gs-dr-ll</br>, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of <br>gs-dr-ll</br>, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In <br>gs-dr-ll</br>, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and <br>gs-dr-ll</br> is that <br>gs-dr-ll</br> uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of <br>gs-dr-ll</br>.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and <br>gs-dr-ll</br>.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using <br>gs-dr-ll</br>, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or <br>gs-dr-ll</br>, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of <br>gs-dr-ll</br>.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, <br>gs-dr-ll</br> can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and <br>gs-dr-ll</br> might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and <br>gs-dr-ll</br> has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and <br>gs-dr-ll</br>.",
                "To <br>gs-dr-ll</br>, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, <br>gs-dr-ll</br> can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However <br>gs-dr-ll</br> allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate <br>gs-dr-ll</br> and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, <br>gs-dr-ll</br> and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of <br>gs-dr-ll</br> on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, <br>gs-dr-ll</br> can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and <br>gs-dr-ll</br> both can eliminate after inconsistency, and <br>gs-dr-ll</br> can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), <br>gs-dr-ll</br> even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) <br>gs-dr-ll</br> GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) <br>gs-dr-ll</br> GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) <br>gs-dr-ll</br> GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) <br>gs-dr-ll</br> GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) <br>gs-dr-ll</br> GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with <br>gs-dr-ll</br> before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with <br>gs-dr-ll</br> a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and <br>gs-dr-ll</br> can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) <br>gs-dr-ll</br> GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) <br>gs-dr-ll</br> GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) <br>gs-dr-ll</br> GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) <br>gs-dr-ll</br> GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) <br>gs-dr-ll</br> GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named <br>gs-dr-ll</br>, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that <br>gs-dr-ll</br> can effectively decrease before inconsistency, and the effects increase with the lag.",
                "<br>gs-dr-ll</br> has significant implications to consistency maintenance approaches.",
                "First, <br>gs-dr-ll</br> shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, <br>gs-dr-ll</br> shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [
                "In this paper, a method named Globally Synchronized DR with Local Lag (<br>gs-dr-ll</br>), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that <br>gs-dr-ll</br> can effectively decrease before inconsistency, and the effects increase with the lag.",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (<br>gs-dr-ll</br>), which combines local lag and GS-DR. By delaying the update to local site, <br>gs-dr-ll</br> can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how <br>gs-dr-ll</br> works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "In order to decrease before inconsistency, we propose <br>gs-dr-ll</br>, which combines GS-DR with local lag and can effectively decrease before inconsistency."
            ],
            "translated_annotated_samples": [
                "En este artículo se presenta un método llamado <br>DR Globalmente Sincronizado con Retardo Local</br> (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR).",
                "La evaluación del rendimiento muestra que <br>GS-DR-LL</br> puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo.",
                "En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (<br>GS-DR-LL</br>), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, <br>GS-DR-LL</br> puede lograr una mayor consistencia que GS-DR.",
                "El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona <br>GS-DR-LL</br>; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento.",
                "Para disminuir la inconsistencia previa, proponemos <br>GS-DR-LL</br>, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa."
            ],
            "translated_text": "Reconocimiento de rumbo muerto globalmente sincronizado con retraso local para juegos multijugador distribuidos continuos Yi Zhang1, Ling Chen1, 2, Gencai Chen1 1Colegio de Ciencias de la Computación, Universidad de Zhejiang, Hangzhou 310027, República Popular China. La navegación inercial (DR) es un método efectivo para mantener la consistencia en los Juegos Multijugador Distribuidos Continuos (CDMG). Dado que DR puede filtrar la mayoría de las actualizaciones de estado innecesarias y mejorar la escalabilidad de un sistema, se utiliza ampliamente en CDMG comercial. Sin embargo, DR no puede mantener una alta consistencia, lo que limita su aplicación en juegos altamente interactivos. Con la ayuda de la sincronización global, DR puede lograr una mayor consistencia, pero aún no puede eliminar por completo la inconsistencia previa. En este artículo se presenta un método llamado <br>DR Globalmente Sincronizado con Retardo Local</br> (GS-DR-LL), que combina el retardo local y el DR Globalmente Sincronizado (GS-DR). La evaluación del rendimiento muestra que <br>GS-DR-LL</br> puede disminuir eficazmente la inconsistencia anterior, y los efectos aumentan con el retardo. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos - aplicaciones distribuidas. Términos generales Algoritmos, Rendimiento, Experimentación. 1. INTRODUCCIÓN En la actualidad, muchos juegos multijugador distribuidos adoptan arquitecturas replicadas. En tales juegos, los estados de las entidades no solo se modifican por las acciones de los jugadores, sino también por el paso del tiempo [1, 2]. Estos juegos son conocidos como Juegos Multijugador Distribuidos Continuos (CDMG). Como otras aplicaciones distribuidas, CDMG también sufren del problema de consistencia causado por el retraso en la transmisión de la red. Aunque las nuevas técnicas de red (por ejemplo, La calidad de servicio (QoS) puede reducir o al menos limitar la demora, pero no puede eliminarla por completo, ya que existe la limitación de velocidad física de la luz, por ejemplo, se necesitan 100 ms para que la luz se propague de Europa a Australia [3]. Hay muchos estudios sobre los efectos del retraso en la transmisión de red en diferentes aplicaciones [4, 5, 6, 7]. En los juegos basados en replicación, la demora en la transmisión de la red hace que los estados de los sitios locales y remotos sean inconsistentes, lo que puede causar problemas graves, como reducir la equidad de un juego y llevar a situaciones paradójicas, etc. Para mantener la consistencia en sistemas distribuidos, se han propuesto muchos enfoques diferentes, entre los cuales el retraso local y el Dead-Reckoning (DR) son dos enfoques representativos. Mauve et al [1] propusieron el retraso local para mantener una alta consistencia en aplicaciones continuas replicadas. Sincroniza los relojes físicos de todos los sitios en un sistema. Después de que se emite una operación en el sitio local, se retrasa la ejecución de la operación por un corto tiempo. Durante este corto período de tiempo, la operación se transmite a sitios remotos, y todos los sitios intentan ejecutar la operación al mismo tiempo físico. Para abordar la inconsistencia causada por la excepcional demora en la transmisión de la red, se propone un mecanismo basado en la distorsión temporal para reparar el estado. La replicación local puede lograr una alta consistencia significativa, pero se basa en la transmisión de operaciones, que reenvía cada operación en una entidad compartida a sitios remotos. Dado que el mecanismo de transmisión de operaciones requiere que todas las operaciones se transmitan de manera confiable, la implementación del filtrado de mensajes es difícil y la escalabilidad de un sistema está limitada. DR se basa en el mecanismo de transmisión del estado. Además del modelo de alta fidelidad que mantiene los estados precisos de sus propias entidades, cada sitio también tiene un modelo de DR que estima los estados de todas las entidades (incluidas sus propias entidades). Después de cada actualización de sus propias entidades, un sitio compara el estado preciso con el estimado. Si la diferencia excede un umbral predefinido, se transmitiría una actualización de estado a todos los sitios y se corregirían todos los modelos de recuperación de desastres. A través de la estimación de estado, DR no solo puede mantener la consistencia, sino también disminuir el número de actualizaciones de estado transmitidas. Comparado con el retraso local mencionado anteriormente, DR no puede mantener una alta consistencia. Debido al retraso en la transmisión de la red, cuando un sitio remoto recibe una actualización de estado de una entidad, el estado de la entidad podría haber cambiado en el sitio que envía la actualización de estado. Para mantener una alta consistencia en la replicación distribuida (DR), Aggarwal et al [8] propusieron la Replicación Distribuida Globalmente Sincronizada (GS-DR), que sincroniza los relojes físicos de todos los sitios en un sistema y agrega marcas de tiempo a las actualizaciones de estado transmitidas. La descripción detallada de GS-DR se puede encontrar en la Sección 3. Cuando hay una actualización de estado disponible, GS-DR actualiza inmediatamente el estado del sitio local y luego transmite la actualización de estado a los sitios remotos, lo que provoca que los estados del sitio local y los sitios remotos sean inconsistentes en el procedimiento de transmisión. Por lo tanto, con la sincronización de relojes físicos, GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar la inconsistencia anterior [8]. En este artículo, proponemos un nuevo método llamado DR globalmente sincronizado con Retardo Local (<br>GS-DR-LL</br>), que combina el retardo local y GS-DR. Al retrasar la actualización al sitio local, <br>GS-DR-LL</br> puede lograr una mayor consistencia que GS-DR. El resto de este documento está organizado de la siguiente manera: La Sección 2 presenta la definición de consistencia y las métricas correspondientes; la causa de la inconsistencia de DR se analiza en la Sección 3; la Sección 4 describe cómo funciona <br>GS-DR-LL</br>; la evaluación del rendimiento se presenta en la Sección 5; la Sección 6 concluye el documento. DEFINICIONES Y MÉTRICAS DE CONSISTENCIA La consistencia de aplicaciones replicadas ya ha sido bien definida en el dominio discreto [9, 10, 11, 12], pero se ha realizado poco trabajo relacionado en el dominio continuo. Mauve et al [1] han proporcionado una definición de consistencia para aplicaciones replicadas en dominio continuo, pero la definición se basa en la transmisión de operaciones y resulta difícil que describa métodos basados en la transmisión de estado (por ejemplo, Lo siento, pero no puedo traducir \"DR).\" ya que no es una oración completa en inglés. ¿Hay algo más en lo que pueda ayudarte a traducir al español? Aquí presentamos una definición alternativa de consistencia en un dominio continuo, que se adapta bien a los métodos basados en la transmisión de estado. Dado dos sitios distintos i y j, que han replicado una entidad compartida e, en un tiempo dado t, los estados de e en los sitios i y j son Si(t) y Sj(t). DEFINICIÓN 1: los estados de e en los sitios i y j son consistentes en el tiempo t, si: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINICIÓN 2: los estados de e en los sitios i y j son consistentes entre los tiempos t1 y t2 (t1 < t2), si: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) En este artículo, las fórmulas (1) y (2) se utilizan para determinar si los estados de las entidades compartidas son consistentes entre sitios locales y remotos. Debido al retraso en la transmisión de la red, es difícil mantener los estados de las entidades compartidas absolutamente consistentes. Se necesitan métricas correspondientes para medir la consistencia de las entidades compartidas entre sitios locales y remotos. De(i, j, t) se puede utilizar como una métrica para medir el grado de consistencia en un momento específico. Si De(i, j, t1) > De(i, j, t2), se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e en el punto de tiempo t1 es menor que en el punto de tiempo t2. Si De(i, j, t) > De(l, k, t), se puede afirmar que, en el momento t, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. De manera similar, De(i, j, t1, t2) puede ser utilizada como una métrica para medir el grado de consistencia en un cierto período de tiempo. Si De(i, j, t1, t2) > De(i, j, t3, t4) y |t1 - t2| = |t3 - t4|, se puede afirmar que entre los sitios i y j, la consistencia de los estados de la entidad e entre los puntos temporales t1 y t2 es menor que entre los puntos temporales t3 y t4. Si De(i, j, t1, t2) > De(l, k, t1, t2), se puede afirmar que entre los puntos temporales t1 y t2, la consistencia de los estados de la entidad e entre los sitios i y j es menor que entre los sitios l y k. En DR, los estados de las entidades están compuestos por las posiciones y orientaciones de las entidades y algunos parámetros relacionados con la predicción (por ejemplo, las velocidades de las entidades). Dadas dos ubicaciones distintas i y j, que han replicado una entidad compartida e, en un momento dado t, las posiciones de e en los sitios i y j son (xit, yit, zit) y (xjt, yjt, zjt), De(i, j, t) y D(i, j, t1, t2) podrían calcularse como: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) En este documento, las fórmulas (3) y (4) se utilizan como métricas para medir la consistencia de las entidades compartidas entre sitios locales y remotos. 3. La inconsistencia en DR se puede dividir en dos secciones según el momento en que un sitio remoto recibe una actualización de estado. La inconsistencia antes de que un sitio remoto reciba una actualización de estado se conoce como inconsistencia antes, y la inconsistencia después de que un sitio remoto recibe una actualización de estado se conoce como inconsistencia después. Antes de la inconsistencia y después de la inconsistencia son similares a los términos antes del error de exportación y después del error de exportación [8]. La inconsistencia se produce por la falta de sincronización entre los relojes físicos de todos los sitios en un sistema. Al emplear la sincronización de relojes físicos, GS-DR puede calcular con precisión los estados de las entidades compartidas después de recibir actualizaciones de estado, y puede eliminar la inconsistencia posterior. La inconsistencia se produce por dos razones. La primera razón es el retraso en el envío de actualizaciones de estado, ya que el sitio local no envía una actualización de estado a menos que la diferencia entre el estado preciso y el estimado sea mayor que un umbral predefinido. La segunda razón es el retraso en la transmisión de la red, ya que una entidad compartida solo puede sincronizarse después de que los sitios remotos reciban la actualización de estado correspondiente. Figura 1. Los caminos de una entidad compartida mediante el uso de GS-DR. Por ejemplo, se asume que la velocidad de una entidad compartida es el único parámetro para predecir la posición de la entidad, y la posición actual de la entidad se puede calcular a partir de su última posición y la velocidad actual. Para simplificar la descripción, también se asume que solo hay dos sitios i y j en una sesión de juego, donde el sitio i actúa como sitio local del 5º Taller sobre Soporte de Red y Sistema para Juegos 2006 - NETGAMES 2006 y el sitio j actúa como sitio remoto, y t1 es el momento en que el sitio local actualiza el estado de la entidad compartida. La Figura 1 ilustra los caminos de la entidad compartida en el sitio local y el sitio remoto en el eje x utilizando GS-DR. Al principio, las posiciones de la entidad compartida son las mismas en los sitios i y j y la velocidad de la entidad compartida es 0. Antes del momento t0, los caminos de la entidad compartida en los sitios i y j en la coordenada x son exactamente iguales. En el instante t0, el jugador en el sitio i emite una operación, la cual cambia la velocidad en el eje x a v0. El sitio primero verifica periódicamente si la diferencia entre la posición precisa de la entidad compartida y la estimada, que en este caso es 0, es mayor que un umbral predefinido. En el momento t1, el sitio i encuentra que la diferencia es mayor que el umbral y envía una actualización de estado al sitio j. La actualización del estado contiene la posición y la velocidad de la entidad compartida en el momento t1 y el momento t1 también se adjunta como una marca de tiempo. En el instante de tiempo t2, la actualización del estado llega al sitio j, y el estado recibido y la desviación de tiempo entre los instantes t1 y t2 se utilizan para calcular la posición actual de la entidad compartida. Luego, el sitio j actualiza la posición y la velocidad de su entidad replicada, y las trayectorias de la entidad compartida en los sitios i y j se superponen nuevamente. A partir de la Figura 1, se puede observar que la inconsistencia posterior es 0, y la consistencia anterior está compuesta por dos partes, D1 y D2. D1 es De(i, j, t0, t1) y es causado por el mecanismo de filtrado de estado de DR. D2 es De(i, j, t1, t2) y es causado por el retraso de transmisión de red. 4. SINCRONIZACIÓN GLOBAL DE DR CON RETRASO LOCAL. A partir del análisis en la Sección 3, se puede observar que GS-DR puede eliminar la inconsistencia posterior, pero no puede abordar eficazmente la inconsistencia anterior. Para disminuir la inconsistencia previa, proponemos <br>GS-DR-LL</br>, que combina GS-DR con rezago local y puede disminuir eficazmente la inconsistencia previa. ",
            "candidates": [],
            "error": [
                [
                    "DR Globalmente Sincronizado con Retardo Local",
                    "GS-DR-LL",
                    "GS-DR-LL",
                    "GS-DR-LL",
                    "GS-DR-LL",
                    "GS-DR-LL"
                ]
            ]
        },
        "distribute multi-player game": {
            "translated_key": "distribuir juego multijugador",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "continuous replicate application": {
            "translated_key": "aplicación replicada continua",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "dead-reckon": {
            "translated_key": "navegación a ojo",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Globally Synchronized Dead-Reckoning with Local Lag for Continuous Distributed Multiplayer Games Yi Zhang1 , Ling Chen1, 2 , Gencai Chen1 1College of Computer Science, Zhejiang University, Hangzhou 310027, P.R.",
                "China 2School of Computer Science and IT, The University of Nottingham, Nottingham NG8 1BB, UK {m05zhangyi, lingchen, chengc}@cs.zju.edu.cn ABSTRACT Dead-Reckoning (DR) is an effective method to maintain consistency for Continuous Distributed Multiplayer Games (CDMG).",
                "Since DR can filter most unnecessary state updates and improve the scalability of a system, it is widely used in commercial CDMG.",
                "However, DR cannot maintain high consistency, and this constrains its application in highly interactive games.",
                "With the help of global synchronization, DR can achieve higher consistency, but it still cannot eliminate before inconsistency.",
                "In this paper, a method named Globally Synchronized DR with Local Lag (GS-DR-LL), which combines local lag and Globally Synchronized DR (GS-DR), is presented.",
                "Performance evaluation shows that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems - distributed applications.",
                "General Terms Algorithms, Performance, Experimentation. 1.",
                "INTRODUCTION Nowadays, many distributed multiplayer games adopt replicated architectures.",
                "In such games, the states of entities are changed not only by the operations of players, but also by the passing of time [1, 2].",
                "These games are referred to as Continuous Distributed Multiplayer Games (CDMG).",
                "Like other distributed applications, CDMG also suffer from the consistency problem caused by network transmission delay.",
                "Although new network techniques (e.g.",
                "QoS) can reduce or at least bound the delay, they can not completely eliminate it, as there exists the physical speed limitation of light, for instance, 100 ms is needed for light to propagate from Europe to Australia [3].",
                "There are many studies about the effects of network transmission delay in different applications [4, 5, 6, 7].",
                "In replication based games, network transmission delay makes the states of local and remote sites to be inconsistent, which can cause serious problems, such as reducing the fairness of a game and leading to paradoxical situations etc.",
                "In order to maintain consistency for distributed systems, many different approaches have been proposed, among which local lag and Dead-Reckoning (DR) are two representative approaches.",
                "Mauve et al [1] proposed local lag to maintain high consistency for replicated continuous applications.",
                "It synchronizes the physical clocks of all sites in a system.",
                "After an operation is issued at local site, it delays the execution of the operation for a short time.",
                "During this short time period the operation is transmitted to remote sites, and all sites try to execute the operation at a same physical time.",
                "In order to tackle the inconsistency caused by exceptional network transmission delay, a time warp based mechanism is proposed to repair the state.",
                "Local lag can achieve significant high consistency, but it is based on operation transmission, which forwards every operation on a shared entity to remote sites.",
                "Since operation transmission mechanism requests that all operations should be transmitted in a reliable way, message filtering is difficult to be deployed and the scalability of a system is limited.",
                "DR is based on state transmission mechanism.",
                "In addition to the high fidelity model that maintains the accurate states of its own entities, each site also has a DR model that estimates the states of all entities (including its own entities).",
                "After each update of its own entities, a site compares the accurate state with the estimated one.",
                "If the difference exceeds a pre-defined threshold, a state update would be transmitted to all sites and all DR models would be corrected.",
                "Through state estimation, DR can not only maintain consistency but also decrease the number of transmitted state updates.",
                "Compared with aforementioned local lag, DR cannot maintain high consistency.",
                "Due to network transmission delay, when a remote site receives a state update of an entity the state of the entity might have changed at the site sending the state update.",
                "In order to make DR maintain high consistency, Aggarwal et al [8] proposed Globally Synchronized DR (GS-DR), which synchronizes the physical clocks of all sites in a system and adds time stamps to transmitted state updates.",
                "Detailed description of GS-DR can be found in Section 3.",
                "When a state update is available, GS-DR immediately updates the state of local site and then transmits the state update to remote sites, which causes the states of local site and remote sites to be inconsistent in the transmission procedure.",
                "Thus with the synchronization of physical clocks, GS-DR can eliminate after inconsistency, but it cannot tackle before inconsistency [8].",
                "In this paper, we propose a new method named globally synchronized DR with Local Lag (GS-DR-LL), which combines local lag and GS-DR. By delaying the update to local site, GS-DR-LL can achieve higher consistency than GS-DR.",
                "The rest of this paper is organized as follows: Section 2 gives the definition of consistency and corresponding metrics; the cause of the inconsistency of DR is analyzed in Section 3; Section 4 describes how GS-DR-LL works; performance evaluation is presented in Section 5; Section 6 concludes the paper. 2.",
                "CONSISTENCY DEFINITIONS AND METRICS The consistency of replicated applications has already been well defined in discrete domain [9, 10, 11, 12], but few related work has been done in continuous domain.",
                "Mauve et al [1] have given a definition of consistency for replicated applications in continuous domain, but the definition is based on operation transmission and it is difficult for the definition to describe state transmission based methods (e.g.",
                "DR).",
                "Here, we present an alternative definition of consistency in continuous domain, which suits state transmission based methods well.",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time t, the states of e at sites i and j are Si(t) and Sj(t).",
                "DEFINITION 1: the states of e at sites i and j are consistent at time t, iff: De(i, j, t) = |Si(t) - Sj(t)| = 0 (1) DEFINITION 2: the states of e at sites i and j are consistent between time t1 and t2 (t1 < t2), iff: De(i, j, t1, t2) = dt|)t(S)t(S| t2 t1 ji = 0 (2) In this paper, formulas (1) and (2) are used to determine whether the states of shared entities are consistent between local and remote sites.",
                "Due to network transmission delay, it is difficult to maintain the states of shared entities absolutely consistent.",
                "Corresponding metrics are needed to measure the consistency of shared entities between local and remote sites.",
                "De(i, j, t) can be used as a metric to measure the degree of consistency at a certain time point.",
                "If De(i, j, t1) > De(i, j, t2), it can be stated that between sites i and j, the consistency of the states of entity e at time point t1 is lower than that at time point t2.",
                "If De(i, j, t) > De(l, k, t), it can be stated that, at time point t, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. Similarly, De(i, j, t1, t2) can been used as a metric to measure the degree of consistency in a certain time period.",
                "If De(i, j, t1, t2) > De(i, j, t3, t4) and |t1 - t2| = |t3 - t4|, it can be stated that between sites i and j, the consistency of the states of entity e between time points t1 and t2 is lower than that between time points t3 and t4.",
                "If De(i, j, t1, t2) > De(l, k, t1, t2), it can be stated that between time points t1 and t2, the consistency of the states of entity e between sites i and j is lower than that between sites l and k. In DR, the states of entities are composed of the positions and orientations of entities and some prediction related parameters (e.g. the velocities of entities).",
                "Given two distinct sites i and j, which have replicated a shared entity e, at a given time point t, the positions of e at sites i and j are (xit, yit, zit) and (xjt, yjt, zjt), De(i, j, t) and D (i, j, t1, t2) could be calculated as: De(i, j, t) = )zz()yy()xx( jtit 2 jtit 2 jtit 2 (3) De(i, j, t1, t2) = dt)zz()yy()xx( 2t 1t jtit 2 jtit 2 jtit 2 (4) In this paper, formulas (3) and (4) are used as metrics to measure the consistency of shared entities between local and remote sites. 3.",
                "INCONSISTENCY IN DR The inconsistency in DR can be divided into two sections by the time point when a remote site receives a state update.",
                "The inconsistency before a remote site receives a state update is referred to as before inconsistency, and the inconsistency after a remote site receives a state update is referred to as after inconsistency.",
                "Before inconsistency and after inconsistency are similar with the terms before export error and after export error [8].",
                "After inconsistency is caused by the lack of synchronization between the physical clocks of all sites in a system.",
                "By employing physical clock synchronization, GS-DR can accurately calculate the states of shared entities after receiving state updates, and it can eliminate after inconsistency.",
                "Before inconsistency is caused by two reasons.",
                "The first reason is the delay of sending state updates, as local site does not send a state update unless the difference between accurate state and the estimated one is larger than a predefined threshold.",
                "The second reason is network transmission delay, as a shared entity can be synchronized only after remote sites receiving corresponding state update.",
                "Figure 1.",
                "The paths of a shared entity by using GS-DR. For example, it is assumed that the velocity of a shared entity is the only parameter to predict the entitys position, and current position of the entity can be calculated by its last position and current velocity.",
                "To simplify the description, it is also assumed that there are only two sites i and j in a game session, site i acts as 2 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 local site and site j acts as remote site, and t1 is the time point the local site updates the state of the shared entity.",
                "Figure 1 illustrates the paths of the shared entity at local site and remote site in x axis by using GS-DR. At the beginning, the positions of the shared entity are the same at sites i and j and the velocity of the shared entity is 0.",
                "Before time point t0, the paths of the shared entity at sites i and j in x coordinate are exactly the same.",
                "At time point t0, the player at site i issues an operation, which changes the velocity in x axis to v0.",
                "Site i first periodically checks whether the difference between the accurate position of the shared entity and the estimated one, 0 in this case, is larger than a predefined threshold.",
                "At time point t1, site i finds that the difference is larger than the threshold and it sends a state update to site j.",
                "The state update contains the position and velocity of the shared entity at time point t1 and time point t1 is also attached as a timestamp.",
                "At time point t2, the state update reaches site j, and the received state and the time deviation between time points t1 and t2 are used to calculate the current position of the shared entity.",
                "Then site j updates its replicated entitys position and velocity, and the paths of the shared entity at sites i and j overlap again.",
                "From Figure 1, it can be seen that the after inconsistency is 0, and the before consistency is composed of two parts, D1 and D2.",
                "D1 is De(i, j, t0, t1) and it is caused by the state filtering mechanism of DR. D2 is De(i, j, t1, t2) and it is caused by network transmission delay. 4.",
                "GLOBALLY SYNCHRONIZED DR WITH LOCAL LAG From the analysis in Section 3, It can be seen that GS-DR can eliminate after inconsistency, but it cannot effectively tackle before inconsistency.",
                "In order to decrease before inconsistency, we propose GS-DR-LL, which combines GS-DR with local lag and can effectively decrease before inconsistency.",
                "In GS-DR-LL, the state of a shared entity at a certain time point t is notated as S = (t, pos, par 1, par 2, ……, par n), in which pos means the position of the entity and par 1 to par n means the parameters to calculate the position of the entity.",
                "In order to simplify the description of GS-DR-LL, it is assumed that there are only one shared entity and one remote site.",
                "At the beginning of a game session, the states of the shared entity are the same at local and remote sites, with the same position p0 and parameters pars0 (pars represents all the parameters).",
                "Local site keeps three states: the real state of the entity Sreal, the predicted state at remote site Sp-remote, and the latest state updated to remote site Slate.",
                "Remote site keep only one state Sremote, which is the real state of the entity at remote site.",
                "Therefore, at the beginning of a game session Sreal = Sp-remote = Slate = Sremote = (t0, p0, pars0).",
                "In GS-DR-LL, it is assumed that the physical clocks of all sites are synchronized with a deviation of less than 50 ms (using NTP or GPS clock).",
                "Furthermore, it is necessary to make corrections to a physical clock in a way that does not result in decreasing the value of the clock, for example by slowing down or halting the clock for a period of time.",
                "Additionally it is assumed that the game scene is updated at a fixed frequency and T stands for the time interval between two consecutive updates, for example, if the scene update frequency is 50 Hz, T would be 20 ms. n stands for the lag value used by local lag, and t stands for current physical time.",
                "After updating the scene, local site waits for a constant amount of time T. During this time period, local site receives the operations of the player and stores them in a list L. All operations in L are sorted by their issue time.",
                "At the end of time period T, local site executes all stored operations, whose issue time is between t - T and t, on Slate to get the new Slate, and it also executes all stored operations, whose issue time is between t - (n + T) and t - n, on Sreal to get the new Sreal.",
                "Additionally, local site uses Sp-remote and corresponding prediction methods to estimate the new Sp-remote.",
                "After new Slate, Sreal, and Sp-remote are calculated, local site compares whether the difference between the new Slate and Spremote exceeds the predefined threshold.",
                "If YES, local site sends new Slate to remote site and Sp-remote is updated with new Slate.",
                "Note that the timestamp of the sent state update is t. After that, local site uses Sreal to update local scene and deletes the operations, whose issue time is less than t - n, from L. After updating the scene, remote site waits for a constant amount of time T. During this time period, remote site stores received state update(s) in a list R. All state updates in R are sorted by their timestamps.",
                "At the end of time period T, remote site checks whether R contains state updates whose timestamps are less than t - n. Note that t is current physical time and it increases during the transmission of state updates.",
                "If YES, it uses these state updates and corresponding prediction methods to calculate the new Sremote, else they use Sremote and corresponding prediction methods to estimate the new Sremote.",
                "After that, local site uses Sremote to update local scene and deletes the sate updates, whose timestamps are less than t - n, from R. From the above description, it can been see that the main difference between GS-DR and GS-DR-LL is that GS-DR-LL uses the operations, whose issue time is less than t - n, to calculate Sreal.",
                "That means that the scene seen by local player is the results of the operations issued a period of time (i.e. n) ago.",
                "Meanwhile, if the results of issued operations make the difference between Slate and Sp-remote exceed a predefined threshold, corresponding state updates are sent to remote sites immediately.",
                "The aforementioned is the basic mechanism of GS-DR-LL.",
                "In the case with multiple shared entities and remote sites, local site calculates Slate, Sreal, and Sp-remote for different shared entities respectively, if there are multiple Slate need to be transmitted, local site packets them in one state update and then send it to all remote sites.",
                "Figure 2 illustrates the paths of a shared entity at local site and remote site while using GS-DR and GS-DR-LL.",
                "All conditions are the same with the conditions used in the aforementioned example describing GS-DR.",
                "Compared with t1, t2, and n, T (i.e. the time interval between two consecutive updates) is quite small and it is ignored in the following description.",
                "At time point t0, the player at site i issues an operation, which changes the velocity of the shared entity form 0 to v0.",
                "By using GS-DR-LL, the results of the operation are updated to local scene at time point t0 + n. However the operation is immediately used to calculate Slate, thus in spite of GS-DR or GS-DR-LL, at time point t1 site i finds that the difference between accurate position and the estimated one is larger than the threshold and it sends a state update to site j.",
                "At time point t2, the state update is received by remote site j.",
                "Assuming that the timestamp of the state update is less than t - n, site j uses it to update local scene immediately.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 3 With GS-DR, the time period of before inconsistency is (t2 - t1) + (t1 - t0), whereas it decreases to (t2 - t1 - n) + (t1 - t0) with the help of GS-DR-LL.",
                "Note that t2 - t1 is caused by network transmission delay and t1 - t0 is caused by the state filtering mechanism of DR.",
                "If n is larger than t2 - t1, GS-DR-LL can eliminate the before inconsistency caused by network transmission delay, but it cannot eliminate the before inconsistency caused by the state filtering mechanism of DR (unless the threshold is set to 0).",
                "In highly interactive games, which request high consistency and GS-DR-LL might be employed, the results of operations are quite difficult to be estimated and a small threshold must be used.",
                "Thus, in practice, most before inconsistency is caused by network transmission delay and GS-DR-LL has the capability to eliminate such before inconsistency.",
                "Figure 2.",
                "The paths of a shared entity by using GS-DR and GS-DR-LL.",
                "To GS-DR-LL, the selection of lag value n is very important, and both network transmission delay and the effects of local lag on interaction should be considered.",
                "According to the results of HCI related researches, humans cannot perceive the delay imposed on a system when it is smaller than a specific value, and the specific value depends on both the system and the task.",
                "For example, in a graphical user interface a delay of approximately 150 ms cannot be noticed for keyboard interaction and the threshold increases to 195 ms for mouse interaction [13], and a delay of up to 50 ms is uncritical for a car-racing game [5].",
                "Thus if network transmission delay is less than the specific value of a game system, n can be set to the specific value.",
                "Else n can be set in terms of the effects of local lag on the interaction of a system [14].",
                "In the case that a large n must be used, some HCI methods (e.g. echo [15]) can be used to relieve the negative effects of the large lag.",
                "In the case that n is larger than the network transmission delay, GS-DR-LL can eliminate most before inconsistency.",
                "Traditional local lag requests that the lag value must be larger than typical network transmission delay, otherwise state repairs would flood the system.",
                "However GS-DR-LL allows n to be smaller than typical network transmission delay.",
                "In this case, the before inconsistency caused by network transmission delay still exists, but it can be decreased. 5.",
                "PERFORMANCE EVALUATION In order to evaluate GS-DR-LL and compare it with GS-DR in a real application, we had implemented both two methods in a networked game named spaceship [1].",
                "Spaceship is a very simple networked computer game, in which players can control their spaceships to accelerate, decelerate, turn, and shoot spaceships controlled by remote players with laser beams.",
                "If a spaceship is hit by a laser beam, its life points decrease one.",
                "If the life points of a spaceship decrease to 0, the spaceship is removed from the game and the player controlling the spaceship loses the game.",
                "In our practical implementation, GS-DR-LL and GS-DR coexisted in the game system, and the test bed was composed of two computers connected by 100 M switched Ethernet, with one computer acted as local site and the other acted as remote site.",
                "In order to simulate network transmission delay, a specific module was developed to delay all packets transmitted between the two computers in terms of a predefined delay value.",
                "The main purpose of performance evaluation is to study the effects of GS-DR-LL on decreasing before inconsistency in a particular game system under different thresholds, lags, and network transmission delays.",
                "Two different thresholds were used in the evaluation, one is 10 pixels deviation in position or 15 degrees deviation in orientation, and the other is 4 pixels or 5 degrees.",
                "Six different combinations of lag and network transmission delay were used in the evaluation and they could be divided into two categories.",
                "In one category, the lag was fixed at 300 ms and three different network transmission delays (100 ms, 300 ms, and 500 ms) were used.",
                "In the other category, the network transmission delay was fixed at 800 ms and three different lags (100 ms, 300 ms, and 500 ms) were used.",
                "Therefore the total number of settings used in the evaluation was 12 (2 × 6).",
                "The procedure of performance evaluation was composed of three steps.",
                "In the first step, two participants were employed to play the game, and the operation sequences were recorded.",
                "Based on the records, a sub operation sequence, which lasted about one minute and included different operations (e.g. accelerate, decelerate, and turn), was selected.",
                "In the second step, the physical clocks of the two computers were synchronized first.",
                "Under different settings and consistency maintenance approaches, the selected sub operation sequence was played back on one computer, and it drove the two spaceships, one was local and the other was remote, to move.",
                "Meanwhile, the tracks of the spaceships on the two computers were recorded separately and they were called as a track couple.",
                "Since there are 12 settings and 2 consistency maintenance approaches, the total number of recorded track couples was 24.",
                "In the last step, to each track couple, the inconsistency between them was calculated, and the unit of inconsistency was pixel.",
                "Since the physical clocks of the two computers were synchronized, the calculation of inconsistency was quite simple.",
                "The inconsistency at a particular time point was the distance between the positions of the two spaceships at that time point (i.e. formula (3)).",
                "In order to show the results of inconsistency in a clear way, only parts of the results, which last about 7 seconds, are used in the following figures, and the figures show almost the same parts of the results.",
                "Figures 3, 4, and 5 show the results of inconsistency when the lag is fixed at 300 ms and the network transmission delays are 100, 300, and 500 ms.",
                "It can been seen that inconsistency does exist, but in most of the time it is 0.",
                "Additionally, inconsistency increases with the network transmission delay, but decreases with the threshold.",
                "Compared with GS-DR, GS-DR-LL can decrease more inconsistency, and it eliminates most inconsistency when the network transmission delay is 100 ms and the threshold is 4 pixels or 5 degrees. 4 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 According to the prediction and state filtering mechanisms of DR, inconsistency cannot be completely eliminated if the threshold is not 0.",
                "With the definitions of before inconsistency and after inconsistency, it can be indicated that GS-DR and GS-DR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency.",
                "It can be foreseen that with proper lag and threshold (e.g. the lag is larger than the network transmission delay and the threshold is 0), GS-DR-LL even can eliminate before inconsistency. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 3.",
                "Inconsistency when the network transmission delay is 100 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 4.",
                "Inconsistency when the network transmission delay is 300 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 5.",
                "Inconsistency when the network transmission delay is 500 ms and the lag is 300 ms.",
                "Figures 6, 7, and 8 show the results of inconsistency when the network transmission delay is fixed at 800 ms and the lag are 100, 300, and 500 ms.",
                "It can be seen that with GS-DR-LL before inconsistency decreases with the lag.",
                "In traditional local lag, the lag must be set to a value larger than typical network transmission delay, otherwise the state repairs would flood the system.",
                "From the above results it can be seen that there does not exist any constraint on the selection of the lag, with GS-DR-LL a system would work fine even if the lag is much smaller than the network transmission delay.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 5 From all above results, it can be indicated that GS-DR and GSDR-LL both can eliminate after inconsistency, and GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag. 0 10 20 30 40 0.0 1.5 3.1 4.7 6.2 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 6.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 100 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 7.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 300 ms. 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 10 pixels or 15degrees 0 10 20 30 40 0.0 1.5 3.1 4.6 6.1 Time (seconds) Inconsistency(pixels) GS-DR-LL GS-DR The threshold is 4 pixels or 5degrees Figure 8.",
                "Inconsistency when the network transmission delay is 800 ms and the lag is 500 ms. 6.",
                "CONCLUSIONS Compared with traditional DR, GS-DR can eliminate after inconsistency through the synchronization of physical clocks, but it cannot tackle before inconsistency, which would significantly influence the usability and fairness of a game.",
                "In this paper, we proposed a method named GS-DR-LL, which combines local lag and GS-DR, to decrease before inconsistency through delaying updating the execution results of local operations to local scene.",
                "Performance evaluation indicates that GS-DR-LL can effectively decrease before inconsistency, and the effects increase with the lag.",
                "GS-DR-LL has significant implications to consistency maintenance approaches.",
                "First, GS-DR-LL shows that improved DR can not only eliminate after inconsistency but also decrease 6 The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 before inconsistency, with proper lag and threshold, it would even eliminate before inconsistency.",
                "As a result, the application of DR can be greatly broadened and it could be used in the systems which request high consistency (e.g. highly interactive games).",
                "Second, GS-DR-LL shows that by combining local lag and GSDR, the constraint on selecting lag value is removed and a lag, which is smaller than typical network transmission delay, could be used.",
                "As a result, the application of local lag can be greatly broadened and it could be used in the systems which have large typical network transmission delay (e.g.",
                "Internet based games). 7.",
                "REFERENCES [1] Mauve, M., Vogel, J., Hilt, V., and Effelsberg, W. Local-Lag and Timewarp: Providing Consistency for Replicated Continuous Applications.",
                "IEEE Transactions on Multimedia, Vol. 6, No.1, 2004, 47-57. [2] Li, F.W., Li, L.W., and Lau, R.W.",
                "Supporting Continuous Consistency in Multiplayer Online Games.",
                "In Proc. of ACM Multimedia, 2004, 388-391. [3] Pantel, L. and Wolf, L. On the Suitability of Dead Reckoning Schemes for Games.",
                "In Proc. of NetGames, 2002, 79-84. [4] Alhalabi, M.O., Horiguchi, S., and Kunifuji, S. An Experimental Study on the Effects of Network Delay in Cooperative Shared Haptic Virtual Environment.",
                "Computers and Graphics, Vol. 27, No. 2, 2003, 205-213. [5] Pantel, L. and Wolf, L.C.",
                "On the Impact of Delay on RealTime Multiplayer Games.",
                "In Proc. of NOSSDAV, 2002, 2329. [6] Meehan, M., Razzaque, S., Whitton, M.C., and Brooks, F.P.",
                "Effect of Latency on Presence in Stressful Virtual Environments.",
                "In Proc. of IEEE VR, 2003, 141-148. [7] Bernier, Y.W.",
                "Latency Compensation Methods in Client/Server In-Game Protocol Design and Optimization.",
                "In Proc. of Game Developers Conference, 2001. [8] Aggarwal, S., Banavar, H., and Khandelwal, A.",
                "Accuracy in Dead-Reckoning based Distributed Multi-Player Games.",
                "In Proc. of NetGames, 2004, 161-165. [9] Raynal, M. and Schiper, A.",
                "From Causal Consistency to Sequential Consistency in Shared Memory Systems.",
                "In Proc. of Conference on Foundations of Software Technology and Theoretical Computer Science, 1995, 180-194. [10] Ahamad, M., Burns, J.E., Hutto, P.W., and Neiger, G. Causal Memory.",
                "In Proc. of International Workshop on Distributed Algorithms, 1991, 9-30. [11] Herlihy, M. and Wing, J. Linearizability: a Correctness Condition for Concurrent Objects.",
                "ACM Transactions on Programming Languages and Systems, Vol. 12, No. 3, 1990, 463-492. [12] Misra, J. Axioms for Memory Access in Asynchronous Hardware Systems.",
                "ACM Transactions on Programming Languages and Systems, Vol. 8, No. 1, 1986, 142-153. [13] Dabrowski, J.R. and Munson, E.V.",
                "Is 100 Milliseconds too Fast.",
                "In Proc. of SIGCHI Conference on Human Factors in Computing Systems, 2001, 317-318. [14] Chen, H., Chen, L., and Chen, G.C.",
                "Effects of Local-Lag Mechanism on Cooperation Performance in a Desktop CVE System.",
                "Journal of Computer Science and Technology, Vol. 20, No. 3, 2005, 396-401. [15] Chen, L., Chen, H., and Chen, G.C.",
                "Echo: a Method to Improve the Interaction Quality of CVEs.",
                "In Proc. of IEEE VR, 2005, 269-270.",
                "The 5th Workshop on Network & System Support for Games 2006 - NETGAMES 2006 7"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        }
    }
}