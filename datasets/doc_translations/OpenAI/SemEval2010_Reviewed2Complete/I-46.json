{
    "id": "I-46",
    "original_text": "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams. Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al.; however, they are also modular and compact in the way concurrent programs are. We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models. Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1. INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years. Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3]. Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled. Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance. Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model. However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other. In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems. The structure of the paper is as follows. First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies. More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information. We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case. The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system. However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems. Thus, we usually need representations that are more compact. Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation. This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate. In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis. We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered. Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture. We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information. Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2. LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL). Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St). A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i]. A q-path is a path that starts in q. Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7]. Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ. Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent). We assume that all ∼a are equivalences. The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q . Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial). This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular). The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt. Informally, A ϕ says that agents A have a collective strategy to enforce ϕ. It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively. The semantics of ATL is defined in so called concurrent game structures (CGSs). A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions. Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St. Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk). DEFINITION 1. A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A. Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system. ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall. Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations. It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ). ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ). A collective strategy is uniform if it contains only uniform individual strategies. Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q. The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game. While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3. MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking. We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world). Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems). We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics). On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g. Boolean variables, n-ary attributes etc.). Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15]. For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity. States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems. Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component. In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way. While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models). Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious. We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system. Unfortunately, ATL models are anything but open in this sense. Theoretical complexity results for explicit models are as follows. Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5]. Alternatively, it can be done in time O(n2 l), where n is the number of states. Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16]. Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways. An alternative is to represent the state/transition space in a symbolic way [17, 18]. Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models. Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems. An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π . St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment. The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St). While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi . It is easy to see that such a representation is modular and compact as far as we are concerned with states. Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states. Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models. This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here. But the bottom line is that the temporal dimension of an interpreted system has exponential representation. And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems. Here, we use the formulation from [15]. A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation. The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names. Concurrent programs have several advantages. First of all, they are modular and compact. They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here). Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization. On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes. For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous. Side effects of actions are also not easy to model. Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions. For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect. The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities. Now, particular actions are no less important than the resulting transitions. Actions may influence other agents local states without their consent, they may have side effects on other agents states etc. Passing messages and/or calling procedures is by no means the only way of interaction between agents. Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions! Finally, we would often like to assume that agents act synchronously. In particular, all agents play simultaneously in concurrent game structures. But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination. To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions. The first postulate is easy to satisfy, as we show in the following section. The second will be addressed in Section 4. We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players. A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all. DEFINITION 2. A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi. We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs. DEFINITION 3. A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π. Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π. It is required that ctr1, . . . ctrk partitions Π. The idea is that agent i controls the variables ctri. The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round. A guarded command is enabled if the guard φ is true in the current state of the system. In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj. Several guarded commands being enabled at the same time model non-deterministic choice. Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20]. That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi . Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20]. SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls. Concurrent epistemic programs are modular and have a grounded semantics. They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program). Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc. The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation. One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security). Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message. The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out. So, availability of actions must be independent of the actions chosen by the other agents under incomplete information. On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded. We have already mentioned a very limited variant of RML (i.e., SRML). The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates. However, the sets of variables controlled by different agents can overlap, they can change over time etc. Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML. Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system. Agents can act synchronously as well as asynchronously. To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony. However, we believe that there is still a need for a simpler and slightly more abstract class of representations. First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions. Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables. This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework. Third, the separation of the local complexity, and the complexity of interaction is not straightforward. Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point. The proposed framework is presented in Section 4. 4. MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components. Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill). Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity. DEFINITION 4. A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet. Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions. The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv. Within our framework, we assume that every action is executed by an actor, that is, an agent. As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS. The environment, on the other hand, represents the (passive) context of agents actions. In practice, it serves to capture the aspects of the global state that are not observable by any of the agents. The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In). However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly. DEFINITION 5. Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i. The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. It is required that ϕn ≡ , so that the mapping is effective. REMARK 1. Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]). Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In. In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6. The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows. Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q). We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ . Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2. Note that MISs can be used as representations of CGSs too. In that case, epistemic relations ∼i are simply omitted in the unfolding. We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q). Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems. On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8. PROPOSITION 3. For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF. Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS. We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k . We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states. First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α). Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk . Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) . Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1). We now argue that St = Q. Clearly, Q ⊆ St . Let ˆq ∈ St ; we must show that ˆq ∈ Q. The argument is on induction on the length of the least o path from Q to ˆq. The base case, ˆq ∈ Q, is immediate. For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1). Thus, St = Q. Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St . It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof. COROLLARY 4. For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa. PROPOSITION 5. For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF. Let M = Agt, St, Act, d, o, Π, π be given. Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM. Let M be the CGS obtained by removing the accessibility relations from ˆM . Clearly, M is isomorphic to M. COROLLARY 6. For every CGS M, there is an ATL-equivalent MIS S with initial states Q. That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa. PROPOSITION 7. The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure. PROOF. Take a CEGS M in which agent i has always perfect information about the current global state of the system. When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage. The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents. PROPOSITION 8. The size of In in S is, in general, exponential with respect to the number of local states and local actions. This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS). PROOF. Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere. The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i. Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}. Still, the current actions of all agents are relevant to determine the resulting local transition of agent i. We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS. In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer. To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions. Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS. Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway. More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent. Moreover, we can control and measure the complexity of each layer in a finer way than before. First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds). Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs. Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems. First, we define our (quite strong) notion of equivalence of representations. DEFINITION 7. Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures. They are CGS-equivalent if they unfold to the same CGS. PROPOSITION 9. For any SRML there is a CGS-equivalent MIS. PROOF. Consider an SRML R with k modules and n variables. We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment). Let us assume without loss of generality that ctri = {x1, ..., xr}. Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥. Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . To define local transitions, we consider three cases. If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α. If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise. Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise. Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi. The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states. In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations). Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ). Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML. We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way. Following the reviewers remarks, we state our complexity results only as conjectures. Preliminary proofs can be found in [14]. CONJECTURE 10. Model checking ATL for modular interpreted systems is EXPTIME-complete. CONJECTURE 11. Model checking ATLir for the class of modular interpreted systems is PSPACE-complete. A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below. The table presents completeness results for various models and settings of input parameters. Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system. The new results, conjectured in this paper, are printed in italics. Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern. When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems. Why can it be so? First, a MIS unfolds into CEGS and CGS in a different way. In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information). In the latter case, the epistemic The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently. Another crucial factor is the number of available strategies (relative to the size of input parameters). The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general. Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem. However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5. CONCLUSIONS We have presented a new class of representations for open multiagent systems. Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems. We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information. The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction. We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules. We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules. We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6. ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks. Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7. REFERENCES [1] R. Alur and T. A. Henzinger. Reactive modules. Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman. Alternating-time Temporal Logic. Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman. Alternating-time Temporal Logic. Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. Rajamani, and S. Tasiran. MOCHA user manual. In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson and J.Y. Halpern. sometimes and not never revisited: On branching versus linear time temporal logic. In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi. Reasoning about Knowledge. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke. Model checking for combined logics. In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga. Comparing semantics of logics for multi-agent systems. Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern. Reasoning about knowledge: a survey. In D. M. Gabbay, C. J. Hogger, and J. A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34. Oxford University Press, 1995. [11] J.Y. Halpern and R. Fagin. Modelling knowledge and action in distributed systems. Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix. Do agents make model checking explode (computationally)? In M. P˘echou˘cek, P. Petta, and L.Z. Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407. Springer Verlag, 2005. [13] W. Jamroga and J. Dix. Model checking abilities of agents: A closer look. Submitted, 2006. [14] W. Jamroga and T. Ågotnes. Modular interpreted systems: A preliminary report. Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y. Vardi, and P. Wolper. An automata-theoretic approach to branching-time model checking. Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby. Expressiveness and complexity of ATL. Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L. McMillan. Symbolic Model Checking: An Approach to the State Explosion Problem. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Applying SAT methods in unbounded symbolic model checking. In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio. Verifying epistemic properties of multi-agent systems via bounded model checking. In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003. ACM Press. [20] F. Raimondi and A. Lomuscio. The complexity of symbolic model checking temporal-epistemic logics. In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens. Alternating-time logic with imperfect recall. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge. On the complexity of practical ATL model checking. In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)",
    "original_translation": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de MOCHA. En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. I'm sorry, but \"Sistla\" is not a valid English sentence. Could you please provide a different sentence for translation? Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. \n\nTraducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson y J.Y. Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal. En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.\n\nMIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparando la semántica de lógicas para sistemas multiagente. Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. \n\nEditorial de la Universidad de Oxford, 1995. [11] J.Y. Halpern y R. Fagin. Modelando conocimiento y acción en sistemas distribuidos. Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación de modelos explote (computacionalmente)? En M. P˘echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Habilidades de verificación de modelos de agentes: Un vistazo más cercano. Presentado en 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: Un informe preliminar. Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación. Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L. McMillan. Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica sin límites. En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press. [20] F. Raimondi y A. Lomuscio. La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas. En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alternante con recuerdo imperfecto. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge. Sobre la complejidad de la verificación de modelos ATL práctica. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07)",
    "original_sentences": [
        "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
        "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
        "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
        "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
        "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
        "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
        "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
        "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
        "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
        "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
        "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
        "The structure of the paper is as follows.",
        "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
        "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
        "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
        "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
        "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
        "Thus, we usually need representations that are more compact.",
        "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
        "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
        "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
        "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
        "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
        "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
        "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
        "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
        "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
        "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
        "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
        "A q-path is a path that starts in q.",
        "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
        "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
        "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
        "We assume that all ∼a are equivalences.",
        "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
        "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
        "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
        "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
        "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
        "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
        "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
        "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
        "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
        "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
        "DEFINITION 1.",
        "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
        "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
        "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
        "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
        "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
        "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
        "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
        "A collective strategy is uniform if it contains only uniform individual strategies.",
        "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
        "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
        "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
        "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
        "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
        "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
        "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
        "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
        "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
        "Boolean variables, n-ary attributes etc.).",
        "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
        "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
        "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
        "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
        "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
        "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
        "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
        "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
        "Unfortunately, ATL models are anything but open in this sense.",
        "Theoretical complexity results for explicit models are as follows.",
        "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
        "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
        "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
        "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
        "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
        "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
        "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
        "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
        "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
        "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
        "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
        "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
        "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
        "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
        "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
        "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
        "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
        "Here, we use the formulation from [15].",
        "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
        "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
        "Concurrent programs have several advantages.",
        "First of all, they are modular and compact.",
        "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
        "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
        "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
        "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
        "Side effects of actions are also not easy to model.",
        "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
        "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
        "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
        "Now, particular actions are no less important than the resulting transitions.",
        "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
        "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
        "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
        "Finally, we would often like to assume that agents act synchronously.",
        "In particular, all agents play simultaneously in concurrent game structures.",
        "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
        "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
        "The first postulate is easy to satisfy, as we show in the following section.",
        "The second will be addressed in Section 4.",
        "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
        "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
        "DEFINITION 2.",
        "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
        "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
        "DEFINITION 3.",
        "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
        "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
        "It is required that ctr1, . . . ctrk partitions Π.",
        "The idea is that agent i controls the variables ctri.",
        "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
        "A guarded command is enabled if the guard φ is true in the current state of the system.",
        "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
        "Several guarded commands being enabled at the same time model non-deterministic choice.",
        "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
        "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
        "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
        "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
        "Concurrent epistemic programs are modular and have a grounded semantics.",
        "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
        "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
        "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
        "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
        "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
        "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
        "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
        "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
        "We have already mentioned a very limited variant of RML (i.e., SRML).",
        "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
        "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
        "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
        "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
        "Agents can act synchronously as well as asynchronously.",
        "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
        "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
        "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
        "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
        "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
        "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
        "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
        "The proposed framework is presented in Section 4. 4.",
        "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
        "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
        "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
        "DEFINITION 4.",
        "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
        "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
        "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
        "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
        "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
        "The environment, on the other hand, represents the (passive) context of agents actions.",
        "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
        "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
        "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
        "DEFINITION 5.",
        "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
        "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
        "It is required that ϕn ≡ , so that the mapping is effective.",
        "REMARK 1.",
        "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
        "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
        "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
        "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
        "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
        "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
        "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
        "Note that MISs can be used as representations of CGSs too.",
        "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
        "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
        "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
        "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
        "PROPOSITION 3.",
        "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
        "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
        "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
        "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
        "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
        "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
        "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
        "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
        "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
        "We now argue that St = Q.",
        "Clearly, Q ⊆ St .",
        "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
        "The argument is on induction on the length of the least o path from Q to ˆq.",
        "The base case, ˆq ∈ Q, is immediate.",
        "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
        "Thus, St = Q.",
        "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
        "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
        "COROLLARY 4.",
        "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
        "PROPOSITION 5.",
        "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
        "Let M = Agt, St, Act, d, o, Π, π be given.",
        "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
        "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
        "Clearly, M is isomorphic to M. COROLLARY 6.",
        "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
        "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
        "PROPOSITION 7.",
        "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
        "PROOF.",
        "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
        "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
        "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
        "PROPOSITION 8.",
        "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
        "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
        "PROOF.",
        "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
        "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
        "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
        "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
        "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
        "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
        "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
        "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
        "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
        "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
        "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
        "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
        "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
        "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
        "First, we define our (quite strong) notion of equivalence of representations.",
        "DEFINITION 7.",
        "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
        "They are CGS-equivalent if they unfold to the same CGS.",
        "PROPOSITION 9.",
        "For any SRML there is a CGS-equivalent MIS.",
        "PROOF.",
        "Consider an SRML R with k modules and n variables.",
        "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
        "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
        "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
        "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
        "To define local transitions, we consider three cases.",
        "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
        "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
        "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
        "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
        "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
        "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
        "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
        "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
        "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
        "Following the reviewers remarks, we state our complexity results only as conjectures.",
        "Preliminary proofs can be found in [14].",
        "CONJECTURE 10.",
        "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
        "CONJECTURE 11.",
        "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
        "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
        "The table presents completeness results for various models and settings of input parameters.",
        "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
        "The new results, conjectured in this paper, are printed in italics.",
        "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
        "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
        "Why can it be so?",
        "First, a MIS unfolds into CEGS and CGS in a different way.",
        "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
        "In the latter case, the epistemic The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
        "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
        "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
        "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
        "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
        "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
        "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
        "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
        "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
        "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
        "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
        "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
        "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
        "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
        "REFERENCES [1] R. Alur and T. A. Henzinger.",
        "Reactive modules.",
        "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
        "Alternating-time Temporal Logic.",
        "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
        "Alternating-time Temporal Logic.",
        "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
        "Henzinger, F.Y.C.",
        "Mang, S. Qadeer, S.K.",
        "Rajamani, and S. Tasiran.",
        "MOCHA user manual.",
        "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
        "Emerson, and A.P.",
        "Sistla.",
        "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
        "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
        "Emerson and J.Y.",
        "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
        "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
        "Reasoning about Knowledge.",
        "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
        "Model checking for combined logics.",
        "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
        "Comparing semantics of logics for multi-agent systems.",
        "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
        "Reasoning about knowledge: a survey.",
        "In D. M. Gabbay, C. J. Hogger, and J.",
        "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
        "Oxford University Press, 1995. [11] J.Y.",
        "Halpern and R. Fagin.",
        "Modelling knowledge and action in distributed systems.",
        "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
        "Do agents make model checking explode (computationally)?",
        "In M. P˘echou˘cek, P. Petta, and L.Z.",
        "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
        "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
        "Model checking abilities of agents: A closer look.",
        "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
        "Modular interpreted systems: A preliminary report.",
        "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
        "Vardi, and P. Wolper.",
        "An automata-theoretic approach to branching-time model checking.",
        "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
        "Expressiveness and complexity of ATL.",
        "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
        "McMillan.",
        "Symbolic Model Checking: An Approach to the State Explosion Problem.",
        "Kluwer Academic Publishers, 1993. [18] K.L.",
        "McMillan.",
        "Applying SAT methods in unbounded symbolic model checking.",
        "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
        "Verifying epistemic properties of multi-agent systems via bounded model checking.",
        "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
        "ACM Press. [20] F. Raimondi and A. Lomuscio.",
        "The complexity of symbolic model checking temporal-epistemic logics.",
        "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
        "Alternating-time logic with imperfect recall.",
        "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
        "On the complexity of practical ATL model checking.",
        "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
    ],
    "translated_text_sentences": [
        "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos.",
        "Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes.",
        "También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos.",
        "Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1.",
        "INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años.",
        "La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3].",
        "Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan.",
        "Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano.",
        "Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo.",
        "Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro.",
        "En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales.",
        "La estructura del documento es la siguiente.",
        "Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias.",
        "Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta.",
        "Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta.",
        "La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema.",
        "Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples.",
        "Por lo tanto, generalmente necesitamos representaciones que sean más compactas.",
        "Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación.",
        "Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata.",
        "En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico.",
        "Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes.",
        "Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama.",
        "Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta.",
        "Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2.",
        "LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla).",
        "Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
        "La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St).",
        "Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i].",
        "Un q-camino es un camino que comienza en q.",
        "La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7].",
        "Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ.",
        "Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente).",
        "Suponemos que todos los ∼a son equivalencias.",
        "La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q.",
        "Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial).",
        "Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular).",
        "El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt.",
        "Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ.",
        "Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente.",
        "La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs).",
        "Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas.",
        "La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St.",
        "Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk).",
        "DEFINICIÓN 1.",
        "Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A.",
        "Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
        "La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema.",
        "ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta.",
        "Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia).",
        "Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q).",
        "ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q).",
        "Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes.",
        "Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q.",
        "La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego.",
        "Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl.",
        "Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i.",
        "Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3.",
        "MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos.",
        "Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real).",
        "Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales).",
        "Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica).",
        "Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo,",
        "Variables booleanas, atributos n-arios, etc.",
        "Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15].",
        "Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad.",
        "Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos.",
        "Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo.",
        "En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa.",
        "Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL).",
        "Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente.",
        "No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema.",
        "Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido.",
        "Los resultados de complejidad teórica para modelos explícitos son los siguientes.",
        "La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5].",
        "Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados.",
        "La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16].",
        "La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras.",
        "Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18].",
        "Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos.",
        "Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos.",
        "Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π.",
        "St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno.",
        "El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St).",
        "Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi.",
        "Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados.",
        "Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos.",
        "Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos.",
        "Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí.",
        "Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial.",
        "Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos.",
        "Aquí, utilizamos la formulación de [15].",
        "Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional.",
        "La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración.",
        "El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes.",
        "Los programas concurrentes tienen varias ventajas.",
        "En primer lugar, son modulares y compactos.",
        "Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales).",
        "Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización.",
        "Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos.",
        "Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo.",
        "Los efectos secundarios de las acciones tampoco son fáciles de modelar.",
        "Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes.",
        "Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos.",
        "La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades.",
        "Ahora, las acciones particulares no son menos importantes que las transiciones resultantes.",
        "Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc.",
        "El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes.",
        "Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones!",
        "Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica.",
        "En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes.",
        "Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación.",
        "En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes.",
        "El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección.",
        "El segundo será abordado en la Sección 4.",
        "Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores.",
        "Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes.",
        "DEFINICIÓN 2.",
        "Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi.",
        "Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos.",
        "DEFINICIÓN 3.",
        "Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π.",
        "Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π.",
        "Se requiere que ctr1, . . . ctrk particionen Π.",
        "La idea es que el agente i controla las variables ctri.",
        "Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda.",
        "Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema.",
        "En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj.",
        "Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista.",
        "La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20].",
        "Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi.",
        "La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20].",
        "SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla.",
        "Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada.",
        "Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa).",
        "Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc.",
        "Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual.",
        "Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad).",
        "Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje.",
        "El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo.",
        "Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta.",
        "Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada.",
        "Ya hemos mencionado una variante muy limitada de RML (es decir, SRML).",
        "El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables.",
        "Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc.",
        "Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML.",
        "Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema.",
        "Los agentes pueden actuar de forma sincrónica y asíncrona.",
        "En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía.",
        "Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas.",
        "Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones.",
        "Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa.",
        "Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible.",
        "Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla.",
        "Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida.",
        "El marco propuesto se presenta en la Sección 4.4.",
        "SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes.",
        "La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas).",
        "Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción.",
        "DEFINICIÓN 4.",
        "Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción.",
        "Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones.",
        "El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv.",
        "Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente.",
        "Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS.",
        "El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes.",
        "En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes.",
        "Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In).",
        "Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción.",
        "DEFINICIÓN 5.",
        "La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i.",
        "La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
        "Se requiere que ϕn sea congruente, para que el mapeo sea efectivo.",
        "OBSERVACIÓN 1.",
        "Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]).",
        "Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In.",
        "En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6.",
        "El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera.",
        "Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q).",
        "Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´.",
        "Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2.",
        "Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs).",
        "En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo.",
        "Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q).",
        "Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente.",
        "Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8.",
        "PROPOSICIÓN 3.",
        "Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA.",
        "Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS.",
        "Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k.",
        "Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes.",
        "Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α).",
        "Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
        "De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk.",
        "Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk).",
        "Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1).",
        "Ahora argumentamos que St = Q.",
        "Claramente, Q ⊆ St.",
        "Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q.",
        "El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq.",
        "El caso base, ˆq ∈ Q, es inmediato.",
        "Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1).",
        "Por lo tanto, St = Q.",
        "Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St.",
        "Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba.",
        "COROLARIO 4.",
        "Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa.",
        "PROPOSICIÓN 5.",
        "Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA.",
        "Dado M = Agt, St, Act, d, o, Π, π.",
        "Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM.",
        "Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM.",
        "Claramente, M es isomorfo a M. COROLARIO 6.",
        "Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q.",
        "Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa.",
        "PROPOSICIÓN 7.",
        "Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente.",
        "PRUEBA.",
        "Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema.",
        "Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl.",
        "La propiedad anterior es parte del patrimonio de los sistemas interpretados.",
        "La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes.",
        "PROPUESTA 8.",
        "El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales.",
        "Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario).",
        "PRUEBA.",
        "Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes.",
        "La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i.",
        "Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}.",
        "Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i.",
        "Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS.",
        "En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local.",
        "Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones.",
        "Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS.",
        "Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local.",
        "Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida.",
        "Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes.",
        "Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad).",
        "Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs.",
        "En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares.",
        "Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones.",
        "DEFINICIÓN 7.",
        "Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas.",
        "Son equivalentes en CGS si se despliegan en el mismo sistema CGS.",
        "PROPUESTA 9.",
        "Para cualquier SRML hay un MIS equivalente en CGS.",
        "PRUEBA.",
        "Considera un SRML R con k módulos y n variables.",
        "Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento).",
        "Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}.",
        "Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥.",
        "Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
        "Para definir las transiciones locales, consideramos tres casos.",
        "Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α.",
        "Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso.",
        "Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso.",
        "Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi.",
        "La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales.",
        "De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización).",
        "Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri).",
        "Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML.",
        "Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa.",
        "Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas.",
        "Las pruebas preliminares se pueden encontrar en [14].",
        "CONJETURA 10.",
        "La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo.",
        "CONJETURA 11.",
        "La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa.",
        "Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación.",
        "La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada.",
        "Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular.",
        "Los nuevos resultados, propuestos en este documento, están impresos en cursiva.",
        "Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante.",
        "Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares.",
        "¿Por qué puede ser así?",
        "Primero, un MIS se despliega en CEGS y CGS de una manera diferente.",
        "En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta).",
        "En el último caso, el Sexto Congreso Internacional.",
        "La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente.",
        "Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada).",
        "El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general.",
        "Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema.",
        "Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5.",
        "CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos.",
        "Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas.",
        "También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta.",
        "Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta.",
        "Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos.",
        "Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos.",
        "También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6.",
        "AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones.",
        "El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega.",
        "REFERENCIAS [1] R. Alur y T. A. Henzinger.",
        "Módulos reactivos.",
        "Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman.",
        "Lógica Temporal de Tiempo Alternante.",
        "Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman.",
        "Lógica Temporal de Tiempo Alternante.",
        "Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
        "Henzinger, F.Y.C.",
        "Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K.",
        "Rajamani y S. Tasiran.",
        "Manual de usuario de MOCHA.",
        "En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A.",
        "Emerson y A.P.",
        "I'm sorry, but \"Sistla\" is not a valid English sentence. Could you please provide a different sentence for translation?",
        "Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal.",
        "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. \n\nTraducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
        "Emerson y J.Y.",
        "Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal.",
        "En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi.",
        "Razonamiento sobre el conocimiento.",
        "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.\n\nMIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke.",
        "Verificación de modelos para lógicas combinadas.",
        "En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga.",
        "Comparando la semántica de lógicas para sistemas multiagente.",
        "Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern.",
        "Razonamiento sobre el conocimiento: una encuesta.",
        "En D. M. Gabbay, C. J. Hogger y J.",
        "A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34.",
        "Oxford University Press, 1995. [11] J.Y. \n\nEditorial de la Universidad de Oxford, 1995. [11] J.Y.",
        "Halpern y R. Fagin.",
        "Modelando conocimiento y acción en sistemas distribuidos.",
        "Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix.",
        "¿Los agentes hacen que la verificación de modelos explote (computacionalmente)?",
        "En M. P˘echou˘cek, P. Petta y L.Z.",
        "Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407.",
        "Springer Verlag, 2005. [13] W. Jamroga y J. Dix.",
        "Habilidades de verificación de modelos de agentes: Un vistazo más cercano.",
        "Presentado en 2006. [14] W. Jamroga y T. Ågotnes.",
        "Sistemas interpretados modulares: Un informe preliminar.",
        "Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y.",
        "Vardi y P. Wolper.",
        "Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación.",
        "Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby.",
        "Expresividad y complejidad de ATL.",
        "Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L.",
        "McMillan.",
        "Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados.",
        "Kluwer Academic Publishers, 1993. [18] K.L.",
        "McMillan.",
        "Aplicando métodos SAT en la verificación simbólica sin límites.",
        "En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio.",
        "Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada.",
        "En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003.",
        "ACM Press. [20] F. Raimondi y A. Lomuscio.",
        "La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas.",
        "En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens.",
        "Lógica de tiempo alternante con recuerdo imperfecto.",
        "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge.",
        "Sobre la complejidad de la verificación de modelos ATL práctica.",
        "En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07)"
    ],
    "error_count": 2,
    "keys": {
        "modular interpreted system": {
            "translated_key": "sistema interpretado modular",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A <br>modular interpreted system</br> (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a <br>modular interpreted system</br> S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a <br>modular interpreted system</br> S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a <br>modular interpreted system</br> with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a <br>modular interpreted system</br> S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or <br>modular interpreted system</br>.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "A <br>modular interpreted system</br> (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a <br>modular interpreted system</br> S. DEFINITION 6.",
                "When constructing a <br>modular interpreted system</br> S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Note that M can be represented as a <br>modular interpreted system</br> with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "We will call items In, outi, ini the interaction layer of a <br>modular interpreted system</br> S; the other elements of S constitute the local layer of the MIS."
            ],
            "translated_annotated_samples": [
                "Un <br>sistema interpretado modular</br> (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción.",
                "En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un <br>sistema interpretado modular</br> S. DEFINICIÓN 6.",
                "Al construir un <br>sistema interpretado modular</br> S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl.",
                "Ten en cuenta que M se puede representar como un <br>sistema interpretado modular</br> con espacios de estado local concisos Sti = {qi 0, ..., qi i}.",
                "Llamaremos a los elementos In, outi, ini la <br>capa de interacción de un sistema interpretado modular</br> S; los otros elementos de S constituyen la capa local del MIS."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un <br>sistema interpretado modular</br> (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un <br>sistema interpretado modular</br> S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un <br>sistema interpretado modular</br> S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un <br>sistema interpretado modular</br> con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la <br>capa de interacción de un sistema interpretado modular</br> S; los otros elementos de S constituyen la capa local del MIS. ",
            "candidates": [],
            "error": [
                [
                    "sistema interpretado modular",
                    "sistema interpretado modular",
                    "sistema interpretado modular",
                    "sistema interpretado modular",
                    "capa de interacción de un sistema interpretado modular"
                ]
            ]
        },
        "open computational system": {
            "translated_key": "sistemas computacionales abiertos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of <br>open computational system</br>s (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about <br>open computational system</br>s.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of <br>open computational system</br>s (multi-agent systems in particular).",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about <br>open computational system</br>s."
            ],
            "translated_annotated_samples": [
                "Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de <br>sistemas computacionales abiertos</br> (sistemas multiagente en particular).",
                "Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre <br>sistemas computacionales abiertos</br>."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de <br>sistemas computacionales abiertos</br> (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre <br>sistemas computacionales abiertos</br>. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de MOCHA. En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. I'm sorry, but \"Sistla\" is not a valid English sentence. Could you please provide a different sentence for translation? Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. \n\nTraducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson y J.Y. Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal. En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.\n\nMIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparando la semántica de lógicas para sistemas multiagente. Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. \n\nEditorial de la Universidad de Oxford, 1995. [11] J.Y. Halpern y R. Fagin. Modelando conocimiento y acción en sistemas distribuidos. Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación de modelos explote (computacionalmente)? En M. P˘echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Habilidades de verificación de modelos de agentes: Un vistazo más cercano. Presentado en 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: Un informe preliminar. Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación. Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L. McMillan. Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica sin límites. En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press. [20] F. Raimondi y A. Lomuscio. La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas. En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alternante con recuerdo imperfecto. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge. Sobre la complejidad de la verificación de modelos ATL práctica. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "temporal and strategic logic": {
            "translated_key": "lógicas temporales y estratégicas",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking <br>temporal and strategic logic</br>s (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "A summary of complexity results for model checking <br>temporal and strategic logic</br>s (with and without epistemic component) is given in the table below."
            ],
            "translated_annotated_samples": [
                "Se presenta un resumen de los resultados de complejidad para la verificación de modelos de <br>lógicas temporales y estratégicas</br> (con y sin componente epistémico) en la tabla a continuación."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de <br>lógicas temporales y estratégicas</br> (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de MOCHA. En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. I'm sorry, but \"Sistla\" is not a valid English sentence. Could you please provide a different sentence for translation? Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. \n\nTraducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson y J.Y. Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal. En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.\n\nMIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparando la semántica de lógicas para sistemas multiagente. Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. \n\nEditorial de la Universidad de Oxford, 1995. [11] J.Y. Halpern y R. Fagin. Modelando conocimiento y acción en sistemas distribuidos. Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación de modelos explote (computacionalmente)? En M. P˘echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Habilidades de verificación de modelos de agentes: Un vistazo más cercano. Presentado en 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: Un informe preliminar. Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación. Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L. McMillan. Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica sin límites. En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press. [20] F. Raimondi y A. Lomuscio. La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas. En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alternante con recuerdo imperfecto. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge. Sobre la complejidad de la verificación de modelos ATL práctica. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "modeling methodology": {
            "translated_key": "metodología de modelado",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or <br>modeling methodology</br>. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or <br>modeling methodology</br>. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems."
            ],
            "translated_annotated_samples": [
                "Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la <br>metodología de modelado</br>. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la <br>metodología de modelado</br>. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de MOCHA. En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. I'm sorry, but \"Sistla\" is not a valid English sentence. Could you please provide a different sentence for translation? Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. \n\nTraducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson y J.Y. Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal. En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.\n\nMIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparando la semántica de lógicas para sistemas multiagente. Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. \n\nEditorial de la Universidad de Oxford, 1995. [11] J.Y. Halpern y R. Fagin. Modelando conocimiento y acción en sistemas distribuidos. Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación de modelos explote (computacionalmente)? En M. P˘echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Habilidades de verificación de modelos de agentes: Un vistazo más cercano. Presentado en 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: Un informe preliminar. Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación. Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L. McMillan. Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica sin límites. En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press. [20] F. Raimondi y A. Lomuscio. La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas. En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alternante con recuerdo imperfecto. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge. Sobre la complejidad de la verificación de modelos ATL práctica. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "model checking": {
            "translated_key": "verificación de modelos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and <br>model checking</br>) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on <br>model checking</br> alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and <br>model checking</br> systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that <br>model checking</br> ability under imperfect information for MIS can be computationally cheaper than <br>model checking</br> perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND <br>model checking</br> In this section, we present and discuss various (existing) representations of systems that can be used for modeling and <br>model checking</br>.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "<br>model checking</br> CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "<br>model checking</br> ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "<br>model checking</br> ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible <br>model checking</br> properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that <br>model checking</br> CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "<br>model checking</br> ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "<br>model checking</br> CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in <br>model checking</br> complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 <br>model checking</br> Modular Interpreted Systems One of our main aims was to study the complexity of symbolic <br>model checking</br> ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "<br>model checking</br> ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "<br>model checking</br> ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for <br>model checking</br> temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for <br>model checking</br> ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare <br>model checking</br> agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, <br>model checking</br> imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of <br>model checking</br> strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "<br>model checking</br> for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make <br>model checking</br> explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "<br>model checking</br> abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time <br>model checking</br>.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic <br>model checking</br>: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic <br>model checking</br>.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded <br>model checking</br>.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic <br>model checking</br> temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL <br>model checking</br>.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and <br>model checking</br>) temporal, strategic and epistemic properties of agents and their teams.",
                "We also mention preliminary results on <br>model checking</br> alternating-time temporal logic for this natural class of models.",
                "In Section 3, we present an overview of representations that have been used for modeling and <br>model checking</br> systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We conclude with a somewhat surprising hypothesis, that <br>model checking</br> ability under imperfect information for MIS can be computationally cheaper than <br>model checking</br> perfect information.",
                "MODELS AND <br>model checking</br> In this section, we present and discuss various (existing) representations of systems that can be used for modeling and <br>model checking</br>."
            ],
            "translated_annotated_samples": [
                "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y <br>verificar modelos</br>) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos.",
                "También mencionamos resultados preliminares sobre la <br>verificación de modelos</br> de lógica temporal de tiempo alternante para esta clase natural de modelos.",
                "En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y <br>verificar</br> sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico.",
                "Concluimos con una hipótesis algo sorprendente, que la capacidad de <br>verificación de modelos</br> bajo información imperfecta para MIS puede ser computacionalmente más barata que la <br>verificación de modelos</br> con información perfecta.",
                "MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y <br>verificar modelos</br>) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la <br>verificación de modelos</br> de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y <br>verificar</br> sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de <br>verificación de modelos</br> bajo información imperfecta para MIS puede ser computacionalmente más barata que la <br>verificación de modelos</br> con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. ",
            "candidates": [],
            "error": [
                [
                    "verificar modelos",
                    "verificación de modelos",
                    "verificar",
                    "verificación de modelos",
                    "verificación de modelos"
                ]
            ]
        },
        "multi-agent system": {
            "translated_key": "sistema multiagente",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a <br>multi-agent system</br> the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a <br>multi-agent system</br> as reading and/or writing from/to program variables.",
                "This view of a <br>multi-agent system</br> is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "In the case of a <br>multi-agent system</br> the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "Second, it is not always convenient to represent all that is going on in a <br>multi-agent system</br> as reading and/or writing from/to program variables.",
                "This view of a <br>multi-agent system</br> is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework."
            ],
            "translated_annotated_samples": [
                "En el caso de un <br>sistema multiagente</br>, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa.",
                "Segundo, no siempre es conveniente representar todo lo que está sucediendo en un <br>sistema multiagente</br> como lectura y/o escritura de variables de programa.",
                "Esta visión de un <br>sistema multiagente</br> está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un <br>sistema multiagente</br>, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un <br>sistema multiagente</br> como lectura y/o escritura de variables de programa. Esta visión de un <br>sistema multiagente</br> está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de MOCHA. En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. I'm sorry, but \"Sistla\" is not a valid English sentence. Could you please provide a different sentence for translation? Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. \n\nTraducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson y J.Y. Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal. En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.\n\nMIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparando la semántica de lógicas para sistemas multiagente. Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. \n\nEditorial de la Universidad de Oxford, 1995. [11] J.Y. Halpern y R. Fagin. Modelando conocimiento y acción en sistemas distribuidos. Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación de modelos explote (computacionalmente)? En M. P˘echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Habilidades de verificación de modelos de agentes: Un vistazo más cercano. Presentado en 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: Un informe preliminar. Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación. Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L. McMillan. Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica sin límites. En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press. [20] F. Raimondi y A. Lomuscio. La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas. En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alternante con recuerdo imperfecto. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge. Sobre la complejidad de la verificación de modelos ATL práctica. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "higher level representation language": {
            "translated_key": "lenguajes de representación de nivel superior",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on <br>higher level representation language</br>s for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Lately, an increasing amount of research has focused on <br>higher level representation language</br>s for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled."
            ],
            "translated_annotated_samples": [
                "Últimamente, una cantidad creciente de investigaciones se ha centrado en <br>lenguajes de representación de nivel superior</br> para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en <br>lenguajes de representación de nivel superior</br> para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de MOCHA. En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. I'm sorry, but \"Sistla\" is not a valid English sentence. Could you please provide a different sentence for translation? Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. \n\nTraducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson y J.Y. Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal. En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.\n\nMIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparando la semántica de lógicas para sistemas multiagente. Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. \n\nEditorial de la Universidad de Oxford, 1995. [11] J.Y. Halpern y R. Fagin. Modelando conocimiento y acción en sistemas distribuidos. Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación de modelos explote (computacionalmente)? En M. P˘echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Habilidades de verificación de modelos de agentes: Un vistazo más cercano. Presentado en 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: Un informe preliminar. Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación. Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L. McMillan. Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica sin límites. En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press. [20] F. Raimondi y A. Lomuscio. La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas. En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alternante con recuerdo imperfecto. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge. Sobre la complejidad de la verificación de modelos ATL práctica. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "branching time": {
            "translated_key": "tiempo ramificado",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine <br>branching time</br>, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 <br>branching time</br>: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "More precisely: modal logics that combine <br>branching time</br>, knowledge, and strategies under incomplete information.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 <br>branching time</br>: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL)."
            ],
            "translated_annotated_samples": [
                "Más precisamente: lógicas modales que combinan el <br>tiempo ramificado</br>, el conocimiento y las estrategias bajo información incompleta.",
                "LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla)."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el <br>tiempo ramificado</br>, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de MOCHA. En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. I'm sorry, but \"Sistla\" is not a valid English sentence. Could you please provide a different sentence for translation? Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. \n\nTraducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson y J.Y. Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal. En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.\n\nMIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparando la semántica de lógicas para sistemas multiagente. Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. \n\nEditorial de la Universidad de Oxford, 1995. [11] J.Y. Halpern y R. Fagin. Modelando conocimiento y acción en sistemas distribuidos. Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación de modelos explote (computacionalmente)? En M. P˘echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Habilidades de verificación de modelos de agentes: Un vistazo más cercano. Presentado en 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: Un informe preliminar. Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación. Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L. McMillan. Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica sin límites. En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press. [20] F. Raimondi y A. Lomuscio. La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas. En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alternante con recuerdo imperfecto. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge. Sobre la complejidad de la verificación de modelos ATL práctica. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "computation tree logic ctl": {
            "translated_key": "lógica de árbol de computación CTL",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with <br>computation tree logic ctl</br>, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL <br>computation tree logic ctl</br> [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "We start with <br>computation tree logic ctl</br>, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL <br>computation tree logic ctl</br> [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL)."
            ],
            "translated_annotated_samples": [
                "Comenzamos con la <br>lógica de árbol de computación CTL</br>, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta.",
                "LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla)."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la <br>lógica de árbol de computación CTL</br>, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de MOCHA. En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. I'm sorry, but \"Sistla\" is not a valid English sentence. Could you please provide a different sentence for translation? Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. \n\nTraducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson y J.Y. Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal. En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.\n\nMIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparando la semántica de lógicas para sistemas multiagente. Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. \n\nEditorial de la Universidad de Oxford, 1995. [11] J.Y. Halpern y R. Fagin. Modelando conocimiento y acción en sistemas distribuidos. Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación de modelos explote (computacionalmente)? En M. P˘echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Habilidades de verificación de modelos de agentes: Un vistazo más cercano. Presentado en 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: Un informe preliminar. Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación. Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L. McMillan. Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica sin límites. En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press. [20] F. Raimondi y A. Lomuscio. La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas. En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alternante con recuerdo imperfecto. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge. Sobre la complejidad de la verificación de modelos ATL práctica. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "alternating-time temporal logic": {
            "translated_key": "lógica temporal de tiempo alternante",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking <br>alternating-time temporal logic</br> for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of <br>alternating-time temporal logic</br> (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL <br>alternating-time temporal logic</br> ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "<br>alternating-time temporal logic</br>.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "<br>alternating-time temporal logic</br>.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "We also mention preliminary results on model checking <br>alternating-time temporal logic</br> for this natural class of models.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of <br>alternating-time temporal logic</br> (ATL): one for the perfect, and one for the imperfect information case.",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL <br>alternating-time temporal logic</br> ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "<br>alternating-time temporal logic</br>.",
                "<br>alternating-time temporal logic</br>."
            ],
            "translated_annotated_samples": [
                "También mencionamos resultados preliminares sobre la verificación de modelos de <br>lógica temporal de tiempo alternante</br> para esta clase natural de modelos.",
                "Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la <br>lógica temporal de tiempo alternante</br> (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta.",
                "Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA <br>Lógica temporal de tiempo alternante</br> LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular).",
                "<br>Lógica Temporal de Tiempo Alternante</br>.",
                "Lógica Temporal de Tiempo Alternante."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de <br>lógica temporal de tiempo alternante</br> para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la <br>lógica temporal de tiempo alternante</br> (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA <br>Lógica temporal de tiempo alternante</br> LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. <br>Lógica Temporal de Tiempo Alternante</br>. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "kripke structure": {
            "translated_key": "estructura de Kripke",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "synchronous concurrent program": {
            "translated_key": "programa concurrente síncrono",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A <br>synchronous concurrent program</br> consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "A <br>synchronous concurrent program</br> consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi."
            ],
            "translated_annotated_samples": [
                "Un <br>programa concurrente síncrono</br> consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un <br>programa concurrente síncrono</br> consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los módulos reactivos (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que hay una necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más sencillo que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios multiagente simples, especialmente para el diseño orientado a humanos (en contraposición al orientado a computadoras). 6. AGRADECIMIENTOS Agradecemos a los revisores anónimos y a Andrzej Tarlecki por sus útiles observaciones. El trabajo de Thomas Ågotnes en este artículo fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega. REFERENCIAS [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos Formales en el Diseño de Sistemas, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Notas de conferencia en Ciencias de la Computación, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica Temporal de Tiempo Alternante. Revista de la ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. -> Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de MOCHA. En las Actas de CAV98, volumen 1427 de Notas de Conferencia en Ciencias de la Computación, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. I'm sorry, but \"Sistla\" is not a valid English sentence. Could you please provide a different sentence for translation? Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones de lógica temporal. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. \n\nTraducción: ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson y J.Y. Halpern. A veces y no nunca revisado: Sobre la lógica temporal de tiempo ramificado versus lineal. En Actas del Simposio Anual de la ACM sobre Principios de Lenguajes de Programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.\n\nMIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ra Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparando la semántica de lógicas para sistemas multiagente. Síntesis, 139(2):241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. \n\nEditorial de la Universidad de Oxford, 1995. [11] J.Y. Halpern y R. Fagin. Modelando conocimiento y acción en sistemas distribuidos. Computación Distribuida, 3(4):159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación de modelos explote (computacionalmente)? En M. P˘echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de Notas de Conferencias en Ciencias de la Computación, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Habilidades de verificación de modelos de agentes: Un vistazo más cercano. Presentado en 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: Un informe preliminar. Informe técnico IfI-06-15, Universidad de Tecnología de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque automático-teórico para la verificación de modelos en tiempo de ramificación. Revista de la ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS y ENS Cachan, Francia, 2006. [17] K.L. McMillan. Verificación simbólica de modelos: Un enfoque al problema de la explosión de estados. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica sin límites. En Actas de CAV02, volumen 2404 de Notas de Conferencia en Ciencias de la Computación, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas multiagente a través de la verificación de modelos acotada. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press. [20] F. Raimondi y A. Lomuscio. La complejidad de la verificación de modelos simbólicos de lógicas temporales-epistémicas. En L. Czaja, editor, Actas de CS&P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alternante con recuerdo imperfecto. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, y M. Wooldridge. Sobre la complejidad de la verificación de modelos ATL práctica. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "reactive module": {
            "translated_key": "módulos reactivos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple <br>reactive module</br>s (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, <br>reactive module</br>s support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple <br>reactive module</br>s are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, <br>reactive module</br>s (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or <br>reactive module</br>s.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than <br>reactive module</br>s.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "We note that the simple <br>reactive module</br>s (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "Moreover, <br>reactive module</br>s support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Simple Reactive Modules In this section we show that simple <br>reactive module</br>s are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "In a way, <br>reactive module</br>s (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or <br>reactive module</br>s."
            ],
            "translated_annotated_samples": [
                "Observamos que los <br>módulos reactivos</br> simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos.",
                "Además, los <br>módulos reactivos</br> admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML.",
                "En esta sección mostramos que los <br>módulos reactivos</br> simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares.",
                "De cierta manera, los <br>módulos reactivos</br> (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización).",
                "Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o <br>módulos reactivos</br>."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y verificar modelos) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la verificación de modelos de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación de modelos con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y verificar modelos. Creemos que los dos puntos de referencia más importantes en este caso son: (1) el formalismo de modelado (es decir, la lógica y la semántica que utilizamos), y (2) el fenómeno, o más generalmente, el dominio que vamos a modelar (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que sea razonablemente cercana al mundo real (es decir, que sea suficientemente compacta y fundamentada), y aún así no esté demasiado alejada del formalismo (de modo que, por ejemplo, permita fácilmente el análisis teórico de problemas computacionales). Comenzamos discutiendo los méritos de los modelos explícitos, en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGSs, presentados en la sección anterior. 3.1 Modelos Explícitos Obviamente, una ventaja de los modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, en muchos aspectos son difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales suelen tener un número exponencial de estados con respecto a cualquier descripción de nivel superior (por ejemplo, Variables booleanas, atributos n-arios, etc. Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones conjuntas (síncronas o asíncronas) de varias entidades activas [15]. Para los CGSs la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si fijamos el número de estados. En la práctica, esto significa que tales representaciones rara vez son escalables. Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema; las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién, y de qué manera. • Lógicas como ATL a menudo se promocionan como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, uno desearía que los elementos de dicho sistema tuvieran la menor cantidad de interdependencias posible, de modo que puedan ser conectados y desconectados sin mucho problema, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema multiagente, la clase de modelos ATL alternativos de sistemas de transición [2] representan las transiciones de una manera más concisa. Mientras todavía tengamos un número exponencial de estados en un ATS, el número de transiciones es simplemente cuadrático con respecto a los estados (como en los modelos CTL). Desafortunadamente, los ATS son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden ser fácilmente extendidos para manejar información incompleta (cf. [9]). La necesidad es quizás aún más evidente. No solo necesitamos volver a conectar varios diseños de un solo agente en la arquitectura general; generalmente también necesitamos cambiar (por ejemplo, aumentar) el número de agentes actuando en un entorno dado sin necesariamente cambiar el diseño de todo el sistema. Desafortunadamente, los modelos de ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La verificación de modelos CTL y CTLK es P-completa, y puede realizarse en tiempo O(ml), donde m es el número de transiciones en el modelo, y l es la longitud de la fórmula [5]. Alternativamente, se puede hacer en tiempo O(n2 l), donde n es el número de estados. La verificación de modelos ATL es P-completa con respecto a m, l y ΔP 3 -completa con respecto a n, k, l (siendo k el número de agentes) [3, 12, 16]. La verificación de modelos de ATLir es ΔP 2-completa con respecto a m, l y ΔP 3-completa con respecto a n, k, l [21, 13]. 3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Tales modelos ofrecen cierta esperanza para la verificación de propiedades de sistemas abiertos/multiagente, aunque es bien sabido que son compactos solo en una fracción de todos los casos. Sin embargo, para nosotros son insuficientes por otra razón: son simplemente representaciones optimizadas de modelos explícitos. Por lo tanto, no son ni más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la metodología de modelado. 3.3 Sistemas Interpretados Los sistemas interpretados [11, 7] son considerados por muchos como un ejemplo principal de modelos computacionalmente fundamentados de sistemas distribuidos. Un sistema interpretado puede ser definido como una tupla IS = St1, ..., Stk, Stenv, R, π. St1, ..., Stk son los espacios de estado locales de los agentes 1, ..., k, y Stenv es el conjunto de estados del entorno. El conjunto de estados globales se define como St = St1 × ... × Stk × Stenv; R ⊆ St × St es una relación de transición, y π : Π → P(St). Mientras que la relación de transición encapsula la evolución (posible) del sistema a lo largo del tiempo, la dimensión epistémica está definida por los componentes locales de cada estado global: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi. Es fácil ver que tal representación es modular y compacta en lo que respecta a los estados. Además, proporciona un enfoque natural (fundamentado) para el conocimiento y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que las transiciones se representan en sistemas interpretados no es ni compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición conjunta, exactamente como en modelos explícitos. Esto no es sin razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene una representación exponencial. Y es casi tan difícil conectar y desconectar componentes en un sistema interpretado como en un modelo CTL o ATL ordinario, ya que la actividad local de un agente está completamente fusionada con su interacción con el resto del sistema. 3.4 Programas Concurrentes La idea de programas concurrentes ha sido conocida desde hace mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, utilizamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado Pi = Sti, Acti, Ri, Πi, πi, donde Sti es el conjunto de estados locales del proceso. La representación R de un modelo explícito M es compacta si el tamaño de R es logarítmico con respecto al tamaño de M. La Sexta Conferencia Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 899 i, Acti es el conjunto de acciones locales, Ri ⊆ Sti ×Acti ×Sti es una relación de transición, y Πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P está dado por el autómata producto de P1, ..., Pk bajo la suposición de que los procesos funcionan de forma asíncrona, las acciones se entrelazan y la sincronización se logra a través de nombres de acciones comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (aquí no solo los estados, sino también las acciones son locales). Además, permiten representar la interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional, y la sincronización. Por otro lado, no permiten representar la interacción implícita, incidental o no del todo benevolente entre procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo cual parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Sin embargo, esta es una queja menor en el contexto de CTL, ya que para lógicas temporales solo nos interesa el flujo de transiciones, y no las acciones subyacentes. Para el razonamiento temporal sobre k procesos asíncronos sin interacción implícita, los programas concurrentes parecen ser casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), que actúan juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en los estados de otros agentes, etc. El intercambio de mensajes y/o la realización de llamadas no son de ninguna manera la única forma de interacción entre agentes. Además, la disponibilidad de acciones (para un agente) no debería depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo, ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría asumir que los agentes actúan de forma sincrónica. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y autonomía de acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se asemeje mucho a los programas concurrentes, pero que permita modelar agentes que jueguen de forma sincrónica, y que posibilite modelar interacciones más sofisticadas entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo será abordado en la Sección 4. Observamos que la verificación de modelos CTL en programas concurrentes es PSPACE-completa en el número de estados locales y la longitud de la fórmula [15]. 3.5 CP Sincrónico y Módulos Reactivos Simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones actualmente ejecutadas por los otros jugadores. Una variante ligeramente diferente de programas concurrentes puede ser definida a través del producto síncrono de programas, de manera que todos los agentes jueguen simultáneamente. Desafortunadamente, bajo esta interpretación, no se puede modelar ninguna interacción directa entre las acciones de los agentes. DEFINICIÓN 2. Un programa concurrente síncrono consiste en k procesos concurrentes Pi = Sti, Acti, Ri, Πi, πi con el siguiente despliegue a un CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri para algún qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk tal que qi, αi, qi ∈ Ri para cada i; Π = Sk i=1 Πi, y π(p) = πi(p) para p ∈ Πi. Observamos que los <br>módulos reactivos</br> simples (SRML) de [22] pueden ser vistos como una implementación particular de programas concurrentes síncronos. DEFINICIÓN 3. Un sistema SRML es una tupla Σ, Π, m1, . . . , mk , donde Σ = {1, . . . , k} es un conjunto de módulos (o agentes), Π es un conjunto de variables booleanas, y, para cada i ∈ Σ, tenemos mi = ctri, initi, updatei , donde ctri ⊆ Π. Los conjuntos initi y updatei consisten en comandos protegidos de la forma φ ; v1 := ψ1; . . . ; vk := ψk, donde cada vj ∈ ctri, y φ, ψ1, . . . , ψk son fórmulas proposicionales sobre Π. Se requiere que ctr1, . . . ctrk particionen Π. La idea es que el agente i controla las variables ctri. Los comandos protegidos de inicialización se utilizan para inicializar las variables controladas, mientras que los comandos protegidos de actualización pueden cambiar sus valores en cada ronda. Un comando protegido está habilitado si la condición de protección φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando protegido de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a vj. Varias órdenes protegidas habilitadas al mismo tiempo modelan la elección no determinista. La verificación de modelos ATL para SRML ha sido demostrada como EXPTIMEcompleta en el tamaño del modelo y la longitud de la fórmula [22]. 3.6 Programas Epistémicos Concurrentes Los programas concurrentes (tanto asíncronos como síncronos) también pueden ser utilizados para codificar relaciones epistémicas, exactamente de la misma manera que lo hacen los sistemas interpretados [20]. Es decir, al desplegar un programa concurrente a un modelo de CTLK o ATLir, definimos que q1, ..., qk ∼i q1, ..., qk si y solo si qi = qi. La verificación de modelos CTLK en programas epistémicos concurrentes es PSPACE-completa [20]. SRML también puede interpretarse de la misma manera; entonces, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre aumentará el tamaño de dicho programa). Sin embargo, heredan todos los problemas de los programas concurrentes con información perfecta, discutidos en la Sección 3.4: interacción limitada entre componentes, disponibilidad de acciones locales dependiendo de la transición actual, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes tienen solo un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de la lógica que combina propiedades estratégicas y epistémicas es la verificación de protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que queramos, por ejemplo, verificar la capacidad de los agentes para pasar información entre ellos sin que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición; simplemente buscamos un protocolo en el que la transición de la interceptación exitosa nunca se lleve a cabo. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas multiagente, y resulta realmente difícil imaginar modelos de lógicas estratégico-epistémicas en los que no sea posible representar la comunicación. Módulos reactivos [1] pueden ser vistos como un refinamiento de programas epistémicos concurrentes (principalmente utilizados por el verificador de modelos MOCHA [4]), pero son mucho más poderosos, expresivos y 900 El Sexto Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) fundamentada. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML es muy cercano a las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son simplemente valuaciones de variables; los eventos/acciones son actualizaciones de variables. Sin embargo, los conjuntos de variables controlados por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los <br>módulos reactivos</br> admiten información incompleta (a través de la observabilidad de variables), aunque no es el enfoque principal de RML. Nuevamente, la relación entre conjuntos de variables observables (y conjuntos de variables controladas) queda principalmente a cargo del diseñador de un sistema. Los agentes pueden actuar de forma sincrónica y asíncrona. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía hay una necesidad de una clase de representaciones más simples y ligeramente más abstractas. Primero, el marco de RML es técnicamente complicado, involucrando una serie de conceptos auxiliares y sus definiciones. Segundo, no siempre es conveniente representar todo lo que está sucediendo en un sistema multiagente como lectura y/o escritura de variables de programa. Esta visión de un sistema multiagente está, sin duda, cerca de su implementación informática, pero suele estar bastante alejada del dominio del mundo real, de ahí la necesidad de un marco más abstracto y conceptualmente flexible. Tercero, la separación entre la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretativos, toma estas observaciones como punto de partida. El marco propuesto se presenta en la Sección 4.4. SISTEMAS INTERPRETADOS MODULARES La idea detrás de los sistemas distribuidos (incluso más en sistemas multiagente) es que tratamos con varios componentes débilmente acoplados, donde la mayor parte del procesamiento se realiza dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamiento ocurre entre los componentes. La interacción es crucial (lo que convierte a los programas concurrentes en una herramienta de modelado insuficiente), pero generalmente consume muchos menos recursos de los agentes que las computaciones locales (lo que convierte a las tablas de transición explícitas de los CGS, CEGS y sistemas interpretados en excesivas). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control preciso de la complejidad de la interacción. DEFINICIÓN 4. Un sistema interpretado modular (SIM) se define como una tupla S = Agt, env, Act, In, donde Agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, Act es un conjunto de acciones, e In es un conjunto de símbolos llamado alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = Sti, di, outi, ini, oi, Πi, πi, donde: • Sti es un conjunto de estados locales, • di: Sti → P(Act) define la disponibilidad local de acciones; para mayor comodidad de la notación, adicionalmente definimos el conjunto de acciones situadas como Di = {qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini son funciones de interacción; outi: Di → In se refiere a la influencia que una acción situada dada (del agente ai) puede tener en el mundo externo, e ini: Sti × Ink → In traduce las manifestaciones externas de los otros agentes (y el entorno) en la impresión que causan en la función de transición de ai dependiendo del estado local de ai, • oi: Di × In → Sti es una función de transición local (determinista), • Πi es un conjunto de proposiciones locales del agente ai donde requerimos que Πi y Πj sean disjuntas cuando i = j, y • πi: Πi → P(Sti) es una valoración de estas proposiciones. El entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, por lo que outenv : Stenv → In y oenv : Stenv × In → Stenv. Dentro de nuestro marco de trabajo, asumimos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un SIM como un agente, al igual que en el caso de CGS y CEGS. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada ini parecen ser los puntos frágiles aquí: cuando se proporcionan explícitamente como tablas, tienen un tamaño exponencial con respecto al número de agentes (y lineal con respecto al tamaño de In). Sin embargo, podemos utilizar, por ejemplo, una construcción similar a la de [16] para representar de manera más compacta las funciones de interacción. DEFINICIÓN 5. La función de entrada implícita para el estado q ∈ Sti está dada por una secuencia ϕ1, η1 , ..., ϕn, ηn , donde cada ηj ∈ In es un símbolo de interacción, y cada ϕj es una combinación booleana de proposiciones ˆηi , con η ∈ In; ˆηi representa que η es el símbolo actualmente generado por el agente i. La función de entrada se define ahora de la siguiente manera: ini(q, 1, ..., k, env) = ηj si y solo si j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. Se requiere que ϕn sea congruente, para que el mapeo sea efectivo. OBSERVACIÓN 1. Cada ini puede ser codificado como una función de entrada implícita, con cada ϕj siendo de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Se debe tener en cuenta que, para algunos dominios, la representación de un sistema en MIS requiere exponencialmente muchos símbolos en el alfabeto de interacción In. En tal caso, el problema es inherente al dominio, e ini tendrá un tamaño exponencial con respecto al número de agentes. 4.1 Representación de Sistemas de Agentes con MIS Sea Stg = ( Qk i=1 Sti)×Stenv el conjunto de todos los posibles estados globales generados por un sistema interpretado modular S. DEFINICIÓN 6. El despliegue de un MIS S para estados iniciales Q ⊆ Stg a un CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k se define de la siguiente manera: • Agt = {1, ..., k} y Act = Act, • St es el conjunto de estados globales de Stg que son alcanzables desde algún estado en Q a través de la relación de transición definida por o (abajo), • Π = Sk i=1 Πi ∪ Πenv, • Para cada q = q1, . . . , qk, qenv ∈ St e i = 1, ..., k, env, definimos q ∈ π (p) si p ∈ Πi y qi ∈ πi(p), • d (i, q) = di(qi) para el estado global q = q1, ..., qk, qenv , • La función de transición se construye de la siguiente manera. Sea q = q1, ..., qk, qenv ∈ St, y α = α1, ..., αk un perfil de acción tal que αi ∈ d(i, q). Definimos inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ para cada agente i = 1, . . . , k, y inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´. Entonces, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv si y solo si qi = qi .6 OBSERVACIÓN 2. Ten en cuenta que los Sistemas de Información de Mercado (MISs) también pueden ser utilizados como representaciones de los Sistemas de Gestión de Clientes (CGSs). En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el despliegue de un MIS S para estados iniciales Q en un CGS como cgs(S, Q). Las proposiciones 3 y 5 afirman que los sistemas interpretados modulares pueden ser utilizados como representaciones de modelos explícitos de sistemas multiagente. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las Proposiciones 7 y 8. PROPOSICIÓN 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM tal que cegs(SM, Q) es isomorfo a M.7 PRUEBA. Sea M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k un CEGS. Construimos un MIS SM = {a1, . . . , ak}, env, Act, In con agentes ai = Sti, di, outi, ini, oi, Πi, πi y entorno env = Stenv, outenv, inenv, oenv, Πenv, πenv, además de un conjunto Q ⊆ Stg de estados globales, de la siguiente manera. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} para 1 ≤ i ≤ k (es decir, Sti es el conjunto de clases de indistinguibilidad en M), • Stenv = St, • di([q]∼i ) = d(i, q) para 1 ≤ i ≤ k (esto está bien definido ya que d(i, q) = d(i, q ) siempre que q ∼i q ), • outi([q]∼i , αi) = αi para 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv para i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) e inenv(x) son arbitrarios para otros argumentos x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i para 1 ≤ i ≤ k y αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi y oenv son arbitrarios para otros argumentos, • Πi = ∅ para 1 ≤ i ≤ k, y Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Sea M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k. Sostenemos que M y M son isomorfos al establecer una correspondencia biunívoca entre los respectivos conjuntos de estados, y al mostrar que las otras partes de las estructuras concuerdan en los estados correspondientes. Primero mostramos que, para cualquier ˆq = [q]∼1, . . . , [q]∼k, q ∈ Q y cualquier α = α1, . . . , αk tal que αi ∈ d(i, ˆq), tenemos o(ˆq, α) = [q]∼1, . . . , [q]∼k, q donde q = o(q, α) (1). Sea ˆq = o(ˆq, α). Ahora, para cualquier i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 Esto muestra otra diferencia entre el entorno y los agentes: el entorno no posee conocimiento. 7 Decimos que dos CEGS son isomórficos si solo difieren en los nombres de los estados y/o acciones. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . De manera similar, obtenemos que inputenv(ˆq , α) = α1, . . . , αk. Así obtenemos que o(ˆq, α) = o1([q]∼1, α1, input1(ˆq, α)), . . . , ok([q]∼k, αk, inputk(ˆq, α)), oenv(q, inputenv(ˆq, α)) = [o(q, α1, . . . , αk)]∼1, . . . , [o(q, α1, . . . , αk)]∼k, o(q, α1, . . . , αk). Por lo tanto, ˆq = [q]∼1 , . . . , [q]∼k , q para q = o(q , α1, . . . , αk), lo cual completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ St. Sea ˆq ∈ St; debemos mostrar que ˆq ∈ Q. El argumento se basa en la inducción en la longitud del camino o más corto desde Q hasta ˆq. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = o (ˆq , α) para algún ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Por lo tanto, St = Q. Ahora tenemos una correspondencia uno a uno entre St y St: r ∈ St corresponde a [r]∼1, . . . , [r]∼k, r ∈ St. Queda por demostrar que las otras partes de las estructuras M y M concuerdan en estados correspondientes: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • Para p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) si y solo si q ∈ πenv(p) si y solo si q ∈ π(p) (mismas valuaciones en estados correspondientes), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • Se sigue inmediatamente de (1), y del hecho de que Q = St , que o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r si y solo si o(q , α) = r (transiciones en la misma acción conjunta en estados correspondientes llevan a estados correspondientes), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r si y solo si [q ]∼i = [r ]∼i si y solo si q ∼i r (las relaciones de accesibilidad relacionan estados correspondientes), lo cual completa la prueba. COROLARIO 4. Para cada CEGS M, hay un MIS S equivalente a ATLir con estados iniciales Q, es decir, para cada estado q en M hay un estado q en cegs(S, Q) que satisface exactamente las mismas fórmulas ATLir, y viceversa. PROPOSICIÓN 5. Para cada CGS M, existe un MIS SM y un conjunto de estados globales Q de SM tal que cgs(SM, Q) es isomorfo a M. PRUEBA. Dado M = Agt, St, Act, d, o, Π, π. Ahora, sea ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Según la Proposición 3, existe un MIS S ˆM con estados globales Q tal que ˆM = cegs(S ˆM , Q) es isomorfo a ˆM. Sea M el CGS obtenido al remover las relaciones de accesibilidad de ˆM. Claramente, M es isomorfo a M. COROLARIO 6. Para cada CGS M, hay un MIS S equivalente en ATL con estados iniciales Q. Es decir, para cada estado q en M hay un estado q en cgs(S, Q) que satisface exactamente las mismas fórmulas de ATL, y viceversa. PROPOSICIÓN 7. Los espacios de estado locales en un SIM no siempre son compactos con respecto a la estructura de juego epistémico concurrente subyacente. PRUEBA. Toma un CEGS M en el que el agente i siempre tiene información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular S de tal manera que M = cegs(S, Q), tenemos que Sti debe ser isomorfo a St. 902 The Sixth Intl. La propiedad anterior es parte del patrimonio de los sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y sistemas interpretados) permiten una interacción intensiva entre agentes. PROPUESTA 8. El tamaño de In en S es, en general, exponencial con respecto al número de estados locales y acciones locales. Esto es así incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considera un CGS M con agentes Agt = {1, ..., k}, estados globales St = Qk i=1{qi 0, ..., qi i}, y acciones Act = {0, 1}, todas habilitadas en todas partes. La función de transición se define como o(q1 j1, ..., qk jk, α1, ..., αk) = q1 l1, ..., qk lk, donde li = (ji + α1 + ... + αk) mod i. Ten en cuenta que M se puede representar como un sistema interpretado modular con espacios de estado local concisos Sti = {qi 0, ..., qi i}. Sin embargo, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos a los elementos In, outi, ini la capa de interacción de un sistema interpretado modular S; los otros elementos de S constituyen la capa local del MIS. En este artículo estamos interesados en última instancia en la complejidad de la verificación de modelos con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinómico en el número de estados locales y acciones. Ten en cuenta que, según las Proposiciones 7 y 8, no todos los modelos explícitos se someten a una representación compacta con un MIS. Sin embargo, como declaramos al principio de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes débilmente acoplados, donde la interacción es esencial, pero la mayor parte del procesamiento se realiza de todos modos de forma local. Más importante aún, el marco de Sistemas de Información Gerencial permite separar la interacción de agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más precisa que antes. Primero, podemos intentar abstraernos de la complejidad de una capa (por ejemplo, como en este artículo, asumiendo que la otra capa se mantiene dentro de ciertos límites de complejidad). Segundo, también podemos medir por separado la complejidad de interacción de diferentes agentes. 4.2 Sistemas Interpretados Modulares vs. En esta sección mostramos que los <br>módulos reactivos</br> simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. DEFINICIÓN 7. Dos representaciones son equivalentes si se despliegan en estructuras de juego epistémico concurrentes isomórficas. Son equivalentes en CGS si se despliegan en el mismo sistema CGS. PROPUESTA 9. Para cualquier SRML hay un MIS equivalente en CGS. PRUEBA. Considera un SRML R con k módulos y n variables. Construimos S = Agt, Act, In con Agt = {a1, ..., ak}, Act = {1, ..., n, ⊥1, ..., ⊥n}, e In = Sk i=1 Sti × Sti (los espacios de estado locales Sti se definirán en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de i son del tipo γi,ψ : ψ ; xi := , o γ⊥ i,ψ : ψ ; xi := ⊥. Ahora, el agente ai en S tiene los siguientes componentes: Sti = P(ctri) (es decir, los estados locales de ai son valuaciones de variables controladas por i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . Para definir las transiciones locales, consideramos tres casos. Si t = f = ∅ (no se permite ninguna actualización), entonces oi(qi, α, t, f ) = qi para cada acción α. Si t = ∅, tomamos cualquier ˆx arbitrario ∈ t, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi ∪ {ˆx} en otro caso; oi(qi, ⊥j, t, f ) = qi \\ {xj} si xj ∈ f, y qi ∪ {ˆx} en otro caso. Además, si t = ∅ = f, tomamos cualquier ˆx arbitrario ∈ f, y definimos oi(qi, j, t, f ) = qi ∪ {xj} si xj ∈ t, y qi \\ {ˆx} en caso contrario; oi(qi, ⊥j, t, f ) = qi \\{xj} si xj ∈ f, y qi \\{ˆx} en otro caso. Finalmente, Πi = ctri, y qi ∈ πi(xj) si y solo si xj ∈ qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que MIS: ri variables locales del agente i dan lugar a 2ri estados locales. De cierta manera, los <br>módulos reactivos</br> (tanto simples como completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos; luego, cada módulo puede ser visto como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, cabe destacar que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de longitud total O(2 Pk i=1 ri). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Finalmente observamos que los Sistemas Interpretados Modulares (MIS, por sus siglas en inglés) son más generales, ya que en SRML las acciones actuales de otros agentes no tienen influencia en el resultado de la acción actual del agente (aunque el resultado puede ser influenciado por los estados locales actuales de otros agentes). 4.3 Verificación de Modelos de Sistemas Interpretados Modulares Uno de nuestros principales objetivos fue estudiar la complejidad de la verificación de modelos simbólicos ATLir de una manera significativa. Siguiendo los comentarios de los revisores, presentamos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. CONJETURA 10. La verificación de modelos ATL para sistemas interpretados modulares es EXPTIME-completo. CONJETURA 11. La verificación de modelos de ATLir para la clase de sistemas interpretados modulares es PSPACE-completa. Se presenta un resumen de los resultados de complejidad para la verificación de modelos de lógicas temporales y estratégicas (con y sin componente epistémico) en la tabla a continuación. La tabla presenta los resultados de completitud para varios modelos y configuraciones de parámetros de entrada. Los símbolos n, k, m representan el número de estados, agentes y transiciones en un modelo explícito; l es la longitud de la fórmula, y nlocal es el número de estados locales en un programa concurrente o sistema interpretado modular. Los nuevos resultados, propuestos en este documento, están impresos en cursiva. Cabe destacar que el resultado para la verificación de modelos ATL contra sistemas interpretados modulares es una extensión del resultado de [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si estamos en lo correcto, entonces los resultados para ATL y ATLir forman un patrón intrigante. Cuando comparamos agentes de verificación de modelos con información perfecta frente a información imperfecta, el primer problema parece ser mucho más fácil contra modelos explícitos medidos con el número de transiciones; a continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes; finalmente, la verificación de modelos con información imperfecta resulta ser más fácil que la verificación de modelos con información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se despliega en CEGS y CGS de una manera diferente. En el primer caso, se asume que el SIE codifica las relaciones epistémicas de forma explícita (lo que hace que explote cuando modelamos agentes con información perfecta, o casi perfecta). En el último caso, el Sexto Congreso Internacional. La Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) ignora el aspecto 903, lo que brinda un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación al tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales; para estrategias uniformes, generalmente hay muchas menos, pero aún así son exponencialmente numerosas en general. Por lo tanto, el hecho de que las estrategias de información perfecta puedan ser sintetizadas de forma incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta. 5. CONCLUSIONES Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes pueden ser cambiados, reemplazados, eliminados o añadidos, con la menor cantidad de cambios posible en la representación completa; más compactas que las representaciones explícitas tradicionales; y fundamentadas, en el sentido de que las correspondencias entre los elementos básicos del modelo y las entidades que se están modelando son más inmediatas, proporcionando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de verificar la habilidad estratégica de nuestro modelo para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones propuestas en este documento no son necesariamente perfectas (por ejemplo, las funciones de impresión ini parecen ser la principal fuente de no modularidad en MIS, y quizás puedan mejorarse), pero creemos que son un paso en la dirección correcta. Tampoco pretendemos afirmar que nuestras representaciones deban reemplazar lenguajes de modelado más elaborados como Promela o <br>módulos reactivos</br>. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "model methodology": {
            "translated_key": "metodología del modelo",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "model check": {
            "translated_key": "verificación de modelos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and <br>model check</br>ing) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on <br>model check</br>ing alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and <br>model check</br>ing systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that <br>model check</br>ing ability under imperfect information for MIS can be computationally cheaper than <br>model check</br>ing perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and <br>model check</br>ing.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible <br>model check</br>ing properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that <br>model check</br>ing CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA <br>model check</br>er [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in <br>model check</br>ing complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic <br>model check</br>ing ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for <br>model check</br>ing temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for <br>model check</br>ing ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare <br>model check</br>ing agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, <br>model check</br>ing imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of <br>model check</br>ing strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make <br>model check</br>ing explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time <br>model check</br>ing.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic <br>model check</br>ing.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded <br>model check</br>ing.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic <br>model check</br>ing temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL <br>model check</br>ing.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and <br>model check</br>ing) temporal, strategic and epistemic properties of agents and their teams.",
                "We also mention preliminary results on <br>model check</br>ing alternating-time temporal logic for this natural class of models.",
                "In Section 3, we present an overview of representations that have been used for modeling and <br>model check</br>ing systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We conclude with a somewhat surprising hypothesis, that <br>model check</br>ing ability under imperfect information for MIS can be computationally cheaper than <br>model check</br>ing perfect information.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and <br>model check</br>ing."
            ],
            "translated_annotated_samples": [
                "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y <br>verificar modelos</br>) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos.",
                "También mencionamos resultados preliminares sobre la <br>verificación de modelos</br> de lógica temporal de tiempo alternante para esta clase natural de modelos.",
                "En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y <br>verificar</br> sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico.",
                "Concluimos con una hipótesis algo sorprendente, que la capacidad de <br>verificación de modelos</br> bajo información imperfecta para MIS puede ser computacionalmente más barata que la <br>verificación de modelos</br> con información perfecta.",
                "MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y <br>verificar modelos</br>."
            ],
            "translated_text": "Sistemas Interpretados Modulares Wojciech Jamroga Departamento de Informática Universidad Tecnológica de Clausthal, Alemania wjamroga@in.tu-clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Colegio Universitario de Bergen, Noruega tag@hib.no RESUMEN Proponemos una nueva clase de representaciones que pueden ser utilizadas para modelar (y <br>verificar modelos</br>) propiedades temporales, estratégicas y epistémicas de agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin, entre otros; sin embargo, también son modulares y compactas de la misma manera que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la <br>verificación de modelos</br> de lógica temporal de tiempo alternante para esta clase natural de modelos. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida Sistemas Multiagente; I.2.4 [Inteligencia Artificial]: Formalismos y Métodos de Representación del Conocimiento-Lógica Modal Términos Generales Teoría 1. INTRODUCCIÓN Los fundamentos lógicos de los sistemas multiagente han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar sobre, por ejemplo, el conocimiento [7], el tiempo [6], la cooperación y la capacidad estratégica [3]. Últimamente, una cantidad creciente de investigaciones se ha centrado en lenguajes de representación de nivel superior para modelos de tales lógicas, motivada principalmente por la necesidad de representaciones compactas y por representaciones que se correspondan más estrechamente con los sistemas reales que se modelan. Los sistemas multiagente son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas multiagente que sean modulares, en el sentido de que un componente, como un agente, pueda ser reemplazado, eliminado o agregado, sin cambios importantes en la representación del modelo completo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son a la vez modulares, compactos y fundamentados computacionalmente por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica por otro. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas multiagentes abiertos, que son modulares, compactas y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos el contexto de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo ramificado, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica de árbol de computación CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de la lógica temporal de tiempo alternante (ATL): una para el caso de información perfecta y otra para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 suele definirse sobre modelos explícitos (estructuras de Kripke) que enumeran todos los posibles estados (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno mayormente quiere evitar, ya que hay demasiados incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para utilizar una clase más especializada de modelos es que las estructuras de Kripke generales no siempre brindan suficiente ayuda en términos de metodología, ni en la etapa de diseño ni en la implementación. Esto requiere una semántica más fundamentada, en el sentido de que la correspondencia entre los elementos del modelo y las entidades que se modelan es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y <br>verificar</br> sistemas en los que el tiempo, la acción (y posiblemente el conocimiento) son importantes; mencionamos especialmente las representaciones utilizadas para análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no desempeñan su papel de manera satisfactoria cuando se consideran las estrategias de los agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (SIM) y mostramos dónde encaja en el panorama. Concluimos con una hipótesis algo sorprendente, que la capacidad de <br>verificación de modelos</br> bajo información imperfecta para MIS puede ser computacionalmente más barata que la <br>verificación de modelos</br> con información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfecta (y los demás eran indiferentes). 2. LÓGICAS DEL TIEMPO, EL CONOCIMIENTO Y LA CAPACIDAD ESTRATÉGICA Primero, presentamos las lógicas CTL, CTLK, ATL y ATLir que son el punto de partida de nuestro estudio. 2.1 Tiempo de Ramificación: CTL La lógica de árbol de cómputo CTL [6] incluye operadores para propiedades temporales de sistemas: es decir, el cuantificador de camino E (hay un camino), junto con operadores temporales: f (en el siguiente estado), 2 (siempre de ahora en adelante) y U (hasta). Cada aparición de un operador temporal es inmediatamente precedida por exactamente un cuantificador de camino (esta variante del lenguaje a veces se llama CTL vainilla). Sea Π un conjunto de proposiciones atómicas con un elemento típico p. Las fórmulas de CTL ϕ se definen de la siguiente manera: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. La semántica de CTL se basa en modelos de Kripke M = St, R, π, que incluyen un conjunto no vacío de estados St, una relación de transición de estados R ⊆ St × St, y una valoración de proposiciones π: Π → P(St). Un camino λ en M se refiere a un posible comportamiento (o computación) del sistema M, y puede ser representado como una secuencia infinita de estados q0q1q2... tal que qiRqi+1 para todo i = 0, 1, 2, .... Denotamos el estado i-ésimo en λ como λ[i]. Un q-camino es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: M, q |= p si y solo si q ∈ π(p); M, q |= ¬ϕ si y solo si M, q |= ϕ; M, q |= ϕ ∧ ψ si y solo si M, q |= ϕ y M, q |= ψ; M, q |= E fϕ si y solo si hay un camino q-λ tal que M, λ[1] |= ϕ; M, q |= E2ϕ si y solo si hay un camino q-λ tal que M, λ[i] |= ϕ para todo i ≥ 0; M, q |= Eϕ U ψ si y solo si hay un camino q-λ y i ≥ 0 tal que M, λ[i] |= ψ y M, λ[j] |= ϕ para todo 0 ≤ j < i. 2.2 Adición de Conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea Agt = {1, ..., k} un conjunto de agentes con un elemento típico a. La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como el agente a sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones de indistinguibilidad epistémica ∼a⊆ St × St (una por agente). Suponemos que todos los ∼a son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: M, q |= Kaϕ si y solo si M, q |= ϕ para todo q tal que q ∼a q. Se debe tener en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una unidad única, pero se volverá importante cuando agentes particulares y sus estrategias tomen protagonismo. 2.3 Agentes y sus estrategias: LTA Lógica temporal de tiempo alternante LTA [3] es una lógica para razonar sobre propiedades temporales y estratégicas de sistemas computacionales abiertos (sistemas multiagente en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ, donde A ⊆ Agt. Informalmente, A ϕ dice que los agentes A tienen una estrategia colectiva para hacer valer ϕ. Cabe destacar que los cuantificadores de trayectoria CTL A, E se pueden expresar con ∅, Agt respectivamente. La semántica de ATL está definida en las llamadas estructuras de juegos concurrentes (CGSs). Un CGS es una tupla M = Agt, St, Act, d, o, Π, π, 1. Los operadores adicionales A (para cada camino) y 3 (en algún momento en el futuro) se definen de la manera habitual, y consisten en: un conjunto Agt = {1, . . . , k} de agentes; un conjunto St de estados; una valoración de proposiciones π: Π → P(St); y un conjunto Act de acciones atómicas. La función d : Agt × St → P(Act) indica las acciones disponibles para el agente a ∈ Agt en el estado q ∈ St. Finalmente, o es una función de transición determinística que mapea un estado q ∈ St y un perfil de acciones α1, . . . , αk ∈ Actk , αi ∈ d(i, q), a otro estado q = o(q, α1, . . . , αk). DEFINICIÓN 1. Una estrategia (sin memoria) del agente a es una función sa: St → Act tal que sa(q) ∈ d(a, q). Una estrategia colectiva SA para un equipo A ⊆ Agt especifica una estrategia individual para cada agente a ∈ A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todas las computaciones que pueden resultar de ejecutar SA desde q en: out(q, SA) = {λ = q0q1q2... | q0 = q y para cada i = 1, 2, ... existe αi−1 1 , ..., αi−1 k tal que αi−1 a = SA(a)(qi−1) para cada a ∈ A, αi−1 a ∈ d(a, qi−1) para cada a /∈ A, y o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. La semántica de las modalidades de cooperación es la siguiente: M, q |= A fϕ si y solo si existe una estrategia colectiva SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[1] |= ϕ; M, q |= A 2ϕ si y solo si existe SA tal que, para cada λ ∈ out(q, SA), tenemos que M, λ[i] para todo i ≥ 0; M, q |= A ϕ U ψ si y solo si existe SA tal que para cada λ ∈ out(q, SA) hay un i ≥ 0, para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para todo 0 ≤ j < i. Agentes con Información Imperfecta: ATLir Dado que ATL no incluye información incompleta en su alcance, puede ser visto como una lógica para razonar sobre agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. ATLir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: A ir indica que se dirigen a agentes con información imperfecta y memoria imperfecta. Formalmente, la definición recursiva de las fórmulas ATLir es: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ. Los modelos de ATLir, estructuras de juego epistémico concurrente (CEGS), pueden ser definidos como tuplas M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π, donde Agt, St, Act, d, o, Π, π es un CGS, y ∼1, ..., ∼k son relaciones epistémicas (de equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: q ∼a q implica d(a, q) = d(a, q). ATLir restringe las estrategias que pueden ser utilizadas por los agentes a estrategias uniformes, es decir, funciones sa: St → Act, tales que: (1) sa(q) ∈ d(a, q), y (2) si q ∼a q entonces sa(q) = sa(q). Una estrategia colectiva es uniforme si solo contiene estrategias individuales uniformes. Nuevamente, la función out(q, SA) devuelve el conjunto de todos los caminos que pueden resultar de los agentes A ejecutando la estrategia colectiva SA desde el estado q. La semántica de las fórmulas de ATLir se puede definir de la siguiente manera: M, q |= A ir fϕ si y solo si existe una estrategia colectiva uniforme SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos que M, λ[1] |= ϕ; Esto es una desviación de la semántica original de ATL [3], donde las estrategias asignan a los agentes opciones a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL completo y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), cabe señalar que ambos tipos de estrategias producen una semántica equivalente para el ATL puro (cf. [21]). 898 The Sixth Intl. Conf. Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) M, q |= A ir2ϕ si y solo si existe SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), tenemos M, λ[i] para cada i ≥ 0; M, q |= A irϕ U ψ si y solo si existen SA tal que, para cada a ∈ A, q tal que q ∼a q, y λ ∈ out(SA, q), existe i ≥ 0 para el cual M, λ[i] |= ψ, y M, λ[j] |= ϕ para cada 0 ≤ j < i. Es decir, A cumple con A irϕ si A tiene una estrategia colectiva uniforme, de modo que para cada camino que pueda resultar de la ejecución de la estrategia según al menos un agente de A, ϕ se cumple. 3. MODELOS Y VERIFICACIÓN DE MODELOS En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden ser utilizadas para modelar y <br>verificar modelos</br>. ",
            "candidates": [],
            "error": [
                [
                    "verificar modelos",
                    "verificación de modelos",
                    "verificar",
                    "verificación de modelos",
                    "verificación de modelos",
                    "verificar modelos"
                ]
            ]
        }
    }
}