{
    "id": "I-1",
    "original_text": "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans. In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent. In this paper we investigate the incorporation of aborts into a BDI-style architecture. We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision. We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages. We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK). A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence. Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1. INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13]. Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21]. In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently. When failures occur, the choice of plans will be reviewed. This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14]. Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions. Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle. Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan. This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment). Aborting a task or plan is distinct from its failure. Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again. In contrast, aborting says nothing about the ability to perform; it merely eliminates the need. Failure propagates from the bottom up, whereas aborting propagates from the top down. The potential for concurrently executing sub-plans introduces different complexities for aborting and failure. For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down. For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up. There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling. However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required. As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world. A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world. We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely). In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort. A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort. This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting. Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code. We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17]. This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9]. Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]). This paper is organized as follows. In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures. In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan. Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2. MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11]. Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her. CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1. Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2. Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3. Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4. Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5. Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference. These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel. Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1. Send Clearance Request (SCR) to Alices manager. 2. Wait For Response (WFR) from the manager. 3. Confirm that the response was positive, and fail otherwise. Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper. Alice will no longer be able to attend IJCAI. She therefore instructs her CALO agent to abort the SMS task. Aborting the task implies aborting both the SMS plan and the AFC subplan. Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task. We note a number of important observations from the example. First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example. In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made. Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when. Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request. In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done. This is similar to the case for failure, in that there may also be actions to take when a task or plan fails. In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task). Rather, cleaning up involves compensation via forward recovery actions [3]. Third, there is a distinction between aborting a task and aborting a plan. In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted. Hence, plan aborting or failure does not necessarily lead to task aborting or failure. Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods. This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3. ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts. They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions. Failure and aborting, however, differ in the way they arise. In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans. In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan. In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses. Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied. The agent selects and executes instances of plan clauses to perform its tasks. There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted. Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed. In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails. The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure. Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan. Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task. Our approach associates an abort-method with each plan. This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task. Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions. The question remains which abort-method should be invoked, and in what manner. Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules. Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events. An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action. We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans. In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1. When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted. For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers. Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance. In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2. When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task. For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline. The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3. When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue. For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI. Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks. Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12]. The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above. The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority. Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work. Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance). Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash). Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required. In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world. As a result, the effects of many actions cannot be simply undone. Moreover, the undo process may cause adverse effects. Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources. The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails. To this, we add the abort-method, which is invoked if the plan is to be aborted. In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number. The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below. The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed. For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan. However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task. Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans. Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe. Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks. When a plan P is aborted: 1. Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2. When there are no more active children, invoke the abort method of plan P. 3. Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1. Abort the current active plan to satisfy T (if any). 2. When there are no more active child processes, drop the task. The agent thus no longer pursues T. 3. Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted. In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail. In reality, however, an abort-method may fail. In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation. The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption. In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures. We also assume that failure- and abort-methods terminate in finite time. 4. OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above. We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms. The extensions also simplified the semantics in the earlier work. We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1. Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems. CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal. Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted. This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2]. In practical systems, tasks are typically translated into events that trigger the execution of some plans. This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced. This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true. An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body. The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true. Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs. The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics. It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program. The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ). The above defines the user language. In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program. When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ). The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed. A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows. A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention). A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1. S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions. A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator). Figure 1 gives some of the operational rules. The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ. The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary. This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists. Rule Sequence handles sequencing of programs in the usual way. Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel. Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17]. The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true. The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal. The fourth rule GS executes a single step of the goal-program. The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted. We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program. The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA. Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA). With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other. We must take into consideration the possible existence of abort-methods in the aborted branch. Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program. We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN. The one non-standard extension to CAN is a wait-until-condition construct. We explain this simple modification of the parallel construct below when we come to translation of the Goal construct. First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs. A key issue is that the FAb constructs may be nested, either directly or indirectly. Let us call each instantiation of the construct at execution time a possible abort point (pap). Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3. The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap. We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause. This variable is used to keep track of the context of execution. The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context. For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1]. We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51. This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v . For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs. These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context. Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v . We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v .(a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children. First let us consider the case of the FAb construct. The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context. We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ). We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort. While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort. This is represented by the predicate sa(v ) being true. However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped. Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ). This condition relies on the fact that as the children paps complete, they remove the relevant a facts. Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met. To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails. We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal. Hence, if the Goal construct fails, then the program either was aborted or it failed. We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail. Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other. Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch. At the end, if either branch was aborted, then we must fail. Let v and v be new variables distinct from any other in the agents plan library. We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied. To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct. The construct φ : P does not execute P until φ becomes true. We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context. We must ensure that belief a(v ) is removed whether the Goal succeeds or fails. We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition. The waiting branch will trigger the abort of the program should either the success or failure condition be met. To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active. Let v be a new variable distinct from any other in the agents plan library. We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true. There are two ways this can occur. First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes. This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true. In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs. The second way for san(v ) to become true is if v or one of its ancestors is aborted. In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2. We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN. Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively. Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two. Let v and v denote new variables. Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct. Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed. If the old plan body fails, or if the task is to be aborted, the Goal construct fails. This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure. The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted. If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true. This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ). The task !CCR(v ) will be executed. Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail. While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2. The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5. RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6]. Failure clean-up plans are triggered from goal deletion events −!g. Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs. In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again. If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal. Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan. Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language. The implementation of H¨ubner et al. [6] requires Jasons internal actions. A requirement for implementing our approach is a reflective capability in the BDI agent implementation. Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9]. All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states. Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent. Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution. These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level. Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions. Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful). The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal). This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge. While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling. Further, the FHC explicitly maintains data structures to track agent execution. We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead. FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed). The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system). Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol. This approach, together with state checkpointing, is used for multi-agent systems in [22]. The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery. Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8]. In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6. CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure. In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort. Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN. We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism. We are also developing an analysis tool for our extended version of CAN as a basis for experimentation. An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action. We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task). Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12]. Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process. This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment. Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one. However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic. A further item of interest is extending our approach to failure and abort to maintenance goals [1]. For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves. Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments. The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486. The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No. NBCHD030010. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7. REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf. Goal representation for BDI Agent systems. In Proc. of Second Intl. Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas. JACK intelligent agents - components for intelligent agents in Java. AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson. Extending the concept of transaction compensation. IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J. C. Meyer. Goal types in agent programming. In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall. Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems. In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge. Programming declarative goals using plan patterns. In Proc. of 4th Intl. Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny. The Psi calculus: an algebraic agent language. In Proc. of ATAL01, 2001. [8] M. Klein, J. A. Rodr´ıguez-Aguilar, and C. Dellarocas. Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death. Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers. The SPARK agent framework. In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith. Continuous refinement of agent resource estimates. In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe. An intelligent personal assistant for task and time management. AI Magazine, 28, 2007. To appear. [12] K. L. Myers and N. Yorke-Smith. A cognitive framework for delegation to an assistive user agent. In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff. Developing Intelligent Agent Systems: A Practical Guide. John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf. Jadex: A BDI reasoning engine. In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming. Springer, 2005. [15] A. S. Rao. AgentSpeak(L): BDI agents speak out in a logical computable language. In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff. An abstract architecture for rational agents. In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham. Hierarchical planning in BDI agent programming languages: a formal approach. In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham. Goals in the context of bdi plan failure and planning. In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff. Detecting and exploiting positive goal interaction in intelligent agents. In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer. Avoiding resource conflicts in intelligent agents. In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao. A framework for goal-based semantic compensation in agent systems. In Proc. of First Intl. Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao. Semantic-compensation-based recovery management in multi-agent systems. In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah. Declarative and procedural goals in intelligent agent systems. In Proc. of KR02, 2002. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15",
    "original_translation": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). Abortar una tarea o plan es distinto de su fracaso. El fracaso refleja una incapacidad para desempeñarse y no anula la necesidad de desempeñarse, por ejemplo, una respuesta razonable al fracaso puede ser intentarlo de nuevo. Por el contrario, abortar no dice nada sobre la capacidad de realizar; simplemente elimina la necesidad. El fracaso se propaga de abajo hacia arriba, mientras que la interrupción se propaga de arriba hacia abajo. El potencial de ejecutar subplanes de forma simultánea introduce diferentes complejidades para la interrupción y el fallo. Para abortar, significa que varios subplanes concurrentes pueden necesitar ser abortados a medida que se propaga el aborto hacia abajo. Para el fallo, significa que los planes paralelos hermanos pueden necesitar ser abortados a medida que el fallo se propaga hacia arriba. Ha habido una cantidad considerable de trabajo sobre fallos en los planes (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallos. Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de aborto más allá de la simple eliminación de los planes y tareas actualmente previstos, lo cual no aborda la limpieza requerida. Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de un constructo paralelo. Se puede considerar que ambas tareas se realizan y se tienen objetivos para lograr un cierto estado del mundo. Una tarea puede considerarse un objetivo de lograr el estado de la tarea una vez realizada, y un objetivo puede considerarse una tarea de llevar a cabo ese estado en el mundo. Adoptamos la última perspectiva y usamos la palabra \"tarea\" también para referirnos a los objetivos. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS falla (los enfoques comunes incluyen permitir que la otra rama se ejecute hasta su finalización sin obstáculos o eliminarla por completo). En este documento discutimos en detalle la incorporación de métodos de limpieza de aborto en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto. Una característica clave de nuestro enfoque basado en procedimientos es que permitimos que cada plan ejecute un código particular en caso de fallo y de aborto. Esto permite que un plan intente asegurar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar de otra manera antes de salir. Por consiguiente, un desafío técnico central es gestionar la ejecución ordenada del código de limpieza adecuado. Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una semántica operativa para abortar en el lenguaje de agente abstracto CAN [23, 17]. Esto nos permite especificar un nivel adecuado de detalle para el modelo de ejecución, sin centrarnos en las construcciones específicas de ningún sistema de agentes en particular, como JACK [2], Jadex [14], Jason [6] o SPARK [9]. Nuestro enfoque se centra en un único agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas de un solo agente y multiagentes (por ejemplo, [22, 5, 6]). Este documento está organizado de la siguiente manera. En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deberían ocurrir los abortos, y los procedimientos adecuados de representación e invocación. En la Sección 4 mostramos cómo podemos utilizar CAN para especificar formalmente el comportamiento de un plan abortado. La sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro. EJEMPLO MOTIVADOR Alice es una trabajadora del conocimiento asistida por un agente de asistencia personal y de aprendizaje como CALO [11]. Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente CALO adopta la tarea de Presentación de Reuniones de Apoyo (SMS) para ayudarla. El plan de CALO para una tarea de SMS en el caso de una presentación en una conferencia consiste en las siguientes sub tareas: 1. Asignar un Número de Documento (APN) para ser utilizado con fines administrativos en la empresa. 2. Seguimiento de la Escritura del Resumen (SER): hacer un seguimiento del progreso de Alicia en la preparación de un resumen. 3. Solicitar autorización de publicación (AFC) del gerente de Alice basado en el resumen y los detalles de la conferencia. 4. Papel de seguimiento de escritura (PSE): llevar un registro del progreso de Alicia en la escritura del papel. 5. Manejo de la presentación de documentos (HPS): seguir los procedimientos internos de la empresa para presentar un documento a una conferencia. Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo. De manera similar, CALO puede realizar la tarea de Solicitar Autorización de Despeje (AFC) mediante un plan que consiste en: 1. Enviar la Solicitud de Autorización (SCR) al gerente de Alice. 2. Espera la respuesta (WFR) del gerente. 3. Confirma que la respuesta fue positiva, y falla en caso contrario. Ahora supongamos que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras está escribiendo el documento. Alice ya no podrá asistir a IJCAI. Por lo tanto, ella instruye a su agente CALO para abortar la tarea de SMS. Abortar la tarea implica abortar tanto el plan de SMS como el subplan de AFC. Abortar el primer plan requiere que CALO notifique al registro de números de papel que el número de papel asignado está obsoleto, lo cual puede lograr mediante la tarea Cancelar Número de Papel (CPN). Abortar el segundo plan requiere que CALO notifique al gerente de Alice que Alice ya no necesita autorización para publicar, lo cual CALO puede lograr invocando la tarea Cancelar Solicitud de Autorización (CCR). Observamos una serie de observaciones importantes del ejemplo. Primero, la decisión de abortar un curso de acción particular puede surgir de las deliberaciones internas del agente (como razonar sobre prioridades en un conflicto por recursos), o de fuentes externas (como otro agente cancelando un compromiso), como en este ejemplo. En este documento solo abordamos el problema de determinar si una tarea o plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se haya tomado esta decisión. Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo. Segundo, una vez que se toma la decisión de abortar el intento de enviar un artículo, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización. En otras palabras, abortar una tarea no es simplemente cuestión de abandonar la tarea y los planes activos asociados: puede haber algunas acciones de limpieza que necesiten realizarse. Esto es similar al caso del fracaso, en el sentido de que también puede haber acciones a tomar cuando una tarea o plan falla. En ambos casos, hay que tener en cuenta que no se trata simplemente de que el agente deshaga sus acciones hasta la fecha; de hecho, esto puede no ser ni posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado del mundo) ni deseable (dependiendo de la semántica de la tarea). Más bien, la limpieza implica compensación a través de acciones de recuperación hacia adelante [3]. Tercero, hay una distinción entre abortar una tarea y abortar un plan. En el primer caso, está claro que todos los planes que se estén ejecutando para realizar la tarea deben ser abortados; en el segundo caso, puede ser que existan mejores alternativas al plan actual y se deba intentar una de estas. Por lo tanto, el aborto o fracaso del plan no necesariamente conduce al aborto o fracaso de la tarea. Dado que las tareas pueden contener sub tareas, las cuales pueden contener más sub tareas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto. Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que una tarea o plan principal es abortado. 3. ABORTANDO TAREAS Y PLANES Como hemos insinuado, el fracaso y abortar son conceptos relacionados. Ambos causan que la ejecución de los planes existentes se detenga y, en consecuencia, que el agente reflexione sobre sus tareas e intenciones actuales. El fracaso y la interrupción, sin embargo, difieren en la forma en que surgen. En caso de fallo, el disparador para detener la ejecución de una tarea o plan proviene de abajo, es decir, del fallo de sub tareas o planes de nivel inferior. En caso de abortar, el disparador proviene de arriba, es decir, de las tareas y los planes principales que iniciaron un plan. En sistemas de estilo BDI como JACK y SPARK, el conocimiento del dominio de los agentes incluye una biblioteca de planes predefinidos de cláusulas de planificación. Cada cláusula de plan tiene un cuerpo de plan, que es un programa (es decir, una combinación de acciones primitivas, subtareas, etc.) que puede ejecutarse en respuesta a una tarea u otro evento si se cumple la condición de contexto de las cláusulas del plan. El agente selecciona y ejecuta instancias de cláusulas de plan para realizar sus tareas. Puede haber más de una cláusula de plan aplicable y, en caso de que una falle, se puede intentar otra aplicable. Los planes pueden tener subtareas que deben tener éxito. CALO solo necesita eliminar las tareas TWA y TWP para abortarlas: por simplicidad, suponemos que no es necesario realizar una limpieza explícita de su estado interno. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) para que el plan tenga éxito. En tales sistemas, ocurre un fallo en el plan si una de las acciones o subtareas dentro del plan falla. La acción de los agentes ante el fracaso del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si se ha intentado un plan y ha resultado en fracaso, o puede intentar planes alternativos y declarar (de hecho, debe declarar) el fracaso de la tarea solo si se han intentado todos los planes alternativos posibles para realizar la tarea y han resultado en fracaso. Observa que, si bien el fracaso de una tarea puede derivar del fracaso de un plan o de una secuencia de fracasos de planes, el fracaso de un plan no tiene por qué llevar al fracaso de la tarea siempre y cuando el agente pueda completar con éxito un plan alternativo. Además, el fracaso de la tarea también puede surgir de forma independiente al fracaso del plan, si el agente decide abortar la tarea. Nuestro enfoque asocia un método de aborto con cada plan. Esto permite al programador especificar acciones de compensación dedicadas según cómo el agente esté intentando realizar la tarea. Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que se pueden realizar dinámicamente de la manera habitual en BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones. La pregunta sigue siendo qué método de aborto se debe invocar, y de qué manera. Dada la complejidad de los espacios de acción de los agentes, no es posible ni deseable enumerar un conjunto estático de reglas. Más bien, el agente invocará sus métodos de aborto dinámicamente de acuerdo al estado de ejecución y sus propios eventos internos. Una alternativa a adjuntar un método de aborto a cada plan es adjuntar dichos métodos a cada acción atómica. Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los métodos de limpieza para el fracaso en los sistemas actuales están adjuntos a los planes. Para entender cómo debería funcionar el proceso de aborto de los agentes, consideramos tres situaciones en las que tiene sentido que un agente considere abortar algunas de sus tareas y planes: 1. Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí mismo, el plan actualmente ejecutado para realizar la tarea debe ser abortado. Por ejemplo, supongamos que la política de la empresa cambia para que los empleados con la antigüedad de Alice tengan automáticamente autorización para publicar artículos. Dado que Alice ahora tiene autorización para publicar su artículo, CALO puede abortar el plan de Solicitar Autorización. Al hacerlo, debe invocar el método de aborto, en este caso realizando la solicitud de cancelación de autorización. Cuando dos o más subprogramas se ejecutan en paralelo, si uno falla entonces los demás deben ser abortados, dado que el fallo de una rama conlleva al fallo de la tarea en general. Por ejemplo, supongamos que a mitad de la escritura del artículo, Alice se da cuenta de que hay un error fatal en sus resultados, por lo que notifica a CALO que no podrá completar el artículo para la fecha límite. El fallo de la tarea de Escritura de Pista debería provocar que la tarea de Solicitar Autorización que se está ejecutando en paralelo sea abortada. 3. Cuando un evento de ejecución altera la importancia de una tarea o intención existente, el agente debe deliberar si el/los plan(es) existente(s) deben continuar. Por ejemplo, supongamos que Alice encarga a CALO una nueva tarea de alta prioridad para comprar una computadora portátil de reemplazo, pero que Alice no tiene suficientes fondos para comprar la computadora portátil y asistir a IJCAI. Razonar sobre los requisitos de recursos [20, 10] hará que el agente se dé cuenta de que no puede completar exitosamente ambas tareas. Si hay alguna diferencia entre cómo abortar una tarea que se realiza externamente y cómo abortar una que ahora se sabe que es imposible, el método de aborto puede detectar las circunstancias y manejar la situación de manera apropiada. Dado que la nueva tarea tiene mayor importancia, un agente racional evaluará su mejor curso de acción y puede decidir abortar o al menos suspender la tarea existente de presentar un documento y las intenciones derivadas de ella [12]. La semántica operativa que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones mencionadas anteriormente. La tercera situación implica deliberar sobre la importancia de una tarea, la cual depende de varios factores como la prioridad de la tarea. Aunque esta deliberación está más allá del alcance de este documento, es un tema complementario de nuestro trabajo futuro. Ten en cuenta que las situaciones anteriores se aplican a metas de logro, para las cuales la tarea se completa cuando se logra un estado particular del mundo (por ejemplo, asegurarse de que tengamos autorización). Diferentes formas de razonamiento se aplican a otros tipos de objetivos, como los objetivos de mantenimiento, donde el objetivo se satisface al mantener un estado del mundo durante algún período de tiempo (por ejemplo, mantener $100 en efectivo). La representación del método de aborto tiene la intención de que una tarea o plan se detenga, y que tanto la tarea o plan como todos sus hijos dejen de ejecutarse, y que se realicen los métodos de limpieza apropiados según sea necesario. A diferencia de los sistemas de planificación offline, los agentes BDI están situados: realizan deliberación en línea y sus acciones cambian el estado del mundo. Como resultado, los efectos de muchas acciones no pueden ser simplemente deshechos. Además, el proceso de deshacer puede causar efectos adversos. Por lo tanto, los métodos de limpieza que especificamos son procedimientos de recuperación hacia adelante que intentan garantizar un estado estable y que también pueden, si es posible, recuperar recursos. La representación común de un plan en sistemas de estilo BDI como JACK y SPARK incluye un método de fallo, que es el método de limpieza designado invocado cuando el plan falla. Para esto, agregamos el método de aborto, que se invoca si se va a abortar el plan. En nuestro ejemplo, el método de aborto para el plan de Envío de Reunión de Soporte consiste en invocar la sub-tarea Cancelar Número de Documento. El método de aborto no necesita abortar explícitamente la solicitud de autorización, ya que el agente invocará el método de aborto para la subtarea de manera apropiada, como detallamos a continuación. La suposición aquí es que, al igual que en el método de falla, el programador del sistema del agente tiene la oportunidad de especificar un método de aborto sensato que tenga en cuenta el punto en el plan en el que se va a ejecutar el aborto. Para cualquier plan, el método de aborto es opcional: si no se especifica un método de aborto, el agente no toma ninguna acción específica para este plan. Sin embargo, las reglas de comportamiento predeterminadas de los agentes siguen aplicándose, por ejemplo, si intentar de nuevo un plan alternativo para la tarea principal. Se debe tener en cuenta que no es necesario una representación explícita de los métodos de limpieza para las tareas, ya que las tareas se realizan ejecutando algún plan o planes. Por lo tanto, abortar una tarea significa abortar el plan actual que se está ejecutando para realizar esa tarea, como describiremos a continuación. Invocación del método de aborto. Ahora describimos de manera informal la acción de los agentes al abortar planes y tareas. Cuando un plan P es abortado: 1. Abortar cada sub-tarea que sea un hijo activo de P. Un hijo activo es aquel que fue desencadenado por P y actualmente está en ejecución. 2. Cuando ya no haya más niños activos, invoque el método de aborto del plan P. 3. Indique un fallo en el plan para TP, la tarea principal de P. Se señala aquí que si la tarea principal TP no debe ser abortada, entonces el agente puede elegir otro plan aplicable para satisfacer TP. 10 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Cuando una tarea (o sub-tarea) T es abortada: 1. Abortar el plan activo actual para satisfacer T (si lo hay). 2. Cuando ya no haya más procesos secundarios activos, elimine la tarea. El agente ya no persigue a T. 3. Ten en cuenta que cuando se aborta el plan activo actual para realizar T, no se deben intentar otros planes aplicables para realizar T, ya que es la tarea que se va a abortar. Para evitar esfuerzos de limpieza en cascada infinita, asumimos que los métodos de aborto nunca serán abortados ni fallarán. En realidad, sin embargo, un método de aborto puede fallar. En este caso, al no contar con un mecanismo de manejo más sofisticado, el agente simplemente deja de ejecutar el método de aborto fallido sin más deliberación. La suposición que hacemos no es, por lo tanto, un reflejo de la complejidad total de la realidad, sino una que es pragmática en términos del ciclo de ejecución del agente; el enfoque para el manejo de fallos de [21] hace la misma suposición. En sistemas como SPARK, el programador puede especificar un comportamiento alternativo para un método de fallo o aborto fallido mediante procedimientos a nivel meta. También asumimos que los métodos de falla y aborto terminan en tiempo finito. 4. SEMÁNTICA OPERACIONAL Proporcionamos la semántica para los procesos de falla y aborto de tareas y planes descritos anteriormente. Utilizamos el lenguaje CAN inicialmente definido en [23] y posteriormente extendido como CANPLAN en [17] para incluir un componente de planificación y luego como CANPLAN2 en [18] para mejorar los mecanismos de adopción y eliminación de objetivos. Las extensiones también simplificaron la semántica en el trabajo anterior. Utilizamos algunas de estas simplificaciones para proporcionar un breve resumen del lenguaje CAN en la Sección 4.1. Tras una presentación de la semántica operacional de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos. 4.1 Lenguaje CAN CAN es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentSpeak [15] y Kinnys Ψ [7], ambos de los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados. CAN proporciona un constructo de objetivo explícito que captura tanto los aspectos declarativos como los procedimentales de un objetivo. Los objetivos son persistentes en CAN en el sentido de que, cuando un plan falla, se intenta otro plan aplicable. Esto equivale al mecanismo predeterminado de manejo de fallos que se encuentra típicamente en sistemas BDI implementados como JACK [2]. En sistemas prácticos, las tareas suelen traducirse en eventos que desencadenan la ejecución de algunos planes. Esto también es cierto en el lenguaje CAN, pero, para mantener la persistencia de los objetivos, se introduce un constructo de objetivo. Esto se denota por Objetivo ` φs, P, φf ´, donde φs es la condición de éxito que determina cuándo se considera que el objetivo se ha logrado, φf es una condición de fracaso bajo la cual se considera que el objetivo ya no es alcanzable o relevante, y P es un programa para lograr el objetivo, que se abortará una vez que φs o φf se vuelvan verdaderos. El comportamiento de un agente está especificado por una biblioteca de planes, denotada por Π, que consiste en una colección de cláusulas de planes de la forma e : c ← P, donde e es un evento, c es una condición de contexto (una fórmula lógica sobre las creencias de los agentes que debe ser verdadera para que el plan sea aplicable) y P es el cuerpo del plan. El cuerpo del plan es un programa que se define recursivamente de la siguiente manera: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Objetivo ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 Un c omitido es equivalente a verdadero. Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figura 1: Reglas operativas de CAN. donde P1, . . . , Pn son ellos mismos programas, act es una acción primitiva que no está más especificada, y +b y −b son operaciones para añadir y eliminar creencias. La base de creencias contiene átomos de creencias fundamentales en forma de relaciones de primer orden, pero podría ser extendida ortogonalmente a otras lógicas. Se asume que se proporcionan operaciones bien definidas para verificar si una condición se sigue de un conjunto de creencias (B |= c), para agregar una creencia a un conjunto de creencias (B ∪ {b}), y para eliminar una creencia de un conjunto de creencias (B \\ {b}). ?φ es una prueba para la condición φ, y !e5 es un evento6 que se publica desde dentro del programa. Los constructos compuestos son secuenciación (P1; P2), ejecución paralela (P1 P2) y metas (Meta ` φs, P, φf ´ ). Lo anterior define el idioma del usuario. Además, se utilizan un conjunto de formas compuestas auxiliares internamente al asignar semántica a los constructos. nil es el programa básico (terminante). Cuando un evento coincide con un conjunto de cláusulas de plan, estas se recopilan en un conjunto de alternativas protegidas (c1: P1, ..., cn: Pn). La otra forma compuesta auxiliar, , es un operador de elección dual a la secuenciación: P1 P2 ejecuta P1 y luego ejecuta P2 solo si P1 falló. Un resumen de la semántica operacional para CAN de acuerdo con [23] y siguiendo algunas de las simplificaciones de [17] es el siguiente. Una configuración básica S = B, G, Γ consiste en la base de creencias actual B del agente, el conjunto actual de metas G que se persiguen (es decir, un conjunto de fórmulas) y el programa actual P que se está ejecutando (es decir, la intención actual). Una transición S0 −→ S1 especifica que ejecutar S0 durante un paso único produce la configuración S1. S0 −→∗ Sn es el cierre reflexivo transitivo usual de −→: Sn es el resultado de una o más transiciones de un solo paso. Una regla de derivación S −→ Sr S −→ Sr consiste en un conjunto (posiblemente vacío) de premisas, que son transiciones junto con algunas condiciones auxiliares (numerador), y una única transición conclusión derivable de estas premisas (denominador). La Figura 1 muestra algunas de las reglas operativas. La regla de Evento maneja eventos de tarea recopilando todas las cláusulas de plan relevantes para el evento en cuestión: para cada cláusula de plan e : ψi ← Pi, si hay un unificador más general, θ = mgu(e, e) de e y el evento en 5 Donde es obvio que e es un evento, a veces excluiremos el signo de exclamación para mayor legibilidad. 6 Típicamente un objetivo de logro. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 11 B |= φs B, Objetivo ` φs, P, φf ´ −→ B, verdadero Gs B |= φf B, Objetivo ` φs, P, φf ´ −→ B, falla Gf P = Objetivo ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Objetivo ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Objetivo ` φs, P, φf ´ −→ B , Objetivo ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {verdadero, falla} B, Objetivo ` φs, P, φf ´ −→ B, Objetivo ` φs, P2 £ P2, φf ´ GR Figura 2: Reglas para objetivos en CAN. pregunta, entonces la regla construye una alternativa guardada ψiθ: Piθ. La regla Select selecciona un cuerpo de plan aplicable de un conjunto de alternativas relevantes (restantes): el programa P Δ establece que el programa P debe intentarse primero, recurriendo a las alternativas restantes, Δ \\ P, si es necesario. Esta regla y la regla de fallo se utilizan juntas para el manejo de fallos: si el programa actual Pi de una cláusula de plan para una tarea falla, primero se aplica la regla de fallo, y luego, si es posible, la regla Select elegirá otra alternativa aplicable para la tarea si existe alguna. Rule Sequence maneja la secuenciación de programas de la manera habitual. Las reglas Parallel1 y Parallel2 definen la posible intercalación al ejecutar dos programas en paralelo. La Figura 2 presenta reglas simplificadas para tratar con objetivos, en línea con las presentadas en [17]. La primera regla establece que un objetivo tiene éxito cuando φs se vuelve verdadero; la segunda regla establece que un objetivo falla cuando φf se vuelve verdadero. La tercera regla GI inicializa la ejecución de un programa de metas actualizando la base de metas y estableciendo el programa en la meta como P £ P; el primer P se ejecutará y el segundo P se utiliza para hacer un seguimiento del programa original para la meta. La cuarta regla GS ejecuta un solo paso del programa de objetivos. La regla final GR reinicia el programa original (codificado como P2 del par P1 £ P2) cada vez que el programa actual ha terminado pero el objetivo deseado y aún posible no se ha logrado. 4.2 Abortando Intenciones y Manejando Fallas A continuación, introducimos la capacidad de especificar programas manejadores, en forma de métodos de falla y aborto, que se ocupan de la limpieza requerida cuando un programa dado falla o es abortado. No asociamos los métodos de falla y aborto con cláusulas de plan o con tareas (eventos), sino que introducimos una nueva construcción de programa que especifica los métodos de falla y aborto para un programa arbitrario. El constructo FAb(P, PF, PA) ejecuta el programa P. En caso de que P falle, ejecuta el programa de manejo de fallos PF; si P necesita ser abortado, ejecuta el programa de manejo de aborto PA. Por lo tanto, para agregar los métodos de falla y aborto PF y PA a una cláusula de plan e : c ← P, escribimos e : c ← FAb(P, PF, PA). Con la introducción de la capacidad de abortar programas, modificamos la construcción paralela para permitir que el fallo de una rama aborte la otra. Debemos tener en cuenta la posible existencia de métodos de aborto en la rama abortada. De manera similar, con el constructo de Objetivo ya no podemos abandonar por completo el programa que contiene tan pronto como se cumpla la condición de éxito o fracaso; ahora debemos tener en cuenta la existencia de cualquier método de aborto aplicable al programa. Proporcionamos la semántica de un lenguaje de agente aumentado que contiene el constructo FAb al definir una transformación de origen, similar a la expansión de macros, que mapea una biblioteca de planes que contiene el constructo FAb(P, PF, PA) en CAN estándar (casi). La única extensión no estándar a CAN es un constructo de espera hasta que se cumpla una condición. Explicamos esta simple modificación del constructo paralelo a continuación cuando llegamos a la traducción del constructo de la Meta. Primero describimos la naturaleza general de la transformación de la fuente, que resulta ser bastante simple para la mayoría de las construcciones del lenguaje, y luego nos concentramos en los tres casos más complejos: las construcciones FAb, paralela y Goal. Un problema clave es que los constructos FAb pueden estar anidados, ya sea directa o indirectamente. Llamemos a cada instancia del constructo en tiempo de ejecución un posible punto de aborto (pap). Donde estos constructos están anidados, es importante que antes de que se ejecute el método de falla o aborto de un pap padre, se ejecuten primero los programas de métodos de falla o aborto de los paps hijos, como se describe anteriormente en la Sección 3. La necesidad de coordinar la ejecución de los métodos de aborto de paps anidados requiere que haya alguna forma de identificar los padres e hijos de un pap en particular. Logramos esto como parte de la transformación de origen al llevar un registro explícito del contexto de ejecución como un parámetro adicional en los eventos y una variable adicional dentro de cada cuerpo del plan. La transformación de origen reemplaza cada cláusula del plan de la forma e : c ← P con una cláusula del plan e(v) : c ← μv(P) donde v es una variable libre, no presente previamente en la cláusula del plan. Esta variable se utiliza para llevar un registro del contexto de ejecución. El valor de la variable de contexto es una lista de identificadores, donde cada nuevo párrafo está representado al anteponer un nuevo identificador al contexto. Por ejemplo, si los identificadores son enteros, el contexto de un documento puede ser representado por una lista [42, 1] y el contexto introducido por un nuevo documento puede ser representado por [52, 42, 1]. Nos referiremos a los paps por el contexto en lugar del nuevo identificador agregado, por ejemplo, por [51, 42, 1] y no solo por 51. Esto nos permite equiparar la relación de ancestro entre paps con la relación de sufijo de lista en los contextos relevantes, es decir, v es un ancestro de v si y solo si v es un sufijo de v. Para la mayoría de los constructos CAN, la variable de contexto no se utiliza o se pasa sin cambios: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) Queda por especificar la transformación μv(·) en tres casos: los constructos FAb, paralelo y Goal. Estos son más complejos en el sentido de que la fuente transformada necesita crear dinámicamente un nuevo identificador de pap, para usarlo como un nuevo contexto dentro de la construcción, y para llevar un registro de cuándo el pap está activo (es decir, actualmente en ejecución) añadiendo y eliminando creencias sobre el contexto. Introduzcamos la acción primitiva prependID(v, v) que crea un nuevo identificador pap y lo antepone a la lista v, dando como resultado la lista v. También introducimos los siguientes predicados: • a(v) - el pap v está actualmente activo. • abort(v) - el pap v debe ser abortado (después de abortar a todos sus descendientes). Una alternativa sería utilizar predicados a nivel meta que reflejen el estado actual de la estructura de intenciones. La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) • f(v) - el programa del pap v ha fallado. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))el pap v es un ancestro del pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v no tiene hijos activos. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - debemos abortar v, es decir, abort es verdadero para v o algún ancestro; sin embargo, debemos esperar hasta que no haya hijos activos de v. • san(v) ≡ sa(v) ∧ nac(v) - debemos abortar v ahora si debemos abortar v y v no tiene hijos activos. Primero consideremos el caso del constructo FAb. La idea es que, cada vez que ocurra un nuevo pap, se utiliza la acción prependID(v, v) para crear una nueva lista de identificadores de pap v a partir de la lista existente v. Luego agregamos la creencia de que v es el contexto activo, es decir, +a(v), y comenzamos a procesar el programa dentro del pap utilizando v en lugar de v como contexto. Necesitamos asegurarnos de retractar la creencia de que v está activo al final, es decir, −a(v). Utilizamos la construcción de Objetivo para permitirnos detener la ejecución de un programa dentro de un pap v cuando sea necesario abortar. Mientras se ejecuta el programa P, sabemos que debemos descartar P e invocar su método de aborto si se le ha indicado a algún ancestro de P que aborte. Esto se representa por el predicado sa(v) siendo verdadero. Sin embargo, debemos asegurarnos de hacer esto solo después de que cada pap de niño haya tenido la oportunidad de invocar su método de aborto y todos estos métodos de aborto hayan sido completados: si abandonamos el programa demasiado pronto, entonces la ejecución de los métodos de aborto de los niños también será abandonada. Por lo tanto, la condición que realmente usamos en la construcción del Objetivo para probar cuándo detener el programa es san(v). Esta condición se basa en el hecho de que a medida que los niños completan sus papilas, eliminan los hechos relevantes. Nuestro uso del constructo Goal es por su capacidad de detener la ejecución de un programa cuando se cumplen ciertas condiciones. Para dejar de lado el aspecto de la repetición de la ejecución hasta que se cumpla una condición, debemos asegurarnos de que la condición de éxito o fracaso del constructo se cumpla una vez que la ejecución del programa tenga éxito o falle. Nos aseguramos de esto al retractar el hecho a(v) en caso de éxito y afirmar el hecho f(v) en caso de fracaso, y al tener las condiciones apropiadas de éxito y fracaso en el Objetivo. Por lo tanto, si falla la construcción del Objetivo, entonces el programa fue abortado o falló. Invocamos el método de fallo o aborto relevante, retiramos el hecho a(v) y luego fallamos. Al juntar todo esto, definimos formalmente μv(FAb(P, PA, PF )) de la siguiente manera, donde v es una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) En segundo lugar, debemos transformar el operador paralelo para asegurar que el fallo de una rama aborte de forma segura la otra. Aquí construimos dos nuevos contextos, v y v, a partir del contexto existente v. Si una rama falla, debe abortar la otra rama. Al final, si se abortó cualquiera de las ramas, entonces debemos fallar. Que v y v sean variables nuevas distintas de cualquier otra en la biblioteca de planes de los agentes. Definimos μv(P1 P2) como: prependID(v, v); prependID(v, v); +a(v); +a(v); (Goal (¬a(v), (μv(P1); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v)) Goal (¬a(v), (μv(P2); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v))); ?¬abort(v) ∧ ¬abort(v) Finalmente, necesitamos modificar las ocurrencias del constructo Goal de dos maneras: primero, asegurarnos de que los métodos de manejo de aborto no se pasen por alto cuando se satisfacen las condiciones de éxito o fracaso, y segundo, activar la interrupción del programa contenido cuando se satisfacen las condiciones de éxito o fracaso. Para transformar el constructo Goal necesitamos extender el estándar CAN con un constructo de espera-hasta-condición. El constructo φ : P no ejecuta P hasta que φ se convierte en verdadero. Aumentamos el lenguaje CAN con las siguientes reglas para el operador de guardia :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false Para especificar μv(Goal ` φs, P, φf ´ ), generamos un nuevo pap y ejecutamos el programa dentro del constructo Goal en este nuevo contexto. Debemos asegurarnos de que la creencia a(v) sea eliminada, ya sea que el objetivo tenga éxito o fracase. Cambiamos la condición de éxito y fracaso del constructo Objetivo a una rama paralela utilizando el constructo de espera-hasta-condición, y modificamos el Objetivo para usar la condición de éxito debería abortar ahora san(v) como condición de éxito. La rama de espera desencadenará la interrupción del programa si se cumple tanto la condición de éxito como la de fracaso. Para evitar cualquier problema al terminar la condición de espera, también finalizamos la espera si el pap ya no está activo. Que v sea una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes. Definimos μv(Goal ` φs, P, φf ´ ) como: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) El programa P se ejecutará repetidamente hasta que san(v ) se convierta en verdadero. Hay dos formas en que esto puede ocurrir. Primero, si se cumple la condición de éxito φs o la condición de fracaso φf, entonces se ejecuta la segunda rama de la construcción en paralelo. Esto hace que abort(v) se convierta en verdadero, y, después de que se ejecuten los métodos de abortmethods descendientes, san(v) se convierte en verdadero. En este caso, P se elimina, se elimina el a(v), y todo el constructo tiene éxito o fracasa en función de φs. La segunda forma en que san(v) puede volverse verdadero es si v o uno de sus ancestros es abortado. En este caso, una vez que se ejecutan los métodos de aborto de los paps descendientes, san(v) se vuelve verdadero, P se elimina, se elimina la creencia a(v) (permitiendo que la segunda rama paralela se ejecute, instruyendo vacuamente a v a abortar), y la primera rama paralela falla (asumiendo que φs es falso). Ejemplo trabajado 4.3 Echemos un vistazo a la traducción del ejemplo de envío a IJCAI de la Sección 2. Expresaremos las tareas mediante eventos, por ejemplo, la tarea Asignar un Número de Papel la expresamos como el evento APN. Que la salida de la tarea Solicitar autorización sea Y o N, indicando la aprobación o no del gerente de Alicia, respectivamente. Entonces tenemos (al menos) las siguientes dos cláusulas de plan en CAN, para las tareas de Envío de Reunión de Apoyo y Solicitar Autorización de Despeje, respectivamente: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Tenga en cuenta que Envío de Reunión de Apoyo tiene un parámetro m, la reunión de interés (IJCAI, en nuestro ejemplo), mientras que Solicitar Autorización de Despeje no tiene parámetros. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 13. Veamos primero la traducción de la segunda cláusula del plan, para AFC, ya que es la más simple de las dos. Que v y v denoten nuevas variables. Entonces tenemos como cláusula del plan traducido: AFC(v): verdadero ← prependID(v, v); +a(v); Meta(¬a(v), (!SCR(v); !WFR(r, v); ?r = Y; −a(v) +f(v)), san(v) ∨ f(v)) (((?sa(v); !CCR(v)) nil); −a(v); ?falso) Podemos ver que se ha añadido un parámetro de contexto adicional a cada tarea y que el antiguo cuerpo del plan ahora aparece dentro de un constructo de Meta. Si el antiguo cuerpo del plan tiene éxito, la creencia a(v) se retira, lo que hace que el Objetivo tenga éxito. Si el cuerpo del plan antiguo falla, o si la tarea debe ser abortada, el constructo de Objetivo falla. Esto es seguido por la ejecución de CCR (en caso de un aborto), la retracción de a(v), y el fallo. La traducción de la primera cláusula del plan, para SMS, es más compleja, debido a la estructura paralela que introduce paps anidados: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Meta ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Meta ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Meta ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Aquí podemos ver que si la tarea !TWP(v ) falla, entonces se afirmará f(v ), lo que hará que falle la construcción de Meta que lo contiene, y llevará a que se afirme abort(v ). Si la tarea !WFR(r, v ) en la expansión de !AFC(v ) todavía se está ejecutando y no tiene paps hijos activos, entonces sa(v ) y sa(v ) serán verdaderos; sin embargo, solo san(v ) y no san(v ) serán verdaderos. Este conjunto de condiciones hará que el constructo Goal en la primera cláusula del plan falle, deteniendo la ejecución de !WFR(r, v). La tarea !CCR(v) será ejecutada. Una vez que esta tarea se complete, la creencia a(v) se retira, lo que hace que san(v) se convierta en verdadero, lo que lleva a que la primera construcción de objetivo de la segunda cláusula del plan falle. Si bien las cláusulas del plan traducido parecen complicadas, observe que la traducción de las cláusulas del plan inicial es completamente automatizada, de acuerdo con las reglas establecidas en la Sección 4.2. Las cláusulas del plan traducido, con la semántica de PUEDE aumentada por nuestra construcción de condición de esperar-hasta, especifican así la operación del agente para manejar tanto el fallo como la interrupción del ejemplo. 5. El fallo del plan se maneja en la versión extendida de AgentSpeak encontrada en el sistema Jason [6]. Los planes de limpieza de fallas se activan a partir de eventos de eliminación de objetivos −!g. Tales planes, similares a nuestros métodos de fracaso, están diseñados para que el agente efectúe cambios de estado (actúe para deshacer sus acciones anteriores) antes de posiblemente intentar otro plan para lograr el objetivo fallido g. Dados los constructos de Jason para abandonar un objetivo con una indicación de si intentar o no un plan alternativo para él, H¨ubner et al. [6] proporcionan una descripción informal de cómo un agente de Jason modifica su estructura de intenciones cuando ocurre un evento de fracaso del objetivo. En un plan de eliminación de objetivos, el programador puede especificar cualquier acción de deshacer y si intentar de nuevo el objetivo. Si no se proporciona un plan de eliminación de objetivos, el comportamiento predeterminado de Jason es no volver a intentar el objetivo. El manejo de fallos se aplica solo a los planes desencadenados por la adición de un logro o meta de prueba; en particular, los eventos de eliminación de metas no se publican por el fallo de un plan de eliminación de metas. Además, la semántica informal de [6] no considera submetas paralelas (es decir, el constructo CAN), ya que dicha ejecución no forma parte del lenguaje de Jason. La implementación de H¨ubner et al. [6] requiere acciones internas de Jason. Un requisito para implementar nuestro enfoque es una capacidad reflexiva en la implementación del agente BDI. Las implementaciones adecuadas del formalismo BDI son JACK [2], Jadex [14] y SPARK [9]. Los tres permiten métodos a nivel meta que son activados por eventos meta como la adopción de objetivos o el fracaso de un plan, y ofrecen capacidades introspectivas sobre los estados de objetivo e intención. Tales instalaciones de nivel meta también son requeridas por el enfoque de Unruh et al. [21], quienes definen la compensación semántica basada en objetivos para un agente. Los objetivos de manejo de fallos son invocados de acuerdo con las reglas de estrategia de manejo de fallos, por un agente dedicado Componente de Manejo de Fallos (FHC) que sigue la ejecución de la tarea. Estos objetivos son especificados por el programador del agente y se adjuntan a las tareas, de manera similar a cómo nuestro constructo FAb(P, PF, PA) asocia métodos de falla y aborto con un plan P. Sin embargo, cabe destacar que, a diferencia tanto de [6] como de nuestra semántica, [21] adjuntan el conocimiento de manejo de fallas a nivel de objetivo, no de plan. Sus objetivos de manejo de fallos pueden consistir en objetivos de estabilización que realicen una limpieza localizada e inmediata para restaurar el estado de los agentes a un estado conocido y estable, y objetivos de compensación que realicen acciones de deshacer. Los objetivos de compensación se activan al abortar un objetivo, y no necesariamente al fallar en el objetivo (es decir, si el FHC indica al agente que vuelva a intentar el objetivo fallido y el nuevo intento tiene éxito). El enfoque FHC se define a nivel de objetivo para facilitar la especificación abstracta del conocimiento de manejo de fallos; el FHC decide cuándo abordar un fallo y qué hacer (es decir, qué objetivos de manejo de fallos invocar), separando este conocimiento del cómo implementar acciones correctivas (es decir, qué plan ejecutar para cumplir con el objetivo de manejo de fallos adoptado). Esto contrasta con el manejo simplista de fallas a nivel de plan en el que el qué y el cómo se entrelazan en el conocimiento de la tarea del dominio. Si bien nuestro enfoque está definido a nivel de plan, nuestra semántica BDI extendida permite la separación de la ejecución y el manejo de fallos. Además, el FHC mantiene explícitamente estructuras de datos para rastrear la ejecución de agentes. Aprovechamos las estructuras de ejecución existentes y la capacidad autorreflexiva de un agente BDI para lograr tanto la interrupción como el manejo de fallos sin costos adicionales. Las reglas de estrategia de manejo de fallos de FHC (por ejemplo, si volver a intentar un objetivo fallido) son reemplazadas por instrucciones en nuestros planes de PF y PA, junto con manejadores de fallos predeterminados a nivel meta de acuerdo con la naturaleza de los agentes (por ejemplo, comprometidos ciegamente). El enfoque FHC es independiente de la arquitectura del agente en sí, a diferencia de nuestro trabajo que está dedicado al formalismo BDI (aunque no está ligado a ningún sistema de agente en particular). Por lo tanto, no se desarrollan semánticas formales en [21]; la operación de los FHCs se presenta como 14 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) un protocolo basado en estados. Este enfoque, junto con el punto de control estatal, se utiliza para sistemas multiagente en [22]. La arquitectura resultante incorpora su enfoque de manejo de fallos dentro de una arquitectura de procesamiento en pares para la recuperación de fallos de agentes. Otro trabajo sobre el manejo de excepciones multiagente incluye los agentes de manejo de excepciones distribuidos AOEXs [5], y los centinelas similares de [8]. En ambos casos, la lógica de manejo de fallos y el conocimiento están desacoplados de los agentes; en contraste, mientras se separa el manejo de excepciones del conocimiento específico del dominio, tanto el enfoque de Unruh et al. como nuestro enfoque retienen la lógica de manejo de fallos dentro de un agente. 6. CONCLUSIÓN Y TRABAJO FUTURO Las tareas y planes de un agente pueden no llegar a completarse con éxito, ya sea por la decisión del agente de abortarlos (quizás a petición de otro agente), o por factores imprevistos que llevan al fracaso. En este artículo hemos presentado un enfoque basado en procedimientos que incorpora la interrupción de tareas y planes en el ciclo de deliberación de un agente de estilo BDI, proporcionando así un enfoque unificado para el fracaso y la interrupción. Nuestra contribución principal es un análisis de los requisitos sobre la operación del agente para abortar tareas y planes, y una semántica operativa correspondiente para abortar en el lenguaje abstracto del agente CAN. Estamos planeando implementar una instancia de nuestro enfoque en el sistema de agentes SPARK [9]; en particular, el trabajo de este artículo será la base para el mecanismo de manejo de abortos de SPARK. También estamos desarrollando una herramienta de análisis para nuestra versión extendida de CAN como base para experimentación. Un agente inteligente no solo manejará con gracia tareas y planes fallidos, sino que también reflexionará sobre sus actitudes cognitivas para decidir su próximo curso de acción. Hemos asumido el comportamiento predeterminado de un agente de estilo BDI, de acuerdo con su naturaleza: por ejemplo, volver a intentar alternativas de un plan fallido hasta que uno tenga éxito o hasta que no queden planes alternativos (en cuyo caso fallar la tarea). El trabajo futuro consiste en poner nuestro enfoque al servicio de un razonamiento de agente más dinámico, como la introspección que un agente capaz de razonar sobre los efectos de la interacción de tareas y los requisitos de recursos puede lograr [19, 12]. Relacionado con esto está determinar el costo de abortar una tarea o un plan, y utilizarlo como un insumo en el proceso de deliberación. Esto influiría en particular en el compromiso que el agente tiene hacia una tarea específica: a mayor costo, mayor compromiso. Nuestra suposición de que los métodos de aborto no fallan, como se discutió anteriormente, es una suposición pragmática. Sin embargo, este es un tema que merece una mayor exploración, ya sea para desarrollar supuestos más débiles que también sean prácticos, o para analizar las condiciones bajo las cuales nuestra suposición es realista. Un elemento adicional de interés es extender nuestro enfoque al fracaso y la interrupción a los objetivos de mantenimiento [1]. Para tales objetivos, se necesita una semántica operativa diferente para la interrupción que para los objetivos de logro, para que coincida con la diferencia en la semántica de los propios objetivos. Agradecimientos Agradecemos a Lin Padgham y a los revisores anónimos por sus comentarios. El primer autor agradece el apoyo del Consejo de Investigación Australiano y del Software Orientado a Agentes bajo la subvención LP0453486. El trabajo de los dos autores en SRI International fue apoyado por la Agencia de Proyectos de Investigación Avanzada de Defensa (DARPA) bajo el Contrato No. NBCHD030010. Cualquier opinión, hallazgo, conclusión o recomendación expresada en este material son responsabilidad de los autores y no reflejan necesariamente la visión de DARPA o el Departamento del Interior-Centro Nacional de Negocios. 7. REFERENCIAS [1] L. Braubach, A. Pokahr, D. Moldt y W. Lamersdorf. Representación de objetivos para sistemas de agentes BDI. En Actas del Segundo Congreso Internacional. Taller sobre Programación de Sistemas Multiagente (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson y A. Lucas. Agentes inteligentes JACK: componentes para agentes inteligentes en Java. AgentLink News, Edición 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira y P. Henderson. Ampliando el concepto de compensación de transacciones. Revista de Sistemas de IBM, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk y J.-J. C. Meyer. Tipos de objetivos en la programación de agentes. En Proc. de AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy y E. Kendall. Aoex: Un marco de manejo de excepciones basado en agentes para construir sistemas de software confiables, distribuidos y abiertos. En Actas de la Séptima Conferencia Conjunta sobre Ingeniería de Software Basada en el Conocimiento, 2006. [6] J. F. H¨ubner, R. H. Bordini y M. Wooldridge. Programación de metas declarativas utilizando patrones de planificación. En Actas de la 4ta Conferencia Internacional. Taller sobre Lenguajes y Tecnologías Declarativos de Agentes, 2006. [7] D. Kinny. El cálculo Psi: un lenguaje algebraico de agentes. En Proc. de ATAL01, 2001. [8] M. Klein, J. A. Rodríguez-Aguilar y C. Dellarocas. Utilizando servicios de manejo de excepciones independientes del dominio para habilitar sistemas multiagente abiertos robustos: El caso de la muerte del agente. Agentes Autónomos y Sistemas Multiagente, 7(1-2):179-189, 2003. [9] D. Morley y K. Myers. El marco de agentes SPARK. En Proc. de AAMAS04, 2004. [10] D. Morley, K. L. Myers y N. Yorke-Smith. Refinamiento continuo de estimaciones de recursos del agente. En Proc. de AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack y M. Tambe. Un asistente personal inteligente para la gestión de tareas y tiempo. Revista de Inteligencia Artificial, 28, 2007. Aparecer. [12] K. L. Myers y N. Yorke-Smith. Un marco cognitivo para la delegación a un agente de usuario asistente. En Actas del Simposio de Otoño de AAAI 2005 sobre Asistentes de Resolución de Problemas de Iniciativa Mixta, 2005. [13] L. Padgham y M. Winikoff. Desarrollo de Sistemas de Agentes Inteligentes: Una Guía Práctica. John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, y W. Lamersdorf. Jadex: Un motor de razonamiento BDI. En R. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores, Programación Multiagente. Springer, 2005. [15] A. S. Rao. \n\nSpringer, 2005. [15] A. S. Rao. AgentSpeak(L): Los agentes BDI se expresan en un lenguaje lógico computable. En Actas del Séptimo Taller Europeo sobre Modelado de Agentes Autónomos en un Mundo Multiagente, 1996. [16] A. S. Rao y M. P. Georgeff. Una arquitectura abstracta para agentes racionales. En Proc. de KR92, 1992. [17] S. Sardiña, L. de Silva y L. Padgham. Planificación jerárquica en lenguajes de programación de agentes BDI: un enfoque formal. En Proc. de AAMAS06, 2006. [18] S. Sardina y L. Padgham. Objetivos en el contexto del fracaso del plan BDI y la planificación. En Proc. de AAMAS07, 2007. [19] J. Thangarajah, L. Padgham y M. Winikoff. Detectar y aprovechar la interacción positiva de objetivos en agentes inteligentes. En Proc. de AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham y K. Fischer. Evitando conflictos de recursos en agentes inteligentes. En Proc. de ECAI-02, 2002. [21] A. Unruh, J. Bailey y K. Ramamohanarao. Un marco para la compensación semántica basada en objetivos en sistemas de agentes. En Actas de la Primera Conferencia Internacional. Taller sobre Seguridad en Sistemas Multiagente, 2004. [22] A. Unruh, H. Harjadi, J. Bailey y K. Ramamohanarao. Gestión de recuperación basada en compensación semántica en sistemas multiagente. En Proc. del Segundo Simposio IEEE sobre Seguridad y Supervivencia Multiagente (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Proc. de KR02, 2002. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 15",
    "original_sentences": [
        "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
        "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
        "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
        "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
        "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
        "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
        "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
        "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
        "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
        "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
        "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
        "When failures occur, the choice of plans will be reviewed.",
        "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
        "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
        "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
        "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
        "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
        "Aborting a task or plan is distinct from its failure.",
        "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
        "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
        "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
        "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
        "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
        "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
        "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
        "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
        "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
        "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
        "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
        "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
        "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
        "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
        "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
        "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
        "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
        "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
        "This paper is organized as follows.",
        "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
        "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
        "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
        "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
        "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
        "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
        "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
        "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
        "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
        "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
        "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
        "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
        "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
        "Send Clearance Request (SCR) to Alices manager. 2.",
        "Wait For Response (WFR) from the manager. 3.",
        "Confirm that the response was positive, and fail otherwise.",
        "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
        "Alice will no longer be able to attend IJCAI.",
        "She therefore instructs her CALO agent to abort the SMS task.",
        "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
        "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
        "We note a number of important observations from the example.",
        "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
        "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
        "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
        "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
        "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
        "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
        "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
        "Rather, cleaning up involves compensation via forward recovery actions [3].",
        "Third, there is a distinction between aborting a task and aborting a plan.",
        "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
        "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
        "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
        "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
        "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
        "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
        "Failure and aborting, however, differ in the way they arise.",
        "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
        "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
        "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
        "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
        "The agent selects and executes instances of plan clauses to perform its tasks.",
        "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
        "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
        "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
        "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
        "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
        "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
        "Our approach associates an abort-method with each plan.",
        "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
        "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
        "The question remains which abort-method should be invoked, and in what manner.",
        "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
        "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
        "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
        "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
        "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
        "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
        "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
        "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
        "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
        "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
        "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
        "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
        "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
        "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
        "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
        "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
        "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
        "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
        "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
        "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
        "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
        "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
        "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
        "As a result, the effects of many actions cannot be simply undone.",
        "Moreover, the undo process may cause adverse effects.",
        "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
        "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
        "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
        "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
        "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
        "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
        "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
        "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
        "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
        "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
        "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
        "When a plan P is aborted: 1.",
        "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
        "When there are no more active children, invoke the abort method of plan P. 3.",
        "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
        "Abort the current active plan to satisfy T (if any). 2.",
        "When there are no more active child processes, drop the task.",
        "The agent thus no longer pursues T. 3.",
        "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
        "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
        "In reality, however, an abort-method may fail.",
        "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
        "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
        "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
        "We also assume that failure- and abort-methods terminate in finite time. 4.",
        "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
        "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
        "The extensions also simplified the semantics in the earlier work.",
        "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
        "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
        "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
        "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
        "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
        "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
        "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
        "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
        "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
        "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
        "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
        "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
        "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
        "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
        "The above defines the user language.",
        "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
        "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
        "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
        "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
        "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
        "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
        "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
        "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
        "Figure 1 gives some of the operational rules.",
        "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
        "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
        "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
        "Rule Sequence handles sequencing of programs in the usual way.",
        "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
        "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
        "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
        "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
        "The fourth rule GS executes a single step of the goal-program.",
        "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
        "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
        "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
        "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
        "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
        "We must take into consideration the possible existence of abort-methods in the aborted branch.",
        "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
        "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
        "The one non-standard extension to CAN is a wait-until-condition construct.",
        "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
        "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
        "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
        "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
        "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
        "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
        "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
        "This variable is used to keep track of the context of execution.",
        "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
        "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
        "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
        "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
        "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
        "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
        "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
        "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
        "First let us consider the case of the FAb construct.",
        "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
        "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
        "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
        "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
        "This is represented by the predicate sa(v ) being true.",
        "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
        "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
        "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
        "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
        "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
        "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
        "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
        "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
        "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
        "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
        "At the end, if either branch was aborted, then we must fail.",
        "Let v and v be new variables distinct from any other in the agents plan library.",
        "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
        "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
        "The construct φ : P does not execute P until φ becomes true.",
        "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
        "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
        "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
        "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
        "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
        "Let v be a new variable distinct from any other in the agents plan library.",
        "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
        "There are two ways this can occur.",
        "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
        "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
        "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
        "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
        "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
        "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
        "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
        "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
        "Let v and v denote new variables.",
        "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
        "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
        "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
        "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
        "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
        "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
        "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
        "The task !CCR(v ) will be executed.",
        "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
        "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
        "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
        "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
        "Failure clean-up plans are triggered from goal deletion events −!g.",
        "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
        "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
        "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
        "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
        "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
        "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
        "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
        "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
        "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
        "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
        "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
        "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
        "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
        "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
        "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
        "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
        "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
        "Further, the FHC explicitly maintains data structures to track agent execution.",
        "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
        "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
        "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
        "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
        "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
        "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
        "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
        "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
        "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
        "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
        "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
        "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
        "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
        "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
        "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
        "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
        "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
        "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
        "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
        "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
        "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
        "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
        "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
        "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
        "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
        "NBCHD030010.",
        "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
        "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
        "Goal representation for BDI Agent systems.",
        "In Proc. of Second Intl.",
        "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
        "JACK intelligent agents - components for intelligent agents in Java.",
        "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
        "Extending the concept of transaction compensation.",
        "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
        "C. Meyer.",
        "Goal types in agent programming.",
        "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
        "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
        "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
        "Programming declarative goals using plan patterns.",
        "In Proc. of 4th Intl.",
        "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
        "The Psi calculus: an algebraic agent language.",
        "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
        "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
        "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
        "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
        "The SPARK agent framework.",
        "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
        "Continuous refinement of agent resource estimates.",
        "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
        "An intelligent personal assistant for task and time management.",
        "AI Magazine, 28, 2007.",
        "To appear. [12] K. L. Myers and N. Yorke-Smith.",
        "A cognitive framework for delegation to an assistive user agent.",
        "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
        "Developing Intelligent Agent Systems: A Practical Guide.",
        "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
        "Jadex: A BDI reasoning engine.",
        "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
        "Springer, 2005. [15] A. S. Rao.",
        "AgentSpeak(L): BDI agents speak out in a logical computable language.",
        "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
        "An abstract architecture for rational agents.",
        "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
        "Hierarchical planning in BDI agent programming languages: a formal approach.",
        "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
        "Goals in the context of bdi plan failure and planning.",
        "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
        "Detecting and exploiting positive goal interaction in intelligent agents.",
        "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
        "Avoiding resource conflicts in intelligent agents.",
        "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
        "A framework for goal-based semantic compensation in agent systems.",
        "In Proc. of First Intl.",
        "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
        "Semantic-compensation-based recovery management in multi-agent systems.",
        "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
        "Declarative and procedural goals in intelligent agent systems.",
        "In Proc. of KR02, 2002.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
    ],
    "translated_text_sentences": [
        "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos.",
        "Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente.",
        "En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI.",
        "Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión.",
        "Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes.",
        "Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK).",
        "Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada.",
        "Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1.",
        "INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13].",
        "Por lo tanto, enfrentarse al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21].",
        "En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente.",
        "Cuando ocurran fallos, se revisará la elección de planes.",
        "Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14].",
        "Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores.",
        "Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes.",
        "Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular.",
        "Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno).",
        "Abortar una tarea o plan es distinto de su fracaso.",
        "El fracaso refleja una incapacidad para desempeñarse y no anula la necesidad de desempeñarse, por ejemplo, una respuesta razonable al fracaso puede ser intentarlo de nuevo.",
        "Por el contrario, abortar no dice nada sobre la capacidad de realizar; simplemente elimina la necesidad.",
        "El fracaso se propaga de abajo hacia arriba, mientras que la interrupción se propaga de arriba hacia abajo.",
        "El potencial de ejecutar subplanes de forma simultánea introduce diferentes complejidades para la interrupción y el fallo.",
        "Para abortar, significa que varios subplanes concurrentes pueden necesitar ser abortados a medida que se propaga el aborto hacia abajo.",
        "Para el fallo, significa que los planes paralelos hermanos pueden necesitar ser abortados a medida que el fallo se propaga hacia arriba.",
        "Ha habido una cantidad considerable de trabajo sobre fallos en los planes (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallos.",
        "Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de aborto más allá de la simple eliminación de los planes y tareas actualmente previstos, lo cual no aborda la limpieza requerida.",
        "Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de un constructo paralelo. Se puede considerar que ambas tareas se realizan y se tienen objetivos para lograr un cierto estado del mundo.",
        "Una tarea puede considerarse un objetivo de lograr el estado de la tarea una vez realizada, y un objetivo puede considerarse una tarea de llevar a cabo ese estado en el mundo.",
        "Adoptamos la última perspectiva y usamos la palabra \"tarea\" también para referirnos a los objetivos. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS falla (los enfoques comunes incluyen permitir que la otra rama se ejecute hasta su finalización sin obstáculos o eliminarla por completo).",
        "En este documento discutimos en detalle la incorporación de métodos de limpieza de aborto en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto.",
        "Una característica clave de nuestro enfoque basado en procedimientos es que permitimos que cada plan ejecute un código particular en caso de fallo y de aborto.",
        "Esto permite que un plan intente asegurar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar de otra manera antes de salir.",
        "Por consiguiente, un desafío técnico central es gestionar la ejecución ordenada del código de limpieza adecuado.",
        "Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una semántica operativa para abortar en el lenguaje de agente abstracto CAN [23, 17].",
        "Esto nos permite especificar un nivel adecuado de detalle para el modelo de ejecución, sin centrarnos en las construcciones específicas de ningún sistema de agentes en particular, como JACK [2], Jadex [14], Jason [6] o SPARK [9].",
        "Nuestro enfoque se centra en un único agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas de un solo agente y multiagentes (por ejemplo, [22, 5, 6]).",
        "Este documento está organizado de la siguiente manera.",
        "En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deberían ocurrir los abortos, y los procedimientos adecuados de representación e invocación.",
        "En la Sección 4 mostramos cómo podemos utilizar CAN para especificar formalmente el comportamiento de un plan abortado.",
        "La sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro.",
        "EJEMPLO MOTIVADOR Alice es una trabajadora del conocimiento asistida por un agente de asistencia personal y de aprendizaje como CALO [11].",
        "Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente CALO adopta la tarea de Presentación de Reuniones de Apoyo (SMS) para ayudarla.",
        "El plan de CALO para una tarea de SMS en el caso de una presentación en una conferencia consiste en las siguientes sub tareas: 1.",
        "Asignar un Número de Documento (APN) para ser utilizado con fines administrativos en la empresa. 2.",
        "Seguimiento de la Escritura del Resumen (SER): hacer un seguimiento del progreso de Alicia en la preparación de un resumen. 3.",
        "Solicitar autorización de publicación (AFC) del gerente de Alice basado en el resumen y los detalles de la conferencia. 4.",
        "Papel de seguimiento de escritura (PSE): llevar un registro del progreso de Alicia en la escritura del papel. 5.",
        "Manejo de la presentación de documentos (HPS): seguir los procedimientos internos de la empresa para presentar un documento a una conferencia.",
        "Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo.",
        "De manera similar, CALO puede realizar la tarea de Solicitar Autorización de Despeje (AFC) mediante un plan que consiste en: 1.",
        "Enviar la Solicitud de Autorización (SCR) al gerente de Alice. 2.",
        "Espera la respuesta (WFR) del gerente. 3.",
        "Confirma que la respuesta fue positiva, y falla en caso contrario.",
        "Ahora supongamos que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras está escribiendo el documento.",
        "Alice ya no podrá asistir a IJCAI.",
        "Por lo tanto, ella instruye a su agente CALO para abortar la tarea de SMS.",
        "Abortar la tarea implica abortar tanto el plan de SMS como el subplan de AFC.",
        "Abortar el primer plan requiere que CALO notifique al registro de números de papel que el número de papel asignado está obsoleto, lo cual puede lograr mediante la tarea Cancelar Número de Papel (CPN). Abortar el segundo plan requiere que CALO notifique al gerente de Alice que Alice ya no necesita autorización para publicar, lo cual CALO puede lograr invocando la tarea Cancelar Solicitud de Autorización (CCR).",
        "Observamos una serie de observaciones importantes del ejemplo.",
        "Primero, la decisión de abortar un curso de acción particular puede surgir de las deliberaciones internas del agente (como razonar sobre prioridades en un conflicto por recursos), o de fuentes externas (como otro agente cancelando un compromiso), como en este ejemplo.",
        "En este documento solo abordamos el problema de determinar si una tarea o plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se haya tomado esta decisión.",
        "Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo.",
        "Segundo, una vez que se toma la decisión de abortar el intento de enviar un artículo, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización.",
        "En otras palabras, abortar una tarea no es simplemente cuestión de abandonar la tarea y los planes activos asociados: puede haber algunas acciones de limpieza que necesiten realizarse.",
        "Esto es similar al caso del fracaso, en el sentido de que también puede haber acciones a tomar cuando una tarea o plan falla.",
        "En ambos casos, hay que tener en cuenta que no se trata simplemente de que el agente deshaga sus acciones hasta la fecha; de hecho, esto puede no ser ni posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado del mundo) ni deseable (dependiendo de la semántica de la tarea).",
        "Más bien, la limpieza implica compensación a través de acciones de recuperación hacia adelante [3].",
        "Tercero, hay una distinción entre abortar una tarea y abortar un plan.",
        "En el primer caso, está claro que todos los planes que se estén ejecutando para realizar la tarea deben ser abortados; en el segundo caso, puede ser que existan mejores alternativas al plan actual y se deba intentar una de estas.",
        "Por lo tanto, el aborto o fracaso del plan no necesariamente conduce al aborto o fracaso de la tarea.",
        "Dado que las tareas pueden contener sub tareas, las cuales pueden contener más sub tareas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto.",
        "Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que una tarea o plan principal es abortado. 3.",
        "ABORTANDO TAREAS Y PLANES Como hemos insinuado, el fracaso y abortar son conceptos relacionados.",
        "Ambos causan que la ejecución de los planes existentes se detenga y, en consecuencia, que el agente reflexione sobre sus tareas e intenciones actuales.",
        "El fracaso y la interrupción, sin embargo, difieren en la forma en que surgen.",
        "En caso de fallo, el disparador para detener la ejecución de una tarea o plan proviene de abajo, es decir, del fallo de sub tareas o planes de nivel inferior.",
        "En caso de abortar, el disparador proviene de arriba, es decir, de las tareas y los planes principales que iniciaron un plan.",
        "En sistemas de estilo BDI como JACK y SPARK, el conocimiento del dominio de los agentes incluye una biblioteca de planes predefinidos de cláusulas de planificación.",
        "Cada cláusula de plan tiene un cuerpo de plan, que es un programa (es decir, una combinación de acciones primitivas, subtareas, etc.) que puede ejecutarse en respuesta a una tarea u otro evento si se cumple la condición de contexto de las cláusulas del plan.",
        "El agente selecciona y ejecuta instancias de cláusulas de plan para realizar sus tareas.",
        "Puede haber más de una cláusula de plan aplicable y, en caso de que una falle, se puede intentar otra aplicable.",
        "Los planes pueden tener subtareas que deben tener éxito. CALO solo necesita eliminar las tareas TWA y TWP para abortarlas: por simplicidad, suponemos que no es necesario realizar una limpieza explícita de su estado interno.",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) para que el plan tenga éxito.",
        "En tales sistemas, ocurre un fallo en el plan si una de las acciones o subtareas dentro del plan falla.",
        "La acción de los agentes ante el fracaso del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si se ha intentado un plan y ha resultado en fracaso, o puede intentar planes alternativos y declarar (de hecho, debe declarar) el fracaso de la tarea solo si se han intentado todos los planes alternativos posibles para realizar la tarea y han resultado en fracaso.",
        "Observa que, si bien el fracaso de una tarea puede derivar del fracaso de un plan o de una secuencia de fracasos de planes, el fracaso de un plan no tiene por qué llevar al fracaso de la tarea siempre y cuando el agente pueda completar con éxito un plan alternativo.",
        "Además, el fracaso de la tarea también puede surgir de forma independiente al fracaso del plan, si el agente decide abortar la tarea.",
        "Nuestro enfoque asocia un método de aborto con cada plan.",
        "Esto permite al programador especificar acciones de compensación dedicadas según cómo el agente esté intentando realizar la tarea.",
        "Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que se pueden realizar dinámicamente de la manera habitual en BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones.",
        "La pregunta sigue siendo qué método de aborto se debe invocar, y de qué manera.",
        "Dada la complejidad de los espacios de acción de los agentes, no es posible ni deseable enumerar un conjunto estático de reglas.",
        "Más bien, el agente invocará sus métodos de aborto dinámicamente de acuerdo al estado de ejecución y sus propios eventos internos.",
        "Una alternativa a adjuntar un método de aborto a cada plan es adjuntar dichos métodos a cada acción atómica.",
        "Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los métodos de limpieza para el fracaso en los sistemas actuales están adjuntos a los planes.",
        "Para entender cómo debería funcionar el proceso de aborto de los agentes, consideramos tres situaciones en las que tiene sentido que un agente considere abortar algunas de sus tareas y planes: 1.",
        "Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí mismo, el plan actualmente ejecutado para realizar la tarea debe ser abortado.",
        "Por ejemplo, supongamos que la política de la empresa cambia para que los empleados con la antigüedad de Alice tengan automáticamente autorización para publicar artículos.",
        "Dado que Alice ahora tiene autorización para publicar su artículo, CALO puede abortar el plan de Solicitar Autorización.",
        "Al hacerlo, debe invocar el método de aborto, en este caso realizando la solicitud de cancelación de autorización.",
        "Cuando dos o más subprogramas se ejecutan en paralelo, si uno falla entonces los demás deben ser abortados, dado que el fallo de una rama conlleva al fallo de la tarea en general.",
        "Por ejemplo, supongamos que a mitad de la escritura del artículo, Alice se da cuenta de que hay un error fatal en sus resultados, por lo que notifica a CALO que no podrá completar el artículo para la fecha límite.",
        "El fallo de la tarea de Escritura de Pista debería provocar que la tarea de Solicitar Autorización que se está ejecutando en paralelo sea abortada. 3.",
        "Cuando un evento de ejecución altera la importancia de una tarea o intención existente, el agente debe deliberar si el/los plan(es) existente(s) deben continuar.",
        "Por ejemplo, supongamos que Alice encarga a CALO una nueva tarea de alta prioridad para comprar una computadora portátil de reemplazo, pero que Alice no tiene suficientes fondos para comprar la computadora portátil y asistir a IJCAI.",
        "Razonar sobre los requisitos de recursos [20, 10] hará que el agente se dé cuenta de que no puede completar exitosamente ambas tareas. Si hay alguna diferencia entre cómo abortar una tarea que se realiza externamente y cómo abortar una que ahora se sabe que es imposible, el método de aborto puede detectar las circunstancias y manejar la situación de manera apropiada.",
        "Dado que la nueva tarea tiene mayor importancia, un agente racional evaluará su mejor curso de acción y puede decidir abortar o al menos suspender la tarea existente de presentar un documento y las intenciones derivadas de ella [12].",
        "La semántica operativa que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones mencionadas anteriormente.",
        "La tercera situación implica deliberar sobre la importancia de una tarea, la cual depende de varios factores como la prioridad de la tarea.",
        "Aunque esta deliberación está más allá del alcance de este documento, es un tema complementario de nuestro trabajo futuro.",
        "Ten en cuenta que las situaciones anteriores se aplican a metas de logro, para las cuales la tarea se completa cuando se logra un estado particular del mundo (por ejemplo, asegurarse de que tengamos autorización).",
        "Diferentes formas de razonamiento se aplican a otros tipos de objetivos, como los objetivos de mantenimiento, donde el objetivo se satisface al mantener un estado del mundo durante algún período de tiempo (por ejemplo, mantener $100 en efectivo).",
        "La representación del método de aborto tiene la intención de que una tarea o plan se detenga, y que tanto la tarea o plan como todos sus hijos dejen de ejecutarse, y que se realicen los métodos de limpieza apropiados según sea necesario.",
        "A diferencia de los sistemas de planificación offline, los agentes BDI están situados: realizan deliberación en línea y sus acciones cambian el estado del mundo.",
        "Como resultado, los efectos de muchas acciones no pueden ser simplemente deshechos.",
        "Además, el proceso de deshacer puede causar efectos adversos.",
        "Por lo tanto, los métodos de limpieza que especificamos son procedimientos de recuperación hacia adelante que intentan garantizar un estado estable y que también pueden, si es posible, recuperar recursos.",
        "La representación común de un plan en sistemas de estilo BDI como JACK y SPARK incluye un método de fallo, que es el método de limpieza designado invocado cuando el plan falla.",
        "Para esto, agregamos el método de aborto, que se invoca si se va a abortar el plan.",
        "En nuestro ejemplo, el método de aborto para el plan de Envío de Reunión de Soporte consiste en invocar la sub-tarea Cancelar Número de Documento.",
        "El método de aborto no necesita abortar explícitamente la solicitud de autorización, ya que el agente invocará el método de aborto para la subtarea de manera apropiada, como detallamos a continuación.",
        "La suposición aquí es que, al igual que en el método de falla, el programador del sistema del agente tiene la oportunidad de especificar un método de aborto sensato que tenga en cuenta el punto en el plan en el que se va a ejecutar el aborto.",
        "Para cualquier plan, el método de aborto es opcional: si no se especifica un método de aborto, el agente no toma ninguna acción específica para este plan.",
        "Sin embargo, las reglas de comportamiento predeterminadas de los agentes siguen aplicándose, por ejemplo, si intentar de nuevo un plan alternativo para la tarea principal.",
        "Se debe tener en cuenta que no es necesario una representación explícita de los métodos de limpieza para las tareas, ya que las tareas se realizan ejecutando algún plan o planes.",
        "Por lo tanto, abortar una tarea significa abortar el plan actual que se está ejecutando para realizar esa tarea, como describiremos a continuación.",
        "Invocación del método de aborto. Ahora describimos de manera informal la acción de los agentes al abortar planes y tareas.",
        "Cuando un plan P es abortado: 1.",
        "Abortar cada sub-tarea que sea un hijo activo de P. Un hijo activo es aquel que fue desencadenado por P y actualmente está en ejecución. 2.",
        "Cuando ya no haya más niños activos, invoque el método de aborto del plan P. 3.",
        "Indique un fallo en el plan para TP, la tarea principal de P. Se señala aquí que si la tarea principal TP no debe ser abortada, entonces el agente puede elegir otro plan aplicable para satisfacer TP. 10 The Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Cuando una tarea (o sub-tarea) T es abortada: 1.",
        "Abortar el plan activo actual para satisfacer T (si lo hay). 2.",
        "Cuando ya no haya más procesos secundarios activos, elimine la tarea.",
        "El agente ya no persigue a T. 3.",
        "Ten en cuenta que cuando se aborta el plan activo actual para realizar T, no se deben intentar otros planes aplicables para realizar T, ya que es la tarea que se va a abortar.",
        "Para evitar esfuerzos de limpieza en cascada infinita, asumimos que los métodos de aborto nunca serán abortados ni fallarán.",
        "En realidad, sin embargo, un método de aborto puede fallar.",
        "En este caso, al no contar con un mecanismo de manejo más sofisticado, el agente simplemente deja de ejecutar el método de aborto fallido sin más deliberación.",
        "La suposición que hacemos no es, por lo tanto, un reflejo de la complejidad total de la realidad, sino una que es pragmática en términos del ciclo de ejecución del agente; el enfoque para el manejo de fallos de [21] hace la misma suposición.",
        "En sistemas como SPARK, el programador puede especificar un comportamiento alternativo para un método de fallo o aborto fallido mediante procedimientos a nivel meta.",
        "También asumimos que los métodos de falla y aborto terminan en tiempo finito. 4.",
        "SEMÁNTICA OPERACIONAL Proporcionamos la semántica para los procesos de falla y aborto de tareas y planes descritos anteriormente.",
        "Utilizamos el lenguaje CAN inicialmente definido en [23] y posteriormente extendido como CANPLAN en [17] para incluir un componente de planificación y luego como CANPLAN2 en [18] para mejorar los mecanismos de adopción y eliminación de objetivos.",
        "Las extensiones también simplificaron la semántica en el trabajo anterior.",
        "Utilizamos algunas de estas simplificaciones para proporcionar un breve resumen del lenguaje CAN en la Sección 4.1.",
        "Tras una presentación de la semántica operacional de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos. 4.1 Lenguaje CAN CAN es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentSpeak [15] y Kinnys Ψ [7], ambos de los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados.",
        "CAN proporciona un constructo de objetivo explícito que captura tanto los aspectos declarativos como los procedimentales de un objetivo.",
        "Los objetivos son persistentes en CAN en el sentido de que, cuando un plan falla, se intenta otro plan aplicable.",
        "Esto equivale al mecanismo predeterminado de manejo de fallos que se encuentra típicamente en sistemas BDI implementados como JACK [2].",
        "En sistemas prácticos, las tareas suelen traducirse en eventos que desencadenan la ejecución de algunos planes.",
        "Esto también es cierto en el lenguaje CAN, pero, para mantener la persistencia de los objetivos, se introduce un constructo de objetivo.",
        "Esto se denota por Objetivo ` φs, P, φf ´, donde φs es la condición de éxito que determina cuándo se considera que el objetivo se ha logrado, φf es una condición de fracaso bajo la cual se considera que el objetivo ya no es alcanzable o relevante, y P es un programa para lograr el objetivo, que se abortará una vez que φs o φf se vuelvan verdaderos.",
        "El comportamiento de un agente está especificado por una biblioteca de planes, denotada por Π, que consiste en una colección de cláusulas de planes de la forma e : c ← P, donde e es un evento, c es una condición de contexto (una fórmula lógica sobre las creencias de los agentes que debe ser verdadera para que el plan sea aplicable) y P es el cuerpo del plan.",
        "El cuerpo del plan es un programa que se define recursivamente de la siguiente manera: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Objetivo ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 Un c omitido es equivalente a verdadero.",
        "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figura 1: Reglas operativas de CAN. donde P1, . . . , Pn son ellos mismos programas, act es una acción primitiva que no está más especificada, y +b y −b son operaciones para añadir y eliminar creencias.",
        "La base de creencias contiene átomos de creencias fundamentales en forma de relaciones de primer orden, pero podría ser extendida ortogonalmente a otras lógicas.",
        "Se asume que se proporcionan operaciones bien definidas para verificar si una condición se sigue de un conjunto de creencias (B |= c), para agregar una creencia a un conjunto de creencias (B ∪ {b}), y para eliminar una creencia de un conjunto de creencias (B \\ {b}). ?φ es una prueba para la condición φ, y !e5 es un evento6 que se publica desde dentro del programa.",
        "Los constructos compuestos son secuenciación (P1; P2), ejecución paralela (P1 P2) y metas (Meta ` φs, P, φf ´ ).",
        "Lo anterior define el idioma del usuario.",
        "Además, se utilizan un conjunto de formas compuestas auxiliares internamente al asignar semántica a los constructos. nil es el programa básico (terminante).",
        "Cuando un evento coincide con un conjunto de cláusulas de plan, estas se recopilan en un conjunto de alternativas protegidas (c1: P1, ..., cn: Pn).",
        "La otra forma compuesta auxiliar, , es un operador de elección dual a la secuenciación: P1 P2 ejecuta P1 y luego ejecuta P2 solo si P1 falló.",
        "Un resumen de la semántica operacional para CAN de acuerdo con [23] y siguiendo algunas de las simplificaciones de [17] es el siguiente.",
        "Una configuración básica S = B, G, Γ consiste en la base de creencias actual B del agente, el conjunto actual de metas G que se persiguen (es decir, un conjunto de fórmulas) y el programa actual P que se está ejecutando (es decir, la intención actual).",
        "Una transición S0 −→ S1 especifica que ejecutar S0 durante un paso único produce la configuración S1.",
        "S0 −→∗ Sn es el cierre reflexivo transitivo usual de −→: Sn es el resultado de una o más transiciones de un solo paso.",
        "Una regla de derivación S −→ Sr S −→ Sr consiste en un conjunto (posiblemente vacío) de premisas, que son transiciones junto con algunas condiciones auxiliares (numerador), y una única transición conclusión derivable de estas premisas (denominador).",
        "La Figura 1 muestra algunas de las reglas operativas.",
        "La regla de Evento maneja eventos de tarea recopilando todas las cláusulas de plan relevantes para el evento en cuestión: para cada cláusula de plan e : ψi ← Pi, si hay un unificador más general, θ = mgu(e, e) de e y el evento en 5 Donde es obvio que e es un evento, a veces excluiremos el signo de exclamación para mayor legibilidad. 6 Típicamente un objetivo de logro.",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 11 B |= φs B, Objetivo ` φs, P, φf ´ −→ B, verdadero Gs B |= φf B, Objetivo ` φs, P, φf ´ −→ B, falla Gf P = Objetivo ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Objetivo ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Objetivo ` φs, P, φf ´ −→ B , Objetivo ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {verdadero, falla} B, Objetivo ` φs, P, φf ´ −→ B, Objetivo ` φs, P2 £ P2, φf ´ GR Figura 2: Reglas para objetivos en CAN. pregunta, entonces la regla construye una alternativa guardada ψiθ: Piθ.",
        "La regla Select selecciona un cuerpo de plan aplicable de un conjunto de alternativas relevantes (restantes): el programa P Δ establece que el programa P debe intentarse primero, recurriendo a las alternativas restantes, Δ \\ P, si es necesario.",
        "Esta regla y la regla de fallo se utilizan juntas para el manejo de fallos: si el programa actual Pi de una cláusula de plan para una tarea falla, primero se aplica la regla de fallo, y luego, si es posible, la regla Select elegirá otra alternativa aplicable para la tarea si existe alguna.",
        "Rule Sequence maneja la secuenciación de programas de la manera habitual.",
        "Las reglas Parallel1 y Parallel2 definen la posible intercalación al ejecutar dos programas en paralelo.",
        "La Figura 2 presenta reglas simplificadas para tratar con objetivos, en línea con las presentadas en [17].",
        "La primera regla establece que un objetivo tiene éxito cuando φs se vuelve verdadero; la segunda regla establece que un objetivo falla cuando φf se vuelve verdadero.",
        "La tercera regla GI inicializa la ejecución de un programa de metas actualizando la base de metas y estableciendo el programa en la meta como P £ P; el primer P se ejecutará y el segundo P se utiliza para hacer un seguimiento del programa original para la meta.",
        "La cuarta regla GS ejecuta un solo paso del programa de objetivos.",
        "La regla final GR reinicia el programa original (codificado como P2 del par P1 £ P2) cada vez que el programa actual ha terminado pero el objetivo deseado y aún posible no se ha logrado. 4.2 Abortando Intenciones y Manejando Fallas A continuación, introducimos la capacidad de especificar programas manejadores, en forma de métodos de falla y aborto, que se ocupan de la limpieza requerida cuando un programa dado falla o es abortado.",
        "No asociamos los métodos de falla y aborto con cláusulas de plan o con tareas (eventos), sino que introducimos una nueva construcción de programa que especifica los métodos de falla y aborto para un programa arbitrario.",
        "El constructo FAb(P, PF, PA) ejecuta el programa P. En caso de que P falle, ejecuta el programa de manejo de fallos PF; si P necesita ser abortado, ejecuta el programa de manejo de aborto PA.",
        "Por lo tanto, para agregar los métodos de falla y aborto PF y PA a una cláusula de plan e : c ← P, escribimos e : c ← FAb(P, PF, PA).",
        "Con la introducción de la capacidad de abortar programas, modificamos la construcción paralela para permitir que el fallo de una rama aborte la otra.",
        "Debemos tener en cuenta la posible existencia de métodos de aborto en la rama abortada.",
        "De manera similar, con el constructo de Objetivo ya no podemos abandonar por completo el programa que contiene tan pronto como se cumpla la condición de éxito o fracaso; ahora debemos tener en cuenta la existencia de cualquier método de aborto aplicable al programa.",
        "Proporcionamos la semántica de un lenguaje de agente aumentado que contiene el constructo FAb al definir una transformación de origen, similar a la expansión de macros, que mapea una biblioteca de planes que contiene el constructo FAb(P, PF, PA) en CAN estándar (casi).",
        "La única extensión no estándar a CAN es un constructo de espera hasta que se cumpla una condición.",
        "Explicamos esta simple modificación del constructo paralelo a continuación cuando llegamos a la traducción del constructo de la Meta.",
        "Primero describimos la naturaleza general de la transformación de la fuente, que resulta ser bastante simple para la mayoría de las construcciones del lenguaje, y luego nos concentramos en los tres casos más complejos: las construcciones FAb, paralela y Goal.",
        "Un problema clave es que los constructos FAb pueden estar anidados, ya sea directa o indirectamente.",
        "Llamemos a cada instancia del constructo en tiempo de ejecución un posible punto de aborto (pap).",
        "Donde estos constructos están anidados, es importante que antes de que se ejecute el método de falla o aborto de un pap padre, se ejecuten primero los programas de métodos de falla o aborto de los paps hijos, como se describe anteriormente en la Sección 3.",
        "La necesidad de coordinar la ejecución de los métodos de aborto de paps anidados requiere que haya alguna forma de identificar los padres e hijos de un pap en particular.",
        "Logramos esto como parte de la transformación de origen al llevar un registro explícito del contexto de ejecución como un parámetro adicional en los eventos y una variable adicional dentro de cada cuerpo del plan. La transformación de origen reemplaza cada cláusula del plan de la forma e : c ← P con una cláusula del plan e(v) : c ← μv(P) donde v es una variable libre, no presente previamente en la cláusula del plan.",
        "Esta variable se utiliza para llevar un registro del contexto de ejecución.",
        "El valor de la variable de contexto es una lista de identificadores, donde cada nuevo párrafo está representado al anteponer un nuevo identificador al contexto.",
        "Por ejemplo, si los identificadores son enteros, el contexto de un documento puede ser representado por una lista [42, 1] y el contexto introducido por un nuevo documento puede ser representado por [52, 42, 1].",
        "Nos referiremos a los paps por el contexto en lugar del nuevo identificador agregado, por ejemplo, por [51, 42, 1] y no solo por 51.",
        "Esto nos permite equiparar la relación de ancestro entre paps con la relación de sufijo de lista en los contextos relevantes, es decir, v es un ancestro de v si y solo si v es un sufijo de v.",
        "Para la mayoría de los constructos CAN, la variable de contexto no se utiliza o se pasa sin cambios: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) Queda por especificar la transformación μv(·) en tres casos: los constructos FAb, paralelo y Goal.",
        "Estos son más complejos en el sentido de que la fuente transformada necesita crear dinámicamente un nuevo identificador de pap, para usarlo como un nuevo contexto dentro de la construcción, y para llevar un registro de cuándo el pap está activo (es decir, actualmente en ejecución) añadiendo y eliminando creencias sobre el contexto.",
        "Introduzcamos la acción primitiva prependID(v, v) que crea un nuevo identificador pap y lo antepone a la lista v, dando como resultado la lista v.",
        "También introducimos los siguientes predicados: • a(v) - el pap v está actualmente activo. • abort(v) - el pap v debe ser abortado (después de abortar a todos sus descendientes). Una alternativa sería utilizar predicados a nivel meta que reflejen el estado actual de la estructura de intenciones. La Sexta Conferencia Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) • f(v) - el programa del pap v ha fallado. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))el pap v es un ancestro del pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v no tiene hijos activos. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - debemos abortar v, es decir, abort es verdadero para v o algún ancestro; sin embargo, debemos esperar hasta que no haya hijos activos de v. • san(v) ≡ sa(v) ∧ nac(v) - debemos abortar v ahora si debemos abortar v y v no tiene hijos activos.",
        "Primero consideremos el caso del constructo FAb.",
        "La idea es que, cada vez que ocurra un nuevo pap, se utiliza la acción prependID(v, v) para crear una nueva lista de identificadores de pap v a partir de la lista existente v. Luego agregamos la creencia de que v es el contexto activo, es decir, +a(v), y comenzamos a procesar el programa dentro del pap utilizando v en lugar de v como contexto.",
        "Necesitamos asegurarnos de retractar la creencia de que v está activo al final, es decir, −a(v).",
        "Utilizamos la construcción de Objetivo para permitirnos detener la ejecución de un programa dentro de un pap v cuando sea necesario abortar.",
        "Mientras se ejecuta el programa P, sabemos que debemos descartar P e invocar su método de aborto si se le ha indicado a algún ancestro de P que aborte.",
        "Esto se representa por el predicado sa(v) siendo verdadero.",
        "Sin embargo, debemos asegurarnos de hacer esto solo después de que cada pap de niño haya tenido la oportunidad de invocar su método de aborto y todos estos métodos de aborto hayan sido completados: si abandonamos el programa demasiado pronto, entonces la ejecución de los métodos de aborto de los niños también será abandonada.",
        "Por lo tanto, la condición que realmente usamos en la construcción del Objetivo para probar cuándo detener el programa es san(v).",
        "Esta condición se basa en el hecho de que a medida que los niños completan sus papilas, eliminan los hechos relevantes.",
        "Nuestro uso del constructo Goal es por su capacidad de detener la ejecución de un programa cuando se cumplen ciertas condiciones.",
        "Para dejar de lado el aspecto de la repetición de la ejecución hasta que se cumpla una condición, debemos asegurarnos de que la condición de éxito o fracaso del constructo se cumpla una vez que la ejecución del programa tenga éxito o falle.",
        "Nos aseguramos de esto al retractar el hecho a(v) en caso de éxito y afirmar el hecho f(v) en caso de fracaso, y al tener las condiciones apropiadas de éxito y fracaso en el Objetivo.",
        "Por lo tanto, si falla la construcción del Objetivo, entonces el programa fue abortado o falló.",
        "Invocamos el método de fallo o aborto relevante, retiramos el hecho a(v) y luego fallamos.",
        "Al juntar todo esto, definimos formalmente μv(FAb(P, PA, PF )) de la siguiente manera, donde v es una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) En segundo lugar, debemos transformar el operador paralelo para asegurar que el fallo de una rama aborte de forma segura la otra.",
        "Aquí construimos dos nuevos contextos, v y v, a partir del contexto existente v. Si una rama falla, debe abortar la otra rama.",
        "Al final, si se abortó cualquiera de las ramas, entonces debemos fallar.",
        "Que v y v sean variables nuevas distintas de cualquier otra en la biblioteca de planes de los agentes.",
        "Definimos μv(P1 P2) como: prependID(v, v); prependID(v, v); +a(v); +a(v); (Goal (¬a(v), (μv(P1); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v)) Goal (¬a(v), (μv(P2); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v))); ?¬abort(v) ∧ ¬abort(v) Finalmente, necesitamos modificar las ocurrencias del constructo Goal de dos maneras: primero, asegurarnos de que los métodos de manejo de aborto no se pasen por alto cuando se satisfacen las condiciones de éxito o fracaso, y segundo, activar la interrupción del programa contenido cuando se satisfacen las condiciones de éxito o fracaso.",
        "Para transformar el constructo Goal necesitamos extender el estándar CAN con un constructo de espera-hasta-condición.",
        "El constructo φ : P no ejecuta P hasta que φ se convierte en verdadero.",
        "Aumentamos el lenguaje CAN con las siguientes reglas para el operador de guardia :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false Para especificar μv(Goal ` φs, P, φf ´ ), generamos un nuevo pap y ejecutamos el programa dentro del constructo Goal en este nuevo contexto.",
        "Debemos asegurarnos de que la creencia a(v) sea eliminada, ya sea que el objetivo tenga éxito o fracase.",
        "Cambiamos la condición de éxito y fracaso del constructo Objetivo a una rama paralela utilizando el constructo de espera-hasta-condición, y modificamos el Objetivo para usar la condición de éxito debería abortar ahora san(v) como condición de éxito.",
        "La rama de espera desencadenará la interrupción del programa si se cumple tanto la condición de éxito como la de fracaso.",
        "Para evitar cualquier problema al terminar la condición de espera, también finalizamos la espera si el pap ya no está activo.",
        "Que v sea una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes.",
        "Definimos μv(Goal ` φs, P, φf ´ ) como: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) El programa P se ejecutará repetidamente hasta que san(v ) se convierta en verdadero.",
        "Hay dos formas en que esto puede ocurrir.",
        "Primero, si se cumple la condición de éxito φs o la condición de fracaso φf, entonces se ejecuta la segunda rama de la construcción en paralelo.",
        "Esto hace que abort(v) se convierta en verdadero, y, después de que se ejecuten los métodos de abortmethods descendientes, san(v) se convierte en verdadero.",
        "En este caso, P se elimina, se elimina el a(v), y todo el constructo tiene éxito o fracasa en función de φs.",
        "La segunda forma en que san(v) puede volverse verdadero es si v o uno de sus ancestros es abortado.",
        "En este caso, una vez que se ejecutan los métodos de aborto de los paps descendientes, san(v) se vuelve verdadero, P se elimina, se elimina la creencia a(v) (permitiendo que la segunda rama paralela se ejecute, instruyendo vacuamente a v a abortar), y la primera rama paralela falla (asumiendo que φs es falso). Ejemplo trabajado 4.3 Echemos un vistazo a la traducción del ejemplo de envío a IJCAI de la Sección 2.",
        "Expresaremos las tareas mediante eventos, por ejemplo, la tarea Asignar un Número de Papel la expresamos como el evento APN.",
        "Que la salida de la tarea Solicitar autorización sea Y o N, indicando la aprobación o no del gerente de Alicia, respectivamente.",
        "Entonces tenemos (al menos) las siguientes dos cláusulas de plan en CAN, para las tareas de Envío de Reunión de Apoyo y Solicitar Autorización de Despeje, respectivamente: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Tenga en cuenta que Envío de Reunión de Apoyo tiene un parámetro m, la reunión de interés (IJCAI, en nuestro ejemplo), mientras que Solicitar Autorización de Despeje no tiene parámetros.",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 13. Veamos primero la traducción de la segunda cláusula del plan, para AFC, ya que es la más simple de las dos.",
        "Que v y v denoten nuevas variables.",
        "Entonces tenemos como cláusula del plan traducido: AFC(v): verdadero ← prependID(v, v); +a(v); Meta(¬a(v), (!SCR(v); !WFR(r, v); ?r = Y; −a(v) +f(v)), san(v) ∨ f(v)) (((?sa(v); !CCR(v)) nil); −a(v); ?falso) Podemos ver que se ha añadido un parámetro de contexto adicional a cada tarea y que el antiguo cuerpo del plan ahora aparece dentro de un constructo de Meta.",
        "Si el antiguo cuerpo del plan tiene éxito, la creencia a(v) se retira, lo que hace que el Objetivo tenga éxito.",
        "Si el cuerpo del plan antiguo falla, o si la tarea debe ser abortada, el constructo de Objetivo falla.",
        "Esto es seguido por la ejecución de CCR (en caso de un aborto), la retracción de a(v), y el fallo.",
        "La traducción de la primera cláusula del plan, para SMS, es más compleja, debido a la estructura paralela que introduce paps anidados: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Meta ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Meta ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Meta ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Aquí podemos ver que si la tarea !TWP(v ) falla, entonces se afirmará f(v ), lo que hará que falle la construcción de Meta que lo contiene, y llevará a que se afirme abort(v ).",
        "Si la tarea !WFR(r, v ) en la expansión de !AFC(v ) todavía se está ejecutando y no tiene paps hijos activos, entonces sa(v ) y sa(v ) serán verdaderos; sin embargo, solo san(v ) y no san(v ) serán verdaderos.",
        "Este conjunto de condiciones hará que el constructo Goal en la primera cláusula del plan falle, deteniendo la ejecución de !WFR(r, v).",
        "La tarea !CCR(v) será ejecutada.",
        "Una vez que esta tarea se complete, la creencia a(v) se retira, lo que hace que san(v) se convierta en verdadero, lo que lleva a que la primera construcción de objetivo de la segunda cláusula del plan falle.",
        "Si bien las cláusulas del plan traducido parecen complicadas, observe que la traducción de las cláusulas del plan inicial es completamente automatizada, de acuerdo con las reglas establecidas en la Sección 4.2.",
        "Las cláusulas del plan traducido, con la semántica de PUEDE aumentada por nuestra construcción de condición de esperar-hasta, especifican así la operación del agente para manejar tanto el fallo como la interrupción del ejemplo. 5.",
        "El fallo del plan se maneja en la versión extendida de AgentSpeak encontrada en el sistema Jason [6].",
        "Los planes de limpieza de fallas se activan a partir de eventos de eliminación de objetivos −!g.",
        "Tales planes, similares a nuestros métodos de fracaso, están diseñados para que el agente efectúe cambios de estado (actúe para deshacer sus acciones anteriores) antes de posiblemente intentar otro plan para lograr el objetivo fallido g. Dados los constructos de Jason para abandonar un objetivo con una indicación de si intentar o no un plan alternativo para él, H¨ubner et al. [6] proporcionan una descripción informal de cómo un agente de Jason modifica su estructura de intenciones cuando ocurre un evento de fracaso del objetivo.",
        "En un plan de eliminación de objetivos, el programador puede especificar cualquier acción de deshacer y si intentar de nuevo el objetivo.",
        "Si no se proporciona un plan de eliminación de objetivos, el comportamiento predeterminado de Jason es no volver a intentar el objetivo.",
        "El manejo de fallos se aplica solo a los planes desencadenados por la adición de un logro o meta de prueba; en particular, los eventos de eliminación de metas no se publican por el fallo de un plan de eliminación de metas.",
        "Además, la semántica informal de [6] no considera submetas paralelas (es decir, el constructo CAN), ya que dicha ejecución no forma parte del lenguaje de Jason.",
        "La implementación de H¨ubner et al. [6] requiere acciones internas de Jason.",
        "Un requisito para implementar nuestro enfoque es una capacidad reflexiva en la implementación del agente BDI.",
        "Las implementaciones adecuadas del formalismo BDI son JACK [2], Jadex [14] y SPARK [9].",
        "Los tres permiten métodos a nivel meta que son activados por eventos meta como la adopción de objetivos o el fracaso de un plan, y ofrecen capacidades introspectivas sobre los estados de objetivo e intención.",
        "Tales instalaciones de nivel meta también son requeridas por el enfoque de Unruh et al. [21], quienes definen la compensación semántica basada en objetivos para un agente.",
        "Los objetivos de manejo de fallos son invocados de acuerdo con las reglas de estrategia de manejo de fallos, por un agente dedicado Componente de Manejo de Fallos (FHC) que sigue la ejecución de la tarea.",
        "Estos objetivos son especificados por el programador del agente y se adjuntan a las tareas, de manera similar a cómo nuestro constructo FAb(P, PF, PA) asocia métodos de falla y aborto con un plan P. Sin embargo, cabe destacar que, a diferencia tanto de [6] como de nuestra semántica, [21] adjuntan el conocimiento de manejo de fallas a nivel de objetivo, no de plan.",
        "Sus objetivos de manejo de fallos pueden consistir en objetivos de estabilización que realicen una limpieza localizada e inmediata para restaurar el estado de los agentes a un estado conocido y estable, y objetivos de compensación que realicen acciones de deshacer.",
        "Los objetivos de compensación se activan al abortar un objetivo, y no necesariamente al fallar en el objetivo (es decir, si el FHC indica al agente que vuelva a intentar el objetivo fallido y el nuevo intento tiene éxito).",
        "El enfoque FHC se define a nivel de objetivo para facilitar la especificación abstracta del conocimiento de manejo de fallos; el FHC decide cuándo abordar un fallo y qué hacer (es decir, qué objetivos de manejo de fallos invocar), separando este conocimiento del cómo implementar acciones correctivas (es decir, qué plan ejecutar para cumplir con el objetivo de manejo de fallos adoptado).",
        "Esto contrasta con el manejo simplista de fallas a nivel de plan en el que el qué y el cómo se entrelazan en el conocimiento de la tarea del dominio.",
        "Si bien nuestro enfoque está definido a nivel de plan, nuestra semántica BDI extendida permite la separación de la ejecución y el manejo de fallos.",
        "Además, el FHC mantiene explícitamente estructuras de datos para rastrear la ejecución de agentes.",
        "Aprovechamos las estructuras de ejecución existentes y la capacidad autorreflexiva de un agente BDI para lograr tanto la interrupción como el manejo de fallos sin costos adicionales.",
        "Las reglas de estrategia de manejo de fallos de FHC (por ejemplo, si volver a intentar un objetivo fallido) son reemplazadas por instrucciones en nuestros planes de PF y PA, junto con manejadores de fallos predeterminados a nivel meta de acuerdo con la naturaleza de los agentes (por ejemplo, comprometidos ciegamente).",
        "El enfoque FHC es independiente de la arquitectura del agente en sí, a diferencia de nuestro trabajo que está dedicado al formalismo BDI (aunque no está ligado a ningún sistema de agente en particular).",
        "Por lo tanto, no se desarrollan semánticas formales en [21]; la operación de los FHCs se presenta como 14 The Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) un protocolo basado en estados.",
        "Este enfoque, junto con el punto de control estatal, se utiliza para sistemas multiagente en [22].",
        "La arquitectura resultante incorpora su enfoque de manejo de fallos dentro de una arquitectura de procesamiento en pares para la recuperación de fallos de agentes.",
        "Otro trabajo sobre el manejo de excepciones multiagente incluye los agentes de manejo de excepciones distribuidos AOEXs [5], y los centinelas similares de [8].",
        "En ambos casos, la lógica de manejo de fallos y el conocimiento están desacoplados de los agentes; en contraste, mientras se separa el manejo de excepciones del conocimiento específico del dominio, tanto el enfoque de Unruh et al. como nuestro enfoque retienen la lógica de manejo de fallos dentro de un agente. 6.",
        "CONCLUSIÓN Y TRABAJO FUTURO Las tareas y planes de un agente pueden no llegar a completarse con éxito, ya sea por la decisión del agente de abortarlos (quizás a petición de otro agente), o por factores imprevistos que llevan al fracaso.",
        "En este artículo hemos presentado un enfoque basado en procedimientos que incorpora la interrupción de tareas y planes en el ciclo de deliberación de un agente de estilo BDI, proporcionando así un enfoque unificado para el fracaso y la interrupción.",
        "Nuestra contribución principal es un análisis de los requisitos sobre la operación del agente para abortar tareas y planes, y una semántica operativa correspondiente para abortar en el lenguaje abstracto del agente CAN.",
        "Estamos planeando implementar una instancia de nuestro enfoque en el sistema de agentes SPARK [9]; en particular, el trabajo de este artículo será la base para el mecanismo de manejo de abortos de SPARK.",
        "También estamos desarrollando una herramienta de análisis para nuestra versión extendida de CAN como base para experimentación.",
        "Un agente inteligente no solo manejará con gracia tareas y planes fallidos, sino que también reflexionará sobre sus actitudes cognitivas para decidir su próximo curso de acción.",
        "Hemos asumido el comportamiento predeterminado de un agente de estilo BDI, de acuerdo con su naturaleza: por ejemplo, volver a intentar alternativas de un plan fallido hasta que uno tenga éxito o hasta que no queden planes alternativos (en cuyo caso fallar la tarea).",
        "El trabajo futuro consiste en poner nuestro enfoque al servicio de un razonamiento de agente más dinámico, como la introspección que un agente capaz de razonar sobre los efectos de la interacción de tareas y los requisitos de recursos puede lograr [19, 12].",
        "Relacionado con esto está determinar el costo de abortar una tarea o un plan, y utilizarlo como un insumo en el proceso de deliberación.",
        "Esto influiría en particular en el compromiso que el agente tiene hacia una tarea específica: a mayor costo, mayor compromiso.",
        "Nuestra suposición de que los métodos de aborto no fallan, como se discutió anteriormente, es una suposición pragmática.",
        "Sin embargo, este es un tema que merece una mayor exploración, ya sea para desarrollar supuestos más débiles que también sean prácticos, o para analizar las condiciones bajo las cuales nuestra suposición es realista.",
        "Un elemento adicional de interés es extender nuestro enfoque al fracaso y la interrupción a los objetivos de mantenimiento [1].",
        "Para tales objetivos, se necesita una semántica operativa diferente para la interrupción que para los objetivos de logro, para que coincida con la diferencia en la semántica de los propios objetivos.",
        "Agradecimientos Agradecemos a Lin Padgham y a los revisores anónimos por sus comentarios.",
        "El primer autor agradece el apoyo del Consejo de Investigación Australiano y del Software Orientado a Agentes bajo la subvención LP0453486.",
        "El trabajo de los dos autores en SRI International fue apoyado por la Agencia de Proyectos de Investigación Avanzada de Defensa (DARPA) bajo el Contrato No.",
        "NBCHD030010.",
        "Cualquier opinión, hallazgo, conclusión o recomendación expresada en este material son responsabilidad de los autores y no reflejan necesariamente la visión de DARPA o el Departamento del Interior-Centro Nacional de Negocios. 7.",
        "REFERENCIAS [1] L. Braubach, A. Pokahr, D. Moldt y W. Lamersdorf.",
        "Representación de objetivos para sistemas de agentes BDI.",
        "En Actas del Segundo Congreso Internacional.",
        "Taller sobre Programación de Sistemas Multiagente (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson y A. Lucas.",
        "Agentes inteligentes JACK: componentes para agentes inteligentes en Java.",
        "AgentLink News, Edición 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira y P. Henderson.",
        "Ampliando el concepto de compensación de transacciones.",
        "Revista de Sistemas de IBM, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk y J.-J.",
        "C. Meyer.",
        "Tipos de objetivos en la programación de agentes.",
        "En Proc. de AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy y E. Kendall.",
        "Aoex: Un marco de manejo de excepciones basado en agentes para construir sistemas de software confiables, distribuidos y abiertos.",
        "En Actas de la Séptima Conferencia Conjunta sobre Ingeniería de Software Basada en el Conocimiento, 2006. [6] J. F. H¨ubner, R. H. Bordini y M. Wooldridge.",
        "Programación de metas declarativas utilizando patrones de planificación.",
        "En Actas de la 4ta Conferencia Internacional.",
        "Taller sobre Lenguajes y Tecnologías Declarativos de Agentes, 2006. [7] D. Kinny.",
        "El cálculo Psi: un lenguaje algebraico de agentes.",
        "En Proc. de ATAL01, 2001. [8] M. Klein, J.",
        "A. Rodríguez-Aguilar y C. Dellarocas.",
        "Utilizando servicios de manejo de excepciones independientes del dominio para habilitar sistemas multiagente abiertos robustos: El caso de la muerte del agente.",
        "Agentes Autónomos y Sistemas Multiagente, 7(1-2):179-189, 2003. [9] D. Morley y K. Myers.",
        "El marco de agentes SPARK.",
        "En Proc. de AAMAS04, 2004. [10] D. Morley, K. L. Myers y N. Yorke-Smith.",
        "Refinamiento continuo de estimaciones de recursos del agente.",
        "En Proc. de AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack y M. Tambe.",
        "Un asistente personal inteligente para la gestión de tareas y tiempo.",
        "Revista de Inteligencia Artificial, 28, 2007.",
        "Aparecer. [12] K. L. Myers y N. Yorke-Smith.",
        "Un marco cognitivo para la delegación a un agente de usuario asistente.",
        "En Actas del Simposio de Otoño de AAAI 2005 sobre Asistentes de Resolución de Problemas de Iniciativa Mixta, 2005. [13] L. Padgham y M. Winikoff.",
        "Desarrollo de Sistemas de Agentes Inteligentes: Una Guía Práctica.",
        "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, y W. Lamersdorf.",
        "Jadex: Un motor de razonamiento BDI.",
        "En R. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores, Programación Multiagente.",
        "Springer, 2005. [15] A. S. Rao. \n\nSpringer, 2005. [15] A. S. Rao.",
        "AgentSpeak(L): Los agentes BDI se expresan en un lenguaje lógico computable.",
        "En Actas del Séptimo Taller Europeo sobre Modelado de Agentes Autónomos en un Mundo Multiagente, 1996. [16] A. S. Rao y M. P. Georgeff.",
        "Una arquitectura abstracta para agentes racionales.",
        "En Proc. de KR92, 1992. [17] S. Sardiña, L. de Silva y L. Padgham.",
        "Planificación jerárquica en lenguajes de programación de agentes BDI: un enfoque formal.",
        "En Proc. de AAMAS06, 2006. [18] S. Sardina y L. Padgham.",
        "Objetivos en el contexto del fracaso del plan BDI y la planificación.",
        "En Proc. de AAMAS07, 2007. [19] J. Thangarajah, L. Padgham y M. Winikoff.",
        "Detectar y aprovechar la interacción positiva de objetivos en agentes inteligentes.",
        "En Proc. de AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham y K. Fischer.",
        "Evitando conflictos de recursos en agentes inteligentes.",
        "En Proc. de ECAI-02, 2002. [21] A. Unruh, J. Bailey y K. Ramamohanarao.",
        "Un marco para la compensación semántica basada en objetivos en sistemas de agentes.",
        "En Actas de la Primera Conferencia Internacional.",
        "Taller sobre Seguridad en Sistemas Multiagente, 2004. [22] A. Unruh, H. Harjadi, J. Bailey y K. Ramamohanarao.",
        "Gestión de recuperación basada en compensación semántica en sistemas multiagente.",
        "En Proc. del Segundo Simposio IEEE sobre Seguridad y Supervivencia Multiagente (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah.",
        "Objetivos declarativos y procedimentales en sistemas de agentes inteligentes.",
        "En Proc. de KR02, 2002.",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 15"
    ],
    "error_count": 3,
    "keys": {
        "intelligent agent": {
            "translated_key": "agente inteligente",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an <br>intelligent agent</br> is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An <br>intelligent agent</br> will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing <br>intelligent agent</br> Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in <br>intelligent agent</br> systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [
                "Besides dealing with failure, an important capability of an <br>intelligent agent</br> is to be able to abort a particular task or plan.",
                "An <br>intelligent agent</br> will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "Developing <br>intelligent agent</br> Systems: A Practical Guide.",
                "Declarative and procedural goals in <br>intelligent agent</br> systems."
            ],
            "translated_annotated_samples": [
                "Además de lidiar con el fracaso, una capacidad importante de un <br>agente inteligente</br> es poder abortar una tarea o plan particular.",
                "Un <br>agente inteligente</br> no solo manejará con gracia tareas y planes fallidos, sino que también reflexionará sobre sus actitudes cognitivas para decidir su próximo curso de acción.",
                "Desarrollo de Sistemas de <br>Agentes Inteligentes</br>: Una Guía Práctica.",
                "Objetivos declarativos y procedimentales en sistemas de agentes inteligentes."
            ],
            "translated_text": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el fracaso, una capacidad importante de un <br>agente inteligente</br> es poder abortar una tarea o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). Abortar una tarea o plan es distinto de su fracaso. El fracaso refleja una incapacidad para desempeñarse y no anula la necesidad de desempeñarse, por ejemplo, una respuesta razonable al fracaso puede ser intentarlo de nuevo. Por el contrario, abortar no dice nada sobre la capacidad de realizar; simplemente elimina la necesidad. El fracaso se propaga de abajo hacia arriba, mientras que la interrupción se propaga de arriba hacia abajo. El potencial de ejecutar subplanes de forma simultánea introduce diferentes complejidades para la interrupción y el fallo. Para abortar, significa que varios subplanes concurrentes pueden necesitar ser abortados a medida que se propaga el aborto hacia abajo. Para el fallo, significa que los planes paralelos hermanos pueden necesitar ser abortados a medida que el fallo se propaga hacia arriba. Ha habido una cantidad considerable de trabajo sobre fallos en los planes (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallos. Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de aborto más allá de la simple eliminación de los planes y tareas actualmente previstos, lo cual no aborda la limpieza requerida. Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de un constructo paralelo. Se puede considerar que ambas tareas se realizan y se tienen objetivos para lograr un cierto estado del mundo. Una tarea puede considerarse un objetivo de lograr el estado de la tarea una vez realizada, y un objetivo puede considerarse una tarea de llevar a cabo ese estado en el mundo. Adoptamos la última perspectiva y usamos la palabra \"tarea\" también para referirnos a los objetivos. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS falla (los enfoques comunes incluyen permitir que la otra rama se ejecute hasta su finalización sin obstáculos o eliminarla por completo). En este documento discutimos en detalle la incorporación de métodos de limpieza de aborto en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto. Una característica clave de nuestro enfoque basado en procedimientos es que permitimos que cada plan ejecute un código particular en caso de fallo y de aborto. Esto permite que un plan intente asegurar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar de otra manera antes de salir. Por consiguiente, un desafío técnico central es gestionar la ejecución ordenada del código de limpieza adecuado. Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una semántica operativa para abortar en el lenguaje de agente abstracto CAN [23, 17]. Esto nos permite especificar un nivel adecuado de detalle para el modelo de ejecución, sin centrarnos en las construcciones específicas de ningún sistema de agentes en particular, como JACK [2], Jadex [14], Jason [6] o SPARK [9]. Nuestro enfoque se centra en un único agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas de un solo agente y multiagentes (por ejemplo, [22, 5, 6]). Este documento está organizado de la siguiente manera. En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deberían ocurrir los abortos, y los procedimientos adecuados de representación e invocación. En la Sección 4 mostramos cómo podemos utilizar CAN para especificar formalmente el comportamiento de un plan abortado. La sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro. EJEMPLO MOTIVADOR Alice es una trabajadora del conocimiento asistida por un agente de asistencia personal y de aprendizaje como CALO [11]. Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente CALO adopta la tarea de Presentación de Reuniones de Apoyo (SMS) para ayudarla. El plan de CALO para una tarea de SMS en el caso de una presentación en una conferencia consiste en las siguientes sub tareas: 1. Asignar un Número de Documento (APN) para ser utilizado con fines administrativos en la empresa. 2. Seguimiento de la Escritura del Resumen (SER): hacer un seguimiento del progreso de Alicia en la preparación de un resumen. 3. Solicitar autorización de publicación (AFC) del gerente de Alice basado en el resumen y los detalles de la conferencia. 4. Papel de seguimiento de escritura (PSE): llevar un registro del progreso de Alicia en la escritura del papel. 5. Manejo de la presentación de documentos (HPS): seguir los procedimientos internos de la empresa para presentar un documento a una conferencia. Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo. De manera similar, CALO puede realizar la tarea de Solicitar Autorización de Despeje (AFC) mediante un plan que consiste en: 1. Enviar la Solicitud de Autorización (SCR) al gerente de Alice. 2. Espera la respuesta (WFR) del gerente. 3. Confirma que la respuesta fue positiva, y falla en caso contrario. Ahora supongamos que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras está escribiendo el documento. Alice ya no podrá asistir a IJCAI. Por lo tanto, ella instruye a su agente CALO para abortar la tarea de SMS. Abortar la tarea implica abortar tanto el plan de SMS como el subplan de AFC. Abortar el primer plan requiere que CALO notifique al registro de números de papel que el número de papel asignado está obsoleto, lo cual puede lograr mediante la tarea Cancelar Número de Papel (CPN). Abortar el segundo plan requiere que CALO notifique al gerente de Alice que Alice ya no necesita autorización para publicar, lo cual CALO puede lograr invocando la tarea Cancelar Solicitud de Autorización (CCR). Observamos una serie de observaciones importantes del ejemplo. Primero, la decisión de abortar un curso de acción particular puede surgir de las deliberaciones internas del agente (como razonar sobre prioridades en un conflicto por recursos), o de fuentes externas (como otro agente cancelando un compromiso), como en este ejemplo. En este documento solo abordamos el problema de determinar si una tarea o plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se haya tomado esta decisión. Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo. Segundo, una vez que se toma la decisión de abortar el intento de enviar un artículo, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización. En otras palabras, abortar una tarea no es simplemente cuestión de abandonar la tarea y los planes activos asociados: puede haber algunas acciones de limpieza que necesiten realizarse. Esto es similar al caso del fracaso, en el sentido de que también puede haber acciones a tomar cuando una tarea o plan falla. En ambos casos, hay que tener en cuenta que no se trata simplemente de que el agente deshaga sus acciones hasta la fecha; de hecho, esto puede no ser ni posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado del mundo) ni deseable (dependiendo de la semántica de la tarea). Más bien, la limpieza implica compensación a través de acciones de recuperación hacia adelante [3]. Tercero, hay una distinción entre abortar una tarea y abortar un plan. En el primer caso, está claro que todos los planes que se estén ejecutando para realizar la tarea deben ser abortados; en el segundo caso, puede ser que existan mejores alternativas al plan actual y se deba intentar una de estas. Por lo tanto, el aborto o fracaso del plan no necesariamente conduce al aborto o fracaso de la tarea. Dado que las tareas pueden contener sub tareas, las cuales pueden contener más sub tareas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto. Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que una tarea o plan principal es abortado. 3. ABORTANDO TAREAS Y PLANES Como hemos insinuado, el fracaso y abortar son conceptos relacionados. Ambos causan que la ejecución de los planes existentes se detenga y, en consecuencia, que el agente reflexione sobre sus tareas e intenciones actuales. El fracaso y la interrupción, sin embargo, difieren en la forma en que surgen. En caso de fallo, el disparador para detener la ejecución de una tarea o plan proviene de abajo, es decir, del fallo de sub tareas o planes de nivel inferior. En caso de abortar, el disparador proviene de arriba, es decir, de las tareas y los planes principales que iniciaron un plan. En sistemas de estilo BDI como JACK y SPARK, el conocimiento del dominio de los agentes incluye una biblioteca de planes predefinidos de cláusulas de planificación. Cada cláusula de plan tiene un cuerpo de plan, que es un programa (es decir, una combinación de acciones primitivas, subtareas, etc.) que puede ejecutarse en respuesta a una tarea u otro evento si se cumple la condición de contexto de las cláusulas del plan. El agente selecciona y ejecuta instancias de cláusulas de plan para realizar sus tareas. Puede haber más de una cláusula de plan aplicable y, en caso de que una falle, se puede intentar otra aplicable. Los planes pueden tener subtareas que deben tener éxito. CALO solo necesita eliminar las tareas TWA y TWP para abortarlas: por simplicidad, suponemos que no es necesario realizar una limpieza explícita de su estado interno. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) para que el plan tenga éxito. En tales sistemas, ocurre un fallo en el plan si una de las acciones o subtareas dentro del plan falla. La acción de los agentes ante el fracaso del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si se ha intentado un plan y ha resultado en fracaso, o puede intentar planes alternativos y declarar (de hecho, debe declarar) el fracaso de la tarea solo si se han intentado todos los planes alternativos posibles para realizar la tarea y han resultado en fracaso. Observa que, si bien el fracaso de una tarea puede derivar del fracaso de un plan o de una secuencia de fracasos de planes, el fracaso de un plan no tiene por qué llevar al fracaso de la tarea siempre y cuando el agente pueda completar con éxito un plan alternativo. Además, el fracaso de la tarea también puede surgir de forma independiente al fracaso del plan, si el agente decide abortar la tarea. Nuestro enfoque asocia un método de aborto con cada plan. Esto permite al programador especificar acciones de compensación dedicadas según cómo el agente esté intentando realizar la tarea. Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que se pueden realizar dinámicamente de la manera habitual en BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones. La pregunta sigue siendo qué método de aborto se debe invocar, y de qué manera. Dada la complejidad de los espacios de acción de los agentes, no es posible ni deseable enumerar un conjunto estático de reglas. Más bien, el agente invocará sus métodos de aborto dinámicamente de acuerdo al estado de ejecución y sus propios eventos internos. Una alternativa a adjuntar un método de aborto a cada plan es adjuntar dichos métodos a cada acción atómica. Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los métodos de limpieza para el fracaso en los sistemas actuales están adjuntos a los planes. Para entender cómo debería funcionar el proceso de aborto de los agentes, consideramos tres situaciones en las que tiene sentido que un agente considere abortar algunas de sus tareas y planes: 1. Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí mismo, el plan actualmente ejecutado para realizar la tarea debe ser abortado. Por ejemplo, supongamos que la política de la empresa cambia para que los empleados con la antigüedad de Alice tengan automáticamente autorización para publicar artículos. Dado que Alice ahora tiene autorización para publicar su artículo, CALO puede abortar el plan de Solicitar Autorización. Al hacerlo, debe invocar el método de aborto, en este caso realizando la solicitud de cancelación de autorización. Cuando dos o más subprogramas se ejecutan en paralelo, si uno falla entonces los demás deben ser abortados, dado que el fallo de una rama conlleva al fallo de la tarea en general. Por ejemplo, supongamos que a mitad de la escritura del artículo, Alice se da cuenta de que hay un error fatal en sus resultados, por lo que notifica a CALO que no podrá completar el artículo para la fecha límite. El fallo de la tarea de Escritura de Pista debería provocar que la tarea de Solicitar Autorización que se está ejecutando en paralelo sea abortada. 3. Cuando un evento de ejecución altera la importancia de una tarea o intención existente, el agente debe deliberar si el/los plan(es) existente(s) deben continuar. Por ejemplo, supongamos que Alice encarga a CALO una nueva tarea de alta prioridad para comprar una computadora portátil de reemplazo, pero que Alice no tiene suficientes fondos para comprar la computadora portátil y asistir a IJCAI. Razonar sobre los requisitos de recursos [20, 10] hará que el agente se dé cuenta de que no puede completar exitosamente ambas tareas. Si hay alguna diferencia entre cómo abortar una tarea que se realiza externamente y cómo abortar una que ahora se sabe que es imposible, el método de aborto puede detectar las circunstancias y manejar la situación de manera apropiada. Dado que la nueva tarea tiene mayor importancia, un agente racional evaluará su mejor curso de acción y puede decidir abortar o al menos suspender la tarea existente de presentar un documento y las intenciones derivadas de ella [12]. La semántica operativa que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones mencionadas anteriormente. La tercera situación implica deliberar sobre la importancia de una tarea, la cual depende de varios factores como la prioridad de la tarea. Aunque esta deliberación está más allá del alcance de este documento, es un tema complementario de nuestro trabajo futuro. Ten en cuenta que las situaciones anteriores se aplican a metas de logro, para las cuales la tarea se completa cuando se logra un estado particular del mundo (por ejemplo, asegurarse de que tengamos autorización). Diferentes formas de razonamiento se aplican a otros tipos de objetivos, como los objetivos de mantenimiento, donde el objetivo se satisface al mantener un estado del mundo durante algún período de tiempo (por ejemplo, mantener $100 en efectivo). La representación del método de aborto tiene la intención de que una tarea o plan se detenga, y que tanto la tarea o plan como todos sus hijos dejen de ejecutarse, y que se realicen los métodos de limpieza apropiados según sea necesario. A diferencia de los sistemas de planificación offline, los agentes BDI están situados: realizan deliberación en línea y sus acciones cambian el estado del mundo. Como resultado, los efectos de muchas acciones no pueden ser simplemente deshechos. Además, el proceso de deshacer puede causar efectos adversos. Por lo tanto, los métodos de limpieza que especificamos son procedimientos de recuperación hacia adelante que intentan garantizar un estado estable y que también pueden, si es posible, recuperar recursos. La representación común de un plan en sistemas de estilo BDI como JACK y SPARK incluye un método de fallo, que es el método de limpieza designado invocado cuando el plan falla. Para esto, agregamos el método de aborto, que se invoca si se va a abortar el plan. En nuestro ejemplo, el método de aborto para el plan de Envío de Reunión de Soporte consiste en invocar la sub-tarea Cancelar Número de Documento. El método de aborto no necesita abortar explícitamente la solicitud de autorización, ya que el agente invocará el método de aborto para la subtarea de manera apropiada, como detallamos a continuación. La suposición aquí es que, al igual que en el método de falla, el programador del sistema del agente tiene la oportunidad de especificar un método de aborto sensato que tenga en cuenta el punto en el plan en el que se va a ejecutar el aborto. Para cualquier plan, el método de aborto es opcional: si no se especifica un método de aborto, el agente no toma ninguna acción específica para este plan. Sin embargo, las reglas de comportamiento predeterminadas de los agentes siguen aplicándose, por ejemplo, si intentar de nuevo un plan alternativo para la tarea principal. Se debe tener en cuenta que no es necesario una representación explícita de los métodos de limpieza para las tareas, ya que las tareas se realizan ejecutando algún plan o planes. Por lo tanto, abortar una tarea significa abortar el plan actual que se está ejecutando para realizar esa tarea, como describiremos a continuación. Invocación del método de aborto. Ahora describimos de manera informal la acción de los agentes al abortar planes y tareas. Cuando un plan P es abortado: 1. Abortar cada sub-tarea que sea un hijo activo de P. Un hijo activo es aquel que fue desencadenado por P y actualmente está en ejecución. 2. Cuando ya no haya más niños activos, invoque el método de aborto del plan P. 3. Indique un fallo en el plan para TP, la tarea principal de P. Se señala aquí que si la tarea principal TP no debe ser abortada, entonces el agente puede elegir otro plan aplicable para satisfacer TP. 10 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Cuando una tarea (o sub-tarea) T es abortada: 1. Abortar el plan activo actual para satisfacer T (si lo hay). 2. Cuando ya no haya más procesos secundarios activos, elimine la tarea. El agente ya no persigue a T. 3. Ten en cuenta que cuando se aborta el plan activo actual para realizar T, no se deben intentar otros planes aplicables para realizar T, ya que es la tarea que se va a abortar. Para evitar esfuerzos de limpieza en cascada infinita, asumimos que los métodos de aborto nunca serán abortados ni fallarán. En realidad, sin embargo, un método de aborto puede fallar. En este caso, al no contar con un mecanismo de manejo más sofisticado, el agente simplemente deja de ejecutar el método de aborto fallido sin más deliberación. La suposición que hacemos no es, por lo tanto, un reflejo de la complejidad total de la realidad, sino una que es pragmática en términos del ciclo de ejecución del agente; el enfoque para el manejo de fallos de [21] hace la misma suposición. En sistemas como SPARK, el programador puede especificar un comportamiento alternativo para un método de fallo o aborto fallido mediante procedimientos a nivel meta. También asumimos que los métodos de falla y aborto terminan en tiempo finito. 4. SEMÁNTICA OPERACIONAL Proporcionamos la semántica para los procesos de falla y aborto de tareas y planes descritos anteriormente. Utilizamos el lenguaje CAN inicialmente definido en [23] y posteriormente extendido como CANPLAN en [17] para incluir un componente de planificación y luego como CANPLAN2 en [18] para mejorar los mecanismos de adopción y eliminación de objetivos. Las extensiones también simplificaron la semántica en el trabajo anterior. Utilizamos algunas de estas simplificaciones para proporcionar un breve resumen del lenguaje CAN en la Sección 4.1. Tras una presentación de la semántica operacional de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos. 4.1 Lenguaje CAN CAN es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentSpeak [15] y Kinnys Ψ [7], ambos de los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados. CAN proporciona un constructo de objetivo explícito que captura tanto los aspectos declarativos como los procedimentales de un objetivo. Los objetivos son persistentes en CAN en el sentido de que, cuando un plan falla, se intenta otro plan aplicable. Esto equivale al mecanismo predeterminado de manejo de fallos que se encuentra típicamente en sistemas BDI implementados como JACK [2]. En sistemas prácticos, las tareas suelen traducirse en eventos que desencadenan la ejecución de algunos planes. Esto también es cierto en el lenguaje CAN, pero, para mantener la persistencia de los objetivos, se introduce un constructo de objetivo. Esto se denota por Objetivo ` φs, P, φf ´, donde φs es la condición de éxito que determina cuándo se considera que el objetivo se ha logrado, φf es una condición de fracaso bajo la cual se considera que el objetivo ya no es alcanzable o relevante, y P es un programa para lograr el objetivo, que se abortará una vez que φs o φf se vuelvan verdaderos. El comportamiento de un agente está especificado por una biblioteca de planes, denotada por Π, que consiste en una colección de cláusulas de planes de la forma e : c ← P, donde e es un evento, c es una condición de contexto (una fórmula lógica sobre las creencias de los agentes que debe ser verdadera para que el plan sea aplicable) y P es el cuerpo del plan. El cuerpo del plan es un programa que se define recursivamente de la siguiente manera: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Objetivo ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 Un c omitido es equivalente a verdadero. Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figura 1: Reglas operativas de CAN. donde P1, . . . , Pn son ellos mismos programas, act es una acción primitiva que no está más especificada, y +b y −b son operaciones para añadir y eliminar creencias. La base de creencias contiene átomos de creencias fundamentales en forma de relaciones de primer orden, pero podría ser extendida ortogonalmente a otras lógicas. Se asume que se proporcionan operaciones bien definidas para verificar si una condición se sigue de un conjunto de creencias (B |= c), para agregar una creencia a un conjunto de creencias (B ∪ {b}), y para eliminar una creencia de un conjunto de creencias (B \\ {b}). ?φ es una prueba para la condición φ, y !e5 es un evento6 que se publica desde dentro del programa. Los constructos compuestos son secuenciación (P1; P2), ejecución paralela (P1 P2) y metas (Meta ` φs, P, φf ´ ). Lo anterior define el idioma del usuario. Además, se utilizan un conjunto de formas compuestas auxiliares internamente al asignar semántica a los constructos. nil es el programa básico (terminante). Cuando un evento coincide con un conjunto de cláusulas de plan, estas se recopilan en un conjunto de alternativas protegidas (c1: P1, ..., cn: Pn). La otra forma compuesta auxiliar, , es un operador de elección dual a la secuenciación: P1 P2 ejecuta P1 y luego ejecuta P2 solo si P1 falló. Un resumen de la semántica operacional para CAN de acuerdo con [23] y siguiendo algunas de las simplificaciones de [17] es el siguiente. Una configuración básica S = B, G, Γ consiste en la base de creencias actual B del agente, el conjunto actual de metas G que se persiguen (es decir, un conjunto de fórmulas) y el programa actual P que se está ejecutando (es decir, la intención actual). Una transición S0 −→ S1 especifica que ejecutar S0 durante un paso único produce la configuración S1. S0 −→∗ Sn es el cierre reflexivo transitivo usual de −→: Sn es el resultado de una o más transiciones de un solo paso. Una regla de derivación S −→ Sr S −→ Sr consiste en un conjunto (posiblemente vacío) de premisas, que son transiciones junto con algunas condiciones auxiliares (numerador), y una única transición conclusión derivable de estas premisas (denominador). La Figura 1 muestra algunas de las reglas operativas. La regla de Evento maneja eventos de tarea recopilando todas las cláusulas de plan relevantes para el evento en cuestión: para cada cláusula de plan e : ψi ← Pi, si hay un unificador más general, θ = mgu(e, e) de e y el evento en 5 Donde es obvio que e es un evento, a veces excluiremos el signo de exclamación para mayor legibilidad. 6 Típicamente un objetivo de logro. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 11 B |= φs B, Objetivo ` φs, P, φf ´ −→ B, verdadero Gs B |= φf B, Objetivo ` φs, P, φf ´ −→ B, falla Gf P = Objetivo ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Objetivo ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Objetivo ` φs, P, φf ´ −→ B , Objetivo ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {verdadero, falla} B, Objetivo ` φs, P, φf ´ −→ B, Objetivo ` φs, P2 £ P2, φf ´ GR Figura 2: Reglas para objetivos en CAN. pregunta, entonces la regla construye una alternativa guardada ψiθ: Piθ. La regla Select selecciona un cuerpo de plan aplicable de un conjunto de alternativas relevantes (restantes): el programa P Δ establece que el programa P debe intentarse primero, recurriendo a las alternativas restantes, Δ \\ P, si es necesario. Esta regla y la regla de fallo se utilizan juntas para el manejo de fallos: si el programa actual Pi de una cláusula de plan para una tarea falla, primero se aplica la regla de fallo, y luego, si es posible, la regla Select elegirá otra alternativa aplicable para la tarea si existe alguna. Rule Sequence maneja la secuenciación de programas de la manera habitual. Las reglas Parallel1 y Parallel2 definen la posible intercalación al ejecutar dos programas en paralelo. La Figura 2 presenta reglas simplificadas para tratar con objetivos, en línea con las presentadas en [17]. La primera regla establece que un objetivo tiene éxito cuando φs se vuelve verdadero; la segunda regla establece que un objetivo falla cuando φf se vuelve verdadero. La tercera regla GI inicializa la ejecución de un programa de metas actualizando la base de metas y estableciendo el programa en la meta como P £ P; el primer P se ejecutará y el segundo P se utiliza para hacer un seguimiento del programa original para la meta. La cuarta regla GS ejecuta un solo paso del programa de objetivos. La regla final GR reinicia el programa original (codificado como P2 del par P1 £ P2) cada vez que el programa actual ha terminado pero el objetivo deseado y aún posible no se ha logrado. 4.2 Abortando Intenciones y Manejando Fallas A continuación, introducimos la capacidad de especificar programas manejadores, en forma de métodos de falla y aborto, que se ocupan de la limpieza requerida cuando un programa dado falla o es abortado. No asociamos los métodos de falla y aborto con cláusulas de plan o con tareas (eventos), sino que introducimos una nueva construcción de programa que especifica los métodos de falla y aborto para un programa arbitrario. El constructo FAb(P, PF, PA) ejecuta el programa P. En caso de que P falle, ejecuta el programa de manejo de fallos PF; si P necesita ser abortado, ejecuta el programa de manejo de aborto PA. Por lo tanto, para agregar los métodos de falla y aborto PF y PA a una cláusula de plan e : c ← P, escribimos e : c ← FAb(P, PF, PA). Con la introducción de la capacidad de abortar programas, modificamos la construcción paralela para permitir que el fallo de una rama aborte la otra. Debemos tener en cuenta la posible existencia de métodos de aborto en la rama abortada. De manera similar, con el constructo de Objetivo ya no podemos abandonar por completo el programa que contiene tan pronto como se cumpla la condición de éxito o fracaso; ahora debemos tener en cuenta la existencia de cualquier método de aborto aplicable al programa. Proporcionamos la semántica de un lenguaje de agente aumentado que contiene el constructo FAb al definir una transformación de origen, similar a la expansión de macros, que mapea una biblioteca de planes que contiene el constructo FAb(P, PF, PA) en CAN estándar (casi). La única extensión no estándar a CAN es un constructo de espera hasta que se cumpla una condición. Explicamos esta simple modificación del constructo paralelo a continuación cuando llegamos a la traducción del constructo de la Meta. Primero describimos la naturaleza general de la transformación de la fuente, que resulta ser bastante simple para la mayoría de las construcciones del lenguaje, y luego nos concentramos en los tres casos más complejos: las construcciones FAb, paralela y Goal. Un problema clave es que los constructos FAb pueden estar anidados, ya sea directa o indirectamente. Llamemos a cada instancia del constructo en tiempo de ejecución un posible punto de aborto (pap). Donde estos constructos están anidados, es importante que antes de que se ejecute el método de falla o aborto de un pap padre, se ejecuten primero los programas de métodos de falla o aborto de los paps hijos, como se describe anteriormente en la Sección 3. La necesidad de coordinar la ejecución de los métodos de aborto de paps anidados requiere que haya alguna forma de identificar los padres e hijos de un pap en particular. Logramos esto como parte de la transformación de origen al llevar un registro explícito del contexto de ejecución como un parámetro adicional en los eventos y una variable adicional dentro de cada cuerpo del plan. La transformación de origen reemplaza cada cláusula del plan de la forma e : c ← P con una cláusula del plan e(v) : c ← μv(P) donde v es una variable libre, no presente previamente en la cláusula del plan. Esta variable se utiliza para llevar un registro del contexto de ejecución. El valor de la variable de contexto es una lista de identificadores, donde cada nuevo párrafo está representado al anteponer un nuevo identificador al contexto. Por ejemplo, si los identificadores son enteros, el contexto de un documento puede ser representado por una lista [42, 1] y el contexto introducido por un nuevo documento puede ser representado por [52, 42, 1]. Nos referiremos a los paps por el contexto en lugar del nuevo identificador agregado, por ejemplo, por [51, 42, 1] y no solo por 51. Esto nos permite equiparar la relación de ancestro entre paps con la relación de sufijo de lista en los contextos relevantes, es decir, v es un ancestro de v si y solo si v es un sufijo de v. Para la mayoría de los constructos CAN, la variable de contexto no se utiliza o se pasa sin cambios: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) Queda por especificar la transformación μv(·) en tres casos: los constructos FAb, paralelo y Goal. Estos son más complejos en el sentido de que la fuente transformada necesita crear dinámicamente un nuevo identificador de pap, para usarlo como un nuevo contexto dentro de la construcción, y para llevar un registro de cuándo el pap está activo (es decir, actualmente en ejecución) añadiendo y eliminando creencias sobre el contexto. Introduzcamos la acción primitiva prependID(v, v) que crea un nuevo identificador pap y lo antepone a la lista v, dando como resultado la lista v. También introducimos los siguientes predicados: • a(v) - el pap v está actualmente activo. • abort(v) - el pap v debe ser abortado (después de abortar a todos sus descendientes). Una alternativa sería utilizar predicados a nivel meta que reflejen el estado actual de la estructura de intenciones. La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) • f(v) - el programa del pap v ha fallado. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))el pap v es un ancestro del pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v no tiene hijos activos. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - debemos abortar v, es decir, abort es verdadero para v o algún ancestro; sin embargo, debemos esperar hasta que no haya hijos activos de v. • san(v) ≡ sa(v) ∧ nac(v) - debemos abortar v ahora si debemos abortar v y v no tiene hijos activos. Primero consideremos el caso del constructo FAb. La idea es que, cada vez que ocurra un nuevo pap, se utiliza la acción prependID(v, v) para crear una nueva lista de identificadores de pap v a partir de la lista existente v. Luego agregamos la creencia de que v es el contexto activo, es decir, +a(v), y comenzamos a procesar el programa dentro del pap utilizando v en lugar de v como contexto. Necesitamos asegurarnos de retractar la creencia de que v está activo al final, es decir, −a(v). Utilizamos la construcción de Objetivo para permitirnos detener la ejecución de un programa dentro de un pap v cuando sea necesario abortar. Mientras se ejecuta el programa P, sabemos que debemos descartar P e invocar su método de aborto si se le ha indicado a algún ancestro de P que aborte. Esto se representa por el predicado sa(v) siendo verdadero. Sin embargo, debemos asegurarnos de hacer esto solo después de que cada pap de niño haya tenido la oportunidad de invocar su método de aborto y todos estos métodos de aborto hayan sido completados: si abandonamos el programa demasiado pronto, entonces la ejecución de los métodos de aborto de los niños también será abandonada. Por lo tanto, la condición que realmente usamos en la construcción del Objetivo para probar cuándo detener el programa es san(v). Esta condición se basa en el hecho de que a medida que los niños completan sus papilas, eliminan los hechos relevantes. Nuestro uso del constructo Goal es por su capacidad de detener la ejecución de un programa cuando se cumplen ciertas condiciones. Para dejar de lado el aspecto de la repetición de la ejecución hasta que se cumpla una condición, debemos asegurarnos de que la condición de éxito o fracaso del constructo se cumpla una vez que la ejecución del programa tenga éxito o falle. Nos aseguramos de esto al retractar el hecho a(v) en caso de éxito y afirmar el hecho f(v) en caso de fracaso, y al tener las condiciones apropiadas de éxito y fracaso en el Objetivo. Por lo tanto, si falla la construcción del Objetivo, entonces el programa fue abortado o falló. Invocamos el método de fallo o aborto relevante, retiramos el hecho a(v) y luego fallamos. Al juntar todo esto, definimos formalmente μv(FAb(P, PA, PF )) de la siguiente manera, donde v es una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) En segundo lugar, debemos transformar el operador paralelo para asegurar que el fallo de una rama aborte de forma segura la otra. Aquí construimos dos nuevos contextos, v y v, a partir del contexto existente v. Si una rama falla, debe abortar la otra rama. Al final, si se abortó cualquiera de las ramas, entonces debemos fallar. Que v y v sean variables nuevas distintas de cualquier otra en la biblioteca de planes de los agentes. Definimos μv(P1 P2) como: prependID(v, v); prependID(v, v); +a(v); +a(v); (Goal (¬a(v), (μv(P1); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v)) Goal (¬a(v), (μv(P2); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v))); ?¬abort(v) ∧ ¬abort(v) Finalmente, necesitamos modificar las ocurrencias del constructo Goal de dos maneras: primero, asegurarnos de que los métodos de manejo de aborto no se pasen por alto cuando se satisfacen las condiciones de éxito o fracaso, y segundo, activar la interrupción del programa contenido cuando se satisfacen las condiciones de éxito o fracaso. Para transformar el constructo Goal necesitamos extender el estándar CAN con un constructo de espera-hasta-condición. El constructo φ : P no ejecuta P hasta que φ se convierte en verdadero. Aumentamos el lenguaje CAN con las siguientes reglas para el operador de guardia :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false Para especificar μv(Goal ` φs, P, φf ´ ), generamos un nuevo pap y ejecutamos el programa dentro del constructo Goal en este nuevo contexto. Debemos asegurarnos de que la creencia a(v) sea eliminada, ya sea que el objetivo tenga éxito o fracase. Cambiamos la condición de éxito y fracaso del constructo Objetivo a una rama paralela utilizando el constructo de espera-hasta-condición, y modificamos el Objetivo para usar la condición de éxito debería abortar ahora san(v) como condición de éxito. La rama de espera desencadenará la interrupción del programa si se cumple tanto la condición de éxito como la de fracaso. Para evitar cualquier problema al terminar la condición de espera, también finalizamos la espera si el pap ya no está activo. Que v sea una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes. Definimos μv(Goal ` φs, P, φf ´ ) como: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) El programa P se ejecutará repetidamente hasta que san(v ) se convierta en verdadero. Hay dos formas en que esto puede ocurrir. Primero, si se cumple la condición de éxito φs o la condición de fracaso φf, entonces se ejecuta la segunda rama de la construcción en paralelo. Esto hace que abort(v) se convierta en verdadero, y, después de que se ejecuten los métodos de abortmethods descendientes, san(v) se convierte en verdadero. En este caso, P se elimina, se elimina el a(v), y todo el constructo tiene éxito o fracasa en función de φs. La segunda forma en que san(v) puede volverse verdadero es si v o uno de sus ancestros es abortado. En este caso, una vez que se ejecutan los métodos de aborto de los paps descendientes, san(v) se vuelve verdadero, P se elimina, se elimina la creencia a(v) (permitiendo que la segunda rama paralela se ejecute, instruyendo vacuamente a v a abortar), y la primera rama paralela falla (asumiendo que φs es falso). Ejemplo trabajado 4.3 Echemos un vistazo a la traducción del ejemplo de envío a IJCAI de la Sección 2. Expresaremos las tareas mediante eventos, por ejemplo, la tarea Asignar un Número de Papel la expresamos como el evento APN. Que la salida de la tarea Solicitar autorización sea Y o N, indicando la aprobación o no del gerente de Alicia, respectivamente. Entonces tenemos (al menos) las siguientes dos cláusulas de plan en CAN, para las tareas de Envío de Reunión de Apoyo y Solicitar Autorización de Despeje, respectivamente: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Tenga en cuenta que Envío de Reunión de Apoyo tiene un parámetro m, la reunión de interés (IJCAI, en nuestro ejemplo), mientras que Solicitar Autorización de Despeje no tiene parámetros. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 13. Veamos primero la traducción de la segunda cláusula del plan, para AFC, ya que es la más simple de las dos. Que v y v denoten nuevas variables. Entonces tenemos como cláusula del plan traducido: AFC(v): verdadero ← prependID(v, v); +a(v); Meta(¬a(v), (!SCR(v); !WFR(r, v); ?r = Y; −a(v) +f(v)), san(v) ∨ f(v)) (((?sa(v); !CCR(v)) nil); −a(v); ?falso) Podemos ver que se ha añadido un parámetro de contexto adicional a cada tarea y que el antiguo cuerpo del plan ahora aparece dentro de un constructo de Meta. Si el antiguo cuerpo del plan tiene éxito, la creencia a(v) se retira, lo que hace que el Objetivo tenga éxito. Si el cuerpo del plan antiguo falla, o si la tarea debe ser abortada, el constructo de Objetivo falla. Esto es seguido por la ejecución de CCR (en caso de un aborto), la retracción de a(v), y el fallo. La traducción de la primera cláusula del plan, para SMS, es más compleja, debido a la estructura paralela que introduce paps anidados: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Meta ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Meta ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Meta ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Aquí podemos ver que si la tarea !TWP(v ) falla, entonces se afirmará f(v ), lo que hará que falle la construcción de Meta que lo contiene, y llevará a que se afirme abort(v ). Si la tarea !WFR(r, v ) en la expansión de !AFC(v ) todavía se está ejecutando y no tiene paps hijos activos, entonces sa(v ) y sa(v ) serán verdaderos; sin embargo, solo san(v ) y no san(v ) serán verdaderos. Este conjunto de condiciones hará que el constructo Goal en la primera cláusula del plan falle, deteniendo la ejecución de !WFR(r, v). La tarea !CCR(v) será ejecutada. Una vez que esta tarea se complete, la creencia a(v) se retira, lo que hace que san(v) se convierta en verdadero, lo que lleva a que la primera construcción de objetivo de la segunda cláusula del plan falle. Si bien las cláusulas del plan traducido parecen complicadas, observe que la traducción de las cláusulas del plan inicial es completamente automatizada, de acuerdo con las reglas establecidas en la Sección 4.2. Las cláusulas del plan traducido, con la semántica de PUEDE aumentada por nuestra construcción de condición de esperar-hasta, especifican así la operación del agente para manejar tanto el fallo como la interrupción del ejemplo. 5. El fallo del plan se maneja en la versión extendida de AgentSpeak encontrada en el sistema Jason [6]. Los planes de limpieza de fallas se activan a partir de eventos de eliminación de objetivos −!g. Tales planes, similares a nuestros métodos de fracaso, están diseñados para que el agente efectúe cambios de estado (actúe para deshacer sus acciones anteriores) antes de posiblemente intentar otro plan para lograr el objetivo fallido g. Dados los constructos de Jason para abandonar un objetivo con una indicación de si intentar o no un plan alternativo para él, H¨ubner et al. [6] proporcionan una descripción informal de cómo un agente de Jason modifica su estructura de intenciones cuando ocurre un evento de fracaso del objetivo. En un plan de eliminación de objetivos, el programador puede especificar cualquier acción de deshacer y si intentar de nuevo el objetivo. Si no se proporciona un plan de eliminación de objetivos, el comportamiento predeterminado de Jason es no volver a intentar el objetivo. El manejo de fallos se aplica solo a los planes desencadenados por la adición de un logro o meta de prueba; en particular, los eventos de eliminación de metas no se publican por el fallo de un plan de eliminación de metas. Además, la semántica informal de [6] no considera submetas paralelas (es decir, el constructo CAN), ya que dicha ejecución no forma parte del lenguaje de Jason. La implementación de H¨ubner et al. [6] requiere acciones internas de Jason. Un requisito para implementar nuestro enfoque es una capacidad reflexiva en la implementación del agente BDI. Las implementaciones adecuadas del formalismo BDI son JACK [2], Jadex [14] y SPARK [9]. Los tres permiten métodos a nivel meta que son activados por eventos meta como la adopción de objetivos o el fracaso de un plan, y ofrecen capacidades introspectivas sobre los estados de objetivo e intención. Tales instalaciones de nivel meta también son requeridas por el enfoque de Unruh et al. [21], quienes definen la compensación semántica basada en objetivos para un agente. Los objetivos de manejo de fallos son invocados de acuerdo con las reglas de estrategia de manejo de fallos, por un agente dedicado Componente de Manejo de Fallos (FHC) que sigue la ejecución de la tarea. Estos objetivos son especificados por el programador del agente y se adjuntan a las tareas, de manera similar a cómo nuestro constructo FAb(P, PF, PA) asocia métodos de falla y aborto con un plan P. Sin embargo, cabe destacar que, a diferencia tanto de [6] como de nuestra semántica, [21] adjuntan el conocimiento de manejo de fallas a nivel de objetivo, no de plan. Sus objetivos de manejo de fallos pueden consistir en objetivos de estabilización que realicen una limpieza localizada e inmediata para restaurar el estado de los agentes a un estado conocido y estable, y objetivos de compensación que realicen acciones de deshacer. Los objetivos de compensación se activan al abortar un objetivo, y no necesariamente al fallar en el objetivo (es decir, si el FHC indica al agente que vuelva a intentar el objetivo fallido y el nuevo intento tiene éxito). El enfoque FHC se define a nivel de objetivo para facilitar la especificación abstracta del conocimiento de manejo de fallos; el FHC decide cuándo abordar un fallo y qué hacer (es decir, qué objetivos de manejo de fallos invocar), separando este conocimiento del cómo implementar acciones correctivas (es decir, qué plan ejecutar para cumplir con el objetivo de manejo de fallos adoptado). Esto contrasta con el manejo simplista de fallas a nivel de plan en el que el qué y el cómo se entrelazan en el conocimiento de la tarea del dominio. Si bien nuestro enfoque está definido a nivel de plan, nuestra semántica BDI extendida permite la separación de la ejecución y el manejo de fallos. Además, el FHC mantiene explícitamente estructuras de datos para rastrear la ejecución de agentes. Aprovechamos las estructuras de ejecución existentes y la capacidad autorreflexiva de un agente BDI para lograr tanto la interrupción como el manejo de fallos sin costos adicionales. Las reglas de estrategia de manejo de fallos de FHC (por ejemplo, si volver a intentar un objetivo fallido) son reemplazadas por instrucciones en nuestros planes de PF y PA, junto con manejadores de fallos predeterminados a nivel meta de acuerdo con la naturaleza de los agentes (por ejemplo, comprometidos ciegamente). El enfoque FHC es independiente de la arquitectura del agente en sí, a diferencia de nuestro trabajo que está dedicado al formalismo BDI (aunque no está ligado a ningún sistema de agente en particular). Por lo tanto, no se desarrollan semánticas formales en [21]; la operación de los FHCs se presenta como 14 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) un protocolo basado en estados. Este enfoque, junto con el punto de control estatal, se utiliza para sistemas multiagente en [22]. La arquitectura resultante incorpora su enfoque de manejo de fallos dentro de una arquitectura de procesamiento en pares para la recuperación de fallos de agentes. Otro trabajo sobre el manejo de excepciones multiagente incluye los agentes de manejo de excepciones distribuidos AOEXs [5], y los centinelas similares de [8]. En ambos casos, la lógica de manejo de fallos y el conocimiento están desacoplados de los agentes; en contraste, mientras se separa el manejo de excepciones del conocimiento específico del dominio, tanto el enfoque de Unruh et al. como nuestro enfoque retienen la lógica de manejo de fallos dentro de un agente. 6. CONCLUSIÓN Y TRABAJO FUTURO Las tareas y planes de un agente pueden no llegar a completarse con éxito, ya sea por la decisión del agente de abortarlos (quizás a petición de otro agente), o por factores imprevistos que llevan al fracaso. En este artículo hemos presentado un enfoque basado en procedimientos que incorpora la interrupción de tareas y planes en el ciclo de deliberación de un agente de estilo BDI, proporcionando así un enfoque unificado para el fracaso y la interrupción. Nuestra contribución principal es un análisis de los requisitos sobre la operación del agente para abortar tareas y planes, y una semántica operativa correspondiente para abortar en el lenguaje abstracto del agente CAN. Estamos planeando implementar una instancia de nuestro enfoque en el sistema de agentes SPARK [9]; en particular, el trabajo de este artículo será la base para el mecanismo de manejo de abortos de SPARK. También estamos desarrollando una herramienta de análisis para nuestra versión extendida de CAN como base para experimentación. Un <br>agente inteligente</br> no solo manejará con gracia tareas y planes fallidos, sino que también reflexionará sobre sus actitudes cognitivas para decidir su próximo curso de acción. Hemos asumido el comportamiento predeterminado de un agente de estilo BDI, de acuerdo con su naturaleza: por ejemplo, volver a intentar alternativas de un plan fallido hasta que uno tenga éxito o hasta que no queden planes alternativos (en cuyo caso fallar la tarea). El trabajo futuro consiste en poner nuestro enfoque al servicio de un razonamiento de agente más dinámico, como la introspección que un agente capaz de razonar sobre los efectos de la interacción de tareas y los requisitos de recursos puede lograr [19, 12]. Relacionado con esto está determinar el costo de abortar una tarea o un plan, y utilizarlo como un insumo en el proceso de deliberación. Esto influiría en particular en el compromiso que el agente tiene hacia una tarea específica: a mayor costo, mayor compromiso. Nuestra suposición de que los métodos de aborto no fallan, como se discutió anteriormente, es una suposición pragmática. Sin embargo, este es un tema que merece una mayor exploración, ya sea para desarrollar supuestos más débiles que también sean prácticos, o para analizar las condiciones bajo las cuales nuestra suposición es realista. Un elemento adicional de interés es extender nuestro enfoque al fracaso y la interrupción a los objetivos de mantenimiento [1]. Para tales objetivos, se necesita una semántica operativa diferente para la interrupción que para los objetivos de logro, para que coincida con la diferencia en la semántica de los propios objetivos. Agradecimientos Agradecemos a Lin Padgham y a los revisores anónimos por sus comentarios. El primer autor agradece el apoyo del Consejo de Investigación Australiano y del Software Orientado a Agentes bajo la subvención LP0453486. El trabajo de los dos autores en SRI International fue apoyado por la Agencia de Proyectos de Investigación Avanzada de Defensa (DARPA) bajo el Contrato No. NBCHD030010. Cualquier opinión, hallazgo, conclusión o recomendación expresada en este material son responsabilidad de los autores y no reflejan necesariamente la visión de DARPA o el Departamento del Interior-Centro Nacional de Negocios. 7. REFERENCIAS [1] L. Braubach, A. Pokahr, D. Moldt y W. Lamersdorf. Representación de objetivos para sistemas de agentes BDI. En Actas del Segundo Congreso Internacional. Taller sobre Programación de Sistemas Multiagente (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson y A. Lucas. Agentes inteligentes JACK: componentes para agentes inteligentes en Java. AgentLink News, Edición 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira y P. Henderson. Ampliando el concepto de compensación de transacciones. Revista de Sistemas de IBM, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk y J.-J. C. Meyer. Tipos de objetivos en la programación de agentes. En Proc. de AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy y E. Kendall. Aoex: Un marco de manejo de excepciones basado en agentes para construir sistemas de software confiables, distribuidos y abiertos. En Actas de la Séptima Conferencia Conjunta sobre Ingeniería de Software Basada en el Conocimiento, 2006. [6] J. F. H¨ubner, R. H. Bordini y M. Wooldridge. Programación de metas declarativas utilizando patrones de planificación. En Actas de la 4ta Conferencia Internacional. Taller sobre Lenguajes y Tecnologías Declarativos de Agentes, 2006. [7] D. Kinny. El cálculo Psi: un lenguaje algebraico de agentes. En Proc. de ATAL01, 2001. [8] M. Klein, J. A. Rodríguez-Aguilar y C. Dellarocas. Utilizando servicios de manejo de excepciones independientes del dominio para habilitar sistemas multiagente abiertos robustos: El caso de la muerte del agente. Agentes Autónomos y Sistemas Multiagente, 7(1-2):179-189, 2003. [9] D. Morley y K. Myers. El marco de agentes SPARK. En Proc. de AAMAS04, 2004. [10] D. Morley, K. L. Myers y N. Yorke-Smith. Refinamiento continuo de estimaciones de recursos del agente. En Proc. de AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack y M. Tambe. Un asistente personal inteligente para la gestión de tareas y tiempo. Revista de Inteligencia Artificial, 28, 2007. Aparecer. [12] K. L. Myers y N. Yorke-Smith. Un marco cognitivo para la delegación a un agente de usuario asistente. En Actas del Simposio de Otoño de AAAI 2005 sobre Asistentes de Resolución de Problemas de Iniciativa Mixta, 2005. [13] L. Padgham y M. Winikoff. Desarrollo de Sistemas de <br>Agentes Inteligentes</br>: Una Guía Práctica. John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, y W. Lamersdorf. Jadex: Un motor de razonamiento BDI. En R. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores, Programación Multiagente. Springer, 2005. [15] A. S. Rao. \n\nSpringer, 2005. [15] A. S. Rao. AgentSpeak(L): Los agentes BDI se expresan en un lenguaje lógico computable. En Actas del Séptimo Taller Europeo sobre Modelado de Agentes Autónomos en un Mundo Multiagente, 1996. [16] A. S. Rao y M. P. Georgeff. Una arquitectura abstracta para agentes racionales. En Proc. de KR92, 1992. [17] S. Sardiña, L. de Silva y L. Padgham. Planificación jerárquica en lenguajes de programación de agentes BDI: un enfoque formal. En Proc. de AAMAS06, 2006. [18] S. Sardina y L. Padgham. Objetivos en el contexto del fracaso del plan BDI y la planificación. En Proc. de AAMAS07, 2007. [19] J. Thangarajah, L. Padgham y M. Winikoff. Detectar y aprovechar la interacción positiva de objetivos en agentes inteligentes. En Proc. de AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham y K. Fischer. Evitando conflictos de recursos en agentes inteligentes. En Proc. de ECAI-02, 2002. [21] A. Unruh, J. Bailey y K. Ramamohanarao. Un marco para la compensación semántica basada en objetivos en sistemas de agentes. En Actas de la Primera Conferencia Internacional. Taller sobre Seguridad en Sistemas Multiagente, 2004. [22] A. Unruh, H. Harjadi, J. Bailey y K. Ramamohanarao. Gestión de recuperación basada en compensación semántica en sistemas multiagente. En Proc. del Segundo Simposio IEEE sobre Seguridad y Supervivencia Multiagente (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Proc. de KR02, 2002. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 15 ",
            "candidates": [],
            "error": [
                [
                    "agente inteligente",
                    "agente inteligente",
                    "Agentes Inteligentes"
                ]
            ]
        },
        "failure": {
            "translated_key": "fracaso",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the <br>failure</br> method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with <br>failure</br> is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, <br>failure</br> deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with <br>failure</br>, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its <br>failure</br>.",
                "<br>failure</br> reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to <br>failure</br> may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "<br>failure</br> propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and <br>failure</br>.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For <br>failure</br>, it means that parallel-sibling plans may need to be aborted as the <br>failure</br> is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of <br>failure</br> handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to <br>failure</br> and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a <br>failure</br> and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for <br>failure</br>, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or <br>failure</br> does not necessarily lead to task aborting or <br>failure</br>.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, <br>failure</br> and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "<br>failure</br> and aborting, however, differ in the way they arise.",
                "In the case of <br>failure</br>, the trigger to cease execution of a task or plan comes from below, that is, the <br>failure</br> of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan <br>failure</br> occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan <br>failure</br> depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in <br>failure</br>, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task <br>failure</br> can follow from plan <br>failure</br> or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task <br>failure</br> can also arise separately from plan <br>failure</br>, if the agent decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for <br>failure</br> in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the <br>failure</br> of one branch leads to the <br>failure</br> of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The <br>failure</br> of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a <br>failure</br>-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the <br>failure</br>-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan <br>failure</br> to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to <br>failure</br>-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed <br>failure</br>- or abort-method by means of meta-level procedures.",
                "We also assume that <br>failure</br>- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan <br>failure</br> and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default <br>failure</br> handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for <br>failure</br> handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling <br>failure</br> We next introduce the ability to specify handler programs, in the form of <br>failure</br>- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate <br>failure</br>- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies <br>failure</br>- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the <br>failure</br> handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add <br>failure</br>- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the <br>failure</br> of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or <br>failure</br> condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the <br>failure</br>- or abort-method of a parent pap is executed, the <br>failure</br>- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or <br>failure</br> condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on <br>failure</br>, and by having the appropriate success and <br>failure</br> conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant <br>failure</br>- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the <br>failure</br> of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or <br>failure</br> conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or <br>failure</br> conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and <br>failure</br> condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or <br>failure</br> condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the <br>failure</br> condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and <br>failure</br>.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both <br>failure</br> and aborting for the example. 5.",
                "RELATED WORK Plan <br>failure</br> is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "<br>failure</br> clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our <br>failure</br> methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal <br>failure</br> event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "<br>failure</br> handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for <br>failure</br> of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan <br>failure</br>, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "<br>failure</br>-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent <br>failure</br> Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates <br>failure</br> and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the <br>failure</br>-handling knowledge at the goal, not plan, level.",
                "Their <br>failure</br>-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal <br>failure</br> (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of <br>failure</br>-handling knowledge; the FHC decides when to address a <br>failure</br> and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level <br>failure</br> handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and <br>failure</br> handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and <br>failure</br> handling without additional overhead.",
                "FHCs <br>failure</br>-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default <br>failure</br> handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their <br>failure</br> handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, <br>failure</br>-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain <br>failure</br>-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to <br>failure</br>.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to <br>failure</br> and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to <br>failure</br> and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan <br>failure</br> and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [
                "We augment each plan with an optional abort-method, analogous to the <br>failure</br> method found in some agent programming languages.",
                "Accordingly, dealing with <br>failure</br> is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "Given this need for deliberation about failed tasks or plans, <br>failure</br> deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with <br>failure</br>, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "Aborting a task or plan is distinct from its <br>failure</br>."
            ],
            "translated_annotated_samples": [
                "Añadimos a cada plan un método de aborto opcional, análogo al <br>método de falla</br> encontrado en algunos lenguajes de programación de agentes.",
                "Por lo tanto, enfrentarse al <br>fracaso</br> es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21].",
                "Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el <br>fracaso</br> se incorpora comúnmente en el ciclo de ejecución de los agentes.",
                "Además de lidiar con el <br>fracaso</br>, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular.",
                "Abortar una tarea o plan es distinto de su <br>fracaso</br>."
            ],
            "translated_text": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al <br>método de falla</br> encontrado en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al <br>fracaso</br> es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el <br>fracaso</br> se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el <br>fracaso</br>, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). Abortar una tarea o plan es distinto de su <br>fracaso</br>. ",
            "candidates": [],
            "error": [
                [
                    "método de falla",
                    "fracaso",
                    "fracaso",
                    "fracaso",
                    "fracaso"
                ]
            ]
        },
        "dealing": {
            "translated_key": "enfrentarse",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, <br>dealing</br> with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides <br>dealing</br> with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for <br>dealing</br> with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [
                "Accordingly, <br>dealing</br> with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "Besides <br>dealing</br> with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "Figure 2 gives simplified rules for <br>dealing</br> with goals, in line with those presented in [17]."
            ],
            "translated_annotated_samples": [
                "Por lo tanto, <br>enfrentarse</br> al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21].",
                "Además de <br>lidiar</br> con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular.",
                "La Figura 2 presenta reglas simplificadas para <br>tratar con</br> objetivos, en línea con las presentadas en [17]."
            ],
            "translated_text": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, <br>enfrentarse</br> al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de <br>lidiar</br> con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). Abortar una tarea o plan es distinto de su fracaso. El fracaso refleja una incapacidad para desempeñarse y no anula la necesidad de desempeñarse, por ejemplo, una respuesta razonable al fracaso puede ser intentarlo de nuevo. Por el contrario, abortar no dice nada sobre la capacidad de realizar; simplemente elimina la necesidad. El fracaso se propaga de abajo hacia arriba, mientras que la interrupción se propaga de arriba hacia abajo. El potencial de ejecutar subplanes de forma simultánea introduce diferentes complejidades para la interrupción y el fallo. Para abortar, significa que varios subplanes concurrentes pueden necesitar ser abortados a medida que se propaga el aborto hacia abajo. Para el fallo, significa que los planes paralelos hermanos pueden necesitar ser abortados a medida que el fallo se propaga hacia arriba. Ha habido una cantidad considerable de trabajo sobre fallos en los planes (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallos. Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de aborto más allá de la simple eliminación de los planes y tareas actualmente previstos, lo cual no aborda la limpieza requerida. Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de un constructo paralelo. Se puede considerar que ambas tareas se realizan y se tienen objetivos para lograr un cierto estado del mundo. Una tarea puede considerarse un objetivo de lograr el estado de la tarea una vez realizada, y un objetivo puede considerarse una tarea de llevar a cabo ese estado en el mundo. Adoptamos la última perspectiva y usamos la palabra \"tarea\" también para referirnos a los objetivos. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS falla (los enfoques comunes incluyen permitir que la otra rama se ejecute hasta su finalización sin obstáculos o eliminarla por completo). En este documento discutimos en detalle la incorporación de métodos de limpieza de aborto en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto. Una característica clave de nuestro enfoque basado en procedimientos es que permitimos que cada plan ejecute un código particular en caso de fallo y de aborto. Esto permite que un plan intente asegurar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar de otra manera antes de salir. Por consiguiente, un desafío técnico central es gestionar la ejecución ordenada del código de limpieza adecuado. Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una semántica operativa para abortar en el lenguaje de agente abstracto CAN [23, 17]. Esto nos permite especificar un nivel adecuado de detalle para el modelo de ejecución, sin centrarnos en las construcciones específicas de ningún sistema de agentes en particular, como JACK [2], Jadex [14], Jason [6] o SPARK [9]. Nuestro enfoque se centra en un único agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas de un solo agente y multiagentes (por ejemplo, [22, 5, 6]). Este documento está organizado de la siguiente manera. En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deberían ocurrir los abortos, y los procedimientos adecuados de representación e invocación. En la Sección 4 mostramos cómo podemos utilizar CAN para especificar formalmente el comportamiento de un plan abortado. La sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro. EJEMPLO MOTIVADOR Alice es una trabajadora del conocimiento asistida por un agente de asistencia personal y de aprendizaje como CALO [11]. Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente CALO adopta la tarea de Presentación de Reuniones de Apoyo (SMS) para ayudarla. El plan de CALO para una tarea de SMS en el caso de una presentación en una conferencia consiste en las siguientes sub tareas: 1. Asignar un Número de Documento (APN) para ser utilizado con fines administrativos en la empresa. 2. Seguimiento de la Escritura del Resumen (SER): hacer un seguimiento del progreso de Alicia en la preparación de un resumen. 3. Solicitar autorización de publicación (AFC) del gerente de Alice basado en el resumen y los detalles de la conferencia. 4. Papel de seguimiento de escritura (PSE): llevar un registro del progreso de Alicia en la escritura del papel. 5. Manejo de la presentación de documentos (HPS): seguir los procedimientos internos de la empresa para presentar un documento a una conferencia. Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo. De manera similar, CALO puede realizar la tarea de Solicitar Autorización de Despeje (AFC) mediante un plan que consiste en: 1. Enviar la Solicitud de Autorización (SCR) al gerente de Alice. 2. Espera la respuesta (WFR) del gerente. 3. Confirma que la respuesta fue positiva, y falla en caso contrario. Ahora supongamos que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras está escribiendo el documento. Alice ya no podrá asistir a IJCAI. Por lo tanto, ella instruye a su agente CALO para abortar la tarea de SMS. Abortar la tarea implica abortar tanto el plan de SMS como el subplan de AFC. Abortar el primer plan requiere que CALO notifique al registro de números de papel que el número de papel asignado está obsoleto, lo cual puede lograr mediante la tarea Cancelar Número de Papel (CPN). Abortar el segundo plan requiere que CALO notifique al gerente de Alice que Alice ya no necesita autorización para publicar, lo cual CALO puede lograr invocando la tarea Cancelar Solicitud de Autorización (CCR). Observamos una serie de observaciones importantes del ejemplo. Primero, la decisión de abortar un curso de acción particular puede surgir de las deliberaciones internas del agente (como razonar sobre prioridades en un conflicto por recursos), o de fuentes externas (como otro agente cancelando un compromiso), como en este ejemplo. En este documento solo abordamos el problema de determinar si una tarea o plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se haya tomado esta decisión. Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo. Segundo, una vez que se toma la decisión de abortar el intento de enviar un artículo, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización. En otras palabras, abortar una tarea no es simplemente cuestión de abandonar la tarea y los planes activos asociados: puede haber algunas acciones de limpieza que necesiten realizarse. Esto es similar al caso del fracaso, en el sentido de que también puede haber acciones a tomar cuando una tarea o plan falla. En ambos casos, hay que tener en cuenta que no se trata simplemente de que el agente deshaga sus acciones hasta la fecha; de hecho, esto puede no ser ni posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado del mundo) ni deseable (dependiendo de la semántica de la tarea). Más bien, la limpieza implica compensación a través de acciones de recuperación hacia adelante [3]. Tercero, hay una distinción entre abortar una tarea y abortar un plan. En el primer caso, está claro que todos los planes que se estén ejecutando para realizar la tarea deben ser abortados; en el segundo caso, puede ser que existan mejores alternativas al plan actual y se deba intentar una de estas. Por lo tanto, el aborto o fracaso del plan no necesariamente conduce al aborto o fracaso de la tarea. Dado que las tareas pueden contener sub tareas, las cuales pueden contener más sub tareas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto. Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que una tarea o plan principal es abortado. 3. ABORTANDO TAREAS Y PLANES Como hemos insinuado, el fracaso y abortar son conceptos relacionados. Ambos causan que la ejecución de los planes existentes se detenga y, en consecuencia, que el agente reflexione sobre sus tareas e intenciones actuales. El fracaso y la interrupción, sin embargo, difieren en la forma en que surgen. En caso de fallo, el disparador para detener la ejecución de una tarea o plan proviene de abajo, es decir, del fallo de sub tareas o planes de nivel inferior. En caso de abortar, el disparador proviene de arriba, es decir, de las tareas y los planes principales que iniciaron un plan. En sistemas de estilo BDI como JACK y SPARK, el conocimiento del dominio de los agentes incluye una biblioteca de planes predefinidos de cláusulas de planificación. Cada cláusula de plan tiene un cuerpo de plan, que es un programa (es decir, una combinación de acciones primitivas, subtareas, etc.) que puede ejecutarse en respuesta a una tarea u otro evento si se cumple la condición de contexto de las cláusulas del plan. El agente selecciona y ejecuta instancias de cláusulas de plan para realizar sus tareas. Puede haber más de una cláusula de plan aplicable y, en caso de que una falle, se puede intentar otra aplicable. Los planes pueden tener subtareas que deben tener éxito. CALO solo necesita eliminar las tareas TWA y TWP para abortarlas: por simplicidad, suponemos que no es necesario realizar una limpieza explícita de su estado interno. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) para que el plan tenga éxito. En tales sistemas, ocurre un fallo en el plan si una de las acciones o subtareas dentro del plan falla. La acción de los agentes ante el fracaso del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si se ha intentado un plan y ha resultado en fracaso, o puede intentar planes alternativos y declarar (de hecho, debe declarar) el fracaso de la tarea solo si se han intentado todos los planes alternativos posibles para realizar la tarea y han resultado en fracaso. Observa que, si bien el fracaso de una tarea puede derivar del fracaso de un plan o de una secuencia de fracasos de planes, el fracaso de un plan no tiene por qué llevar al fracaso de la tarea siempre y cuando el agente pueda completar con éxito un plan alternativo. Además, el fracaso de la tarea también puede surgir de forma independiente al fracaso del plan, si el agente decide abortar la tarea. Nuestro enfoque asocia un método de aborto con cada plan. Esto permite al programador especificar acciones de compensación dedicadas según cómo el agente esté intentando realizar la tarea. Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que se pueden realizar dinámicamente de la manera habitual en BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones. La pregunta sigue siendo qué método de aborto se debe invocar, y de qué manera. Dada la complejidad de los espacios de acción de los agentes, no es posible ni deseable enumerar un conjunto estático de reglas. Más bien, el agente invocará sus métodos de aborto dinámicamente de acuerdo al estado de ejecución y sus propios eventos internos. Una alternativa a adjuntar un método de aborto a cada plan es adjuntar dichos métodos a cada acción atómica. Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los métodos de limpieza para el fracaso en los sistemas actuales están adjuntos a los planes. Para entender cómo debería funcionar el proceso de aborto de los agentes, consideramos tres situaciones en las que tiene sentido que un agente considere abortar algunas de sus tareas y planes: 1. Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí mismo, el plan actualmente ejecutado para realizar la tarea debe ser abortado. Por ejemplo, supongamos que la política de la empresa cambia para que los empleados con la antigüedad de Alice tengan automáticamente autorización para publicar artículos. Dado que Alice ahora tiene autorización para publicar su artículo, CALO puede abortar el plan de Solicitar Autorización. Al hacerlo, debe invocar el método de aborto, en este caso realizando la solicitud de cancelación de autorización. Cuando dos o más subprogramas se ejecutan en paralelo, si uno falla entonces los demás deben ser abortados, dado que el fallo de una rama conlleva al fallo de la tarea en general. Por ejemplo, supongamos que a mitad de la escritura del artículo, Alice se da cuenta de que hay un error fatal en sus resultados, por lo que notifica a CALO que no podrá completar el artículo para la fecha límite. El fallo de la tarea de Escritura de Pista debería provocar que la tarea de Solicitar Autorización que se está ejecutando en paralelo sea abortada. 3. Cuando un evento de ejecución altera la importancia de una tarea o intención existente, el agente debe deliberar si el/los plan(es) existente(s) deben continuar. Por ejemplo, supongamos que Alice encarga a CALO una nueva tarea de alta prioridad para comprar una computadora portátil de reemplazo, pero que Alice no tiene suficientes fondos para comprar la computadora portátil y asistir a IJCAI. Razonar sobre los requisitos de recursos [20, 10] hará que el agente se dé cuenta de que no puede completar exitosamente ambas tareas. Si hay alguna diferencia entre cómo abortar una tarea que se realiza externamente y cómo abortar una que ahora se sabe que es imposible, el método de aborto puede detectar las circunstancias y manejar la situación de manera apropiada. Dado que la nueva tarea tiene mayor importancia, un agente racional evaluará su mejor curso de acción y puede decidir abortar o al menos suspender la tarea existente de presentar un documento y las intenciones derivadas de ella [12]. La semántica operativa que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones mencionadas anteriormente. La tercera situación implica deliberar sobre la importancia de una tarea, la cual depende de varios factores como la prioridad de la tarea. Aunque esta deliberación está más allá del alcance de este documento, es un tema complementario de nuestro trabajo futuro. Ten en cuenta que las situaciones anteriores se aplican a metas de logro, para las cuales la tarea se completa cuando se logra un estado particular del mundo (por ejemplo, asegurarse de que tengamos autorización). Diferentes formas de razonamiento se aplican a otros tipos de objetivos, como los objetivos de mantenimiento, donde el objetivo se satisface al mantener un estado del mundo durante algún período de tiempo (por ejemplo, mantener $100 en efectivo). La representación del método de aborto tiene la intención de que una tarea o plan se detenga, y que tanto la tarea o plan como todos sus hijos dejen de ejecutarse, y que se realicen los métodos de limpieza apropiados según sea necesario. A diferencia de los sistemas de planificación offline, los agentes BDI están situados: realizan deliberación en línea y sus acciones cambian el estado del mundo. Como resultado, los efectos de muchas acciones no pueden ser simplemente deshechos. Además, el proceso de deshacer puede causar efectos adversos. Por lo tanto, los métodos de limpieza que especificamos son procedimientos de recuperación hacia adelante que intentan garantizar un estado estable y que también pueden, si es posible, recuperar recursos. La representación común de un plan en sistemas de estilo BDI como JACK y SPARK incluye un método de fallo, que es el método de limpieza designado invocado cuando el plan falla. Para esto, agregamos el método de aborto, que se invoca si se va a abortar el plan. En nuestro ejemplo, el método de aborto para el plan de Envío de Reunión de Soporte consiste en invocar la sub-tarea Cancelar Número de Documento. El método de aborto no necesita abortar explícitamente la solicitud de autorización, ya que el agente invocará el método de aborto para la subtarea de manera apropiada, como detallamos a continuación. La suposición aquí es que, al igual que en el método de falla, el programador del sistema del agente tiene la oportunidad de especificar un método de aborto sensato que tenga en cuenta el punto en el plan en el que se va a ejecutar el aborto. Para cualquier plan, el método de aborto es opcional: si no se especifica un método de aborto, el agente no toma ninguna acción específica para este plan. Sin embargo, las reglas de comportamiento predeterminadas de los agentes siguen aplicándose, por ejemplo, si intentar de nuevo un plan alternativo para la tarea principal. Se debe tener en cuenta que no es necesario una representación explícita de los métodos de limpieza para las tareas, ya que las tareas se realizan ejecutando algún plan o planes. Por lo tanto, abortar una tarea significa abortar el plan actual que se está ejecutando para realizar esa tarea, como describiremos a continuación. Invocación del método de aborto. Ahora describimos de manera informal la acción de los agentes al abortar planes y tareas. Cuando un plan P es abortado: 1. Abortar cada sub-tarea que sea un hijo activo de P. Un hijo activo es aquel que fue desencadenado por P y actualmente está en ejecución. 2. Cuando ya no haya más niños activos, invoque el método de aborto del plan P. 3. Indique un fallo en el plan para TP, la tarea principal de P. Se señala aquí que si la tarea principal TP no debe ser abortada, entonces el agente puede elegir otro plan aplicable para satisfacer TP. 10 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Cuando una tarea (o sub-tarea) T es abortada: 1. Abortar el plan activo actual para satisfacer T (si lo hay). 2. Cuando ya no haya más procesos secundarios activos, elimine la tarea. El agente ya no persigue a T. 3. Ten en cuenta que cuando se aborta el plan activo actual para realizar T, no se deben intentar otros planes aplicables para realizar T, ya que es la tarea que se va a abortar. Para evitar esfuerzos de limpieza en cascada infinita, asumimos que los métodos de aborto nunca serán abortados ni fallarán. En realidad, sin embargo, un método de aborto puede fallar. En este caso, al no contar con un mecanismo de manejo más sofisticado, el agente simplemente deja de ejecutar el método de aborto fallido sin más deliberación. La suposición que hacemos no es, por lo tanto, un reflejo de la complejidad total de la realidad, sino una que es pragmática en términos del ciclo de ejecución del agente; el enfoque para el manejo de fallos de [21] hace la misma suposición. En sistemas como SPARK, el programador puede especificar un comportamiento alternativo para un método de fallo o aborto fallido mediante procedimientos a nivel meta. También asumimos que los métodos de falla y aborto terminan en tiempo finito. 4. SEMÁNTICA OPERACIONAL Proporcionamos la semántica para los procesos de falla y aborto de tareas y planes descritos anteriormente. Utilizamos el lenguaje CAN inicialmente definido en [23] y posteriormente extendido como CANPLAN en [17] para incluir un componente de planificación y luego como CANPLAN2 en [18] para mejorar los mecanismos de adopción y eliminación de objetivos. Las extensiones también simplificaron la semántica en el trabajo anterior. Utilizamos algunas de estas simplificaciones para proporcionar un breve resumen del lenguaje CAN en la Sección 4.1. Tras una presentación de la semántica operacional de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos. 4.1 Lenguaje CAN CAN es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentSpeak [15] y Kinnys Ψ [7], ambos de los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados. CAN proporciona un constructo de objetivo explícito que captura tanto los aspectos declarativos como los procedimentales de un objetivo. Los objetivos son persistentes en CAN en el sentido de que, cuando un plan falla, se intenta otro plan aplicable. Esto equivale al mecanismo predeterminado de manejo de fallos que se encuentra típicamente en sistemas BDI implementados como JACK [2]. En sistemas prácticos, las tareas suelen traducirse en eventos que desencadenan la ejecución de algunos planes. Esto también es cierto en el lenguaje CAN, pero, para mantener la persistencia de los objetivos, se introduce un constructo de objetivo. Esto se denota por Objetivo ` φs, P, φf ´, donde φs es la condición de éxito que determina cuándo se considera que el objetivo se ha logrado, φf es una condición de fracaso bajo la cual se considera que el objetivo ya no es alcanzable o relevante, y P es un programa para lograr el objetivo, que se abortará una vez que φs o φf se vuelvan verdaderos. El comportamiento de un agente está especificado por una biblioteca de planes, denotada por Π, que consiste en una colección de cláusulas de planes de la forma e : c ← P, donde e es un evento, c es una condición de contexto (una fórmula lógica sobre las creencias de los agentes que debe ser verdadera para que el plan sea aplicable) y P es el cuerpo del plan. El cuerpo del plan es un programa que se define recursivamente de la siguiente manera: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Objetivo ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 Un c omitido es equivalente a verdadero. Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figura 1: Reglas operativas de CAN. donde P1, . . . , Pn son ellos mismos programas, act es una acción primitiva que no está más especificada, y +b y −b son operaciones para añadir y eliminar creencias. La base de creencias contiene átomos de creencias fundamentales en forma de relaciones de primer orden, pero podría ser extendida ortogonalmente a otras lógicas. Se asume que se proporcionan operaciones bien definidas para verificar si una condición se sigue de un conjunto de creencias (B |= c), para agregar una creencia a un conjunto de creencias (B ∪ {b}), y para eliminar una creencia de un conjunto de creencias (B \\ {b}). ?φ es una prueba para la condición φ, y !e5 es un evento6 que se publica desde dentro del programa. Los constructos compuestos son secuenciación (P1; P2), ejecución paralela (P1 P2) y metas (Meta ` φs, P, φf ´ ). Lo anterior define el idioma del usuario. Además, se utilizan un conjunto de formas compuestas auxiliares internamente al asignar semántica a los constructos. nil es el programa básico (terminante). Cuando un evento coincide con un conjunto de cláusulas de plan, estas se recopilan en un conjunto de alternativas protegidas (c1: P1, ..., cn: Pn). La otra forma compuesta auxiliar, , es un operador de elección dual a la secuenciación: P1 P2 ejecuta P1 y luego ejecuta P2 solo si P1 falló. Un resumen de la semántica operacional para CAN de acuerdo con [23] y siguiendo algunas de las simplificaciones de [17] es el siguiente. Una configuración básica S = B, G, Γ consiste en la base de creencias actual B del agente, el conjunto actual de metas G que se persiguen (es decir, un conjunto de fórmulas) y el programa actual P que se está ejecutando (es decir, la intención actual). Una transición S0 −→ S1 especifica que ejecutar S0 durante un paso único produce la configuración S1. S0 −→∗ Sn es el cierre reflexivo transitivo usual de −→: Sn es el resultado de una o más transiciones de un solo paso. Una regla de derivación S −→ Sr S −→ Sr consiste en un conjunto (posiblemente vacío) de premisas, que son transiciones junto con algunas condiciones auxiliares (numerador), y una única transición conclusión derivable de estas premisas (denominador). La Figura 1 muestra algunas de las reglas operativas. La regla de Evento maneja eventos de tarea recopilando todas las cláusulas de plan relevantes para el evento en cuestión: para cada cláusula de plan e : ψi ← Pi, si hay un unificador más general, θ = mgu(e, e) de e y el evento en 5 Donde es obvio que e es un evento, a veces excluiremos el signo de exclamación para mayor legibilidad. 6 Típicamente un objetivo de logro. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 11 B |= φs B, Objetivo ` φs, P, φf ´ −→ B, verdadero Gs B |= φf B, Objetivo ` φs, P, φf ´ −→ B, falla Gf P = Objetivo ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Objetivo ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Objetivo ` φs, P, φf ´ −→ B , Objetivo ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {verdadero, falla} B, Objetivo ` φs, P, φf ´ −→ B, Objetivo ` φs, P2 £ P2, φf ´ GR Figura 2: Reglas para objetivos en CAN. pregunta, entonces la regla construye una alternativa guardada ψiθ: Piθ. La regla Select selecciona un cuerpo de plan aplicable de un conjunto de alternativas relevantes (restantes): el programa P Δ establece que el programa P debe intentarse primero, recurriendo a las alternativas restantes, Δ \\ P, si es necesario. Esta regla y la regla de fallo se utilizan juntas para el manejo de fallos: si el programa actual Pi de una cláusula de plan para una tarea falla, primero se aplica la regla de fallo, y luego, si es posible, la regla Select elegirá otra alternativa aplicable para la tarea si existe alguna. Rule Sequence maneja la secuenciación de programas de la manera habitual. Las reglas Parallel1 y Parallel2 definen la posible intercalación al ejecutar dos programas en paralelo. La Figura 2 presenta reglas simplificadas para <br>tratar con</br> objetivos, en línea con las presentadas en [17]. La primera regla establece que un objetivo tiene éxito cuando φs se vuelve verdadero; la segunda regla establece que un objetivo falla cuando φf se vuelve verdadero. La tercera regla GI inicializa la ejecución de un programa de metas actualizando la base de metas y estableciendo el programa en la meta como P £ P; el primer P se ejecutará y el segundo P se utiliza para hacer un seguimiento del programa original para la meta. La cuarta regla GS ejecuta un solo paso del programa de objetivos. La regla final GR reinicia el programa original (codificado como P2 del par P1 £ P2) cada vez que el programa actual ha terminado pero el objetivo deseado y aún posible no se ha logrado. 4.2 Abortando Intenciones y Manejando Fallas A continuación, introducimos la capacidad de especificar programas manejadores, en forma de métodos de falla y aborto, que se ocupan de la limpieza requerida cuando un programa dado falla o es abortado. No asociamos los métodos de falla y aborto con cláusulas de plan o con tareas (eventos), sino que introducimos una nueva construcción de programa que especifica los métodos de falla y aborto para un programa arbitrario. El constructo FAb(P, PF, PA) ejecuta el programa P. En caso de que P falle, ejecuta el programa de manejo de fallos PF; si P necesita ser abortado, ejecuta el programa de manejo de aborto PA. Por lo tanto, para agregar los métodos de falla y aborto PF y PA a una cláusula de plan e : c ← P, escribimos e : c ← FAb(P, PF, PA). Con la introducción de la capacidad de abortar programas, modificamos la construcción paralela para permitir que el fallo de una rama aborte la otra. Debemos tener en cuenta la posible existencia de métodos de aborto en la rama abortada. De manera similar, con el constructo de Objetivo ya no podemos abandonar por completo el programa que contiene tan pronto como se cumpla la condición de éxito o fracaso; ahora debemos tener en cuenta la existencia de cualquier método de aborto aplicable al programa. Proporcionamos la semántica de un lenguaje de agente aumentado que contiene el constructo FAb al definir una transformación de origen, similar a la expansión de macros, que mapea una biblioteca de planes que contiene el constructo FAb(P, PF, PA) en CAN estándar (casi). La única extensión no estándar a CAN es un constructo de espera hasta que se cumpla una condición. Explicamos esta simple modificación del constructo paralelo a continuación cuando llegamos a la traducción del constructo de la Meta. Primero describimos la naturaleza general de la transformación de la fuente, que resulta ser bastante simple para la mayoría de las construcciones del lenguaje, y luego nos concentramos en los tres casos más complejos: las construcciones FAb, paralela y Goal. Un problema clave es que los constructos FAb pueden estar anidados, ya sea directa o indirectamente. Llamemos a cada instancia del constructo en tiempo de ejecución un posible punto de aborto (pap). Donde estos constructos están anidados, es importante que antes de que se ejecute el método de falla o aborto de un pap padre, se ejecuten primero los programas de métodos de falla o aborto de los paps hijos, como se describe anteriormente en la Sección 3. La necesidad de coordinar la ejecución de los métodos de aborto de paps anidados requiere que haya alguna forma de identificar los padres e hijos de un pap en particular. Logramos esto como parte de la transformación de origen al llevar un registro explícito del contexto de ejecución como un parámetro adicional en los eventos y una variable adicional dentro de cada cuerpo del plan. La transformación de origen reemplaza cada cláusula del plan de la forma e : c ← P con una cláusula del plan e(v) : c ← μv(P) donde v es una variable libre, no presente previamente en la cláusula del plan. Esta variable se utiliza para llevar un registro del contexto de ejecución. El valor de la variable de contexto es una lista de identificadores, donde cada nuevo párrafo está representado al anteponer un nuevo identificador al contexto. Por ejemplo, si los identificadores son enteros, el contexto de un documento puede ser representado por una lista [42, 1] y el contexto introducido por un nuevo documento puede ser representado por [52, 42, 1]. Nos referiremos a los paps por el contexto en lugar del nuevo identificador agregado, por ejemplo, por [51, 42, 1] y no solo por 51. Esto nos permite equiparar la relación de ancestro entre paps con la relación de sufijo de lista en los contextos relevantes, es decir, v es un ancestro de v si y solo si v es un sufijo de v. Para la mayoría de los constructos CAN, la variable de contexto no se utiliza o se pasa sin cambios: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) Queda por especificar la transformación μv(·) en tres casos: los constructos FAb, paralelo y Goal. Estos son más complejos en el sentido de que la fuente transformada necesita crear dinámicamente un nuevo identificador de pap, para usarlo como un nuevo contexto dentro de la construcción, y para llevar un registro de cuándo el pap está activo (es decir, actualmente en ejecución) añadiendo y eliminando creencias sobre el contexto. Introduzcamos la acción primitiva prependID(v, v) que crea un nuevo identificador pap y lo antepone a la lista v, dando como resultado la lista v. También introducimos los siguientes predicados: • a(v) - el pap v está actualmente activo. • abort(v) - el pap v debe ser abortado (después de abortar a todos sus descendientes). Una alternativa sería utilizar predicados a nivel meta que reflejen el estado actual de la estructura de intenciones. La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) • f(v) - el programa del pap v ha fallado. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))el pap v es un ancestro del pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v no tiene hijos activos. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - debemos abortar v, es decir, abort es verdadero para v o algún ancestro; sin embargo, debemos esperar hasta que no haya hijos activos de v. • san(v) ≡ sa(v) ∧ nac(v) - debemos abortar v ahora si debemos abortar v y v no tiene hijos activos. Primero consideremos el caso del constructo FAb. La idea es que, cada vez que ocurra un nuevo pap, se utiliza la acción prependID(v, v) para crear una nueva lista de identificadores de pap v a partir de la lista existente v. Luego agregamos la creencia de que v es el contexto activo, es decir, +a(v), y comenzamos a procesar el programa dentro del pap utilizando v en lugar de v como contexto. Necesitamos asegurarnos de retractar la creencia de que v está activo al final, es decir, −a(v). Utilizamos la construcción de Objetivo para permitirnos detener la ejecución de un programa dentro de un pap v cuando sea necesario abortar. Mientras se ejecuta el programa P, sabemos que debemos descartar P e invocar su método de aborto si se le ha indicado a algún ancestro de P que aborte. Esto se representa por el predicado sa(v) siendo verdadero. Sin embargo, debemos asegurarnos de hacer esto solo después de que cada pap de niño haya tenido la oportunidad de invocar su método de aborto y todos estos métodos de aborto hayan sido completados: si abandonamos el programa demasiado pronto, entonces la ejecución de los métodos de aborto de los niños también será abandonada. Por lo tanto, la condición que realmente usamos en la construcción del Objetivo para probar cuándo detener el programa es san(v). Esta condición se basa en el hecho de que a medida que los niños completan sus papilas, eliminan los hechos relevantes. Nuestro uso del constructo Goal es por su capacidad de detener la ejecución de un programa cuando se cumplen ciertas condiciones. Para dejar de lado el aspecto de la repetición de la ejecución hasta que se cumpla una condición, debemos asegurarnos de que la condición de éxito o fracaso del constructo se cumpla una vez que la ejecución del programa tenga éxito o falle. Nos aseguramos de esto al retractar el hecho a(v) en caso de éxito y afirmar el hecho f(v) en caso de fracaso, y al tener las condiciones apropiadas de éxito y fracaso en el Objetivo. Por lo tanto, si falla la construcción del Objetivo, entonces el programa fue abortado o falló. Invocamos el método de fallo o aborto relevante, retiramos el hecho a(v) y luego fallamos. Al juntar todo esto, definimos formalmente μv(FAb(P, PA, PF )) de la siguiente manera, donde v es una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) En segundo lugar, debemos transformar el operador paralelo para asegurar que el fallo de una rama aborte de forma segura la otra. Aquí construimos dos nuevos contextos, v y v, a partir del contexto existente v. Si una rama falla, debe abortar la otra rama. Al final, si se abortó cualquiera de las ramas, entonces debemos fallar. Que v y v sean variables nuevas distintas de cualquier otra en la biblioteca de planes de los agentes. Definimos μv(P1 P2) como: prependID(v, v); prependID(v, v); +a(v); +a(v); (Goal (¬a(v), (μv(P1); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v)) Goal (¬a(v), (μv(P2); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v))); ?¬abort(v) ∧ ¬abort(v) Finalmente, necesitamos modificar las ocurrencias del constructo Goal de dos maneras: primero, asegurarnos de que los métodos de manejo de aborto no se pasen por alto cuando se satisfacen las condiciones de éxito o fracaso, y segundo, activar la interrupción del programa contenido cuando se satisfacen las condiciones de éxito o fracaso. Para transformar el constructo Goal necesitamos extender el estándar CAN con un constructo de espera-hasta-condición. El constructo φ : P no ejecuta P hasta que φ se convierte en verdadero. Aumentamos el lenguaje CAN con las siguientes reglas para el operador de guardia :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false Para especificar μv(Goal ` φs, P, φf ´ ), generamos un nuevo pap y ejecutamos el programa dentro del constructo Goal en este nuevo contexto. Debemos asegurarnos de que la creencia a(v) sea eliminada, ya sea que el objetivo tenga éxito o fracase. Cambiamos la condición de éxito y fracaso del constructo Objetivo a una rama paralela utilizando el constructo de espera-hasta-condición, y modificamos el Objetivo para usar la condición de éxito debería abortar ahora san(v) como condición de éxito. La rama de espera desencadenará la interrupción del programa si se cumple tanto la condición de éxito como la de fracaso. Para evitar cualquier problema al terminar la condición de espera, también finalizamos la espera si el pap ya no está activo. Que v sea una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes. Definimos μv(Goal ` φs, P, φf ´ ) como: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) El programa P se ejecutará repetidamente hasta que san(v ) se convierta en verdadero. Hay dos formas en que esto puede ocurrir. Primero, si se cumple la condición de éxito φs o la condición de fracaso φf, entonces se ejecuta la segunda rama de la construcción en paralelo. Esto hace que abort(v) se convierta en verdadero, y, después de que se ejecuten los métodos de abortmethods descendientes, san(v) se convierte en verdadero. En este caso, P se elimina, se elimina el a(v), y todo el constructo tiene éxito o fracasa en función de φs. La segunda forma en que san(v) puede volverse verdadero es si v o uno de sus ancestros es abortado. En este caso, una vez que se ejecutan los métodos de aborto de los paps descendientes, san(v) se vuelve verdadero, P se elimina, se elimina la creencia a(v) (permitiendo que la segunda rama paralela se ejecute, instruyendo vacuamente a v a abortar), y la primera rama paralela falla (asumiendo que φs es falso). Ejemplo trabajado 4.3 Echemos un vistazo a la traducción del ejemplo de envío a IJCAI de la Sección 2. Expresaremos las tareas mediante eventos, por ejemplo, la tarea Asignar un Número de Papel la expresamos como el evento APN. Que la salida de la tarea Solicitar autorización sea Y o N, indicando la aprobación o no del gerente de Alicia, respectivamente. Entonces tenemos (al menos) las siguientes dos cláusulas de plan en CAN, para las tareas de Envío de Reunión de Apoyo y Solicitar Autorización de Despeje, respectivamente: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Tenga en cuenta que Envío de Reunión de Apoyo tiene un parámetro m, la reunión de interés (IJCAI, en nuestro ejemplo), mientras que Solicitar Autorización de Despeje no tiene parámetros. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 13. Veamos primero la traducción de la segunda cláusula del plan, para AFC, ya que es la más simple de las dos. Que v y v denoten nuevas variables. Entonces tenemos como cláusula del plan traducido: AFC(v): verdadero ← prependID(v, v); +a(v); Meta(¬a(v), (!SCR(v); !WFR(r, v); ?r = Y; −a(v) +f(v)), san(v) ∨ f(v)) (((?sa(v); !CCR(v)) nil); −a(v); ?falso) Podemos ver que se ha añadido un parámetro de contexto adicional a cada tarea y que el antiguo cuerpo del plan ahora aparece dentro de un constructo de Meta. Si el antiguo cuerpo del plan tiene éxito, la creencia a(v) se retira, lo que hace que el Objetivo tenga éxito. Si el cuerpo del plan antiguo falla, o si la tarea debe ser abortada, el constructo de Objetivo falla. Esto es seguido por la ejecución de CCR (en caso de un aborto), la retracción de a(v), y el fallo. La traducción de la primera cláusula del plan, para SMS, es más compleja, debido a la estructura paralela que introduce paps anidados: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Meta ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Meta ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Meta ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Aquí podemos ver que si la tarea !TWP(v ) falla, entonces se afirmará f(v ), lo que hará que falle la construcción de Meta que lo contiene, y llevará a que se afirme abort(v ). Si la tarea !WFR(r, v ) en la expansión de !AFC(v ) todavía se está ejecutando y no tiene paps hijos activos, entonces sa(v ) y sa(v ) serán verdaderos; sin embargo, solo san(v ) y no san(v ) serán verdaderos. Este conjunto de condiciones hará que el constructo Goal en la primera cláusula del plan falle, deteniendo la ejecución de !WFR(r, v). La tarea !CCR(v) será ejecutada. Una vez que esta tarea se complete, la creencia a(v) se retira, lo que hace que san(v) se convierta en verdadero, lo que lleva a que la primera construcción de objetivo de la segunda cláusula del plan falle. Si bien las cláusulas del plan traducido parecen complicadas, observe que la traducción de las cláusulas del plan inicial es completamente automatizada, de acuerdo con las reglas establecidas en la Sección 4.2. Las cláusulas del plan traducido, con la semántica de PUEDE aumentada por nuestra construcción de condición de esperar-hasta, especifican así la operación del agente para manejar tanto el fallo como la interrupción del ejemplo. 5. El fallo del plan se maneja en la versión extendida de AgentSpeak encontrada en el sistema Jason [6]. Los planes de limpieza de fallas se activan a partir de eventos de eliminación de objetivos −!g. Tales planes, similares a nuestros métodos de fracaso, están diseñados para que el agente efectúe cambios de estado (actúe para deshacer sus acciones anteriores) antes de posiblemente intentar otro plan para lograr el objetivo fallido g. Dados los constructos de Jason para abandonar un objetivo con una indicación de si intentar o no un plan alternativo para él, H¨ubner et al. [6] proporcionan una descripción informal de cómo un agente de Jason modifica su estructura de intenciones cuando ocurre un evento de fracaso del objetivo. En un plan de eliminación de objetivos, el programador puede especificar cualquier acción de deshacer y si intentar de nuevo el objetivo. Si no se proporciona un plan de eliminación de objetivos, el comportamiento predeterminado de Jason es no volver a intentar el objetivo. El manejo de fallos se aplica solo a los planes desencadenados por la adición de un logro o meta de prueba; en particular, los eventos de eliminación de metas no se publican por el fallo de un plan de eliminación de metas. Además, la semántica informal de [6] no considera submetas paralelas (es decir, el constructo CAN), ya que dicha ejecución no forma parte del lenguaje de Jason. La implementación de H¨ubner et al. [6] requiere acciones internas de Jason. Un requisito para implementar nuestro enfoque es una capacidad reflexiva en la implementación del agente BDI. Las implementaciones adecuadas del formalismo BDI son JACK [2], Jadex [14] y SPARK [9]. Los tres permiten métodos a nivel meta que son activados por eventos meta como la adopción de objetivos o el fracaso de un plan, y ofrecen capacidades introspectivas sobre los estados de objetivo e intención. Tales instalaciones de nivel meta también son requeridas por el enfoque de Unruh et al. [21], quienes definen la compensación semántica basada en objetivos para un agente. Los objetivos de manejo de fallos son invocados de acuerdo con las reglas de estrategia de manejo de fallos, por un agente dedicado Componente de Manejo de Fallos (FHC) que sigue la ejecución de la tarea. Estos objetivos son especificados por el programador del agente y se adjuntan a las tareas, de manera similar a cómo nuestro constructo FAb(P, PF, PA) asocia métodos de falla y aborto con un plan P. Sin embargo, cabe destacar que, a diferencia tanto de [6] como de nuestra semántica, [21] adjuntan el conocimiento de manejo de fallas a nivel de objetivo, no de plan. Sus objetivos de manejo de fallos pueden consistir en objetivos de estabilización que realicen una limpieza localizada e inmediata para restaurar el estado de los agentes a un estado conocido y estable, y objetivos de compensación que realicen acciones de deshacer. Los objetivos de compensación se activan al abortar un objetivo, y no necesariamente al fallar en el objetivo (es decir, si el FHC indica al agente que vuelva a intentar el objetivo fallido y el nuevo intento tiene éxito). El enfoque FHC se define a nivel de objetivo para facilitar la especificación abstracta del conocimiento de manejo de fallos; el FHC decide cuándo abordar un fallo y qué hacer (es decir, qué objetivos de manejo de fallos invocar), separando este conocimiento del cómo implementar acciones correctivas (es decir, qué plan ejecutar para cumplir con el objetivo de manejo de fallos adoptado). Esto contrasta con el manejo simplista de fallas a nivel de plan en el que el qué y el cómo se entrelazan en el conocimiento de la tarea del dominio. Si bien nuestro enfoque está definido a nivel de plan, nuestra semántica BDI extendida permite la separación de la ejecución y el manejo de fallos. Además, el FHC mantiene explícitamente estructuras de datos para rastrear la ejecución de agentes. Aprovechamos las estructuras de ejecución existentes y la capacidad autorreflexiva de un agente BDI para lograr tanto la interrupción como el manejo de fallos sin costos adicionales. Las reglas de estrategia de manejo de fallos de FHC (por ejemplo, si volver a intentar un objetivo fallido) son reemplazadas por instrucciones en nuestros planes de PF y PA, junto con manejadores de fallos predeterminados a nivel meta de acuerdo con la naturaleza de los agentes (por ejemplo, comprometidos ciegamente). El enfoque FHC es independiente de la arquitectura del agente en sí, a diferencia de nuestro trabajo que está dedicado al formalismo BDI (aunque no está ligado a ningún sistema de agente en particular). Por lo tanto, no se desarrollan semánticas formales en [21]; la operación de los FHCs se presenta como 14 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) un protocolo basado en estados. Este enfoque, junto con el punto de control estatal, se utiliza para sistemas multiagente en [22]. La arquitectura resultante incorpora su enfoque de manejo de fallos dentro de una arquitectura de procesamiento en pares para la recuperación de fallos de agentes. Otro trabajo sobre el manejo de excepciones multiagente incluye los agentes de manejo de excepciones distribuidos AOEXs [5], y los centinelas similares de [8]. En ambos casos, la lógica de manejo de fallos y el conocimiento están desacoplados de los agentes; en contraste, mientras se separa el manejo de excepciones del conocimiento específico del dominio, tanto el enfoque de Unruh et al. como nuestro enfoque retienen la lógica de manejo de fallos dentro de un agente. 6. CONCLUSIÓN Y TRABAJO FUTURO Las tareas y planes de un agente pueden no llegar a completarse con éxito, ya sea por la decisión del agente de abortarlos (quizás a petición de otro agente), o por factores imprevistos que llevan al fracaso. En este artículo hemos presentado un enfoque basado en procedimientos que incorpora la interrupción de tareas y planes en el ciclo de deliberación de un agente de estilo BDI, proporcionando así un enfoque unificado para el fracaso y la interrupción. Nuestra contribución principal es un análisis de los requisitos sobre la operación del agente para abortar tareas y planes, y una semántica operativa correspondiente para abortar en el lenguaje abstracto del agente CAN. Estamos planeando implementar una instancia de nuestro enfoque en el sistema de agentes SPARK [9]; en particular, el trabajo de este artículo será la base para el mecanismo de manejo de abortos de SPARK. También estamos desarrollando una herramienta de análisis para nuestra versión extendida de CAN como base para experimentación. Un agente inteligente no solo manejará con gracia tareas y planes fallidos, sino que también reflexionará sobre sus actitudes cognitivas para decidir su próximo curso de acción. Hemos asumido el comportamiento predeterminado de un agente de estilo BDI, de acuerdo con su naturaleza: por ejemplo, volver a intentar alternativas de un plan fallido hasta que uno tenga éxito o hasta que no queden planes alternativos (en cuyo caso fallar la tarea). El trabajo futuro consiste en poner nuestro enfoque al servicio de un razonamiento de agente más dinámico, como la introspección que un agente capaz de razonar sobre los efectos de la interacción de tareas y los requisitos de recursos puede lograr [19, 12]. Relacionado con esto está determinar el costo de abortar una tarea o un plan, y utilizarlo como un insumo en el proceso de deliberación. Esto influiría en particular en el compromiso que el agente tiene hacia una tarea específica: a mayor costo, mayor compromiso. Nuestra suposición de que los métodos de aborto no fallan, como se discutió anteriormente, es una suposición pragmática. Sin embargo, este es un tema que merece una mayor exploración, ya sea para desarrollar supuestos más débiles que también sean prácticos, o para analizar las condiciones bajo las cuales nuestra suposición es realista. Un elemento adicional de interés es extender nuestro enfoque al fracaso y la interrupción a los objetivos de mantenimiento [1]. Para tales objetivos, se necesita una semántica operativa diferente para la interrupción que para los objetivos de logro, para que coincida con la diferencia en la semántica de los propios objetivos. Agradecimientos Agradecemos a Lin Padgham y a los revisores anónimos por sus comentarios. El primer autor agradece el apoyo del Consejo de Investigación Australiano y del Software Orientado a Agentes bajo la subvención LP0453486. El trabajo de los dos autores en SRI International fue apoyado por la Agencia de Proyectos de Investigación Avanzada de Defensa (DARPA) bajo el Contrato No. NBCHD030010. Cualquier opinión, hallazgo, conclusión o recomendación expresada en este material son responsabilidad de los autores y no reflejan necesariamente la visión de DARPA o el Departamento del Interior-Centro Nacional de Negocios. 7. REFERENCIAS [1] L. Braubach, A. Pokahr, D. Moldt y W. Lamersdorf. Representación de objetivos para sistemas de agentes BDI. En Actas del Segundo Congreso Internacional. Taller sobre Programación de Sistemas Multiagente (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson y A. Lucas. Agentes inteligentes JACK: componentes para agentes inteligentes en Java. AgentLink News, Edición 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira y P. Henderson. Ampliando el concepto de compensación de transacciones. Revista de Sistemas de IBM, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk y J.-J. C. Meyer. Tipos de objetivos en la programación de agentes. En Proc. de AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy y E. Kendall. Aoex: Un marco de manejo de excepciones basado en agentes para construir sistemas de software confiables, distribuidos y abiertos. En Actas de la Séptima Conferencia Conjunta sobre Ingeniería de Software Basada en el Conocimiento, 2006. [6] J. F. H¨ubner, R. H. Bordini y M. Wooldridge. Programación de metas declarativas utilizando patrones de planificación. En Actas de la 4ta Conferencia Internacional. Taller sobre Lenguajes y Tecnologías Declarativos de Agentes, 2006. [7] D. Kinny. El cálculo Psi: un lenguaje algebraico de agentes. En Proc. de ATAL01, 2001. [8] M. Klein, J. A. Rodríguez-Aguilar y C. Dellarocas. Utilizando servicios de manejo de excepciones independientes del dominio para habilitar sistemas multiagente abiertos robustos: El caso de la muerte del agente. Agentes Autónomos y Sistemas Multiagente, 7(1-2):179-189, 2003. [9] D. Morley y K. Myers. El marco de agentes SPARK. En Proc. de AAMAS04, 2004. [10] D. Morley, K. L. Myers y N. Yorke-Smith. Refinamiento continuo de estimaciones de recursos del agente. En Proc. de AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack y M. Tambe. Un asistente personal inteligente para la gestión de tareas y tiempo. Revista de Inteligencia Artificial, 28, 2007. Aparecer. [12] K. L. Myers y N. Yorke-Smith. Un marco cognitivo para la delegación a un agente de usuario asistente. En Actas del Simposio de Otoño de AAAI 2005 sobre Asistentes de Resolución de Problemas de Iniciativa Mixta, 2005. [13] L. Padgham y M. Winikoff. Desarrollo de Sistemas de Agentes Inteligentes: Una Guía Práctica. John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, y W. Lamersdorf. Jadex: Un motor de razonamiento BDI. En R. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores, Programación Multiagente. Springer, 2005. [15] A. S. Rao. \n\nSpringer, 2005. [15] A. S. Rao. AgentSpeak(L): Los agentes BDI se expresan en un lenguaje lógico computable. En Actas del Séptimo Taller Europeo sobre Modelado de Agentes Autónomos en un Mundo Multiagente, 1996. [16] A. S. Rao y M. P. Georgeff. Una arquitectura abstracta para agentes racionales. En Proc. de KR92, 1992. [17] S. Sardiña, L. de Silva y L. Padgham. Planificación jerárquica en lenguajes de programación de agentes BDI: un enfoque formal. En Proc. de AAMAS06, 2006. [18] S. Sardina y L. Padgham. Objetivos en el contexto del fracaso del plan BDI y la planificación. En Proc. de AAMAS07, 2007. [19] J. Thangarajah, L. Padgham y M. Winikoff. Detectar y aprovechar la interacción positiva de objetivos en agentes inteligentes. En Proc. de AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham y K. Fischer. Evitando conflictos de recursos en agentes inteligentes. En Proc. de ECAI-02, 2002. [21] A. Unruh, J. Bailey y K. Ramamohanarao. Un marco para la compensación semántica basada en objetivos en sistemas de agentes. En Actas de la Primera Conferencia Internacional. Taller sobre Seguridad en Sistemas Multiagente, 2004. [22] A. Unruh, H. Harjadi, J. Bailey y K. Ramamohanarao. Gestión de recuperación basada en compensación semántica en sistemas multiagente. En Proc. del Segundo Simposio IEEE sobre Seguridad y Supervivencia Multiagente (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Proc. de KR02, 2002. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 15 ",
            "candidates": [],
            "error": [
                [
                    "enfrentarse",
                    "lidiar",
                    "tratar con"
                ]
            ]
        },
        "cleanup method": {
            "translated_key": "métodos de limpieza de aborto",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort <br>cleanup method</br>s into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the <br>cleanup method</br>s for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [
                "In this paper we discuss in detail the incorporation of abort <br>cleanup method</br>s into the agent execution cycle, providing a unified approach to failure and abort.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the <br>cleanup method</br>s for failure in current systems are attached to plans."
            ],
            "translated_annotated_samples": [
                "En este documento discutimos en detalle la incorporación de <br>métodos de limpieza de aborto</br> en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto.",
                "Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los <br>métodos de limpieza</br> para el fracaso en los sistemas actuales están adjuntos a los planes."
            ],
            "translated_text": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). Abortar una tarea o plan es distinto de su fracaso. El fracaso refleja una incapacidad para desempeñarse y no anula la necesidad de desempeñarse, por ejemplo, una respuesta razonable al fracaso puede ser intentarlo de nuevo. Por el contrario, abortar no dice nada sobre la capacidad de realizar; simplemente elimina la necesidad. El fracaso se propaga de abajo hacia arriba, mientras que la interrupción se propaga de arriba hacia abajo. El potencial de ejecutar subplanes de forma simultánea introduce diferentes complejidades para la interrupción y el fallo. Para abortar, significa que varios subplanes concurrentes pueden necesitar ser abortados a medida que se propaga el aborto hacia abajo. Para el fallo, significa que los planes paralelos hermanos pueden necesitar ser abortados a medida que el fallo se propaga hacia arriba. Ha habido una cantidad considerable de trabajo sobre fallos en los planes (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallos. Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de aborto más allá de la simple eliminación de los planes y tareas actualmente previstos, lo cual no aborda la limpieza requerida. Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de un constructo paralelo. Se puede considerar que ambas tareas se realizan y se tienen objetivos para lograr un cierto estado del mundo. Una tarea puede considerarse un objetivo de lograr el estado de la tarea una vez realizada, y un objetivo puede considerarse una tarea de llevar a cabo ese estado en el mundo. Adoptamos la última perspectiva y usamos la palabra \"tarea\" también para referirnos a los objetivos. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS falla (los enfoques comunes incluyen permitir que la otra rama se ejecute hasta su finalización sin obstáculos o eliminarla por completo). En este documento discutimos en detalle la incorporación de <br>métodos de limpieza de aborto</br> en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto. Una característica clave de nuestro enfoque basado en procedimientos es que permitimos que cada plan ejecute un código particular en caso de fallo y de aborto. Esto permite que un plan intente asegurar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar de otra manera antes de salir. Por consiguiente, un desafío técnico central es gestionar la ejecución ordenada del código de limpieza adecuado. Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una semántica operativa para abortar en el lenguaje de agente abstracto CAN [23, 17]. Esto nos permite especificar un nivel adecuado de detalle para el modelo de ejecución, sin centrarnos en las construcciones específicas de ningún sistema de agentes en particular, como JACK [2], Jadex [14], Jason [6] o SPARK [9]. Nuestro enfoque se centra en un único agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas de un solo agente y multiagentes (por ejemplo, [22, 5, 6]). Este documento está organizado de la siguiente manera. En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deberían ocurrir los abortos, y los procedimientos adecuados de representación e invocación. En la Sección 4 mostramos cómo podemos utilizar CAN para especificar formalmente el comportamiento de un plan abortado. La sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro. EJEMPLO MOTIVADOR Alice es una trabajadora del conocimiento asistida por un agente de asistencia personal y de aprendizaje como CALO [11]. Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente CALO adopta la tarea de Presentación de Reuniones de Apoyo (SMS) para ayudarla. El plan de CALO para una tarea de SMS en el caso de una presentación en una conferencia consiste en las siguientes sub tareas: 1. Asignar un Número de Documento (APN) para ser utilizado con fines administrativos en la empresa. 2. Seguimiento de la Escritura del Resumen (SER): hacer un seguimiento del progreso de Alicia en la preparación de un resumen. 3. Solicitar autorización de publicación (AFC) del gerente de Alice basado en el resumen y los detalles de la conferencia. 4. Papel de seguimiento de escritura (PSE): llevar un registro del progreso de Alicia en la escritura del papel. 5. Manejo de la presentación de documentos (HPS): seguir los procedimientos internos de la empresa para presentar un documento a una conferencia. Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo. De manera similar, CALO puede realizar la tarea de Solicitar Autorización de Despeje (AFC) mediante un plan que consiste en: 1. Enviar la Solicitud de Autorización (SCR) al gerente de Alice. 2. Espera la respuesta (WFR) del gerente. 3. Confirma que la respuesta fue positiva, y falla en caso contrario. Ahora supongamos que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras está escribiendo el documento. Alice ya no podrá asistir a IJCAI. Por lo tanto, ella instruye a su agente CALO para abortar la tarea de SMS. Abortar la tarea implica abortar tanto el plan de SMS como el subplan de AFC. Abortar el primer plan requiere que CALO notifique al registro de números de papel que el número de papel asignado está obsoleto, lo cual puede lograr mediante la tarea Cancelar Número de Papel (CPN). Abortar el segundo plan requiere que CALO notifique al gerente de Alice que Alice ya no necesita autorización para publicar, lo cual CALO puede lograr invocando la tarea Cancelar Solicitud de Autorización (CCR). Observamos una serie de observaciones importantes del ejemplo. Primero, la decisión de abortar un curso de acción particular puede surgir de las deliberaciones internas del agente (como razonar sobre prioridades en un conflicto por recursos), o de fuentes externas (como otro agente cancelando un compromiso), como en este ejemplo. En este documento solo abordamos el problema de determinar si una tarea o plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se haya tomado esta decisión. Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo. Segundo, una vez que se toma la decisión de abortar el intento de enviar un artículo, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización. En otras palabras, abortar una tarea no es simplemente cuestión de abandonar la tarea y los planes activos asociados: puede haber algunas acciones de limpieza que necesiten realizarse. Esto es similar al caso del fracaso, en el sentido de que también puede haber acciones a tomar cuando una tarea o plan falla. En ambos casos, hay que tener en cuenta que no se trata simplemente de que el agente deshaga sus acciones hasta la fecha; de hecho, esto puede no ser ni posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado del mundo) ni deseable (dependiendo de la semántica de la tarea). Más bien, la limpieza implica compensación a través de acciones de recuperación hacia adelante [3]. Tercero, hay una distinción entre abortar una tarea y abortar un plan. En el primer caso, está claro que todos los planes que se estén ejecutando para realizar la tarea deben ser abortados; en el segundo caso, puede ser que existan mejores alternativas al plan actual y se deba intentar una de estas. Por lo tanto, el aborto o fracaso del plan no necesariamente conduce al aborto o fracaso de la tarea. Dado que las tareas pueden contener sub tareas, las cuales pueden contener más sub tareas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto. Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que una tarea o plan principal es abortado. 3. ABORTANDO TAREAS Y PLANES Como hemos insinuado, el fracaso y abortar son conceptos relacionados. Ambos causan que la ejecución de los planes existentes se detenga y, en consecuencia, que el agente reflexione sobre sus tareas e intenciones actuales. El fracaso y la interrupción, sin embargo, difieren en la forma en que surgen. En caso de fallo, el disparador para detener la ejecución de una tarea o plan proviene de abajo, es decir, del fallo de sub tareas o planes de nivel inferior. En caso de abortar, el disparador proviene de arriba, es decir, de las tareas y los planes principales que iniciaron un plan. En sistemas de estilo BDI como JACK y SPARK, el conocimiento del dominio de los agentes incluye una biblioteca de planes predefinidos de cláusulas de planificación. Cada cláusula de plan tiene un cuerpo de plan, que es un programa (es decir, una combinación de acciones primitivas, subtareas, etc.) que puede ejecutarse en respuesta a una tarea u otro evento si se cumple la condición de contexto de las cláusulas del plan. El agente selecciona y ejecuta instancias de cláusulas de plan para realizar sus tareas. Puede haber más de una cláusula de plan aplicable y, en caso de que una falle, se puede intentar otra aplicable. Los planes pueden tener subtareas que deben tener éxito. CALO solo necesita eliminar las tareas TWA y TWP para abortarlas: por simplicidad, suponemos que no es necesario realizar una limpieza explícita de su estado interno. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) para que el plan tenga éxito. En tales sistemas, ocurre un fallo en el plan si una de las acciones o subtareas dentro del plan falla. La acción de los agentes ante el fracaso del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si se ha intentado un plan y ha resultado en fracaso, o puede intentar planes alternativos y declarar (de hecho, debe declarar) el fracaso de la tarea solo si se han intentado todos los planes alternativos posibles para realizar la tarea y han resultado en fracaso. Observa que, si bien el fracaso de una tarea puede derivar del fracaso de un plan o de una secuencia de fracasos de planes, el fracaso de un plan no tiene por qué llevar al fracaso de la tarea siempre y cuando el agente pueda completar con éxito un plan alternativo. Además, el fracaso de la tarea también puede surgir de forma independiente al fracaso del plan, si el agente decide abortar la tarea. Nuestro enfoque asocia un método de aborto con cada plan. Esto permite al programador especificar acciones de compensación dedicadas según cómo el agente esté intentando realizar la tarea. Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que se pueden realizar dinámicamente de la manera habitual en BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones. La pregunta sigue siendo qué método de aborto se debe invocar, y de qué manera. Dada la complejidad de los espacios de acción de los agentes, no es posible ni deseable enumerar un conjunto estático de reglas. Más bien, el agente invocará sus métodos de aborto dinámicamente de acuerdo al estado de ejecución y sus propios eventos internos. Una alternativa a adjuntar un método de aborto a cada plan es adjuntar dichos métodos a cada acción atómica. Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los <br>métodos de limpieza</br> para el fracaso en los sistemas actuales están adjuntos a los planes. Para entender cómo debería funcionar el proceso de aborto de los agentes, consideramos tres situaciones en las que tiene sentido que un agente considere abortar algunas de sus tareas y planes: 1. Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí mismo, el plan actualmente ejecutado para realizar la tarea debe ser abortado. Por ejemplo, supongamos que la política de la empresa cambia para que los empleados con la antigüedad de Alice tengan automáticamente autorización para publicar artículos. Dado que Alice ahora tiene autorización para publicar su artículo, CALO puede abortar el plan de Solicitar Autorización. Al hacerlo, debe invocar el método de aborto, en este caso realizando la solicitud de cancelación de autorización. Cuando dos o más subprogramas se ejecutan en paralelo, si uno falla entonces los demás deben ser abortados, dado que el fallo de una rama conlleva al fallo de la tarea en general. Por ejemplo, supongamos que a mitad de la escritura del artículo, Alice se da cuenta de que hay un error fatal en sus resultados, por lo que notifica a CALO que no podrá completar el artículo para la fecha límite. El fallo de la tarea de Escritura de Pista debería provocar que la tarea de Solicitar Autorización que se está ejecutando en paralelo sea abortada. 3. Cuando un evento de ejecución altera la importancia de una tarea o intención existente, el agente debe deliberar si el/los plan(es) existente(s) deben continuar. Por ejemplo, supongamos que Alice encarga a CALO una nueva tarea de alta prioridad para comprar una computadora portátil de reemplazo, pero que Alice no tiene suficientes fondos para comprar la computadora portátil y asistir a IJCAI. Razonar sobre los requisitos de recursos [20, 10] hará que el agente se dé cuenta de que no puede completar exitosamente ambas tareas. Si hay alguna diferencia entre cómo abortar una tarea que se realiza externamente y cómo abortar una que ahora se sabe que es imposible, el método de aborto puede detectar las circunstancias y manejar la situación de manera apropiada. Dado que la nueva tarea tiene mayor importancia, un agente racional evaluará su mejor curso de acción y puede decidir abortar o al menos suspender la tarea existente de presentar un documento y las intenciones derivadas de ella [12]. La semántica operativa que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones mencionadas anteriormente. La tercera situación implica deliberar sobre la importancia de una tarea, la cual depende de varios factores como la prioridad de la tarea. Aunque esta deliberación está más allá del alcance de este documento, es un tema complementario de nuestro trabajo futuro. Ten en cuenta que las situaciones anteriores se aplican a metas de logro, para las cuales la tarea se completa cuando se logra un estado particular del mundo (por ejemplo, asegurarse de que tengamos autorización). Diferentes formas de razonamiento se aplican a otros tipos de objetivos, como los objetivos de mantenimiento, donde el objetivo se satisface al mantener un estado del mundo durante algún período de tiempo (por ejemplo, mantener $100 en efectivo). La representación del método de aborto tiene la intención de que una tarea o plan se detenga, y que tanto la tarea o plan como todos sus hijos dejen de ejecutarse, y que se realicen los métodos de limpieza apropiados según sea necesario. A diferencia de los sistemas de planificación offline, los agentes BDI están situados: realizan deliberación en línea y sus acciones cambian el estado del mundo. Como resultado, los efectos de muchas acciones no pueden ser simplemente deshechos. Además, el proceso de deshacer puede causar efectos adversos. Por lo tanto, los métodos de limpieza que especificamos son procedimientos de recuperación hacia adelante que intentan garantizar un estado estable y que también pueden, si es posible, recuperar recursos. La representación común de un plan en sistemas de estilo BDI como JACK y SPARK incluye un método de fallo, que es el método de limpieza designado invocado cuando el plan falla. Para esto, agregamos el método de aborto, que se invoca si se va a abortar el plan. En nuestro ejemplo, el método de aborto para el plan de Envío de Reunión de Soporte consiste en invocar la sub-tarea Cancelar Número de Documento. El método de aborto no necesita abortar explícitamente la solicitud de autorización, ya que el agente invocará el método de aborto para la subtarea de manera apropiada, como detallamos a continuación. La suposición aquí es que, al igual que en el método de falla, el programador del sistema del agente tiene la oportunidad de especificar un método de aborto sensato que tenga en cuenta el punto en el plan en el que se va a ejecutar el aborto. Para cualquier plan, el método de aborto es opcional: si no se especifica un método de aborto, el agente no toma ninguna acción específica para este plan. Sin embargo, las reglas de comportamiento predeterminadas de los agentes siguen aplicándose, por ejemplo, si intentar de nuevo un plan alternativo para la tarea principal. Se debe tener en cuenta que no es necesario una representación explícita de los métodos de limpieza para las tareas, ya que las tareas se realizan ejecutando algún plan o planes. Por lo tanto, abortar una tarea significa abortar el plan actual que se está ejecutando para realizar esa tarea, como describiremos a continuación. Invocación del método de aborto. Ahora describimos de manera informal la acción de los agentes al abortar planes y tareas. Cuando un plan P es abortado: 1. Abortar cada sub-tarea que sea un hijo activo de P. Un hijo activo es aquel que fue desencadenado por P y actualmente está en ejecución. 2. Cuando ya no haya más niños activos, invoque el método de aborto del plan P. 3. Indique un fallo en el plan para TP, la tarea principal de P. Se señala aquí que si la tarea principal TP no debe ser abortada, entonces el agente puede elegir otro plan aplicable para satisfacer TP. 10 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Cuando una tarea (o sub-tarea) T es abortada: 1. Abortar el plan activo actual para satisfacer T (si lo hay). 2. Cuando ya no haya más procesos secundarios activos, elimine la tarea. El agente ya no persigue a T. 3. Ten en cuenta que cuando se aborta el plan activo actual para realizar T, no se deben intentar otros planes aplicables para realizar T, ya que es la tarea que se va a abortar. Para evitar esfuerzos de limpieza en cascada infinita, asumimos que los métodos de aborto nunca serán abortados ni fallarán. En realidad, sin embargo, un método de aborto puede fallar. En este caso, al no contar con un mecanismo de manejo más sofisticado, el agente simplemente deja de ejecutar el método de aborto fallido sin más deliberación. La suposición que hacemos no es, por lo tanto, un reflejo de la complejidad total de la realidad, sino una que es pragmática en términos del ciclo de ejecución del agente; el enfoque para el manejo de fallos de [21] hace la misma suposición. En sistemas como SPARK, el programador puede especificar un comportamiento alternativo para un método de fallo o aborto fallido mediante procedimientos a nivel meta. También asumimos que los métodos de falla y aborto terminan en tiempo finito. 4. SEMÁNTICA OPERACIONAL Proporcionamos la semántica para los procesos de falla y aborto de tareas y planes descritos anteriormente. Utilizamos el lenguaje CAN inicialmente definido en [23] y posteriormente extendido como CANPLAN en [17] para incluir un componente de planificación y luego como CANPLAN2 en [18] para mejorar los mecanismos de adopción y eliminación de objetivos. Las extensiones también simplificaron la semántica en el trabajo anterior. Utilizamos algunas de estas simplificaciones para proporcionar un breve resumen del lenguaje CAN en la Sección 4.1. Tras una presentación de la semántica operacional de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos. 4.1 Lenguaje CAN CAN es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentSpeak [15] y Kinnys Ψ [7], ambos de los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados. CAN proporciona un constructo de objetivo explícito que captura tanto los aspectos declarativos como los procedimentales de un objetivo. Los objetivos son persistentes en CAN en el sentido de que, cuando un plan falla, se intenta otro plan aplicable. Esto equivale al mecanismo predeterminado de manejo de fallos que se encuentra típicamente en sistemas BDI implementados como JACK [2]. En sistemas prácticos, las tareas suelen traducirse en eventos que desencadenan la ejecución de algunos planes. Esto también es cierto en el lenguaje CAN, pero, para mantener la persistencia de los objetivos, se introduce un constructo de objetivo. Esto se denota por Objetivo ` φs, P, φf ´, donde φs es la condición de éxito que determina cuándo se considera que el objetivo se ha logrado, φf es una condición de fracaso bajo la cual se considera que el objetivo ya no es alcanzable o relevante, y P es un programa para lograr el objetivo, que se abortará una vez que φs o φf se vuelvan verdaderos. El comportamiento de un agente está especificado por una biblioteca de planes, denotada por Π, que consiste en una colección de cláusulas de planes de la forma e : c ← P, donde e es un evento, c es una condición de contexto (una fórmula lógica sobre las creencias de los agentes que debe ser verdadera para que el plan sea aplicable) y P es el cuerpo del plan. El cuerpo del plan es un programa que se define recursivamente de la siguiente manera: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Objetivo ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 Un c omitido es equivalente a verdadero. Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figura 1: Reglas operativas de CAN. donde P1, . . . , Pn son ellos mismos programas, act es una acción primitiva que no está más especificada, y +b y −b son operaciones para añadir y eliminar creencias. La base de creencias contiene átomos de creencias fundamentales en forma de relaciones de primer orden, pero podría ser extendida ortogonalmente a otras lógicas. Se asume que se proporcionan operaciones bien definidas para verificar si una condición se sigue de un conjunto de creencias (B |= c), para agregar una creencia a un conjunto de creencias (B ∪ {b}), y para eliminar una creencia de un conjunto de creencias (B \\ {b}). ?φ es una prueba para la condición φ, y !e5 es un evento6 que se publica desde dentro del programa. Los constructos compuestos son secuenciación (P1; P2), ejecución paralela (P1 P2) y metas (Meta ` φs, P, φf ´ ). Lo anterior define el idioma del usuario. Además, se utilizan un conjunto de formas compuestas auxiliares internamente al asignar semántica a los constructos. nil es el programa básico (terminante). Cuando un evento coincide con un conjunto de cláusulas de plan, estas se recopilan en un conjunto de alternativas protegidas (c1: P1, ..., cn: Pn). La otra forma compuesta auxiliar, , es un operador de elección dual a la secuenciación: P1 P2 ejecuta P1 y luego ejecuta P2 solo si P1 falló. Un resumen de la semántica operacional para CAN de acuerdo con [23] y siguiendo algunas de las simplificaciones de [17] es el siguiente. Una configuración básica S = B, G, Γ consiste en la base de creencias actual B del agente, el conjunto actual de metas G que se persiguen (es decir, un conjunto de fórmulas) y el programa actual P que se está ejecutando (es decir, la intención actual). Una transición S0 −→ S1 especifica que ejecutar S0 durante un paso único produce la configuración S1. S0 −→∗ Sn es el cierre reflexivo transitivo usual de −→: Sn es el resultado de una o más transiciones de un solo paso. Una regla de derivación S −→ Sr S −→ Sr consiste en un conjunto (posiblemente vacío) de premisas, que son transiciones junto con algunas condiciones auxiliares (numerador), y una única transición conclusión derivable de estas premisas (denominador). La Figura 1 muestra algunas de las reglas operativas. La regla de Evento maneja eventos de tarea recopilando todas las cláusulas de plan relevantes para el evento en cuestión: para cada cláusula de plan e : ψi ← Pi, si hay un unificador más general, θ = mgu(e, e) de e y el evento en 5 Donde es obvio que e es un evento, a veces excluiremos el signo de exclamación para mayor legibilidad. 6 Típicamente un objetivo de logro. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 11 B |= φs B, Objetivo ` φs, P, φf ´ −→ B, verdadero Gs B |= φf B, Objetivo ` φs, P, φf ´ −→ B, falla Gf P = Objetivo ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Objetivo ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Objetivo ` φs, P, φf ´ −→ B , Objetivo ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {verdadero, falla} B, Objetivo ` φs, P, φf ´ −→ B, Objetivo ` φs, P2 £ P2, φf ´ GR Figura 2: Reglas para objetivos en CAN. pregunta, entonces la regla construye una alternativa guardada ψiθ: Piθ. La regla Select selecciona un cuerpo de plan aplicable de un conjunto de alternativas relevantes (restantes): el programa P Δ establece que el programa P debe intentarse primero, recurriendo a las alternativas restantes, Δ \\ P, si es necesario. Esta regla y la regla de fallo se utilizan juntas para el manejo de fallos: si el programa actual Pi de una cláusula de plan para una tarea falla, primero se aplica la regla de fallo, y luego, si es posible, la regla Select elegirá otra alternativa aplicable para la tarea si existe alguna. Rule Sequence maneja la secuenciación de programas de la manera habitual. Las reglas Parallel1 y Parallel2 definen la posible intercalación al ejecutar dos programas en paralelo. La Figura 2 presenta reglas simplificadas para tratar con objetivos, en línea con las presentadas en [17]. La primera regla establece que un objetivo tiene éxito cuando φs se vuelve verdadero; la segunda regla establece que un objetivo falla cuando φf se vuelve verdadero. La tercera regla GI inicializa la ejecución de un programa de metas actualizando la base de metas y estableciendo el programa en la meta como P £ P; el primer P se ejecutará y el segundo P se utiliza para hacer un seguimiento del programa original para la meta. La cuarta regla GS ejecuta un solo paso del programa de objetivos. La regla final GR reinicia el programa original (codificado como P2 del par P1 £ P2) cada vez que el programa actual ha terminado pero el objetivo deseado y aún posible no se ha logrado. 4.2 Abortando Intenciones y Manejando Fallas A continuación, introducimos la capacidad de especificar programas manejadores, en forma de métodos de falla y aborto, que se ocupan de la limpieza requerida cuando un programa dado falla o es abortado. No asociamos los métodos de falla y aborto con cláusulas de plan o con tareas (eventos), sino que introducimos una nueva construcción de programa que especifica los métodos de falla y aborto para un programa arbitrario. El constructo FAb(P, PF, PA) ejecuta el programa P. En caso de que P falle, ejecuta el programa de manejo de fallos PF; si P necesita ser abortado, ejecuta el programa de manejo de aborto PA. Por lo tanto, para agregar los métodos de falla y aborto PF y PA a una cláusula de plan e : c ← P, escribimos e : c ← FAb(P, PF, PA). Con la introducción de la capacidad de abortar programas, modificamos la construcción paralela para permitir que el fallo de una rama aborte la otra. Debemos tener en cuenta la posible existencia de métodos de aborto en la rama abortada. De manera similar, con el constructo de Objetivo ya no podemos abandonar por completo el programa que contiene tan pronto como se cumpla la condición de éxito o fracaso; ahora debemos tener en cuenta la existencia de cualquier método de aborto aplicable al programa. Proporcionamos la semántica de un lenguaje de agente aumentado que contiene el constructo FAb al definir una transformación de origen, similar a la expansión de macros, que mapea una biblioteca de planes que contiene el constructo FAb(P, PF, PA) en CAN estándar (casi). La única extensión no estándar a CAN es un constructo de espera hasta que se cumpla una condición. Explicamos esta simple modificación del constructo paralelo a continuación cuando llegamos a la traducción del constructo de la Meta. Primero describimos la naturaleza general de la transformación de la fuente, que resulta ser bastante simple para la mayoría de las construcciones del lenguaje, y luego nos concentramos en los tres casos más complejos: las construcciones FAb, paralela y Goal. Un problema clave es que los constructos FAb pueden estar anidados, ya sea directa o indirectamente. Llamemos a cada instancia del constructo en tiempo de ejecución un posible punto de aborto (pap). Donde estos constructos están anidados, es importante que antes de que se ejecute el método de falla o aborto de un pap padre, se ejecuten primero los programas de métodos de falla o aborto de los paps hijos, como se describe anteriormente en la Sección 3. La necesidad de coordinar la ejecución de los métodos de aborto de paps anidados requiere que haya alguna forma de identificar los padres e hijos de un pap en particular. Logramos esto como parte de la transformación de origen al llevar un registro explícito del contexto de ejecución como un parámetro adicional en los eventos y una variable adicional dentro de cada cuerpo del plan. La transformación de origen reemplaza cada cláusula del plan de la forma e : c ← P con una cláusula del plan e(v) : c ← μv(P) donde v es una variable libre, no presente previamente en la cláusula del plan. Esta variable se utiliza para llevar un registro del contexto de ejecución. El valor de la variable de contexto es una lista de identificadores, donde cada nuevo párrafo está representado al anteponer un nuevo identificador al contexto. Por ejemplo, si los identificadores son enteros, el contexto de un documento puede ser representado por una lista [42, 1] y el contexto introducido por un nuevo documento puede ser representado por [52, 42, 1]. Nos referiremos a los paps por el contexto en lugar del nuevo identificador agregado, por ejemplo, por [51, 42, 1] y no solo por 51. Esto nos permite equiparar la relación de ancestro entre paps con la relación de sufijo de lista en los contextos relevantes, es decir, v es un ancestro de v si y solo si v es un sufijo de v. Para la mayoría de los constructos CAN, la variable de contexto no se utiliza o se pasa sin cambios: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) Queda por especificar la transformación μv(·) en tres casos: los constructos FAb, paralelo y Goal. Estos son más complejos en el sentido de que la fuente transformada necesita crear dinámicamente un nuevo identificador de pap, para usarlo como un nuevo contexto dentro de la construcción, y para llevar un registro de cuándo el pap está activo (es decir, actualmente en ejecución) añadiendo y eliminando creencias sobre el contexto. Introduzcamos la acción primitiva prependID(v, v) que crea un nuevo identificador pap y lo antepone a la lista v, dando como resultado la lista v. También introducimos los siguientes predicados: • a(v) - el pap v está actualmente activo. • abort(v) - el pap v debe ser abortado (después de abortar a todos sus descendientes). Una alternativa sería utilizar predicados a nivel meta que reflejen el estado actual de la estructura de intenciones. La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) • f(v) - el programa del pap v ha fallado. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))el pap v es un ancestro del pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v no tiene hijos activos. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - debemos abortar v, es decir, abort es verdadero para v o algún ancestro; sin embargo, debemos esperar hasta que no haya hijos activos de v. • san(v) ≡ sa(v) ∧ nac(v) - debemos abortar v ahora si debemos abortar v y v no tiene hijos activos. Primero consideremos el caso del constructo FAb. La idea es que, cada vez que ocurra un nuevo pap, se utiliza la acción prependID(v, v) para crear una nueva lista de identificadores de pap v a partir de la lista existente v. Luego agregamos la creencia de que v es el contexto activo, es decir, +a(v), y comenzamos a procesar el programa dentro del pap utilizando v en lugar de v como contexto. Necesitamos asegurarnos de retractar la creencia de que v está activo al final, es decir, −a(v). Utilizamos la construcción de Objetivo para permitirnos detener la ejecución de un programa dentro de un pap v cuando sea necesario abortar. Mientras se ejecuta el programa P, sabemos que debemos descartar P e invocar su método de aborto si se le ha indicado a algún ancestro de P que aborte. Esto se representa por el predicado sa(v) siendo verdadero. Sin embargo, debemos asegurarnos de hacer esto solo después de que cada pap de niño haya tenido la oportunidad de invocar su método de aborto y todos estos métodos de aborto hayan sido completados: si abandonamos el programa demasiado pronto, entonces la ejecución de los métodos de aborto de los niños también será abandonada. Por lo tanto, la condición que realmente usamos en la construcción del Objetivo para probar cuándo detener el programa es san(v). Esta condición se basa en el hecho de que a medida que los niños completan sus papilas, eliminan los hechos relevantes. Nuestro uso del constructo Goal es por su capacidad de detener la ejecución de un programa cuando se cumplen ciertas condiciones. Para dejar de lado el aspecto de la repetición de la ejecución hasta que se cumpla una condición, debemos asegurarnos de que la condición de éxito o fracaso del constructo se cumpla una vez que la ejecución del programa tenga éxito o falle. Nos aseguramos de esto al retractar el hecho a(v) en caso de éxito y afirmar el hecho f(v) en caso de fracaso, y al tener las condiciones apropiadas de éxito y fracaso en el Objetivo. Por lo tanto, si falla la construcción del Objetivo, entonces el programa fue abortado o falló. Invocamos el método de fallo o aborto relevante, retiramos el hecho a(v) y luego fallamos. Al juntar todo esto, definimos formalmente μv(FAb(P, PA, PF )) de la siguiente manera, donde v es una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) En segundo lugar, debemos transformar el operador paralelo para asegurar que el fallo de una rama aborte de forma segura la otra. Aquí construimos dos nuevos contextos, v y v, a partir del contexto existente v. Si una rama falla, debe abortar la otra rama. Al final, si se abortó cualquiera de las ramas, entonces debemos fallar. Que v y v sean variables nuevas distintas de cualquier otra en la biblioteca de planes de los agentes. Definimos μv(P1 P2) como: prependID(v, v); prependID(v, v); +a(v); +a(v); (Goal (¬a(v), (μv(P1); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v)) Goal (¬a(v), (μv(P2); −a(v) +f(v)), san(v) ∨ f(v)) (+abort(v); −a(v))); ?¬abort(v) ∧ ¬abort(v) Finalmente, necesitamos modificar las ocurrencias del constructo Goal de dos maneras: primero, asegurarnos de que los métodos de manejo de aborto no se pasen por alto cuando se satisfacen las condiciones de éxito o fracaso, y segundo, activar la interrupción del programa contenido cuando se satisfacen las condiciones de éxito o fracaso. Para transformar el constructo Goal necesitamos extender el estándar CAN con un constructo de espera-hasta-condición. El constructo φ : P no ejecuta P hasta que φ se convierte en verdadero. Aumentamos el lenguaje CAN con las siguientes reglas para el operador de guardia :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false Para especificar μv(Goal ` φs, P, φf ´ ), generamos un nuevo pap y ejecutamos el programa dentro del constructo Goal en este nuevo contexto. Debemos asegurarnos de que la creencia a(v) sea eliminada, ya sea que el objetivo tenga éxito o fracase. Cambiamos la condición de éxito y fracaso del constructo Objetivo a una rama paralela utilizando el constructo de espera-hasta-condición, y modificamos el Objetivo para usar la condición de éxito debería abortar ahora san(v) como condición de éxito. La rama de espera desencadenará la interrupción del programa si se cumple tanto la condición de éxito como la de fracaso. Para evitar cualquier problema al terminar la condición de espera, también finalizamos la espera si el pap ya no está activo. Que v sea una nueva variable distinta de cualquier otra en la biblioteca de planes de los agentes. Definimos μv(Goal ` φs, P, φf ´ ) como: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) El programa P se ejecutará repetidamente hasta que san(v ) se convierta en verdadero. Hay dos formas en que esto puede ocurrir. Primero, si se cumple la condición de éxito φs o la condición de fracaso φf, entonces se ejecuta la segunda rama de la construcción en paralelo. Esto hace que abort(v) se convierta en verdadero, y, después de que se ejecuten los métodos de abortmethods descendientes, san(v) se convierte en verdadero. En este caso, P se elimina, se elimina el a(v), y todo el constructo tiene éxito o fracasa en función de φs. La segunda forma en que san(v) puede volverse verdadero es si v o uno de sus ancestros es abortado. En este caso, una vez que se ejecutan los métodos de aborto de los paps descendientes, san(v) se vuelve verdadero, P se elimina, se elimina la creencia a(v) (permitiendo que la segunda rama paralela se ejecute, instruyendo vacuamente a v a abortar), y la primera rama paralela falla (asumiendo que φs es falso). Ejemplo trabajado 4.3 Echemos un vistazo a la traducción del ejemplo de envío a IJCAI de la Sección 2. Expresaremos las tareas mediante eventos, por ejemplo, la tarea Asignar un Número de Papel la expresamos como el evento APN. Que la salida de la tarea Solicitar autorización sea Y o N, indicando la aprobación o no del gerente de Alicia, respectivamente. Entonces tenemos (al menos) las siguientes dos cláusulas de plan en CAN, para las tareas de Envío de Reunión de Apoyo y Solicitar Autorización de Despeje, respectivamente: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Tenga en cuenta que Envío de Reunión de Apoyo tiene un parámetro m, la reunión de interés (IJCAI, en nuestro ejemplo), mientras que Solicitar Autorización de Despeje no tiene parámetros. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 13. Veamos primero la traducción de la segunda cláusula del plan, para AFC, ya que es la más simple de las dos. Que v y v denoten nuevas variables. Entonces tenemos como cláusula del plan traducido: AFC(v): verdadero ← prependID(v, v); +a(v); Meta(¬a(v), (!SCR(v); !WFR(r, v); ?r = Y; −a(v) +f(v)), san(v) ∨ f(v)) (((?sa(v); !CCR(v)) nil); −a(v); ?falso) Podemos ver que se ha añadido un parámetro de contexto adicional a cada tarea y que el antiguo cuerpo del plan ahora aparece dentro de un constructo de Meta. Si el antiguo cuerpo del plan tiene éxito, la creencia a(v) se retira, lo que hace que el Objetivo tenga éxito. Si el cuerpo del plan antiguo falla, o si la tarea debe ser abortada, el constructo de Objetivo falla. Esto es seguido por la ejecución de CCR (en caso de un aborto), la retracción de a(v), y el fallo. La traducción de la primera cláusula del plan, para SMS, es más compleja, debido a la estructura paralela que introduce paps anidados: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Meta ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Meta ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Meta ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Aquí podemos ver que si la tarea !TWP(v ) falla, entonces se afirmará f(v ), lo que hará que falle la construcción de Meta que lo contiene, y llevará a que se afirme abort(v ). Si la tarea !WFR(r, v ) en la expansión de !AFC(v ) todavía se está ejecutando y no tiene paps hijos activos, entonces sa(v ) y sa(v ) serán verdaderos; sin embargo, solo san(v ) y no san(v ) serán verdaderos. Este conjunto de condiciones hará que el constructo Goal en la primera cláusula del plan falle, deteniendo la ejecución de !WFR(r, v). La tarea !CCR(v) será ejecutada. Una vez que esta tarea se complete, la creencia a(v) se retira, lo que hace que san(v) se convierta en verdadero, lo que lleva a que la primera construcción de objetivo de la segunda cláusula del plan falle. Si bien las cláusulas del plan traducido parecen complicadas, observe que la traducción de las cláusulas del plan inicial es completamente automatizada, de acuerdo con las reglas establecidas en la Sección 4.2. Las cláusulas del plan traducido, con la semántica de PUEDE aumentada por nuestra construcción de condición de esperar-hasta, especifican así la operación del agente para manejar tanto el fallo como la interrupción del ejemplo. 5. El fallo del plan se maneja en la versión extendida de AgentSpeak encontrada en el sistema Jason [6]. Los planes de limpieza de fallas se activan a partir de eventos de eliminación de objetivos −!g. Tales planes, similares a nuestros métodos de fracaso, están diseñados para que el agente efectúe cambios de estado (actúe para deshacer sus acciones anteriores) antes de posiblemente intentar otro plan para lograr el objetivo fallido g. Dados los constructos de Jason para abandonar un objetivo con una indicación de si intentar o no un plan alternativo para él, H¨ubner et al. [6] proporcionan una descripción informal de cómo un agente de Jason modifica su estructura de intenciones cuando ocurre un evento de fracaso del objetivo. En un plan de eliminación de objetivos, el programador puede especificar cualquier acción de deshacer y si intentar de nuevo el objetivo. Si no se proporciona un plan de eliminación de objetivos, el comportamiento predeterminado de Jason es no volver a intentar el objetivo. El manejo de fallos se aplica solo a los planes desencadenados por la adición de un logro o meta de prueba; en particular, los eventos de eliminación de metas no se publican por el fallo de un plan de eliminación de metas. Además, la semántica informal de [6] no considera submetas paralelas (es decir, el constructo CAN), ya que dicha ejecución no forma parte del lenguaje de Jason. La implementación de H¨ubner et al. [6] requiere acciones internas de Jason. Un requisito para implementar nuestro enfoque es una capacidad reflexiva en la implementación del agente BDI. Las implementaciones adecuadas del formalismo BDI son JACK [2], Jadex [14] y SPARK [9]. Los tres permiten métodos a nivel meta que son activados por eventos meta como la adopción de objetivos o el fracaso de un plan, y ofrecen capacidades introspectivas sobre los estados de objetivo e intención. Tales instalaciones de nivel meta también son requeridas por el enfoque de Unruh et al. [21], quienes definen la compensación semántica basada en objetivos para un agente. Los objetivos de manejo de fallos son invocados de acuerdo con las reglas de estrategia de manejo de fallos, por un agente dedicado Componente de Manejo de Fallos (FHC) que sigue la ejecución de la tarea. Estos objetivos son especificados por el programador del agente y se adjuntan a las tareas, de manera similar a cómo nuestro constructo FAb(P, PF, PA) asocia métodos de falla y aborto con un plan P. Sin embargo, cabe destacar que, a diferencia tanto de [6] como de nuestra semántica, [21] adjuntan el conocimiento de manejo de fallas a nivel de objetivo, no de plan. Sus objetivos de manejo de fallos pueden consistir en objetivos de estabilización que realicen una limpieza localizada e inmediata para restaurar el estado de los agentes a un estado conocido y estable, y objetivos de compensación que realicen acciones de deshacer. Los objetivos de compensación se activan al abortar un objetivo, y no necesariamente al fallar en el objetivo (es decir, si el FHC indica al agente que vuelva a intentar el objetivo fallido y el nuevo intento tiene éxito). El enfoque FHC se define a nivel de objetivo para facilitar la especificación abstracta del conocimiento de manejo de fallos; el FHC decide cuándo abordar un fallo y qué hacer (es decir, qué objetivos de manejo de fallos invocar), separando este conocimiento del cómo implementar acciones correctivas (es decir, qué plan ejecutar para cumplir con el objetivo de manejo de fallos adoptado). Esto contrasta con el manejo simplista de fallas a nivel de plan en el que el qué y el cómo se entrelazan en el conocimiento de la tarea del dominio. Si bien nuestro enfoque está definido a nivel de plan, nuestra semántica BDI extendida permite la separación de la ejecución y el manejo de fallos. Además, el FHC mantiene explícitamente estructuras de datos para rastrear la ejecución de agentes. Aprovechamos las estructuras de ejecución existentes y la capacidad autorreflexiva de un agente BDI para lograr tanto la interrupción como el manejo de fallos sin costos adicionales. Las reglas de estrategia de manejo de fallos de FHC (por ejemplo, si volver a intentar un objetivo fallido) son reemplazadas por instrucciones en nuestros planes de PF y PA, junto con manejadores de fallos predeterminados a nivel meta de acuerdo con la naturaleza de los agentes (por ejemplo, comprometidos ciegamente). El enfoque FHC es independiente de la arquitectura del agente en sí, a diferencia de nuestro trabajo que está dedicado al formalismo BDI (aunque no está ligado a ningún sistema de agente en particular). Por lo tanto, no se desarrollan semánticas formales en [21]; la operación de los FHCs se presenta como 14 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) un protocolo basado en estados. Este enfoque, junto con el punto de control estatal, se utiliza para sistemas multiagente en [22]. La arquitectura resultante incorpora su enfoque de manejo de fallos dentro de una arquitectura de procesamiento en pares para la recuperación de fallos de agentes. Otro trabajo sobre el manejo de excepciones multiagente incluye los agentes de manejo de excepciones distribuidos AOEXs [5], y los centinelas similares de [8]. En ambos casos, la lógica de manejo de fallos y el conocimiento están desacoplados de los agentes; en contraste, mientras se separa el manejo de excepciones del conocimiento específico del dominio, tanto el enfoque de Unruh et al. como nuestro enfoque retienen la lógica de manejo de fallos dentro de un agente. 6. CONCLUSIÓN Y TRABAJO FUTURO Las tareas y planes de un agente pueden no llegar a completarse con éxito, ya sea por la decisión del agente de abortarlos (quizás a petición de otro agente), o por factores imprevistos que llevan al fracaso. En este artículo hemos presentado un enfoque basado en procedimientos que incorpora la interrupción de tareas y planes en el ciclo de deliberación de un agente de estilo BDI, proporcionando así un enfoque unificado para el fracaso y la interrupción. Nuestra contribución principal es un análisis de los requisitos sobre la operación del agente para abortar tareas y planes, y una semántica operativa correspondiente para abortar en el lenguaje abstracto del agente CAN. Estamos planeando implementar una instancia de nuestro enfoque en el sistema de agentes SPARK [9]; en particular, el trabajo de este artículo será la base para el mecanismo de manejo de abortos de SPARK. También estamos desarrollando una herramienta de análisis para nuestra versión extendida de CAN como base para experimentación. Un agente inteligente no solo manejará con gracia tareas y planes fallidos, sino que también reflexionará sobre sus actitudes cognitivas para decidir su próximo curso de acción. Hemos asumido el comportamiento predeterminado de un agente de estilo BDI, de acuerdo con su naturaleza: por ejemplo, volver a intentar alternativas de un plan fallido hasta que uno tenga éxito o hasta que no queden planes alternativos (en cuyo caso fallar la tarea). El trabajo futuro consiste en poner nuestro enfoque al servicio de un razonamiento de agente más dinámico, como la introspección que un agente capaz de razonar sobre los efectos de la interacción de tareas y los requisitos de recursos puede lograr [19, 12]. Relacionado con esto está determinar el costo de abortar una tarea o un plan, y utilizarlo como un insumo en el proceso de deliberación. Esto influiría en particular en el compromiso que el agente tiene hacia una tarea específica: a mayor costo, mayor compromiso. Nuestra suposición de que los métodos de aborto no fallan, como se discutió anteriormente, es una suposición pragmática. Sin embargo, este es un tema que merece una mayor exploración, ya sea para desarrollar supuestos más débiles que también sean prácticos, o para analizar las condiciones bajo las cuales nuestra suposición es realista. Un elemento adicional de interés es extender nuestro enfoque al fracaso y la interrupción a los objetivos de mantenimiento [1]. Para tales objetivos, se necesita una semántica operativa diferente para la interrupción que para los objetivos de logro, para que coincida con la diferencia en la semántica de los propios objetivos. Agradecimientos Agradecemos a Lin Padgham y a los revisores anónimos por sus comentarios. El primer autor agradece el apoyo del Consejo de Investigación Australiano y del Software Orientado a Agentes bajo la subvención LP0453486. El trabajo de los dos autores en SRI International fue apoyado por la Agencia de Proyectos de Investigación Avanzada de Defensa (DARPA) bajo el Contrato No. NBCHD030010. Cualquier opinión, hallazgo, conclusión o recomendación expresada en este material son responsabilidad de los autores y no reflejan necesariamente la visión de DARPA o el Departamento del Interior-Centro Nacional de Negocios. 7. REFERENCIAS [1] L. Braubach, A. Pokahr, D. Moldt y W. Lamersdorf. Representación de objetivos para sistemas de agentes BDI. En Actas del Segundo Congreso Internacional. Taller sobre Programación de Sistemas Multiagente (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson y A. Lucas. Agentes inteligentes JACK: componentes para agentes inteligentes en Java. AgentLink News, Edición 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira y P. Henderson. Ampliando el concepto de compensación de transacciones. Revista de Sistemas de IBM, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk y J.-J. C. Meyer. Tipos de objetivos en la programación de agentes. En Proc. de AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy y E. Kendall. Aoex: Un marco de manejo de excepciones basado en agentes para construir sistemas de software confiables, distribuidos y abiertos. En Actas de la Séptima Conferencia Conjunta sobre Ingeniería de Software Basada en el Conocimiento, 2006. [6] J. F. H¨ubner, R. H. Bordini y M. Wooldridge. Programación de metas declarativas utilizando patrones de planificación. En Actas de la 4ta Conferencia Internacional. Taller sobre Lenguajes y Tecnologías Declarativos de Agentes, 2006. [7] D. Kinny. El cálculo Psi: un lenguaje algebraico de agentes. En Proc. de ATAL01, 2001. [8] M. Klein, J. A. Rodríguez-Aguilar y C. Dellarocas. Utilizando servicios de manejo de excepciones independientes del dominio para habilitar sistemas multiagente abiertos robustos: El caso de la muerte del agente. Agentes Autónomos y Sistemas Multiagente, 7(1-2):179-189, 2003. [9] D. Morley y K. Myers. El marco de agentes SPARK. En Proc. de AAMAS04, 2004. [10] D. Morley, K. L. Myers y N. Yorke-Smith. Refinamiento continuo de estimaciones de recursos del agente. En Proc. de AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack y M. Tambe. Un asistente personal inteligente para la gestión de tareas y tiempo. Revista de Inteligencia Artificial, 28, 2007. Aparecer. [12] K. L. Myers y N. Yorke-Smith. Un marco cognitivo para la delegación a un agente de usuario asistente. En Actas del Simposio de Otoño de AAAI 2005 sobre Asistentes de Resolución de Problemas de Iniciativa Mixta, 2005. [13] L. Padgham y M. Winikoff. Desarrollo de Sistemas de Agentes Inteligentes: Una Guía Práctica. John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, y W. Lamersdorf. Jadex: Un motor de razonamiento BDI. En R. Bordini, M. Dastani, J. Dix y A. E. F. Seghrouchni, editores, Programación Multiagente. Springer, 2005. [15] A. S. Rao. \n\nSpringer, 2005. [15] A. S. Rao. AgentSpeak(L): Los agentes BDI se expresan en un lenguaje lógico computable. En Actas del Séptimo Taller Europeo sobre Modelado de Agentes Autónomos en un Mundo Multiagente, 1996. [16] A. S. Rao y M. P. Georgeff. Una arquitectura abstracta para agentes racionales. En Proc. de KR92, 1992. [17] S. Sardiña, L. de Silva y L. Padgham. Planificación jerárquica en lenguajes de programación de agentes BDI: un enfoque formal. En Proc. de AAMAS06, 2006. [18] S. Sardina y L. Padgham. Objetivos en el contexto del fracaso del plan BDI y la planificación. En Proc. de AAMAS07, 2007. [19] J. Thangarajah, L. Padgham y M. Winikoff. Detectar y aprovechar la interacción positiva de objetivos en agentes inteligentes. En Proc. de AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham y K. Fischer. Evitando conflictos de recursos en agentes inteligentes. En Proc. de ECAI-02, 2002. [21] A. Unruh, J. Bailey y K. Ramamohanarao. Un marco para la compensación semántica basada en objetivos en sistemas de agentes. En Actas de la Primera Conferencia Internacional. Taller sobre Seguridad en Sistemas Multiagente, 2004. [22] A. Unruh, H. Harjadi, J. Bailey y K. Ramamohanarao. Gestión de recuperación basada en compensación semántica en sistemas multiagente. En Proc. del Segundo Simposio IEEE sobre Seguridad y Supervivencia Multiagente (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland y J. Thangarajah. Objetivos declarativos y procedimentales en sistemas de agentes inteligentes. En Proc. de KR02, 2002. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 15 ",
            "candidates": [],
            "error": [
                [
                    "métodos de limpieza de aborto",
                    "métodos de limpieza"
                ]
            ]
        },
        "abort-method": {
            "translated_key": "método de aborto",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional <br>abort-method</br>, analogous to the failure method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
                "Our approach associates an <br>abort-method</br> with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which <br>abort-method</br> should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an <br>abort-method</br> to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the <br>abort-method</br>, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the <br>abort-method</br> can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the <br>abort-method</br>, which is invoked if the plan is to be aborted.",
                "In our example, the <br>abort-method</br> for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The <br>abort-method</br> need not explicitly abort Apply For Clearance, because the agent will invoke the <br>abort-method</br> for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible <br>abort-method</br> that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the <br>abort-method</br> is optional: if no <br>abort-method</br> is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an <br>abort-method</br> may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed <br>abort-method</br> with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or <br>abort-method</br> by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or <br>abort-method</br> of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its <br>abort-method</br> if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its <br>abort-method</br> and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [
                "We augment each plan with an optional <br>abort-method</br>, analogous to the failure method found in some agent programming languages.",
                "Our approach associates an <br>abort-method</br> with each plan.",
                "The question remains which <br>abort-method</br> should be invoked, and in what manner.",
                "An alternative to attaching an <br>abort-method</br> to each plan is to attach such methods to each atomic action.",
                "In doing so it must invoke the <br>abort-method</br>, in this case thus performing Cancel Clearance Request.3 2."
            ],
            "translated_annotated_samples": [
                "Añadimos a cada plan un <br>método de aborto</br> opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes.",
                "Nuestro enfoque asocia un <br>método de aborto</br> con cada plan.",
                "La pregunta sigue siendo qué <br>método de aborto</br> se debe invocar, y de qué manera.",
                "Una alternativa a adjuntar un <br>método de aborto</br> a cada plan es adjuntar dichos métodos a cada acción atómica.",
                "Al hacerlo, debe invocar el <br>método de aborto</br>, en este caso realizando la solicitud de cancelación de autorización."
            ],
            "translated_text": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un <br>método de aborto</br> opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). Abortar una tarea o plan es distinto de su fracaso. El fracaso refleja una incapacidad para desempeñarse y no anula la necesidad de desempeñarse, por ejemplo, una respuesta razonable al fracaso puede ser intentarlo de nuevo. Por el contrario, abortar no dice nada sobre la capacidad de realizar; simplemente elimina la necesidad. El fracaso se propaga de abajo hacia arriba, mientras que la interrupción se propaga de arriba hacia abajo. El potencial de ejecutar subplanes de forma simultánea introduce diferentes complejidades para la interrupción y el fallo. Para abortar, significa que varios subplanes concurrentes pueden necesitar ser abortados a medida que se propaga el aborto hacia abajo. Para el fallo, significa que los planes paralelos hermanos pueden necesitar ser abortados a medida que el fallo se propaga hacia arriba. Ha habido una cantidad considerable de trabajo sobre fallos en los planes (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallos. Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de aborto más allá de la simple eliminación de los planes y tareas actualmente previstos, lo cual no aborda la limpieza requerida. Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de un constructo paralelo. Se puede considerar que ambas tareas se realizan y se tienen objetivos para lograr un cierto estado del mundo. Una tarea puede considerarse un objetivo de lograr el estado de la tarea una vez realizada, y un objetivo puede considerarse una tarea de llevar a cabo ese estado en el mundo. Adoptamos la última perspectiva y usamos la palabra \"tarea\" también para referirnos a los objetivos. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS falla (los enfoques comunes incluyen permitir que la otra rama se ejecute hasta su finalización sin obstáculos o eliminarla por completo). En este documento discutimos en detalle la incorporación de métodos de limpieza de aborto en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto. Una característica clave de nuestro enfoque basado en procedimientos es que permitimos que cada plan ejecute un código particular en caso de fallo y de aborto. Esto permite que un plan intente asegurar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar de otra manera antes de salir. Por consiguiente, un desafío técnico central es gestionar la ejecución ordenada del código de limpieza adecuado. Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una semántica operativa para abortar en el lenguaje de agente abstracto CAN [23, 17]. Esto nos permite especificar un nivel adecuado de detalle para el modelo de ejecución, sin centrarnos en las construcciones específicas de ningún sistema de agentes en particular, como JACK [2], Jadex [14], Jason [6] o SPARK [9]. Nuestro enfoque se centra en un único agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas de un solo agente y multiagentes (por ejemplo, [22, 5, 6]). Este documento está organizado de la siguiente manera. En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deberían ocurrir los abortos, y los procedimientos adecuados de representación e invocación. En la Sección 4 mostramos cómo podemos utilizar CAN para especificar formalmente el comportamiento de un plan abortado. La sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro. EJEMPLO MOTIVADOR Alice es una trabajadora del conocimiento asistida por un agente de asistencia personal y de aprendizaje como CALO [11]. Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente CALO adopta la tarea de Presentación de Reuniones de Apoyo (SMS) para ayudarla. El plan de CALO para una tarea de SMS en el caso de una presentación en una conferencia consiste en las siguientes sub tareas: 1. Asignar un Número de Documento (APN) para ser utilizado con fines administrativos en la empresa. 2. Seguimiento de la Escritura del Resumen (SER): hacer un seguimiento del progreso de Alicia en la preparación de un resumen. 3. Solicitar autorización de publicación (AFC) del gerente de Alice basado en el resumen y los detalles de la conferencia. 4. Papel de seguimiento de escritura (PSE): llevar un registro del progreso de Alicia en la escritura del papel. 5. Manejo de la presentación de documentos (HPS): seguir los procedimientos internos de la empresa para presentar un documento a una conferencia. Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo. De manera similar, CALO puede realizar la tarea de Solicitar Autorización de Despeje (AFC) mediante un plan que consiste en: 1. Enviar la Solicitud de Autorización (SCR) al gerente de Alice. 2. Espera la respuesta (WFR) del gerente. 3. Confirma que la respuesta fue positiva, y falla en caso contrario. Ahora supongamos que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras está escribiendo el documento. Alice ya no podrá asistir a IJCAI. Por lo tanto, ella instruye a su agente CALO para abortar la tarea de SMS. Abortar la tarea implica abortar tanto el plan de SMS como el subplan de AFC. Abortar el primer plan requiere que CALO notifique al registro de números de papel que el número de papel asignado está obsoleto, lo cual puede lograr mediante la tarea Cancelar Número de Papel (CPN). Abortar el segundo plan requiere que CALO notifique al gerente de Alice que Alice ya no necesita autorización para publicar, lo cual CALO puede lograr invocando la tarea Cancelar Solicitud de Autorización (CCR). Observamos una serie de observaciones importantes del ejemplo. Primero, la decisión de abortar un curso de acción particular puede surgir de las deliberaciones internas del agente (como razonar sobre prioridades en un conflicto por recursos), o de fuentes externas (como otro agente cancelando un compromiso), como en este ejemplo. En este documento solo abordamos el problema de determinar si una tarea o plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se haya tomado esta decisión. Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo. Segundo, una vez que se toma la decisión de abortar el intento de enviar un artículo, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización. En otras palabras, abortar una tarea no es simplemente cuestión de abandonar la tarea y los planes activos asociados: puede haber algunas acciones de limpieza que necesiten realizarse. Esto es similar al caso del fracaso, en el sentido de que también puede haber acciones a tomar cuando una tarea o plan falla. En ambos casos, hay que tener en cuenta que no se trata simplemente de que el agente deshaga sus acciones hasta la fecha; de hecho, esto puede no ser ni posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado del mundo) ni deseable (dependiendo de la semántica de la tarea). Más bien, la limpieza implica compensación a través de acciones de recuperación hacia adelante [3]. Tercero, hay una distinción entre abortar una tarea y abortar un plan. En el primer caso, está claro que todos los planes que se estén ejecutando para realizar la tarea deben ser abortados; en el segundo caso, puede ser que existan mejores alternativas al plan actual y se deba intentar una de estas. Por lo tanto, el aborto o fracaso del plan no necesariamente conduce al aborto o fracaso de la tarea. Dado que las tareas pueden contener sub tareas, las cuales pueden contener más sub tareas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto. Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que una tarea o plan principal es abortado. 3. ABORTANDO TAREAS Y PLANES Como hemos insinuado, el fracaso y abortar son conceptos relacionados. Ambos causan que la ejecución de los planes existentes se detenga y, en consecuencia, que el agente reflexione sobre sus tareas e intenciones actuales. El fracaso y la interrupción, sin embargo, difieren en la forma en que surgen. En caso de fallo, el disparador para detener la ejecución de una tarea o plan proviene de abajo, es decir, del fallo de sub tareas o planes de nivel inferior. En caso de abortar, el disparador proviene de arriba, es decir, de las tareas y los planes principales que iniciaron un plan. En sistemas de estilo BDI como JACK y SPARK, el conocimiento del dominio de los agentes incluye una biblioteca de planes predefinidos de cláusulas de planificación. Cada cláusula de plan tiene un cuerpo de plan, que es un programa (es decir, una combinación de acciones primitivas, subtareas, etc.) que puede ejecutarse en respuesta a una tarea u otro evento si se cumple la condición de contexto de las cláusulas del plan. El agente selecciona y ejecuta instancias de cláusulas de plan para realizar sus tareas. Puede haber más de una cláusula de plan aplicable y, en caso de que una falle, se puede intentar otra aplicable. Los planes pueden tener subtareas que deben tener éxito. CALO solo necesita eliminar las tareas TWA y TWP para abortarlas: por simplicidad, suponemos que no es necesario realizar una limpieza explícita de su estado interno. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) para que el plan tenga éxito. En tales sistemas, ocurre un fallo en el plan si una de las acciones o subtareas dentro del plan falla. La acción de los agentes ante el fracaso del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si se ha intentado un plan y ha resultado en fracaso, o puede intentar planes alternativos y declarar (de hecho, debe declarar) el fracaso de la tarea solo si se han intentado todos los planes alternativos posibles para realizar la tarea y han resultado en fracaso. Observa que, si bien el fracaso de una tarea puede derivar del fracaso de un plan o de una secuencia de fracasos de planes, el fracaso de un plan no tiene por qué llevar al fracaso de la tarea siempre y cuando el agente pueda completar con éxito un plan alternativo. Además, el fracaso de la tarea también puede surgir de forma independiente al fracaso del plan, si el agente decide abortar la tarea. Nuestro enfoque asocia un <br>método de aborto</br> con cada plan. Esto permite al programador especificar acciones de compensación dedicadas según cómo el agente esté intentando realizar la tarea. Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que se pueden realizar dinámicamente de la manera habitual en BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones. La pregunta sigue siendo qué <br>método de aborto</br> se debe invocar, y de qué manera. Dada la complejidad de los espacios de acción de los agentes, no es posible ni deseable enumerar un conjunto estático de reglas. Más bien, el agente invocará sus métodos de aborto dinámicamente de acuerdo al estado de ejecución y sus propios eventos internos. Una alternativa a adjuntar un <br>método de aborto</br> a cada plan es adjuntar dichos métodos a cada acción atómica. Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los métodos de limpieza para el fracaso en los sistemas actuales están adjuntos a los planes. Para entender cómo debería funcionar el proceso de aborto de los agentes, consideramos tres situaciones en las que tiene sentido que un agente considere abortar algunas de sus tareas y planes: 1. Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí mismo, el plan actualmente ejecutado para realizar la tarea debe ser abortado. Por ejemplo, supongamos que la política de la empresa cambia para que los empleados con la antigüedad de Alice tengan automáticamente autorización para publicar artículos. Dado que Alice ahora tiene autorización para publicar su artículo, CALO puede abortar el plan de Solicitar Autorización. Al hacerlo, debe invocar el <br>método de aborto</br>, en este caso realizando la solicitud de cancelación de autorización. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "operational semantics": {
            "translated_key": "semántica operativa",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
                "We provide an <br>operational semantics</br> for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an <br>operational semantics</br> for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The <br>operational semantics</br> we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "<br>operational semantics</br> We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the <br>operational semantics</br> of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the <br>operational semantics</br> for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding <br>operational semantics</br> for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different <br>operational semantics</br> for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [
                "We provide an <br>operational semantics</br> for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an <br>operational semantics</br> for aborting in the abstract agent language CAN [23, 17].",
                "The <br>operational semantics</br> we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "<br>operational semantics</br> We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "Following a presentation of the <br>operational semantics</br> of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems."
            ],
            "translated_annotated_samples": [
                "Proporcionamos una <br>semántica operativa</br> para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK).",
                "Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una <br>semántica operativa</br> para abortar en el lenguaje de agente abstracto CAN [23, 17].",
                "La <br>semántica operativa</br> que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones mencionadas anteriormente.",
                "SEMÁNTICA OPERACIONAL Proporcionamos la semántica para los procesos de falla y aborto de tareas y planes descritos anteriormente.",
                "Tras una presentación de la <br>semántica operacional</br> de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos. 4.1 Lenguaje CAN CAN es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentSpeak [15] y Kinnys Ψ [7], ambos de los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados."
            ],
            "translated_text": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes. Proporcionamos una <br>semántica operativa</br> para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). Abortar una tarea o plan es distinto de su fracaso. El fracaso refleja una incapacidad para desempeñarse y no anula la necesidad de desempeñarse, por ejemplo, una respuesta razonable al fracaso puede ser intentarlo de nuevo. Por el contrario, abortar no dice nada sobre la capacidad de realizar; simplemente elimina la necesidad. El fracaso se propaga de abajo hacia arriba, mientras que la interrupción se propaga de arriba hacia abajo. El potencial de ejecutar subplanes de forma simultánea introduce diferentes complejidades para la interrupción y el fallo. Para abortar, significa que varios subplanes concurrentes pueden necesitar ser abortados a medida que se propaga el aborto hacia abajo. Para el fallo, significa que los planes paralelos hermanos pueden necesitar ser abortados a medida que el fallo se propaga hacia arriba. Ha habido una cantidad considerable de trabajo sobre fallos en los planes (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallos. Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de aborto más allá de la simple eliminación de los planes y tareas actualmente previstos, lo cual no aborda la limpieza requerida. Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de un constructo paralelo. Se puede considerar que ambas tareas se realizan y se tienen objetivos para lograr un cierto estado del mundo. Una tarea puede considerarse un objetivo de lograr el estado de la tarea una vez realizada, y un objetivo puede considerarse una tarea de llevar a cabo ese estado en el mundo. Adoptamos la última perspectiva y usamos la palabra \"tarea\" también para referirnos a los objetivos. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS falla (los enfoques comunes incluyen permitir que la otra rama se ejecute hasta su finalización sin obstáculos o eliminarla por completo). En este documento discutimos en detalle la incorporación de métodos de limpieza de aborto en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto. Una característica clave de nuestro enfoque basado en procedimientos es que permitimos que cada plan ejecute un código particular en caso de fallo y de aborto. Esto permite que un plan intente asegurar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar de otra manera antes de salir. Por consiguiente, un desafío técnico central es gestionar la ejecución ordenada del código de limpieza adecuado. Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una <br>semántica operativa</br> para abortar en el lenguaje de agente abstracto CAN [23, 17]. Esto nos permite especificar un nivel adecuado de detalle para el modelo de ejecución, sin centrarnos en las construcciones específicas de ningún sistema de agentes en particular, como JACK [2], Jadex [14], Jason [6] o SPARK [9]. Nuestro enfoque se centra en un único agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas de un solo agente y multiagentes (por ejemplo, [22, 5, 6]). Este documento está organizado de la siguiente manera. En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deberían ocurrir los abortos, y los procedimientos adecuados de representación e invocación. En la Sección 4 mostramos cómo podemos utilizar CAN para especificar formalmente el comportamiento de un plan abortado. La sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro. EJEMPLO MOTIVADOR Alice es una trabajadora del conocimiento asistida por un agente de asistencia personal y de aprendizaje como CALO [11]. Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente CALO adopta la tarea de Presentación de Reuniones de Apoyo (SMS) para ayudarla. El plan de CALO para una tarea de SMS en el caso de una presentación en una conferencia consiste en las siguientes sub tareas: 1. Asignar un Número de Documento (APN) para ser utilizado con fines administrativos en la empresa. 2. Seguimiento de la Escritura del Resumen (SER): hacer un seguimiento del progreso de Alicia en la preparación de un resumen. 3. Solicitar autorización de publicación (AFC) del gerente de Alice basado en el resumen y los detalles de la conferencia. 4. Papel de seguimiento de escritura (PSE): llevar un registro del progreso de Alicia en la escritura del papel. 5. Manejo de la presentación de documentos (HPS): seguir los procedimientos internos de la empresa para presentar un documento a una conferencia. Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo. De manera similar, CALO puede realizar la tarea de Solicitar Autorización de Despeje (AFC) mediante un plan que consiste en: 1. Enviar la Solicitud de Autorización (SCR) al gerente de Alice. 2. Espera la respuesta (WFR) del gerente. 3. Confirma que la respuesta fue positiva, y falla en caso contrario. Ahora supongamos que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras está escribiendo el documento. Alice ya no podrá asistir a IJCAI. Por lo tanto, ella instruye a su agente CALO para abortar la tarea de SMS. Abortar la tarea implica abortar tanto el plan de SMS como el subplan de AFC. Abortar el primer plan requiere que CALO notifique al registro de números de papel que el número de papel asignado está obsoleto, lo cual puede lograr mediante la tarea Cancelar Número de Papel (CPN). Abortar el segundo plan requiere que CALO notifique al gerente de Alice que Alice ya no necesita autorización para publicar, lo cual CALO puede lograr invocando la tarea Cancelar Solicitud de Autorización (CCR). Observamos una serie de observaciones importantes del ejemplo. Primero, la decisión de abortar un curso de acción particular puede surgir de las deliberaciones internas del agente (como razonar sobre prioridades en un conflicto por recursos), o de fuentes externas (como otro agente cancelando un compromiso), como en este ejemplo. En este documento solo abordamos el problema de determinar si una tarea o plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se haya tomado esta decisión. Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo. Segundo, una vez que se toma la decisión de abortar el intento de enviar un artículo, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización. En otras palabras, abortar una tarea no es simplemente cuestión de abandonar la tarea y los planes activos asociados: puede haber algunas acciones de limpieza que necesiten realizarse. Esto es similar al caso del fracaso, en el sentido de que también puede haber acciones a tomar cuando una tarea o plan falla. En ambos casos, hay que tener en cuenta que no se trata simplemente de que el agente deshaga sus acciones hasta la fecha; de hecho, esto puede no ser ni posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado del mundo) ni deseable (dependiendo de la semántica de la tarea). Más bien, la limpieza implica compensación a través de acciones de recuperación hacia adelante [3]. Tercero, hay una distinción entre abortar una tarea y abortar un plan. En el primer caso, está claro que todos los planes que se estén ejecutando para realizar la tarea deben ser abortados; en el segundo caso, puede ser que existan mejores alternativas al plan actual y se deba intentar una de estas. Por lo tanto, el aborto o fracaso del plan no necesariamente conduce al aborto o fracaso de la tarea. Dado que las tareas pueden contener sub tareas, las cuales pueden contener más sub tareas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto. Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que una tarea o plan principal es abortado. 3. ABORTANDO TAREAS Y PLANES Como hemos insinuado, el fracaso y abortar son conceptos relacionados. Ambos causan que la ejecución de los planes existentes se detenga y, en consecuencia, que el agente reflexione sobre sus tareas e intenciones actuales. El fracaso y la interrupción, sin embargo, difieren en la forma en que surgen. En caso de fallo, el disparador para detener la ejecución de una tarea o plan proviene de abajo, es decir, del fallo de sub tareas o planes de nivel inferior. En caso de abortar, el disparador proviene de arriba, es decir, de las tareas y los planes principales que iniciaron un plan. En sistemas de estilo BDI como JACK y SPARK, el conocimiento del dominio de los agentes incluye una biblioteca de planes predefinidos de cláusulas de planificación. Cada cláusula de plan tiene un cuerpo de plan, que es un programa (es decir, una combinación de acciones primitivas, subtareas, etc.) que puede ejecutarse en respuesta a una tarea u otro evento si se cumple la condición de contexto de las cláusulas del plan. El agente selecciona y ejecuta instancias de cláusulas de plan para realizar sus tareas. Puede haber más de una cláusula de plan aplicable y, en caso de que una falle, se puede intentar otra aplicable. Los planes pueden tener subtareas que deben tener éxito. CALO solo necesita eliminar las tareas TWA y TWP para abortarlas: por simplicidad, suponemos que no es necesario realizar una limpieza explícita de su estado interno. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) para que el plan tenga éxito. En tales sistemas, ocurre un fallo en el plan si una de las acciones o subtareas dentro del plan falla. La acción de los agentes ante el fracaso del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si se ha intentado un plan y ha resultado en fracaso, o puede intentar planes alternativos y declarar (de hecho, debe declarar) el fracaso de la tarea solo si se han intentado todos los planes alternativos posibles para realizar la tarea y han resultado en fracaso. Observa que, si bien el fracaso de una tarea puede derivar del fracaso de un plan o de una secuencia de fracasos de planes, el fracaso de un plan no tiene por qué llevar al fracaso de la tarea siempre y cuando el agente pueda completar con éxito un plan alternativo. Además, el fracaso de la tarea también puede surgir de forma independiente al fracaso del plan, si el agente decide abortar la tarea. Nuestro enfoque asocia un método de aborto con cada plan. Esto permite al programador especificar acciones de compensación dedicadas según cómo el agente esté intentando realizar la tarea. Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que se pueden realizar dinámicamente de la manera habitual en BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones. La pregunta sigue siendo qué método de aborto se debe invocar, y de qué manera. Dada la complejidad de los espacios de acción de los agentes, no es posible ni deseable enumerar un conjunto estático de reglas. Más bien, el agente invocará sus métodos de aborto dinámicamente de acuerdo al estado de ejecución y sus propios eventos internos. Una alternativa a adjuntar un método de aborto a cada plan es adjuntar dichos métodos a cada acción atómica. Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los métodos de limpieza para el fracaso en los sistemas actuales están adjuntos a los planes. Para entender cómo debería funcionar el proceso de aborto de los agentes, consideramos tres situaciones en las que tiene sentido que un agente considere abortar algunas de sus tareas y planes: 1. Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí mismo, el plan actualmente ejecutado para realizar la tarea debe ser abortado. Por ejemplo, supongamos que la política de la empresa cambia para que los empleados con la antigüedad de Alice tengan automáticamente autorización para publicar artículos. Dado que Alice ahora tiene autorización para publicar su artículo, CALO puede abortar el plan de Solicitar Autorización. Al hacerlo, debe invocar el método de aborto, en este caso realizando la solicitud de cancelación de autorización. Cuando dos o más subprogramas se ejecutan en paralelo, si uno falla entonces los demás deben ser abortados, dado que el fallo de una rama conlleva al fallo de la tarea en general. Por ejemplo, supongamos que a mitad de la escritura del artículo, Alice se da cuenta de que hay un error fatal en sus resultados, por lo que notifica a CALO que no podrá completar el artículo para la fecha límite. El fallo de la tarea de Escritura de Pista debería provocar que la tarea de Solicitar Autorización que se está ejecutando en paralelo sea abortada. 3. Cuando un evento de ejecución altera la importancia de una tarea o intención existente, el agente debe deliberar si el/los plan(es) existente(s) deben continuar. Por ejemplo, supongamos que Alice encarga a CALO una nueva tarea de alta prioridad para comprar una computadora portátil de reemplazo, pero que Alice no tiene suficientes fondos para comprar la computadora portátil y asistir a IJCAI. Razonar sobre los requisitos de recursos [20, 10] hará que el agente se dé cuenta de que no puede completar exitosamente ambas tareas. Si hay alguna diferencia entre cómo abortar una tarea que se realiza externamente y cómo abortar una que ahora se sabe que es imposible, el método de aborto puede detectar las circunstancias y manejar la situación de manera apropiada. Dado que la nueva tarea tiene mayor importancia, un agente racional evaluará su mejor curso de acción y puede decidir abortar o al menos suspender la tarea existente de presentar un documento y las intenciones derivadas de ella [12]. La <br>semántica operativa</br> que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones mencionadas anteriormente. La tercera situación implica deliberar sobre la importancia de una tarea, la cual depende de varios factores como la prioridad de la tarea. Aunque esta deliberación está más allá del alcance de este documento, es un tema complementario de nuestro trabajo futuro. Ten en cuenta que las situaciones anteriores se aplican a metas de logro, para las cuales la tarea se completa cuando se logra un estado particular del mundo (por ejemplo, asegurarse de que tengamos autorización). Diferentes formas de razonamiento se aplican a otros tipos de objetivos, como los objetivos de mantenimiento, donde el objetivo se satisface al mantener un estado del mundo durante algún período de tiempo (por ejemplo, mantener $100 en efectivo). La representación del método de aborto tiene la intención de que una tarea o plan se detenga, y que tanto la tarea o plan como todos sus hijos dejen de ejecutarse, y que se realicen los métodos de limpieza apropiados según sea necesario. A diferencia de los sistemas de planificación offline, los agentes BDI están situados: realizan deliberación en línea y sus acciones cambian el estado del mundo. Como resultado, los efectos de muchas acciones no pueden ser simplemente deshechos. Además, el proceso de deshacer puede causar efectos adversos. Por lo tanto, los métodos de limpieza que especificamos son procedimientos de recuperación hacia adelante que intentan garantizar un estado estable y que también pueden, si es posible, recuperar recursos. La representación común de un plan en sistemas de estilo BDI como JACK y SPARK incluye un método de fallo, que es el método de limpieza designado invocado cuando el plan falla. Para esto, agregamos el método de aborto, que se invoca si se va a abortar el plan. En nuestro ejemplo, el método de aborto para el plan de Envío de Reunión de Soporte consiste en invocar la sub-tarea Cancelar Número de Documento. El método de aborto no necesita abortar explícitamente la solicitud de autorización, ya que el agente invocará el método de aborto para la subtarea de manera apropiada, como detallamos a continuación. La suposición aquí es que, al igual que en el método de falla, el programador del sistema del agente tiene la oportunidad de especificar un método de aborto sensato que tenga en cuenta el punto en el plan en el que se va a ejecutar el aborto. Para cualquier plan, el método de aborto es opcional: si no se especifica un método de aborto, el agente no toma ninguna acción específica para este plan. Sin embargo, las reglas de comportamiento predeterminadas de los agentes siguen aplicándose, por ejemplo, si intentar de nuevo un plan alternativo para la tarea principal. Se debe tener en cuenta que no es necesario una representación explícita de los métodos de limpieza para las tareas, ya que las tareas se realizan ejecutando algún plan o planes. Por lo tanto, abortar una tarea significa abortar el plan actual que se está ejecutando para realizar esa tarea, como describiremos a continuación. Invocación del método de aborto. Ahora describimos de manera informal la acción de los agentes al abortar planes y tareas. Cuando un plan P es abortado: 1. Abortar cada sub-tarea que sea un hijo activo de P. Un hijo activo es aquel que fue desencadenado por P y actualmente está en ejecución. 2. Cuando ya no haya más niños activos, invoque el método de aborto del plan P. 3. Indique un fallo en el plan para TP, la tarea principal de P. Se señala aquí que si la tarea principal TP no debe ser abortada, entonces el agente puede elegir otro plan aplicable para satisfacer TP. 10 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Cuando una tarea (o sub-tarea) T es abortada: 1. Abortar el plan activo actual para satisfacer T (si lo hay). 2. Cuando ya no haya más procesos secundarios activos, elimine la tarea. El agente ya no persigue a T. 3. Ten en cuenta que cuando se aborta el plan activo actual para realizar T, no se deben intentar otros planes aplicables para realizar T, ya que es la tarea que se va a abortar. Para evitar esfuerzos de limpieza en cascada infinita, asumimos que los métodos de aborto nunca serán abortados ni fallarán. En realidad, sin embargo, un método de aborto puede fallar. En este caso, al no contar con un mecanismo de manejo más sofisticado, el agente simplemente deja de ejecutar el método de aborto fallido sin más deliberación. La suposición que hacemos no es, por lo tanto, un reflejo de la complejidad total de la realidad, sino una que es pragmática en términos del ciclo de ejecución del agente; el enfoque para el manejo de fallos de [21] hace la misma suposición. En sistemas como SPARK, el programador puede especificar un comportamiento alternativo para un método de fallo o aborto fallido mediante procedimientos a nivel meta. También asumimos que los métodos de falla y aborto terminan en tiempo finito. 4. SEMÁNTICA OPERACIONAL Proporcionamos la semántica para los procesos de falla y aborto de tareas y planes descritos anteriormente. Utilizamos el lenguaje CAN inicialmente definido en [23] y posteriormente extendido como CANPLAN en [17] para incluir un componente de planificación y luego como CANPLAN2 en [18] para mejorar los mecanismos de adopción y eliminación de objetivos. Las extensiones también simplificaron la semántica en el trabajo anterior. Utilizamos algunas de estas simplificaciones para proporcionar un breve resumen del lenguaje CAN en la Sección 4.1. Tras una presentación de la <br>semántica operacional</br> de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos. 4.1 Lenguaje CAN CAN es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentSpeak [15] y Kinnys Ψ [7], ambos de los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados. ",
            "candidates": [],
            "error": [
                [
                    "semántica operativa",
                    "semántica operativa",
                    "semántica operativa",
                    "semántica operacional"
                ]
            ]
        },
        "task": {
            "translated_key": "tarea",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a <br>task</br> or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a <br>task</br> or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular <br>task</br>, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular <br>task</br> or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the <br>task</br> can no longer be achieved, or that some conflicting <br>task</br> now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a <br>task</br> or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A <br>task</br> can be considered a goal of achieving the state of the <br>task</br> having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use <br>task</br> to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a <br>task</br>, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the <br>task</br> of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS <br>task</br> in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the <br>task</br> Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS <br>task</br>.",
                "Aborting the <br>task</br> implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) <br>task</br>2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) <br>task</br>.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a <br>task</br> or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a <br>task</br> is not simply a matter of dropping the <br>task</br> and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a <br>task</br> or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the <br>task</br>).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a <br>task</br> and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the <br>task</br> should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to <br>task</br> aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent <br>task</br> to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent <br>task</br> or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a <br>task</br> or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a <br>task</br> or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the <br>task</br> to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) <br>task</br> failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while <br>task</br> failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to <br>task</br> failure provided the agent can successfully complete an alternate plan.",
                "Moreover, <br>task</br> failure can also arise separately from plan failure, if the agent decides to abort the <br>task</br>.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the <br>task</br>.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a <br>task</br> succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the <br>task</br> should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall <br>task</br>.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper <br>task</br> should cause the Apply For Clearance <br>task</br> being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing <br>task</br> or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority <br>task</br> to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a <br>task</br> that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new <br>task</br> has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing <br>task</br> of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a <br>task</br>, which depends on various factors such as <br>task</br> priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the <br>task</br> is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a <br>task</br> or plan is that the <br>task</br> or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-<br>task</br> Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent <br>task</br>.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a <br>task</br> means aborting the current plan that is executed to perform that <br>task</br>, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-<br>task</br> that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent <br>task</br> of P. We note here that if the parent <br>task</br> TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a <br>task</br> (or sub-<br>task</br>) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the <br>task</br>.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the <br>task</br> that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the <br>task</br> and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles <br>task</br> events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a <br>task</br> fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the <br>task</br> if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the <br>task</br> Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance <br>task</br> be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each <br>task</br> and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the <br>task</br> is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the <br>task</br> !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) <br>task</br> in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The <br>task</br> !CCR(v ) will be executed.",
                "Once this <br>task</br> completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks <br>task</br> execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain <br>task</br> knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the <br>task</br>).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over <br>task</br> interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a <br>task</br> or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular <br>task</br>: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for <br>task</br> and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a <br>task</br> or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "We discuss some conditions under which aborting a <br>task</br> or plan is appropriate, and how to determine the consequences of such a decision.",
                "This may involve seeking alternative plans for a particular <br>task</br>, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular <br>task</br> or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the <br>task</br> can no longer be achieved, or that some conflicting <br>task</br> now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment)."
            ],
            "translated_annotated_samples": [
                "Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una <br>tarea</br> o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente.",
                "Discutimos algunas condiciones bajo las cuales abortar una <br>tarea</br> o un plan es apropiado, y cómo determinar las consecuencias de tal decisión.",
                "Esto puede implicar buscar planes alternativos para una <br>tarea</br> en particular, reprogramar <br>tarea</br>s para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14].",
                "Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una <br>tarea</br> o plan particular.",
                "Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la <br>tarea</br> ya no se puede lograr, o que alguna <br>tarea</br> conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno)."
            ],
            "translated_text": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una <br>tarea</br> o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una <br>tarea</br> o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una <br>tarea</br> en particular, reprogramar <br>tarea</br>s para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una <br>tarea</br> o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la <br>tarea</br> ya no se puede lograr, o que alguna <br>tarea</br> conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "goal": {
            "translated_key": "objetivo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a <br>goal</br> of achieving the state of the task having been performed, and a <br>goal</br> can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other <br>goal</br> types [4] such as maintenance goals [1], where the <br>goal</br> is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the <br>goal</br> adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit <br>goal</br> construct that captures both the declarative and procedural aspects of a <br>goal</br>.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a <br>goal</br> construct is introduced.",
                "This is denoted by <br>goal</br> ` φs, P, φf ´ , where φs is the success condition that determines when the <br>goal</br> is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | <br>goal</br> ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (<br>goal</br> ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement <br>goal</br>.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, <br>goal</br> ` φs, P, φf ´ −→ B, true Gs B |= φf B, <br>goal</br> ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a <br>goal</br> succeeds when φs become true; the second rule states that a <br>goal</br> fails when φf become true.",
                "The third rule GI initializes the execution of a <br>goal</br>-program by updating the <br>goal</br> base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the <br>goal</br>-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible <br>goal</br> has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the <br>goal</br> construct we can no longer completely abandon the program the <br>goal</br> contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the <br>goal</br> construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and <br>goal</br> constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and <br>goal</br> constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the <br>goal</br> construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the <br>goal</br> construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the <br>goal</br> construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the <br>goal</br>.",
                "Hence, if the <br>goal</br> construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); <br>goal</br> ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( <br>goal</br> (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) <br>goal</br> (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the <br>goal</br> construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(<br>goal</br> ` φs, P, φf ´ ), we generate a new pap and execute the program within the <br>goal</br> construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the <br>goal</br> succeeds or fails.",
                "We shift the success and failure condition of the <br>goal</br> construct into a parallel branch using the wait-until-condition construct, and modify the <br>goal</br> to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(<br>goal</br> ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( <br>goal</br> ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); <br>goal</br> ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a <br>goal</br> construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the <br>goal</br> to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the <br>goal</br> construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); <br>goal</br> ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( <br>goal</br> ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the <br>goal</br> construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first <br>goal</br> construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from <br>goal</br> deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed <br>goal</br> g. Given Jasons constructs for dropping a <br>goal</br> with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a <br>goal</br> deletion plan, the programmer can specify any undo actions and whether to attempt the <br>goal</br> again.",
                "If no <br>goal</br> deletion plan is provided, Jasons default behaviour is to not reattempt the <br>goal</br>.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test <br>goal</br>; in particular, <br>goal</br> deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as <br>goal</br> adoption or plan failure, and offer introspective capabilities over <br>goal</br> and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define <br>goal</br>-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the <br>goal</br>, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a <br>goal</br>, and so not necessarily on <br>goal</br> failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the <br>goal</br> level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling <br>goal</br>).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed <br>goal</br>) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "<br>goal</br> representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "<br>goal</br> types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive <br>goal</br> interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for <br>goal</br>-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [
                "A task can be considered a <br>goal</br> of achieving the state of the task having been performed, and a <br>goal</br> can be considered a task of bringing about that state of the world.",
                "Different forms of reasoning apply to other <br>goal</br> types [4] such as maintenance goals [1], where the <br>goal</br> is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the <br>goal</br> adoption and dropping mechanisms.",
                "CAN provides an explicit <br>goal</br> construct that captures both the declarative and procedural aspects of a <br>goal</br>.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a <br>goal</br> construct is introduced."
            ],
            "translated_annotated_samples": [
                "Una tarea puede considerarse un <br>objetivo</br> de lograr el estado de la tarea una vez realizada, y un <br>objetivo</br> puede considerarse una tarea de llevar a cabo ese estado en el mundo.",
                "Diferentes formas de razonamiento se aplican a otros tipos de <br>objetivo</br>s, como los <br>objetivo</br>s de mantenimiento, donde el objetivo se satisface al mantener un estado del mundo durante algún período de tiempo (por ejemplo, mantener $100 en efectivo).",
                "Utilizamos el lenguaje CAN inicialmente definido en [23] y posteriormente extendido como CANPLAN en [17] para incluir un componente de planificación y luego como CANPLAN2 en [18] para mejorar los mecanismos de adopción y eliminación de <br>objetivos</br>.",
                "CAN proporciona un constructo de <br>objetivo</br> explícito que captura tanto los aspectos declarativos como los procedimentales de un <br>objetivo</br>.",
                "Esto también es cierto en el lenguaje CAN, pero, para mantener la persistencia de los <br>objetivo</br>s, se introduce un constructo de <br>objetivo</br>."
            ],
            "translated_text": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). Abortar una tarea o plan es distinto de su fracaso. El fracaso refleja una incapacidad para desempeñarse y no anula la necesidad de desempeñarse, por ejemplo, una respuesta razonable al fracaso puede ser intentarlo de nuevo. Por el contrario, abortar no dice nada sobre la capacidad de realizar; simplemente elimina la necesidad. El fracaso se propaga de abajo hacia arriba, mientras que la interrupción se propaga de arriba hacia abajo. El potencial de ejecutar subplanes de forma simultánea introduce diferentes complejidades para la interrupción y el fallo. Para abortar, significa que varios subplanes concurrentes pueden necesitar ser abortados a medida que se propaga el aborto hacia abajo. Para el fallo, significa que los planes paralelos hermanos pueden necesitar ser abortados a medida que el fallo se propaga hacia arriba. Ha habido una cantidad considerable de trabajo sobre fallos en los planes (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallos. Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de aborto más allá de la simple eliminación de los planes y tareas actualmente previstos, lo cual no aborda la limpieza requerida. Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de un constructo paralelo. Se puede considerar que ambas tareas se realizan y se tienen objetivos para lograr un cierto estado del mundo. Una tarea puede considerarse un <br>objetivo</br> de lograr el estado de la tarea una vez realizada, y un <br>objetivo</br> puede considerarse una tarea de llevar a cabo ese estado en el mundo. Adoptamos la última perspectiva y usamos la palabra \"tarea\" también para referirnos a los objetivos. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS falla (los enfoques comunes incluyen permitir que la otra rama se ejecute hasta su finalización sin obstáculos o eliminarla por completo). En este documento discutimos en detalle la incorporación de métodos de limpieza de aborto en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto. Una característica clave de nuestro enfoque basado en procedimientos es que permitimos que cada plan ejecute un código particular en caso de fallo y de aborto. Esto permite que un plan intente asegurar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar de otra manera antes de salir. Por consiguiente, un desafío técnico central es gestionar la ejecución ordenada del código de limpieza adecuado. Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una semántica operativa para abortar en el lenguaje de agente abstracto CAN [23, 17]. Esto nos permite especificar un nivel adecuado de detalle para el modelo de ejecución, sin centrarnos en las construcciones específicas de ningún sistema de agentes en particular, como JACK [2], Jadex [14], Jason [6] o SPARK [9]. Nuestro enfoque se centra en un único agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas de un solo agente y multiagentes (por ejemplo, [22, 5, 6]). Este documento está organizado de la siguiente manera. En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deberían ocurrir los abortos, y los procedimientos adecuados de representación e invocación. En la Sección 4 mostramos cómo podemos utilizar CAN para especificar formalmente el comportamiento de un plan abortado. La sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro. EJEMPLO MOTIVADOR Alice es una trabajadora del conocimiento asistida por un agente de asistencia personal y de aprendizaje como CALO [11]. Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente CALO adopta la tarea de Presentación de Reuniones de Apoyo (SMS) para ayudarla. El plan de CALO para una tarea de SMS en el caso de una presentación en una conferencia consiste en las siguientes sub tareas: 1. Asignar un Número de Documento (APN) para ser utilizado con fines administrativos en la empresa. 2. Seguimiento de la Escritura del Resumen (SER): hacer un seguimiento del progreso de Alicia en la preparación de un resumen. 3. Solicitar autorización de publicación (AFC) del gerente de Alice basado en el resumen y los detalles de la conferencia. 4. Papel de seguimiento de escritura (PSE): llevar un registro del progreso de Alicia en la escritura del papel. 5. Manejo de la presentación de documentos (HPS): seguir los procedimientos internos de la empresa para presentar un documento a una conferencia. Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo. De manera similar, CALO puede realizar la tarea de Solicitar Autorización de Despeje (AFC) mediante un plan que consiste en: 1. Enviar la Solicitud de Autorización (SCR) al gerente de Alice. 2. Espera la respuesta (WFR) del gerente. 3. Confirma que la respuesta fue positiva, y falla en caso contrario. Ahora supongamos que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras está escribiendo el documento. Alice ya no podrá asistir a IJCAI. Por lo tanto, ella instruye a su agente CALO para abortar la tarea de SMS. Abortar la tarea implica abortar tanto el plan de SMS como el subplan de AFC. Abortar el primer plan requiere que CALO notifique al registro de números de papel que el número de papel asignado está obsoleto, lo cual puede lograr mediante la tarea Cancelar Número de Papel (CPN). Abortar el segundo plan requiere que CALO notifique al gerente de Alice que Alice ya no necesita autorización para publicar, lo cual CALO puede lograr invocando la tarea Cancelar Solicitud de Autorización (CCR). Observamos una serie de observaciones importantes del ejemplo. Primero, la decisión de abortar un curso de acción particular puede surgir de las deliberaciones internas del agente (como razonar sobre prioridades en un conflicto por recursos), o de fuentes externas (como otro agente cancelando un compromiso), como en este ejemplo. En este documento solo abordamos el problema de determinar si una tarea o plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se haya tomado esta decisión. Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo. Segundo, una vez que se toma la decisión de abortar el intento de enviar un artículo, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización. En otras palabras, abortar una tarea no es simplemente cuestión de abandonar la tarea y los planes activos asociados: puede haber algunas acciones de limpieza que necesiten realizarse. Esto es similar al caso del fracaso, en el sentido de que también puede haber acciones a tomar cuando una tarea o plan falla. En ambos casos, hay que tener en cuenta que no se trata simplemente de que el agente deshaga sus acciones hasta la fecha; de hecho, esto puede no ser ni posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado del mundo) ni deseable (dependiendo de la semántica de la tarea). Más bien, la limpieza implica compensación a través de acciones de recuperación hacia adelante [3]. Tercero, hay una distinción entre abortar una tarea y abortar un plan. En el primer caso, está claro que todos los planes que se estén ejecutando para realizar la tarea deben ser abortados; en el segundo caso, puede ser que existan mejores alternativas al plan actual y se deba intentar una de estas. Por lo tanto, el aborto o fracaso del plan no necesariamente conduce al aborto o fracaso de la tarea. Dado que las tareas pueden contener sub tareas, las cuales pueden contener más sub tareas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto. Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que una tarea o plan principal es abortado. 3. ABORTANDO TAREAS Y PLANES Como hemos insinuado, el fracaso y abortar son conceptos relacionados. Ambos causan que la ejecución de los planes existentes se detenga y, en consecuencia, que el agente reflexione sobre sus tareas e intenciones actuales. El fracaso y la interrupción, sin embargo, difieren en la forma en que surgen. En caso de fallo, el disparador para detener la ejecución de una tarea o plan proviene de abajo, es decir, del fallo de sub tareas o planes de nivel inferior. En caso de abortar, el disparador proviene de arriba, es decir, de las tareas y los planes principales que iniciaron un plan. En sistemas de estilo BDI como JACK y SPARK, el conocimiento del dominio de los agentes incluye una biblioteca de planes predefinidos de cláusulas de planificación. Cada cláusula de plan tiene un cuerpo de plan, que es un programa (es decir, una combinación de acciones primitivas, subtareas, etc.) que puede ejecutarse en respuesta a una tarea u otro evento si se cumple la condición de contexto de las cláusulas del plan. El agente selecciona y ejecuta instancias de cláusulas de plan para realizar sus tareas. Puede haber más de una cláusula de plan aplicable y, en caso de que una falle, se puede intentar otra aplicable. Los planes pueden tener subtareas que deben tener éxito. CALO solo necesita eliminar las tareas TWA y TWP para abortarlas: por simplicidad, suponemos que no es necesario realizar una limpieza explícita de su estado interno. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) para que el plan tenga éxito. En tales sistemas, ocurre un fallo en el plan si una de las acciones o subtareas dentro del plan falla. La acción de los agentes ante el fracaso del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si se ha intentado un plan y ha resultado en fracaso, o puede intentar planes alternativos y declarar (de hecho, debe declarar) el fracaso de la tarea solo si se han intentado todos los planes alternativos posibles para realizar la tarea y han resultado en fracaso. Observa que, si bien el fracaso de una tarea puede derivar del fracaso de un plan o de una secuencia de fracasos de planes, el fracaso de un plan no tiene por qué llevar al fracaso de la tarea siempre y cuando el agente pueda completar con éxito un plan alternativo. Además, el fracaso de la tarea también puede surgir de forma independiente al fracaso del plan, si el agente decide abortar la tarea. Nuestro enfoque asocia un método de aborto con cada plan. Esto permite al programador especificar acciones de compensación dedicadas según cómo el agente esté intentando realizar la tarea. Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que se pueden realizar dinámicamente de la manera habitual en BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones. La pregunta sigue siendo qué método de aborto se debe invocar, y de qué manera. Dada la complejidad de los espacios de acción de los agentes, no es posible ni deseable enumerar un conjunto estático de reglas. Más bien, el agente invocará sus métodos de aborto dinámicamente de acuerdo al estado de ejecución y sus propios eventos internos. Una alternativa a adjuntar un método de aborto a cada plan es adjuntar dichos métodos a cada acción atómica. Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los métodos de limpieza para el fracaso en los sistemas actuales están adjuntos a los planes. Para entender cómo debería funcionar el proceso de aborto de los agentes, consideramos tres situaciones en las que tiene sentido que un agente considere abortar algunas de sus tareas y planes: 1. Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí mismo, el plan actualmente ejecutado para realizar la tarea debe ser abortado. Por ejemplo, supongamos que la política de la empresa cambia para que los empleados con la antigüedad de Alice tengan automáticamente autorización para publicar artículos. Dado que Alice ahora tiene autorización para publicar su artículo, CALO puede abortar el plan de Solicitar Autorización. Al hacerlo, debe invocar el método de aborto, en este caso realizando la solicitud de cancelación de autorización. Cuando dos o más subprogramas se ejecutan en paralelo, si uno falla entonces los demás deben ser abortados, dado que el fallo de una rama conlleva al fallo de la tarea en general. Por ejemplo, supongamos que a mitad de la escritura del artículo, Alice se da cuenta de que hay un error fatal en sus resultados, por lo que notifica a CALO que no podrá completar el artículo para la fecha límite. El fallo de la tarea de Escritura de Pista debería provocar que la tarea de Solicitar Autorización que se está ejecutando en paralelo sea abortada. 3. Cuando un evento de ejecución altera la importancia de una tarea o intención existente, el agente debe deliberar si el/los plan(es) existente(s) deben continuar. Por ejemplo, supongamos que Alice encarga a CALO una nueva tarea de alta prioridad para comprar una computadora portátil de reemplazo, pero que Alice no tiene suficientes fondos para comprar la computadora portátil y asistir a IJCAI. Razonar sobre los requisitos de recursos [20, 10] hará que el agente se dé cuenta de que no puede completar exitosamente ambas tareas. Si hay alguna diferencia entre cómo abortar una tarea que se realiza externamente y cómo abortar una que ahora se sabe que es imposible, el método de aborto puede detectar las circunstancias y manejar la situación de manera apropiada. Dado que la nueva tarea tiene mayor importancia, un agente racional evaluará su mejor curso de acción y puede decidir abortar o al menos suspender la tarea existente de presentar un documento y las intenciones derivadas de ella [12]. La semántica operativa que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones mencionadas anteriormente. La tercera situación implica deliberar sobre la importancia de una tarea, la cual depende de varios factores como la prioridad de la tarea. Aunque esta deliberación está más allá del alcance de este documento, es un tema complementario de nuestro trabajo futuro. Ten en cuenta que las situaciones anteriores se aplican a metas de logro, para las cuales la tarea se completa cuando se logra un estado particular del mundo (por ejemplo, asegurarse de que tengamos autorización). Diferentes formas de razonamiento se aplican a otros tipos de <br>objetivo</br>s, como los <br>objetivo</br>s de mantenimiento, donde el objetivo se satisface al mantener un estado del mundo durante algún período de tiempo (por ejemplo, mantener $100 en efectivo). La representación del método de aborto tiene la intención de que una tarea o plan se detenga, y que tanto la tarea o plan como todos sus hijos dejen de ejecutarse, y que se realicen los métodos de limpieza apropiados según sea necesario. A diferencia de los sistemas de planificación offline, los agentes BDI están situados: realizan deliberación en línea y sus acciones cambian el estado del mundo. Como resultado, los efectos de muchas acciones no pueden ser simplemente deshechos. Además, el proceso de deshacer puede causar efectos adversos. Por lo tanto, los métodos de limpieza que especificamos son procedimientos de recuperación hacia adelante que intentan garantizar un estado estable y que también pueden, si es posible, recuperar recursos. La representación común de un plan en sistemas de estilo BDI como JACK y SPARK incluye un método de fallo, que es el método de limpieza designado invocado cuando el plan falla. Para esto, agregamos el método de aborto, que se invoca si se va a abortar el plan. En nuestro ejemplo, el método de aborto para el plan de Envío de Reunión de Soporte consiste en invocar la sub-tarea Cancelar Número de Documento. El método de aborto no necesita abortar explícitamente la solicitud de autorización, ya que el agente invocará el método de aborto para la subtarea de manera apropiada, como detallamos a continuación. La suposición aquí es que, al igual que en el método de falla, el programador del sistema del agente tiene la oportunidad de especificar un método de aborto sensato que tenga en cuenta el punto en el plan en el que se va a ejecutar el aborto. Para cualquier plan, el método de aborto es opcional: si no se especifica un método de aborto, el agente no toma ninguna acción específica para este plan. Sin embargo, las reglas de comportamiento predeterminadas de los agentes siguen aplicándose, por ejemplo, si intentar de nuevo un plan alternativo para la tarea principal. Se debe tener en cuenta que no es necesario una representación explícita de los métodos de limpieza para las tareas, ya que las tareas se realizan ejecutando algún plan o planes. Por lo tanto, abortar una tarea significa abortar el plan actual que se está ejecutando para realizar esa tarea, como describiremos a continuación. Invocación del método de aborto. Ahora describimos de manera informal la acción de los agentes al abortar planes y tareas. Cuando un plan P es abortado: 1. Abortar cada sub-tarea que sea un hijo activo de P. Un hijo activo es aquel que fue desencadenado por P y actualmente está en ejecución. 2. Cuando ya no haya más niños activos, invoque el método de aborto del plan P. 3. Indique un fallo en el plan para TP, la tarea principal de P. Se señala aquí que si la tarea principal TP no debe ser abortada, entonces el agente puede elegir otro plan aplicable para satisfacer TP. 10 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Cuando una tarea (o sub-tarea) T es abortada: 1. Abortar el plan activo actual para satisfacer T (si lo hay). 2. Cuando ya no haya más procesos secundarios activos, elimine la tarea. El agente ya no persigue a T. 3. Ten en cuenta que cuando se aborta el plan activo actual para realizar T, no se deben intentar otros planes aplicables para realizar T, ya que es la tarea que se va a abortar. Para evitar esfuerzos de limpieza en cascada infinita, asumimos que los métodos de aborto nunca serán abortados ni fallarán. En realidad, sin embargo, un método de aborto puede fallar. En este caso, al no contar con un mecanismo de manejo más sofisticado, el agente simplemente deja de ejecutar el método de aborto fallido sin más deliberación. La suposición que hacemos no es, por lo tanto, un reflejo de la complejidad total de la realidad, sino una que es pragmática en términos del ciclo de ejecución del agente; el enfoque para el manejo de fallos de [21] hace la misma suposición. En sistemas como SPARK, el programador puede especificar un comportamiento alternativo para un método de fallo o aborto fallido mediante procedimientos a nivel meta. También asumimos que los métodos de falla y aborto terminan en tiempo finito. 4. SEMÁNTICA OPERACIONAL Proporcionamos la semántica para los procesos de falla y aborto de tareas y planes descritos anteriormente. Utilizamos el lenguaje CAN inicialmente definido en [23] y posteriormente extendido como CANPLAN en [17] para incluir un componente de planificación y luego como CANPLAN2 en [18] para mejorar los mecanismos de adopción y eliminación de <br>objetivos</br>. Las extensiones también simplificaron la semántica en el trabajo anterior. Utilizamos algunas de estas simplificaciones para proporcionar un breve resumen del lenguaje CAN en la Sección 4.1. Tras una presentación de la semántica operacional de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos. 4.1 Lenguaje CAN CAN es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentSpeak [15] y Kinnys Ψ [7], ambos de los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados. CAN proporciona un constructo de <br>objetivo</br> explícito que captura tanto los aspectos declarativos como los procedimentales de un <br>objetivo</br>. Los objetivos son persistentes en CAN en el sentido de que, cuando un plan falla, se intenta otro plan aplicable. Esto equivale al mecanismo predeterminado de manejo de fallos que se encuentra típicamente en sistemas BDI implementados como JACK [2]. En sistemas prácticos, las tareas suelen traducirse en eventos que desencadenan la ejecución de algunos planes. Esto también es cierto en el lenguaje CAN, pero, para mantener la persistencia de los <br>objetivo</br>s, se introduce un constructo de <br>objetivo</br>. ",
            "candidates": [],
            "error": [
                [
                    "objetivo",
                    "objetivo",
                    "objetivo",
                    "objetivo",
                    "objetivos",
                    "objetivo",
                    "objetivo",
                    "objetivo",
                    "objetivo"
                ]
            ]
        },
        "goal construct": {
            "translated_key": "constructo de objetivo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit <br>goal construct</br> that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a <br>goal construct</br> is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the <br>goal construct</br> we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the <br>goal construct</br>.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the <br>goal construct</br> to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the <br>goal construct</br> to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the <br>goal construct</br> is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the <br>goal construct</br> fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the <br>goal construct</br> in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the <br>goal construct</br> we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the <br>goal construct</br> in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the <br>goal construct</br> into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a <br>goal construct</br>.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the <br>goal construct</br> fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the <br>goal construct</br> that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the <br>goal construct</br> in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first <br>goal construct</br> of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [
                "CAN provides an explicit <br>goal construct</br> that captures both the declarative and procedural aspects of a goal.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a <br>goal construct</br> is introduced.",
                "Similarly, with the <br>goal construct</br> we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We explain this simple modification of the parallel construct below when we come to translation of the <br>goal construct</br>.",
                "We use the <br>goal construct</br> to allow us to drop the execution of a program within a pap v when it is necessary to abort."
            ],
            "translated_annotated_samples": [
                "CAN proporciona un <br>constructo de objetivo</br> explícito que captura tanto los aspectos declarativos como los procedimentales de un objetivo.",
                "Esto también es cierto en el lenguaje CAN, pero, para mantener la persistencia de los objetivos, se introduce un <br>constructo de objetivo</br>.",
                "De manera similar, con el <br>constructo de Objetivo</br> ya no podemos abandonar por completo el programa que contiene tan pronto como se cumpla la condición de éxito o fracaso; ahora debemos tener en cuenta la existencia de cualquier método de aborto aplicable al programa.",
                "Explicamos esta simple modificación del constructo paralelo a continuación cuando llegamos a la traducción del <br>constructo de la Meta</br>.",
                "Utilizamos la <br>construcción de Objetivo</br> para permitirnos detener la ejecución de un programa dentro de un pap v cuando sea necesario abortar."
            ],
            "translated_text": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos agentes deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del agente, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de agentes. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de agente abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de agentes particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el agente se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al fracaso es fundamental para la programación de agentes, y es un elemento importante de las características de los agentes como la robustez, la flexibilidad y la persistencia [21]. En arquitecturas de agentes inspiradas en el modelo de Creencia-Deseo-Intención (BDI) [16], estas propiedades suelen caracterizarse por las interacciones entre creencias, metas y planes [2]. En general, un agente que desea lograr un conjunto particular de tareas perseguirá varios planes simultáneamente. Cuando ocurran fallos, se revisará la elección de planes. Esto puede implicar buscar planes alternativos para una tarea en particular, reprogramar tareas para cumplir mejor con las limitaciones de recursos, eliminar algunas tareas u otra decisión que aumentará la probabilidad de éxito [12, 14]. Las fallas pueden ocurrir por diversas razones, y muchas veces no es posible predecirlas con antelación, ya sea debido a la complejidad del sistema o porque los cambios en el entorno invalidan algunas decisiones anteriores. Dada esta necesidad de deliberación sobre tareas o planes fallidos, la deliberación sobre el fracaso se incorpora comúnmente en el ciclo de ejecución de los agentes. Además de lidiar con el fracaso, una capacidad importante de un agente inteligente es poder abortar una tarea o plan particular. Esta decisión puede deberse a una deliberación interna (como el agente creyendo que la tarea ya no se puede lograr, o que alguna tarea conflictiva ahora tiene una prioridad más alta) o a un factor externo (como otro agente modificando un compromiso, o un cambio en el entorno). Abortar una tarea o plan es distinto de su fracaso. El fracaso refleja una incapacidad para desempeñarse y no anula la necesidad de desempeñarse, por ejemplo, una respuesta razonable al fracaso puede ser intentarlo de nuevo. Por el contrario, abortar no dice nada sobre la capacidad de realizar; simplemente elimina la necesidad. El fracaso se propaga de abajo hacia arriba, mientras que la interrupción se propaga de arriba hacia abajo. El potencial de ejecutar subplanes de forma simultánea introduce diferentes complejidades para la interrupción y el fallo. Para abortar, significa que varios subplanes concurrentes pueden necesitar ser abortados a medida que se propaga el aborto hacia abajo. Para el fallo, significa que los planes paralelos hermanos pueden necesitar ser abortados a medida que el fallo se propaga hacia arriba. Ha habido una cantidad considerable de trabajo sobre fallos en los planes (como detectar y resolver conflictos de recursos [20, 10]) y la mayoría de los sistemas de agentes incorporan alguna noción de manejo de fallos. Sin embargo, ha habido relativamente poco trabajo en el desarrollo de técnicas de aborto más allá de la simple eliminación de los planes y tareas actualmente previstos, lo cual no aborda la limpieza requerida. Como consecuencia, la mayoría de los sistemas de agentes son bastante limitados en su tratamiento de la situación en la que una rama de un constructo paralelo. Se puede considerar que ambas tareas se realizan y se tienen objetivos para lograr un cierto estado del mundo. Una tarea puede considerarse un objetivo de lograr el estado de la tarea una vez realizada, y un objetivo puede considerarse una tarea de llevar a cabo ese estado en el mundo. Adoptamos la última perspectiva y usamos la palabra \"tarea\" también para referirnos a los objetivos. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS falla (los enfoques comunes incluyen permitir que la otra rama se ejecute hasta su finalización sin obstáculos o eliminarla por completo). En este documento discutimos en detalle la incorporación de métodos de limpieza de aborto en el ciclo de ejecución del agente, proporcionando un enfoque unificado para el fallo y el aborto. Una característica clave de nuestro enfoque basado en procedimientos es que permitimos que cada plan ejecute un código particular en caso de fallo y de aborto. Esto permite que un plan intente asegurar un estado estable y conocido, y posiblemente recuperar algunos recursos y limpiar de otra manera antes de salir. Por consiguiente, un desafío técnico central es gestionar la ejecución ordenada del código de limpieza adecuado. Mostramos cómo las abortos pueden ser introducidos suavemente en una arquitectura de estilo BDI, y por primera vez damos una semántica operativa para abortar en el lenguaje de agente abstracto CAN [23, 17]. Esto nos permite especificar un nivel adecuado de detalle para el modelo de ejecución, sin centrarnos en las construcciones específicas de ningún sistema de agentes en particular, como JACK [2], Jadex [14], Jason [6] o SPARK [9]. Nuestro enfoque se centra en un único agente, complementario al trabajo relacionado que considera el manejo de excepciones para sistemas de un solo agente y multiagentes (por ejemplo, [22, 5, 6]). Este documento está organizado de la siguiente manera. En la Sección 2 damos un ejemplo de las consecuencias de abortar una tarea, y en la Sección 3 discutimos algunas circunstancias bajo las cuales deberían ocurrir los abortos, y los procedimientos adecuados de representación e invocación. En la Sección 4 mostramos cómo podemos utilizar CAN para especificar formalmente el comportamiento de un plan abortado. La sección 5 discute el trabajo relacionado, y en la Sección 6 presentamos nuestras conclusiones y trabajo futuro. EJEMPLO MOTIVADOR Alice es una trabajadora del conocimiento asistida por un agente de asistencia personal y de aprendizaje como CALO [11]. Alice planea asistir a la conferencia IJCAI más adelante en el año, y su agente CALO adopta la tarea de Presentación de Reuniones de Apoyo (SMS) para ayudarla. El plan de CALO para una tarea de SMS en el caso de una presentación en una conferencia consiste en las siguientes sub tareas: 1. Asignar un Número de Documento (APN) para ser utilizado con fines administrativos en la empresa. 2. Seguimiento de la Escritura del Resumen (SER): hacer un seguimiento del progreso de Alicia en la preparación de un resumen. 3. Solicitar autorización de publicación (AFC) del gerente de Alice basado en el resumen y los detalles de la conferencia. 4. Papel de seguimiento de escritura (PSE): llevar un registro del progreso de Alicia en la escritura del papel. 5. Manejo de la presentación de documentos (HPS): seguir los procedimientos internos de la empresa para presentar un documento a una conferencia. Estos pasos deben realizarse en orden, con la excepción de los pasos 3 (AFC) y 4 (TWP), que pueden realizarse en paralelo. De manera similar, CALO puede realizar la tarea de Solicitar Autorización de Despeje (AFC) mediante un plan que consiste en: 1. Enviar la Solicitud de Autorización (SCR) al gerente de Alice. 2. Espera la respuesta (WFR) del gerente. 3. Confirma que la respuesta fue positiva, y falla en caso contrario. Ahora supongamos que un cambio en las circunstancias hace que Alice reconsidere sus planes de viaje mientras está escribiendo el documento. Alice ya no podrá asistir a IJCAI. Por lo tanto, ella instruye a su agente CALO para abortar la tarea de SMS. Abortar la tarea implica abortar tanto el plan de SMS como el subplan de AFC. Abortar el primer plan requiere que CALO notifique al registro de números de papel que el número de papel asignado está obsoleto, lo cual puede lograr mediante la tarea Cancelar Número de Papel (CPN). Abortar el segundo plan requiere que CALO notifique al gerente de Alice que Alice ya no necesita autorización para publicar, lo cual CALO puede lograr invocando la tarea Cancelar Solicitud de Autorización (CCR). Observamos una serie de observaciones importantes del ejemplo. Primero, la decisión de abortar un curso de acción particular puede surgir de las deliberaciones internas del agente (como razonar sobre prioridades en un conflicto por recursos), o de fuentes externas (como otro agente cancelando un compromiso), como en este ejemplo. En este documento solo abordamos el problema de determinar si una tarea o plan debe ser abortado, en lugar de concentrarnos en determinar las acciones apropiadas una vez que se haya tomado esta decisión. Por lo tanto, nuestro objetivo es determinar cómo incorporar mecanismos de aborto en el ciclo de ejecución estándar en lugar de determinar qué debe ser abortado y cuándo. Segundo, una vez que se toma la decisión de abortar el intento de enviar un artículo, hay algunas acciones que el agente debe tomar, como cancelar la solicitud de autorización. En otras palabras, abortar una tarea no es simplemente cuestión de abandonar la tarea y los planes activos asociados: puede haber algunas acciones de limpieza que necesiten realizarse. Esto es similar al caso del fracaso, en el sentido de que también puede haber acciones a tomar cuando una tarea o plan falla. En ambos casos, hay que tener en cuenta que no se trata simplemente de que el agente deshaga sus acciones hasta la fecha; de hecho, esto puede no ser ni posible (ya que el agente actúa en un mundo situado y sus acciones cambian el estado del mundo) ni deseable (dependiendo de la semántica de la tarea). Más bien, la limpieza implica compensación a través de acciones de recuperación hacia adelante [3]. Tercero, hay una distinción entre abortar una tarea y abortar un plan. En el primer caso, está claro que todos los planes que se estén ejecutando para realizar la tarea deben ser abortados; en el segundo caso, puede ser que existan mejores alternativas al plan actual y se deba intentar una de estas. Por lo tanto, el aborto o fracaso del plan no necesariamente conduce al aborto o fracaso de la tarea. Dado que las tareas pueden contener sub tareas, las cuales pueden contener más sub tareas, es necesario que una tarea principal espere hasta que sus hijos hayan terminado sus métodos de aborto. Esta es la fuente de uno de los desafíos técnicos que abordamos: determinar la secuencia precisa de acciones una vez que una tarea o plan principal es abortado. 3. ABORTANDO TAREAS Y PLANES Como hemos insinuado, el fracaso y abortar son conceptos relacionados. Ambos causan que la ejecución de los planes existentes se detenga y, en consecuencia, que el agente reflexione sobre sus tareas e intenciones actuales. El fracaso y la interrupción, sin embargo, difieren en la forma en que surgen. En caso de fallo, el disparador para detener la ejecución de una tarea o plan proviene de abajo, es decir, del fallo de sub tareas o planes de nivel inferior. En caso de abortar, el disparador proviene de arriba, es decir, de las tareas y los planes principales que iniciaron un plan. En sistemas de estilo BDI como JACK y SPARK, el conocimiento del dominio de los agentes incluye una biblioteca de planes predefinidos de cláusulas de planificación. Cada cláusula de plan tiene un cuerpo de plan, que es un programa (es decir, una combinación de acciones primitivas, subtareas, etc.) que puede ejecutarse en respuesta a una tarea u otro evento si se cumple la condición de contexto de las cláusulas del plan. El agente selecciona y ejecuta instancias de cláusulas de plan para realizar sus tareas. Puede haber más de una cláusula de plan aplicable y, en caso de que una falle, se puede intentar otra aplicable. Los planes pueden tener subtareas que deben tener éxito. CALO solo necesita eliminar las tareas TWA y TWP para abortarlas: por simplicidad, suponemos que no es necesario realizar una limpieza explícita de su estado interno. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) para que el plan tenga éxito. En tales sistemas, ocurre un fallo en el plan si una de las acciones o subtareas dentro del plan falla. La acción de los agentes ante el fracaso del plan depende de su naturaleza: por ejemplo, el agente puede declarar que la tarea ha fallado si se ha intentado un plan y ha resultado en fracaso, o puede intentar planes alternativos y declarar (de hecho, debe declarar) el fracaso de la tarea solo si se han intentado todos los planes alternativos posibles para realizar la tarea y han resultado en fracaso. Observa que, si bien el fracaso de una tarea puede derivar del fracaso de un plan o de una secuencia de fracasos de planes, el fracaso de un plan no tiene por qué llevar al fracaso de la tarea siempre y cuando el agente pueda completar con éxito un plan alternativo. Además, el fracaso de la tarea también puede surgir de forma independiente al fracaso del plan, si el agente decide abortar la tarea. Nuestro enfoque asocia un método de aborto con cada plan. Esto permite al programador especificar acciones de compensación dedicadas según cómo el agente esté intentando realizar la tarea. Tenga en cuenta que nuestros métodos de aborto pueden ser programas arbitrarios y, por lo tanto, pueden invocar tareas que se pueden realizar dinámicamente de la manera habitual en BDI, es decir, la limpieza no se limita a ejecutar un conjunto predeterminado de acciones. La pregunta sigue siendo qué método de aborto se debe invocar, y de qué manera. Dada la complejidad de los espacios de acción de los agentes, no es posible ni deseable enumerar un conjunto estático de reglas. Más bien, el agente invocará sus métodos de aborto dinámicamente de acuerdo al estado de ejecución y sus propios eventos internos. Una alternativa a adjuntar un método de aborto a cada plan es adjuntar dichos métodos a cada acción atómica. Elegimos lo primero porque: (1) los métodos de aborto a nivel de acción incurrirían en una mayor sobrecarga, (2) los planes están destinados a ser diseñados como unidades cohesivas individuales y son la unidad de deliberación en los sistemas BDI, y (3) los métodos de limpieza para el fracaso en los sistemas actuales están adjuntos a los planes. Para entender cómo debería funcionar el proceso de aborto de los agentes, consideramos tres situaciones en las que tiene sentido que un agente considere abortar algunas de sus tareas y planes: 1. Cuando una tarea tiene éxito o falla debido a un factor externo que no sea el agente en sí mismo, el plan actualmente ejecutado para realizar la tarea debe ser abortado. Por ejemplo, supongamos que la política de la empresa cambia para que los empleados con la antigüedad de Alice tengan automáticamente autorización para publicar artículos. Dado que Alice ahora tiene autorización para publicar su artículo, CALO puede abortar el plan de Solicitar Autorización. Al hacerlo, debe invocar el método de aborto, en este caso realizando la solicitud de cancelación de autorización. Cuando dos o más subprogramas se ejecutan en paralelo, si uno falla entonces los demás deben ser abortados, dado que el fallo de una rama conlleva al fallo de la tarea en general. Por ejemplo, supongamos que a mitad de la escritura del artículo, Alice se da cuenta de que hay un error fatal en sus resultados, por lo que notifica a CALO que no podrá completar el artículo para la fecha límite. El fallo de la tarea de Escritura de Pista debería provocar que la tarea de Solicitar Autorización que se está ejecutando en paralelo sea abortada. 3. Cuando un evento de ejecución altera la importancia de una tarea o intención existente, el agente debe deliberar si el/los plan(es) existente(s) deben continuar. Por ejemplo, supongamos que Alice encarga a CALO una nueva tarea de alta prioridad para comprar una computadora portátil de reemplazo, pero que Alice no tiene suficientes fondos para comprar la computadora portátil y asistir a IJCAI. Razonar sobre los requisitos de recursos [20, 10] hará que el agente se dé cuenta de que no puede completar exitosamente ambas tareas. Si hay alguna diferencia entre cómo abortar una tarea que se realiza externamente y cómo abortar una que ahora se sabe que es imposible, el método de aborto puede detectar las circunstancias y manejar la situación de manera apropiada. Dado que la nueva tarea tiene mayor importancia, un agente racional evaluará su mejor curso de acción y puede decidir abortar o al menos suspender la tarea existente de presentar un documento y las intenciones derivadas de ella [12]. La semántica operativa que proporcionamos en la Sección 4 para abortar tareas y planes captura las dos primeras situaciones mencionadas anteriormente. La tercera situación implica deliberar sobre la importancia de una tarea, la cual depende de varios factores como la prioridad de la tarea. Aunque esta deliberación está más allá del alcance de este documento, es un tema complementario de nuestro trabajo futuro. Ten en cuenta que las situaciones anteriores se aplican a metas de logro, para las cuales la tarea se completa cuando se logra un estado particular del mundo (por ejemplo, asegurarse de que tengamos autorización). Diferentes formas de razonamiento se aplican a otros tipos de objetivos, como los objetivos de mantenimiento, donde el objetivo se satisface al mantener un estado del mundo durante algún período de tiempo (por ejemplo, mantener $100 en efectivo). La representación del método de aborto tiene la intención de que una tarea o plan se detenga, y que tanto la tarea o plan como todos sus hijos dejen de ejecutarse, y que se realicen los métodos de limpieza apropiados según sea necesario. A diferencia de los sistemas de planificación offline, los agentes BDI están situados: realizan deliberación en línea y sus acciones cambian el estado del mundo. Como resultado, los efectos de muchas acciones no pueden ser simplemente deshechos. Además, el proceso de deshacer puede causar efectos adversos. Por lo tanto, los métodos de limpieza que especificamos son procedimientos de recuperación hacia adelante que intentan garantizar un estado estable y que también pueden, si es posible, recuperar recursos. La representación común de un plan en sistemas de estilo BDI como JACK y SPARK incluye un método de fallo, que es el método de limpieza designado invocado cuando el plan falla. Para esto, agregamos el método de aborto, que se invoca si se va a abortar el plan. En nuestro ejemplo, el método de aborto para el plan de Envío de Reunión de Soporte consiste en invocar la sub-tarea Cancelar Número de Documento. El método de aborto no necesita abortar explícitamente la solicitud de autorización, ya que el agente invocará el método de aborto para la subtarea de manera apropiada, como detallamos a continuación. La suposición aquí es que, al igual que en el método de falla, el programador del sistema del agente tiene la oportunidad de especificar un método de aborto sensato que tenga en cuenta el punto en el plan en el que se va a ejecutar el aborto. Para cualquier plan, el método de aborto es opcional: si no se especifica un método de aborto, el agente no toma ninguna acción específica para este plan. Sin embargo, las reglas de comportamiento predeterminadas de los agentes siguen aplicándose, por ejemplo, si intentar de nuevo un plan alternativo para la tarea principal. Se debe tener en cuenta que no es necesario una representación explícita de los métodos de limpieza para las tareas, ya que las tareas se realizan ejecutando algún plan o planes. Por lo tanto, abortar una tarea significa abortar el plan actual que se está ejecutando para realizar esa tarea, como describiremos a continuación. Invocación del método de aborto. Ahora describimos de manera informal la acción de los agentes al abortar planes y tareas. Cuando un plan P es abortado: 1. Abortar cada sub-tarea que sea un hijo activo de P. Un hijo activo es aquel que fue desencadenado por P y actualmente está en ejecución. 2. Cuando ya no haya más niños activos, invoque el método de aborto del plan P. 3. Indique un fallo en el plan para TP, la tarea principal de P. Se señala aquí que si la tarea principal TP no debe ser abortada, entonces el agente puede elegir otro plan aplicable para satisfacer TP. 10 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) Cuando una tarea (o sub-tarea) T es abortada: 1. Abortar el plan activo actual para satisfacer T (si lo hay). 2. Cuando ya no haya más procesos secundarios activos, elimine la tarea. El agente ya no persigue a T. 3. Ten en cuenta que cuando se aborta el plan activo actual para realizar T, no se deben intentar otros planes aplicables para realizar T, ya que es la tarea que se va a abortar. Para evitar esfuerzos de limpieza en cascada infinita, asumimos que los métodos de aborto nunca serán abortados ni fallarán. En realidad, sin embargo, un método de aborto puede fallar. En este caso, al no contar con un mecanismo de manejo más sofisticado, el agente simplemente deja de ejecutar el método de aborto fallido sin más deliberación. La suposición que hacemos no es, por lo tanto, un reflejo de la complejidad total de la realidad, sino una que es pragmática en términos del ciclo de ejecución del agente; el enfoque para el manejo de fallos de [21] hace la misma suposición. En sistemas como SPARK, el programador puede especificar un comportamiento alternativo para un método de fallo o aborto fallido mediante procedimientos a nivel meta. También asumimos que los métodos de falla y aborto terminan en tiempo finito. 4. SEMÁNTICA OPERACIONAL Proporcionamos la semántica para los procesos de falla y aborto de tareas y planes descritos anteriormente. Utilizamos el lenguaje CAN inicialmente definido en [23] y posteriormente extendido como CANPLAN en [17] para incluir un componente de planificación y luego como CANPLAN2 en [18] para mejorar los mecanismos de adopción y eliminación de objetivos. Las extensiones también simplificaron la semántica en el trabajo anterior. Utilizamos algunas de estas simplificaciones para proporcionar un breve resumen del lenguaje CAN en la Sección 4.1. Tras una presentación de la semántica operacional de nuestro enfoque en la Sección 4.2, en la Sección 4.3 proporcionamos un ejemplo trabajado para aclarar la semántica que presentamos. 4.1 Lenguaje CAN CAN es un lenguaje de agente de alto nivel, en un espíritu similar al de AgentSpeak [15] y Kinnys Ψ [7], ambos de los cuales intentan extraer la esencia de una clase de sistemas de agentes BDI implementados. CAN proporciona un <br>constructo de objetivo</br> explícito que captura tanto los aspectos declarativos como los procedimentales de un objetivo. Los objetivos son persistentes en CAN en el sentido de que, cuando un plan falla, se intenta otro plan aplicable. Esto equivale al mecanismo predeterminado de manejo de fallos que se encuentra típicamente en sistemas BDI implementados como JACK [2]. En sistemas prácticos, las tareas suelen traducirse en eventos que desencadenan la ejecución de algunos planes. Esto también es cierto en el lenguaje CAN, pero, para mantener la persistencia de los objetivos, se introduce un <br>constructo de objetivo</br>. Esto se denota por Objetivo ` φs, P, φf ´, donde φs es la condición de éxito que determina cuándo se considera que el objetivo se ha logrado, φf es una condición de fracaso bajo la cual se considera que el objetivo ya no es alcanzable o relevante, y P es un programa para lograr el objetivo, que se abortará una vez que φs o φf se vuelvan verdaderos. El comportamiento de un agente está especificado por una biblioteca de planes, denotada por Π, que consiste en una colección de cláusulas de planes de la forma e : c ← P, donde e es un evento, c es una condición de contexto (una fórmula lógica sobre las creencias de los agentes que debe ser verdadera para que el plan sea aplicable) y P es el cuerpo del plan. El cuerpo del plan es un programa que se define recursivamente de la siguiente manera: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Objetivo ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 Un c omitido es equivalente a verdadero. Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figura 1: Reglas operativas de CAN. donde P1, . . . , Pn son ellos mismos programas, act es una acción primitiva que no está más especificada, y +b y −b son operaciones para añadir y eliminar creencias. La base de creencias contiene átomos de creencias fundamentales en forma de relaciones de primer orden, pero podría ser extendida ortogonalmente a otras lógicas. Se asume que se proporcionan operaciones bien definidas para verificar si una condición se sigue de un conjunto de creencias (B |= c), para agregar una creencia a un conjunto de creencias (B ∪ {b}), y para eliminar una creencia de un conjunto de creencias (B \\ {b}). ?φ es una prueba para la condición φ, y !e5 es un evento6 que se publica desde dentro del programa. Los constructos compuestos son secuenciación (P1; P2), ejecución paralela (P1 P2) y metas (Meta ` φs, P, φf ´ ). Lo anterior define el idioma del usuario. Además, se utilizan un conjunto de formas compuestas auxiliares internamente al asignar semántica a los constructos. nil es el programa básico (terminante). Cuando un evento coincide con un conjunto de cláusulas de plan, estas se recopilan en un conjunto de alternativas protegidas (c1: P1, ..., cn: Pn). La otra forma compuesta auxiliar, , es un operador de elección dual a la secuenciación: P1 P2 ejecuta P1 y luego ejecuta P2 solo si P1 falló. Un resumen de la semántica operacional para CAN de acuerdo con [23] y siguiendo algunas de las simplificaciones de [17] es el siguiente. Una configuración básica S = B, G, Γ consiste en la base de creencias actual B del agente, el conjunto actual de metas G que se persiguen (es decir, un conjunto de fórmulas) y el programa actual P que se está ejecutando (es decir, la intención actual). Una transición S0 −→ S1 especifica que ejecutar S0 durante un paso único produce la configuración S1. S0 −→∗ Sn es el cierre reflexivo transitivo usual de −→: Sn es el resultado de una o más transiciones de un solo paso. Una regla de derivación S −→ Sr S −→ Sr consiste en un conjunto (posiblemente vacío) de premisas, que son transiciones junto con algunas condiciones auxiliares (numerador), y una única transición conclusión derivable de estas premisas (denominador). La Figura 1 muestra algunas de las reglas operativas. La regla de Evento maneja eventos de tarea recopilando todas las cláusulas de plan relevantes para el evento en cuestión: para cada cláusula de plan e : ψi ← Pi, si hay un unificador más general, θ = mgu(e, e) de e y el evento en 5 Donde es obvio que e es un evento, a veces excluiremos el signo de exclamación para mayor legibilidad. 6 Típicamente un objetivo de logro. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 11 B |= φs B, Objetivo ` φs, P, φf ´ −→ B, verdadero Gs B |= φf B, Objetivo ` φs, P, φf ´ −→ B, falla Gf P = Objetivo ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Objetivo ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Objetivo ` φs, P, φf ´ −→ B , Objetivo ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {verdadero, falla} B, Objetivo ` φs, P, φf ´ −→ B, Objetivo ` φs, P2 £ P2, φf ´ GR Figura 2: Reglas para objetivos en CAN. pregunta, entonces la regla construye una alternativa guardada ψiθ: Piθ. La regla Select selecciona un cuerpo de plan aplicable de un conjunto de alternativas relevantes (restantes): el programa P Δ establece que el programa P debe intentarse primero, recurriendo a las alternativas restantes, Δ \\ P, si es necesario. Esta regla y la regla de fallo se utilizan juntas para el manejo de fallos: si el programa actual Pi de una cláusula de plan para una tarea falla, primero se aplica la regla de fallo, y luego, si es posible, la regla Select elegirá otra alternativa aplicable para la tarea si existe alguna. Rule Sequence maneja la secuenciación de programas de la manera habitual. Las reglas Parallel1 y Parallel2 definen la posible intercalación al ejecutar dos programas en paralelo. La Figura 2 presenta reglas simplificadas para tratar con objetivos, en línea con las presentadas en [17]. La primera regla establece que un objetivo tiene éxito cuando φs se vuelve verdadero; la segunda regla establece que un objetivo falla cuando φf se vuelve verdadero. La tercera regla GI inicializa la ejecución de un programa de metas actualizando la base de metas y estableciendo el programa en la meta como P £ P; el primer P se ejecutará y el segundo P se utiliza para hacer un seguimiento del programa original para la meta. La cuarta regla GS ejecuta un solo paso del programa de objetivos. La regla final GR reinicia el programa original (codificado como P2 del par P1 £ P2) cada vez que el programa actual ha terminado pero el objetivo deseado y aún posible no se ha logrado. 4.2 Abortando Intenciones y Manejando Fallas A continuación, introducimos la capacidad de especificar programas manejadores, en forma de métodos de falla y aborto, que se ocupan de la limpieza requerida cuando un programa dado falla o es abortado. No asociamos los métodos de falla y aborto con cláusulas de plan o con tareas (eventos), sino que introducimos una nueva construcción de programa que especifica los métodos de falla y aborto para un programa arbitrario. El constructo FAb(P, PF, PA) ejecuta el programa P. En caso de que P falle, ejecuta el programa de manejo de fallos PF; si P necesita ser abortado, ejecuta el programa de manejo de aborto PA. Por lo tanto, para agregar los métodos de falla y aborto PF y PA a una cláusula de plan e : c ← P, escribimos e : c ← FAb(P, PF, PA). Con la introducción de la capacidad de abortar programas, modificamos la construcción paralela para permitir que el fallo de una rama aborte la otra. Debemos tener en cuenta la posible existencia de métodos de aborto en la rama abortada. De manera similar, con el <br>constructo de Objetivo</br> ya no podemos abandonar por completo el programa que contiene tan pronto como se cumpla la condición de éxito o fracaso; ahora debemos tener en cuenta la existencia de cualquier método de aborto aplicable al programa. Proporcionamos la semántica de un lenguaje de agente aumentado que contiene el constructo FAb al definir una transformación de origen, similar a la expansión de macros, que mapea una biblioteca de planes que contiene el constructo FAb(P, PF, PA) en CAN estándar (casi). La única extensión no estándar a CAN es un constructo de espera hasta que se cumpla una condición. Explicamos esta simple modificación del constructo paralelo a continuación cuando llegamos a la traducción del <br>constructo de la Meta</br>. Primero describimos la naturaleza general de la transformación de la fuente, que resulta ser bastante simple para la mayoría de las construcciones del lenguaje, y luego nos concentramos en los tres casos más complejos: las construcciones FAb, paralela y Goal. Un problema clave es que los constructos FAb pueden estar anidados, ya sea directa o indirectamente. Llamemos a cada instancia del constructo en tiempo de ejecución un posible punto de aborto (pap). Donde estos constructos están anidados, es importante que antes de que se ejecute el método de falla o aborto de un pap padre, se ejecuten primero los programas de métodos de falla o aborto de los paps hijos, como se describe anteriormente en la Sección 3. La necesidad de coordinar la ejecución de los métodos de aborto de paps anidados requiere que haya alguna forma de identificar los padres e hijos de un pap en particular. Logramos esto como parte de la transformación de origen al llevar un registro explícito del contexto de ejecución como un parámetro adicional en los eventos y una variable adicional dentro de cada cuerpo del plan. La transformación de origen reemplaza cada cláusula del plan de la forma e : c ← P con una cláusula del plan e(v) : c ← μv(P) donde v es una variable libre, no presente previamente en la cláusula del plan. Esta variable se utiliza para llevar un registro del contexto de ejecución. El valor de la variable de contexto es una lista de identificadores, donde cada nuevo párrafo está representado al anteponer un nuevo identificador al contexto. Por ejemplo, si los identificadores son enteros, el contexto de un documento puede ser representado por una lista [42, 1] y el contexto introducido por un nuevo documento puede ser representado por [52, 42, 1]. Nos referiremos a los paps por el contexto en lugar del nuevo identificador agregado, por ejemplo, por [51, 42, 1] y no solo por 51. Esto nos permite equiparar la relación de ancestro entre paps con la relación de sufijo de lista en los contextos relevantes, es decir, v es un ancestro de v si y solo si v es un sufijo de v. Para la mayoría de los constructos CAN, la variable de contexto no se utiliza o se pasa sin cambios: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) Queda por especificar la transformación μv(·) en tres casos: los constructos FAb, paralelo y Goal. Estos son más complejos en el sentido de que la fuente transformada necesita crear dinámicamente un nuevo identificador de pap, para usarlo como un nuevo contexto dentro de la construcción, y para llevar un registro de cuándo el pap está activo (es decir, actualmente en ejecución) añadiendo y eliminando creencias sobre el contexto. Introduzcamos la acción primitiva prependID(v, v) que crea un nuevo identificador pap y lo antepone a la lista v, dando como resultado la lista v. También introducimos los siguientes predicados: • a(v) - el pap v está actualmente activo. • abort(v) - el pap v debe ser abortado (después de abortar a todos sus descendientes). Una alternativa sería utilizar predicados a nivel meta que reflejen el estado actual de la estructura de intenciones. La Sexta Conferencia Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) • f(v) - el programa del pap v ha fallado. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))el pap v es un ancestro del pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v no tiene hijos activos. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - debemos abortar v, es decir, abort es verdadero para v o algún ancestro; sin embargo, debemos esperar hasta que no haya hijos activos de v. • san(v) ≡ sa(v) ∧ nac(v) - debemos abortar v ahora si debemos abortar v y v no tiene hijos activos. Primero consideremos el caso del constructo FAb. La idea es que, cada vez que ocurra un nuevo pap, se utiliza la acción prependID(v, v) para crear una nueva lista de identificadores de pap v a partir de la lista existente v. Luego agregamos la creencia de que v es el contexto activo, es decir, +a(v), y comenzamos a procesar el programa dentro del pap utilizando v en lugar de v como contexto. Necesitamos asegurarnos de retractar la creencia de que v está activo al final, es decir, −a(v). Utilizamos la <br>construcción de Objetivo</br> para permitirnos detener la ejecución de un programa dentro de un pap v cuando sea necesario abortar. ",
            "candidates": [],
            "error": [
                [
                    "constructo de objetivo",
                    "constructo de objetivo",
                    "constructo de Objetivo",
                    "constructo de la Meta",
                    "construcción de Objetivo"
                ]
            ]
        },
        "agent": {
            "translated_key": "agente",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another <br>agent</br>.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some <br>agent</br> programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract <br>agent</br> language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular <br>agent</br> system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the <br>agent</br> to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to <br>agent</br> programming, and is an important element of <br>agent</br> characteristics such as robustness, flexibility, and persistence [21].",
                "In <br>agent</br> architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an <br>agent</br> that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an intelligent <br>agent</br> is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the <br>agent</br> believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another <br>agent</br> altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most <br>agent</br> systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most <br>agent</br> systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the <br>agent</br> execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract <br>agent</br> language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one <br>agent</br> system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single <br>agent</br>, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive <br>agent</br> such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO <br>agent</br> adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO <br>agent</br> to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the <br>agent</br> (such as reasoning about priorities in a conflict over resources), or from external sources (such as another <br>agent</br> cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the <br>agent</br> should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the <br>agent</br> undo-ing its actions to date; indeed, this may be neither possible (since the <br>agent</br> acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the <br>agent</br> to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The <br>agent</br> selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the <br>agent</br> may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the <br>agent</br> can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the <br>agent</br> decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the <br>agent</br> is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of <br>agent</br> action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the <br>agent</br> will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an <br>agent</br> to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the <br>agent</br> itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the <br>agent</br> should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the <br>agent</br> to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational <br>agent</br> will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the <br>agent</br> will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the <br>agent</br> system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the <br>agent</br> takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the <br>agent</br> may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The <br>agent</br> thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the <br>agent</br> simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the <br>agent</br> execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level <br>agent</br> language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI <br>agent</br> systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the <br>agent</br>, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented <br>agent</br> language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the <br>agent</br> to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the <br>agent</br> to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason <br>agent</br> modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI <br>agent</br> implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an <br>agent</br>.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated <br>agent</br> Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the <br>agent</br> programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the <br>agent</br> to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track <br>agent</br> execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI <br>agent</br> to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the <br>agent</br> itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one <br>agent</br> system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-<br>agent</br> systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for <br>agent</br> crash recovery.",
                "Other work on multi-<br>agent</br> exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an <br>agent</br>. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an <br>agent</br> may not successfully reach completion, either by the choice of the <br>agent</br> to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style <br>agent</br>, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the <br>agent</br> for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract <br>agent</br> language CAN.",
                "We are planning to implement an instance of our approach in the SPARK <br>agent</br> system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent <br>agent</br> will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style <br>agent</br>, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic <br>agent</br> reasoning, such as the introspection that an <br>agent</br> capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the <br>agent</br> has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and <br>agent</br> Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI <br>agent</br> systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-<br>agent</br> Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in <br>agent</br> programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An <br>agent</br>-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative <br>agent</br> Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic <br>agent</br> language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-<br>agent</br> systems: The case of <br>agent</br> death.",
                "Autonomous Agents and Multi-<br>agent</br> Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK <br>agent</br> framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of <br>agent</br> resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user <br>agent</br>.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent <br>agent</br> Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-<br>agent</br> Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-<br>agent</br> World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI <br>agent</br> programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in <br>agent</br> systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-<br>agent</br> Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-<br>agent</br> systems.",
                "In Proc. of Second IEEE Symposium on Multi-<br>agent</br> Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent <br>agent</br> systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another <br>agent</br>.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some <br>agent</br> programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract <br>agent</br> language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular <br>agent</br> system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the <br>agent</br> to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Accordingly, dealing with failure is fundamental to <br>agent</br> programming, and is an important element of <br>agent</br> characteristics such as robustness, flexibility, and persistence [21]."
            ],
            "translated_annotated_samples": [
                "Además, dichos <br>agente</br>s deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del <br>agente</br>, o potencialmente a solicitud de otro agente.",
                "Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de <br>agente</br>s.",
                "Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de <br>agente</br> abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de <br>agente</br>s particular (como JACK, Jadex, Jason o SPARK).",
                "Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el <br>agente</br> se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada.",
                "Por lo tanto, enfrentarse al fracaso es fundamental para la programación de <br>agente</br>s, y es un elemento importante de las características de los <br>agente</br>s como la robustez, la flexibilidad y la persistencia [21]."
            ],
            "translated_text": "Los agentes BDI deben ser capaces de abortar tareas de manera elegante cuando estas no tienen éxito, especialmente en entornos dinámicos. Además, dichos <br>agente</br>s deberían ser capaces de tomar decisiones racionales sobre un curso de acción apropiado, que puede incluir la interrupción de una tarea o plan, ya sea como resultado de las propias deliberaciones del <br>agente</br>, o potencialmente a solicitud de otro agente. En este artículo investigamos la incorporación de abortos en una arquitectura de estilo BDI. Discutimos algunas condiciones bajo las cuales abortar una tarea o un plan es apropiado, y cómo determinar las consecuencias de tal decisión. Añadimos a cada plan un método de aborto opcional, análogo al método de falla encontrado en algunos lenguajes de programación de <br>agente</br>s. Proporcionamos una semántica operativa para el ciclo de ejecución en presencia de abortos en el lenguaje de <br>agente</br> abstracto CAN, lo que nos permite especificar un modelo de ejecución basado en BDI sin limitar nuestra atención a un sistema de <br>agente</br>s particular (como JACK, Jadex, Jason o SPARK). Un desafío técnico clave que abordamos es la presencia de hilos de ejecución paralelos y de subtareas, lo que requiere que el <br>agente</br> se asegure de que los métodos de aborto para cada plan se lleven a cabo en una secuencia apropiada. Categorías y Descriptores de Asignaturas I.2.11 [INTELIGENCIA ARTIFICIAL]: Inteligencia Artificial Distribuida-Agentes Inteligentes Términos Generales Diseño, Confiabilidad, Teoría 1. INTRODUCCIÓN Los agentes inteligentes generalmente trabajan en entornos complejos y dinámicos, como el control del tráfico aéreo o la navegación de robots, en los que el éxito de cualquier acción o plan en particular no puede ser garantizado [13]. Por lo tanto, enfrentarse al fracaso es fundamental para la programación de <br>agente</br>s, y es un elemento importante de las características de los <br>agente</br>s como la robustez, la flexibilidad y la persistencia [21]. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "reactive and deliberative architecture": {
            "translated_key": "arquitectura reactiva y deliberativa",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "formal model of agency": {
            "translated_key": "modelo formal de agencia",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "agency formal model": {
            "translated_key": "modelo formal de agencia",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Aborting Tasks in BDI Agents John Thangarajah, James Harland RMIT University Melbourne, Australia {johthan,jah}@cs.rmit.edu.au David Morley, Neil Yorke-Smith Artificial Intelligence Center, SRI International Menlo Park, CA 94025 U.S.A. {morley,nysmith}@ai.sri.com ABSTRACT Intelligent agents that are intended to work in dynamic environments must be able to gracefully handle unsuccessful tasks and plans.",
                "In addition, such agents should be able to make rational decisions about an appropriate course of action, which may include aborting a task or plan, either as a result of the agents own deliberations, or potentially at the request of another agent.",
                "In this paper we investigate the incorporation of aborts into a BDI-style architecture.",
                "We discuss some conditions under which aborting a task or plan is appropriate, and how to determine the consequences of such a decision.",
                "We augment each plan with an optional abort-method, analogous to the failure method found in some agent programming languages.",
                "We provide an operational semantics for the execution cycle in the presence of aborts in the abstract agent language CAN, which enables us to specify a BDI-based execution model without limiting our attention to a particular agent system (such as JACK, Jadex, Jason, or SPARK).",
                "A key technical challenge we address is the presence of parallel execution threads and of sub-tasks, which require the agent to ensure that the abort methods for each plan are carried out in an appropriate sequence.",
                "Categories and Subject Descriptors I.2.11 [ARTIFICIAL INTELLIGENCE]: Distributed Artificial Intelligence-Intelligent agents General Terms Design, Reliability, Theory 1.",
                "INTRODUCTION Intelligent agents generally work in complex, dynamic environments, such as air traffic control or robot navigation, in which the success of any particular action or plan cannot be guaranteed [13].",
                "Accordingly, dealing with failure is fundamental to agent programming, and is an important element of agent characteristics such as robustness, flexibility, and persistence [21].",
                "In agent architectures inspired by the Belief-Desire-Intention (BDI) model [16], these properties are often characterized by the interactions between beliefs, goals, and plans [2].1 In general, an agent that wishes to achieve a particular set of tasks will pursue a number of plans concurrently.",
                "When failures occur, the choice of plans will be reviewed.",
                "This may involve seeking alternative plans for a particular task, re-scheduling tasks to better comply with resource constraints, dropping some tasks, or some other decision that will increase the likelihood of success [12, 14].",
                "Failures can occur for a number of reasons, and it is often not possible to predict these in advance, either because of the complexity of the system or because changes in the environment invalidate some earlier decisions.",
                "Given this need for deliberation about failed tasks or plans, failure deliberation is commonly built into the agents execution cycle.",
                "Besides dealing with failure, an important capability of an intelligent agent is to be able to abort a particular task or plan.",
                "This decision may be due to an internal deliberation (such as the agent believing the task can no longer be achieved, or that some conflicting task now has a higher priority) or due to an external factor (such as another agent altering a commitment, or a change in the environment).",
                "Aborting a task or plan is distinct from its failure.",
                "Failure reflects an inability to perform and does not negate the need to perform - for example, a reasonable response to failure may be to try again.",
                "In contrast, aborting says nothing about the ability to perform; it merely eliminates the need.",
                "Failure propagates from the bottom up, whereas aborting propagates from the top down.",
                "The potential for concurrently executing sub-plans introduces different complexities for aborting and failure.",
                "For aborting, it means that multiple concurrent sub-plans may need to be aborted as the abort is propagated down.",
                "For failure, it means that parallel-sibling plans may need to be aborted as the failure is propagated up.",
                "There has been a considerable amount of work on plan failures (such as detecting and resolving resource conflicts [20, 10]) and most agent systems incorporate some notion of failure handling.",
                "However, there has been relatively little work on the development of abort techniques beyond simple dropping of currently intended plans and tasks, which does not deal with the clean-up required.",
                "As one consequence, most agent systems are quite limited in their treatment of the situation where one branch of a parallel construct 1 One can consider both tasks to be performed and goals to achieve a certain state of the world.",
                "A task can be considered a goal of achieving the state of the task having been performed, and a goal can be considered a task of bringing about that state of the world.",
                "We adopt the latter view and use task to also refer to goals. 8 978-81-904262-7-5 (RPS) c 2007 IFAAMAS fails (common approaches include either letting the other branch run to completion unhindered or dropping it completely).",
                "In this paper we discuss in detail the incorporation of abort cleanup methods into the agent execution cycle, providing a unified approach to failure and abort.",
                "A key feature of our procedure-based approach is that we allow each plan to execute some particular code on a failure and on an abort.",
                "This allows a plan to attempt to ensure a stable, known state, and possibly to recover some resources and otherwise clean up before exiting.",
                "Accordingly, a central technical challenge is to manage the orderly execution of the appropriate clean-up code.",
                "We show how aborts can be smoothly introduced into a BDI-style architecture, and for the first time we give an operational semantics for aborting in the abstract agent language CAN [23, 17].",
                "This allows us to specify an appropriate level of detail for the execution model, without focusing on the specific constructs of any one agent system such as JACK [2], Jadex [14], Jason [6], or SPARK [9].",
                "Our focus is on a single agent, complementary to related work that considers exception handling for single- and multiagent systems (e.g., [22, 5, 6]).",
                "This paper is organized as follows.",
                "In Section 2 we give an example of the consequences of aborting a task, and in Section 3 we discuss some circumstances under which aborts should occur, and the appropriate representation and invocation procedures.",
                "In Section 4 we show how we can use CAN to formally specify the behaviour of an aborted plan.",
                "Section 5 discusses related work, and in Section 6 we present our conclusions and future work. 2.",
                "MOTIVATING EXAMPLE Alice is a knowledge worker assisted by a learning, personal assistive agent such as CALO [11].",
                "Alice plans to attend the IJCAI conference later in the year, and her CALO agent adopts the task of Support Meeting Submission (SMS) to assist her.",
                "CALOs plan for an SMS task in the case of a conference submission consists of the following sub-tasks: 1.",
                "Allocate a Paper Number (APN) to be used for administrative purposes in the company. 2.",
                "Track Writing Abstract (TWA): keep track of Alices progress in preparing an abstract. 3.",
                "Apply For Clearance (AFC) for publication from Alices manager based on the abstract and conference details. 4.",
                "Track Writing Paper (TWP): keep track of Alices progress in writing the paper. 5.",
                "Handle Paper Submission (HPS): follow company internal procedures for submitting a paper to a conference.",
                "These steps must be performed in order, with the exception of steps 3 (AFC) and 4 (TWP), which may be performed in parallel.",
                "Similarly, CALO can perform the task Apply For Clearance (AFC) by a plan consisting of: 1.",
                "Send Clearance Request (SCR) to Alices manager. 2.",
                "Wait For Response (WFR) from the manager. 3.",
                "Confirm that the response was positive, and fail otherwise.",
                "Now suppose that a change in circumstances causes Alice to reconsider her travel plans while she is writing the paper.",
                "Alice will no longer be able to attend IJCAI.",
                "She therefore instructs her CALO agent to abort the SMS task.",
                "Aborting the task implies aborting both the SMS plan and the AFC subplan.",
                "Aborting the first plan requires CALO to notify the paper number registry that the allocated paper number is obsolete, which it can achieve by the Cancel Paper Number (CPN) task.2 Aborting the second plan requires CALO to notify Alices manager that Alice no longer requires clearance for publication, which CALO can achieve by invoking the Cancel Clearance Request (CCR) task.",
                "We note a number of important observations from the example.",
                "First, the decision to abort a particular course of action can come from the internal deliberations of the agent (such as reasoning about priorities in a conflict over resources), or from external sources (such as another agent cancelling a commitment), as in this example.",
                "In this paper we only touch on the problem of determining whether a task or plan should be aborted, instead concentrating on determining the appropriate actions once this decision is made.",
                "Hence, our objective is to determine how to incorporate aborting mechanisms into the standard execution cycle rather than determine what should be aborted and when.",
                "Second, once the decision is made to abort the attempt to submit a paper, there are some actions the agent should take, such as cancelling the clearance request.",
                "In other words, aborting a task is not simply a matter of dropping the task and associated active plans: there are some clean up actions that may need to be done.",
                "This is similar to the case for failure, in that there may also be actions to take when a task or plan fails.",
                "In both cases, note that it is not simply a matter of the agent undo-ing its actions to date; indeed, this may be neither possible (since the agent acts in a situated world and its actions change world state) nor desirable (depending on the semantics of the task).",
                "Rather, cleaning up involves compensation via forward recovery actions [3].",
                "Third, there is a distinction between aborting a task and aborting a plan.",
                "In the former case, it is clear that all plans being executed to perform the task should be aborted; in the latter case, it may be that there are better alternatives to the current plan and one of these should be attempted.",
                "Hence, plan aborting or failure does not necessarily lead to task aborting or failure.",
                "Fourth, given that tasks may contain sub-tasks, which may contain further sub-tasks, it is necessary for a parent task to wait until its children have finished their abort methods.",
                "This is the source of one of the technical challenges that we address: determining the precise sequence of actions once a parent task or plan is aborted. 3.",
                "ABORTING TASKS AND PLANS As we have alluded to, failure and aborting are related concepts.",
                "They both cause the execution of existing plans to cease and, consequentially, the agent to reflect over its current tasks and intentions.",
                "Failure and aborting, however, differ in the way they arise.",
                "In the case of failure, the trigger to cease execution of a task or plan comes from below, that is, the failure of sub-tasks or lower-level plans.",
                "In the case of aborting, the trigger comes from above, that is, the tasks and the parent plans that initiated a plan.",
                "In BDI-style systems such as JACK and SPARK, an agents domain knowledge includes a pre-defined plan library of plan clauses.",
                "Each plan clause has a plan body, which is a program (i.e., combination of primitive actions, sub-tasks, etc.) that can be executed in response to a task or other event should the plan clauses context condition be satisfied.",
                "The agent selects and executes instances of plan clauses to perform its tasks.",
                "There can be more than one applicable plan clause and, in the event that one fails, another applicable one may be attempted.",
                "Plans may have sub-tasks that must succeed 2 CALO needs only drop the TWA and TWP tasks to abort them: for the sake of simplicity we suppose no explicit clean up of its internal state is necessary.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 9 for the plan to succeed.",
                "In such systems, a plan failure occurs if one of the actions or sub-tasks within the plan fails.",
                "The agents action upon plan failure depends on its nature: for example, the agent may declare the task to have failed if one plan has been tried and resulted in failure, or it may retry alternate plans and declare (indeed, must declare) task failure only if all possible alternate plans to perform the task have been tried and resulted in failure.",
                "Observe that, while task failure can follow from plan failure or a sequence of plan failures, plan failure need not lead to task failure provided the agent can successfully complete an alternate plan.",
                "Moreover, task failure can also arise separately from plan failure, if the agent decides to abort the task.",
                "Our approach associates an abort-method with each plan.",
                "This enables the programmer to specify dedicated compensation actions according to how the agent is attempting to perform the task.",
                "Note that our abort-methods can be arbitrary programs and so can invoke tasks that may be performed dynamically in the usual BDI fashion, i.e., the clean-up is not limited to executing a predetermined set of actions.",
                "The question remains which abort-method should be invoked, and in what manner.",
                "Given the complexity of agent action spaces, it is not possible nor desirable to enumerate a static set of rules.",
                "Rather, the agent will invoke its abort-methods dynamically according to the state of execution and its own internal events.",
                "An alternative to attaching an abort-method to each plan is to attach such methods to each atomic action.",
                "We choose the former because: (1) action-level abort-methods would incur a greater overhead, (2) plans are meant to be designed as single cohesive units and are the unit of deliberation in BDI systems, and (3) the cleanup methods for failure in current systems are attached to plans.",
                "In order to understand how the agents abort processing should function, we consider three situations where it is sensible for an agent to consider aborting some of its tasks and plans: 1.",
                "When a task succeeds or fails because of an external factor other than the agent itself, the plan currently executed to perform the task should be aborted.",
                "For example, suppose company policy changes so that employees of Alices seniority automatically have clearance for publishing papers.",
                "Since Alice now has clearance for publishing her paper, CALO can abort the plan for Apply For Clearance.",
                "In doing so it must invoke the abort-method, in this case thus performing Cancel Clearance Request.3 2.",
                "When two or more sub-programs are executed in parallel, if one fails then the others should be aborted, given that the failure of one branch leads to the failure of the overall task.",
                "For example, suppose that part-way through writing the paper, Alice realizes that there is a fatal flaw in her results, and so notifies CALO that she will not be able to complete the paper by the deadline.",
                "The failure of the Track Writing Paper task should cause the Apply For Clearance task being executed in parallel to be aborted. 3.",
                "When an execution event alters the importance of an existing task or intention, the agent should deliberate over whether the existing plan(s) should continue.",
                "For example, suppose that Alice tasks CALO with a new, high-priority task to purchase a replacement laptop, but that Alice lacks enough funds to both purchase the laptop and to attend IJCAI.",
                "Reasoning over resource requirements [20, 10] will cause the agent to realize 3 If there is any difference between how to abort a task that is externally performed versus how to abort one that is now known to be impossible, the abort-method can detect the circumstances and handle the situation as appropriate. that it cannot successfully complete both tasks.",
                "Given that the new task has greater importance, a rational agent will evaluate its best course of action and may decide to abortor at least suspend - the existing task of submitting a paper and intentions derived from it [12].",
                "The operational semantics we provide in Section 4 for aborting tasks and plans captures the first two situations above.",
                "The third situation involves deliberating over the importance of a task, which depends on various factors such as task priority.",
                "Although this deliberation is beyond the scope of this paper, it is a complementary topic of our future work.",
                "Note that the above situations apply to achievement goals, for which the task is completed when a particular state of the world is brought about (e.g., ensure we have clearance).",
                "Different forms of reasoning apply to other goal types [4] such as maintenance goals [1], where the goal is satisfied by maintaining a state of the world for some period of time (e.g., maintain $100 in cash).",
                "Abort Method Representation The intent of aborting a task or plan is that the task or plan and all its children cease to execute, and that appropriate clean-up methods are performed as required.",
                "In contrast to offline planning systems, BDI agents are situated: they perform online deliberation and their actions change the state of the world.",
                "As a result, the effects of many actions cannot be simply undone.",
                "Moreover, the undo process may cause adverse effects.",
                "Therefore, the clean-up methods that we specify are forward recovery procedures that attempt to ensure a stable state and that also may, if possible, recover resources.",
                "The common plan representation in BDI-style systems such as JACK and SPARK includes a failure-method, which is the designated clean-up method invoked when the plan fails.",
                "To this, we add the abort-method, which is invoked if the plan is to be aborted.",
                "In our example, the abort-method for the plan for Support Meeting Submission consists of invoking the sub-task Cancel Paper Number.",
                "The abort-method need not explicitly abort Apply For Clearance, because the agent will invoke the abort-method for the subtask appropriately, as we outline below.",
                "The assumption here is that, like the failure-method, the programmer of the agent system has the opportunity to specify a sensible abort-method that takes into consideration the point in the plan at which the abort is to be executed.",
                "For any plan, the abort-method is optional: if no abort-method is specified, the agent takes no specific action for this plan.",
                "However, the agents default behavioural rules still apply, for example, whether to retry an alternate plan for the parent task.",
                "Note that an explicit representation of the clean-up methods for tasks is not required, since tasks are performed by executing some plan or plans.",
                "Hence, aborting a task means aborting the current plan that is executed to perform that task, as we next describe.",
                "Abort Method Invocation We now informally lay out the agents action upon aborting plans and tasks.",
                "When a plan P is aborted: 1.",
                "Abort each sub-task that is an active child of P. An active child is one that was triggered by P and is currently in execution. 2.",
                "When there are no more active children, invoke the abort method of plan P. 3.",
                "Indicate a plan failure to TP , the parent task of P. We note here that if the parent task TP is not to be aborted then the agent may choose another applicable plan to satisfy TP . 10 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) When a task (or sub-task) T is aborted: 1.",
                "Abort the current active plan to satisfy T (if any). 2.",
                "When there are no more active child processes, drop the task.",
                "The agent thus no longer pursues T. 3.",
                "Note here that when the current active plan for performing T is aborted, no other applicable plans to perform T should be tried as it is the task that is to be aborted.",
                "In order to prevent infinitely cascading clean-up efforts, we assume that abort-methods will never be aborted nor fail.",
                "In reality, however, an abort-method may fail.",
                "In this case, lacking a more sophisticated handling mechanism, the agent simply stops executing the failed abort-method with no further deliberation.",
                "The assumption we make is thus not a reflection of the full complexity of reality, but one that is pragmatic in terms of the agent execution cycle; the approach to failure-handling of [21] makes the same assumption.",
                "In systems such as SPARK, the programmer can specify an alternative behaviour for a failed failure- or abort-method by means of meta-level procedures.",
                "We also assume that failure- and abort-methods terminate in finite time. 4.",
                "OPERATIONAL SEMANTICS We provide the semantics for the task and plan failure and aborting processes outlined above.",
                "We use the CAN language initially defined in [23] and later extended as CANPLAN in [17] to include a planning component and then as CANPLAN2 in [18] to improve the goal adoption and dropping mechanisms.",
                "The extensions also simplified the semantics in the earlier work.",
                "We use some of these simplifications for providing a brief summary of the CAN language in Section 4.1.",
                "Following a presentation of the operational semantics of our approach in Section 4.2, in Section 4.3 we provide a worked example to clarify the semantics that we present. 4.1 CAN Language CAN is a high-level agent language, in a spirit similar to that of AgentSpeak [15] and Kinnys Ψ [7], both of which attempt to extract the essence of a class of implemented BDI agent systems.",
                "CAN provides an explicit goal construct that captures both the declarative and procedural aspects of a goal.",
                "Goals are persistent in CAN in that, when a plan fails, another applicable plan is attempted.",
                "This equates to the default failure handling mechanism typically found in implemented BDI systems such as JACK [2].",
                "In practical systems, tasks are typically translated into events that trigger the execution of some plans.",
                "This is also true in the CAN language, but, in order to maintain the persistence of goals, a goal construct is introduced.",
                "This is denoted by Goal ` φs, P, φf ´ , where φs is the success condition that determines when the goal is considered achieved, φf is a fail condition under which it is considered the goal is no longer achievable or relevant, and P is a program for achieving the goal, which will be aborted once φs or φf become true.",
                "An agents behavior is specified by a plan library, denoted by Π, that consists of a collection of plan clauses of the form e : c ← P, where e is an event, c is a context condition (a logical formula over the agents beliefs that must be true in order for the plan to be applicable)4 and P is the plan body.",
                "The plan body is a program that is defined recursively as follows: P ::= act | +b | −b | ?φ | !e | P1; P2 | P1 P2 | Goal ` φs, P1, φf ´ | P1 P2 | {ψ1 : P1, . . . , ψn : Pn} | nil 4 An omitted c is equivalent to true.",
                "Δ = {ψiθ : Piθ | e : ψi ← Pi ∈ Π ∧ θ = mgu(e, e )} B, !e −→ B, Δ Event ψi : Pi ∈ Δ B |= ψi B, Δ −→ B, Pi Δ \\ {ψi : Pi} Select B, P1 −→ B, (P1 P2) −→ B, P2 fail B, P1 −→ B , P1 B, (P1; P2) −→ B , (P ; P2) Sequence B, P1 −→ B , P B, (P1 P2) −→ B , (P P2) Parallel1 B, P2 −→ B , P B, (P1 P2) −→ B , (P P1) Parallel2 Figure 1: Operational rules of CAN. where P1, . . . , Pn are themselves programs, act is a primitive action that is not further specified, and +b and −b are operations to add and delete beliefs.",
                "The belief base contains ground belief atoms in the form of first-order relations but could be orthogonally extended to other logics.",
                "It is assumed that well-defined operations are provided to check whether a condition follows from a belief set (B |= c), to add a belief to a belief set (B ∪ {b}), and to delete a belief from a belief set (B \\ {b}). ?φ is a test for condition φ, and !e5 is an event6 that is posted from within the program.",
                "The compound constructs are sequencing (P1; P2), parallel execution (P1 P2), and goals (Goal ` φs, P, φf ´ ).",
                "The above defines the user language.",
                "In addition, a set of auxiliary compound forms are used internally when assigning semantics to constructs. nil is the basic (terminating) program.",
                "When an event matches a set of plan clauses these are collected into a set of guarded alternatives ( c1 : P1, . . . , cn : Pn ).",
                "The other auxiliary compound form, , is a choice operator dual to sequencing: P1 P2 executes P1 and then executes P2 only if P1 failed.",
                "A summary of the operational semantics for CAN in line with [23] and following some of the simplifications of [17] is as follows.",
                "A basic configuration S = B, G, Γ consists of the current belief base B of the agent, the current set of goals G being pursued (i.e., set of formulae), and the current program P being executed (i.e., the current intention).",
                "A transition S0 −→ S1 specifies that executing S0 for a single step yields configuration S1.",
                "S0 −→∗ Sn is the usual reflexive transitive closure of −→: Sn is the result of one or more singlestep transitions.",
                "A derivation rule S −→ Sr S −→ Sr consists of a (possibly empty) set of premises, which are transitions together with some auxiliary conditions (numerator), and a single transition conclusion derivable from these premises (denominator).",
                "Figure 1 gives some of the operational rules.",
                "The Event rule handles task events by collecting all relevant plan clauses for the event in question: for each plan clause e : ψi ← Pi, if there is a most general unifier, θ = mgu(e, e ) of e and the event in 5 Where it is obvious that e is an event we will sometimes exclude the exclamation mark for readability. 6 Typically an achievement goal.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 11 B |= φs B, Goal ` φs, P, φf ´ −→ B, true Gs B |= φf B, Goal ` φs, P, φf ´ −→ B, fail Gf P = Goal ` φs, P , φf ´ P = P1 £ P2 B |= φs ∨ φf B, P −→ B, Goal ` φs, P £ P , φf ´ GI P = P1 £ P2 B |= φs ∨ φf B, P1 −→ B , P B, Goal ` φs, P, φf ´ −→ B , Goal ` φs, P £ P2, φf ´ GS P = P1 £ P2 B |= φs ∨ φf P1 ∈ {true, fail} B, Goal ` φs, P, φf ´ −→ B, Goal ` φs, P2 £ P2, φf ´ GR Figure 2: Rules for goals in CAN. question, then the rule constructs a guarded alternative ψiθ : Piθ.",
                "The Select rule then selects one applicable plan body from a set of (remaining) relevant alternatives: program P Δ states that program P should be tried first, falling back to the remaining alternatives, Δ \\ P, if necessary.",
                "This rule and the fail rule together are used for failure handling: if the current program Pi from a plan clause for a task fails, rule fail is applied first, and then if possible, rule Select will choose another applicable alternative for the task if one exists.",
                "Rule Sequence handles sequencing of programs in the usual way.",
                "Rules Parallel1 and Parallel2 define the possible interleaving when executing two programs in parallel.",
                "Figure 2 gives simplified rules for dealing with goals, in line with those presented in [17].",
                "The first rule states that a goal succeeds when φs become true; the second rule states that a goal fails when φf become true.",
                "The third rule GI initializes the execution of a goal-program by updating the goal base and setting the program in the goal to P £ P; the first P is to be executed and the second P is used to keep track of the original program for the goal.",
                "The fourth rule GS executes a single step of the goal-program.",
                "The final rule GR restarts the original program (encoded as P2 of pair P1 £ P2) whenever the current program is finished but the desired and still possible goal has not yet been achieved. 4.2 Aborting Intentions and Handling Failure We next introduce the ability to specify handler programs, in the form of failure- and abort-methods, that deal with the clean-up required when a given program respectively fails or is aborted.",
                "We do not associate failure- and abort- methods with plan clauses or with tasks (events), but rather we introduce a new program construct that specifies failure- and abort- methods for an arbitrary program.",
                "The FAb(P, PF , PA) construct executes the program P. Should P fail, it executes the failure handling program PF ; should P need to be aborted, it executes the abort handling program PA.",
                "Thus to add failure- and abort- methods PF and PA to a plan clause e : c ← P, we write e : c ← FAb(P, PF , PA).",
                "With the introduction of the ability to abort programs, we modify the parallel construct to allow the failure of one branch to abort the other.",
                "We must take into consideration the possible existence of abort-methods in the aborted branch.",
                "Similarly, with the Goal construct we can no longer completely abandon the program the goal contains as soon as the success or failure condition holds; we must now take into consideration the existence of any abort-methods applicable to the program.",
                "We provide the semantics of an augmented agent language containing the FAb construct by defining a source transformation, similar to macro-expansion, that maps a plan library containing the FAb(P, PF , PA) construct into (almost) standard CAN.",
                "The one non-standard extension to CAN is a wait-until-condition construct.",
                "We explain this simple modification of the parallel construct below when we come to translation of the Goal construct.",
                "First we describe the general nature of the source transformation, which proves to be quite simple for most of the language constructs, and then we concentrate on the three more complex cases: the FAb, parallel, and Goal constructs.",
                "A key issue is that the FAb constructs may be nested, either directly or indirectly.",
                "Let us call each instantiation of the construct at execution time a possible abort point (pap).",
                "Where these constructs are nested, it is important that before the failure- or abort-method of a parent pap is executed, the failure- or abort-methods programs of the children paps are executed first, as described earlier in Section 3.",
                "The need to coordinate the execution of the abort-methods of nested paps requires that there be some way to identify the parents and children of a particular pap.",
                "We achieve this as part of the source transformation by explicitly keeping track of the context of execution as an extra parameter on the events and an extra variable within each plan body.7 The source transformation replaces each plan clause of the form e : c ← P with a plan clause e(v) : c ← μv(P) where v is a free variable, not previously present in the plan clause.",
                "This variable is used to keep track of the context of execution.",
                "The value of the context variable is a list of identifiers, where each new pap is represented by prepending a new identifier to the context.",
                "For example, if the identifiers are integers, the context of one pap may be represented by a list [42, 1] and the context introduced by a new pap may be represented by [52, 42, 1].",
                "We will refer to paps by the context rather than by the new identifier added, e.g., by [51, 42, 1] not 51.",
                "This enables us to equate the ancestor relationship between paps with the list suffix relationship on the relevant contexts, i.e., v is an ancestor of v if and only if v is a suffix of v .",
                "For most CAN constructs, the context variable is unused or passed unchanged: μv(act) = act μv(+b) = +b μv(−b) = −b μv(nil) = nil μv(!e) = !e(v) μv(P1; P2) = μv(P1); μv(P2) μv(P1 P2) = μv(P1) μv(P2) μv( ψ1 : P1, . . . , ψn : Pn ) = ψ1 : μv(P1), . . . , ψn : μv(Pn) It remains to specify the transformation μv(·) in three cases: the FAb, parallel, and Goal constructs.",
                "These are more complex in that the transformed source needs to create a new pap identifier dynamically, for use as a new context within the construct, and to keep track of when the pap is active (i.e., currently in execution) by adding and removing beliefs about the context.",
                "Let us introduce the primitive action prependID(v, v ) that creates a new pap identifier and prepends it to list v giving list v .",
                "We also introduce the following predicates: • a(v) - the pap v is currently active. • abort(v) - the pap v should be aborted (after aborting all of its descendants). 7 An alternative would be to use meta-level predicates that reflect the current state of the intention structure. 12 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) • f(v) - the program of pap v has failed. • ancestorof(v, v ) ≡ v = v ∨ ancestorof(v, tail(v ))the pap v is an ancestor of pap v . • nac(v) ≡ ¬∃v . (a(v ) ∧ ancestorof(v, v ) ∧ v = v ) - v has no active children. • sa(v) ≡ ∃v .abort(v ) ∧ ancestorof(v , v) - we should abort v, i.e., abort is true of v or some ancestor; however, we need to wait until no children of v are active. • san(v) ≡ sa(v) ∧ nac(v) - we should abort v now if we should abort v and v has no active children.",
                "First let us consider the case of the FAb construct.",
                "The idea is that, whenever a new pap occurs, the prependID(v, v ) action is used to create a new pap identifier list v from the existing list v. We then add the belief that v is the active context, i.e., +a(v ), and start processing the program within the pap using v instead of v as the context.",
                "We need to make sure that we retract the belief that v is active at the end, i.e., −a(v ).",
                "We use the Goal construct to allow us to drop the execution of a program within a pap v when it is necessary to abort.",
                "While executing the program P, we know that we need to drop P and invoke its abort-method if some ancestor of P has been told to abort.",
                "This is represented by the predicate sa(v ) being true.",
                "However, we need to make sure that we do this only after every child pap has had the chance to invoke its abort-method and all these abort-methods have completed: if we drop the program too soon, then execution of the abort-methods of the children will also be dropped.",
                "Therefore, the condition we actually use in the Goal construct to test when to drop the program is san(v ).",
                "This condition relies on the fact that as the children paps complete, they remove the relevant a facts.",
                "Our use of the Goal construct is for its ability to drop the execution of a program when conditions are met.",
                "To leave aside the repeat execution until a condition is met aspect, we must ensure that the success or failure condition of the construct is satisfied once the execution of the program succeeds or fails.",
                "We make sure of this by retracting the fact a(v ) on success and asserting the fact f(v ) on failure, and by having the appropriate success and failure conditions on the Goal.",
                "Hence, if the Goal construct fails, then the program either was aborted or it failed.",
                "We invoke the relevant failure- or abort- method, retract the a(v ) fact, and then fail.",
                "Putting all this together, we formally define μv(FAb(P, PA, PF )) to be the following, where v is a new variable distinct from any other in the agents plan library: prependID(v, v ); +a(v ); Goal ( ¬a(v ), (μv (P); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); μv(PA)) μv(PF )); −a(v ); ?false) Second, we must transform the parallel operator to ensure that the failure of one branch safely aborts the other.",
                "Here we construct two new contexts, v and v , from the existing context v. If one branch fails, it must abort the other branch.",
                "At the end, if either branch was aborted, then we must fail.",
                "Let v and v be new variables distinct from any other in the agents plan library.",
                "We define μv(P1 P2) to be: prependID(v, v ); prependID(v, v ); +a(v ); +a(v ); ( Goal (¬a(v ), (μv (P1); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal (¬a(v ), (μv (P2); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ); ?¬abort(v ) ∧ ¬abort(v ) Finally, we need to modify occurrences of the Goal construct in two ways: first, to make sure that the abort handling methods are not bypassed when the success or failure conditions are satisfied, and second, to trigger the aborting of the contained program when either the success or failure conditions are satisfied.",
                "To transform the Goal construct we need to extend standard CAN with a wait-until-condition construct.",
                "The construct φ : P does not execute P until φ becomes true.",
                "We augment the CAN language with the following rules for the guard operator :: B |= φ B, G, (φ : P −→ B, G, P :true B |= φ B, G, (φ : P) −→ B, G, (φ : P) :false In order to specify μv(Goal ` φs, P, φf ´ ), we generate a new pap and execute the program within the Goal construct in this new context.",
                "We must ensure that belief a(v ) is removed whether the Goal succeeds or fails.",
                "We shift the success and failure condition of the Goal construct into a parallel branch using the wait-until-condition construct, and modify the Goal to use the should abort now condition san(v ) as the success condition.",
                "The waiting branch will trigger the abort of the program should either the success or failure condition be met.",
                "To avoid any problems with terminating the wait condition, we also end the wait if the pap is no longer active.",
                "Let v be a new variable distinct from any other in the agents plan library.",
                "We define μv(Goal ` φs, P, φf ´ ) to be: prependID(v, v ); +a(v ); ( Goal ( san(v ), μv (P), false) ; −a(v ); ?φs ) φs ∨ φf ∨ ¬a(v ) : +abort(v ) ) The program P will be repeatedly executed until san(v ) becomes true.",
                "There are two ways this can occur.",
                "First, if either the success condition φs or the failure condition φf becomes true, then the second branch of the parallel construct executes.",
                "This causes abort(v ) to become true, and, after the descendant paps abortmethods are executed, san(v ) becomes true.",
                "In this case, P is now dropped, the a(v ) is removed, and the entire construct succeeds or fails based on φs.",
                "The second way for san(v ) to become true is if v or one of its ancestors is aborted.",
                "In this case, once the descendant paps abort-methods are executed, san(v ) becomes true, P is dropped, the a(v ) belief is removed (allowing the second parallel branch to execute, vacuously instructing v to abort), and the first parallel branch fails (assuming φs is false). 4.3 Worked Example Let us look at translation of the IJCAI submission example of Section 2.",
                "We will express tasks by events, for example, the task Allocate a Paper Number we express as the event APN.",
                "Let the output of the Apply For Clearance task be Y or N, indicating the approval or not of Alices manager, respectively.",
                "Then we have (at least) the following two plan clauses in CAN, for the Support Meeting Submission and Apply For Clearance tasks, respectively: SMS(m) : isconf(m) ← FAb(!APN; !TWA; (!AFC !TWP); !HPS, !CPN, !CPN) AFC : true ← FAb(!SCR; !WFR(r); ?r = Y, nil, !CCR) Note that Support Meeting Submission has a parameter m, the meeting of interest (IJCAI, in our example), while Apply For Clearance has no parameters.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 13 Let us look first at the translation of the second plan clause, for AFC, since it is the simpler of the two.",
                "Let v and v denote new variables.",
                "Then we have as the translated plan clause: AFC(v ) : true ← prependID(v , v ); +a(v ); Goal ( ¬a(v ), (!SCR(v ); !WFR(r, v ); ?r = Y; −a(v ) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CCR(v )) nil); −a(v ); ?false) We can see that an extra context parameter has been added to each task and that the old plan body now appears inside a Goal construct.",
                "Should the old plan body succeed, belief a(v ) is retracted, causing the Goal to succeed.",
                "If the old plan body fails, or if the task is to be aborted, the Goal construct fails.",
                "This is followed by the execution of CCR (in the case of an abort), the retraction of a(v ), and failure.",
                "The translation of the first plan clause, for SMS, is more complex, because of the parallel construct that introduces nested paps: SMS(m, v) : isconf(m) ← prependID(v, v ); +a(v ); Goal ( ¬a(v ), ((!APN(v ); !TWA(v ); prependID(v , v ); prependID(v , v ); +a(v ); +a(v ); ( Goal ( ¬a(v ), (!AFC(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) Goal ( ¬a(v ), (!TWP(v ); −a(v ) +f(v )), san(v ) ∨ f(v ) ) (+abort(v ); −a(v )) ) ; ?¬abort(v ) ∧ ¬abort(v ); !HPS(v ); −a(v )) +f(v )), san(v ) ∨ f(v ) ) (((?sa(v ); !CPN(v)) !CPN(v)); −a(v ); ?false) Here we can see that if the task !TWP(v ) fails then f(v ) will be asserted, failing the Goal construct that contains it, and leading to abort(v ) being asserted.",
                "If the !WFR(r, v ) task in the expansion of !AFC(v ) is still executing and has no active child paps, then sa(v ) and sa(v ) will be true; however, only san(v ) and not san(v ) will be true.",
                "This set of conditions will cause the Goal construct in the first plan clause to fail, dropping execution of !WFR(r, v ).",
                "The task !CCR(v ) will be executed.",
                "Once this task completes, belief a(v ) is retracted, causing san(v ) to become true, leading to the first Goal construct of the second plan clause to fail.",
                "While the translated plan clauses appear complicated, observe that the translation from the initial plan clauses is entirely automated, according to the rules set out in Section 4.2.",
                "The translated plan clauses, with the semantics of CAN augmented by our waituntil-condition construct, thus specify the operation of the agent to handle both failure and aborting for the example. 5.",
                "RELATED WORK Plan failure is handled in the extended version of AgentSpeak found in the Jason system [6].",
                "Failure clean-up plans are triggered from goal deletion events −!g.",
                "Such plans, similar to our failure methods, are designed for the agent to effect state changes (act to undo its earlier actions) prior to possibly attempting another plan to achieve the failed goal g. Given Jasons constructs for dropping a goal with an indication of whether or not to try an alternate plan for it, H¨ubner et al. [6] provide an informal description of how a Jason agent modifies its intention structure when a goal failure event occurs.",
                "In a goal deletion plan, the programmer can specify any undo actions and whether to attempt the goal again.",
                "If no goal deletion plan is provided, Jasons default behaviour is to not reattempt the goal.",
                "Failure handling is applied only to plans triggered by addition of an achievement or test goal; in particular, goal deletion events are not posted for failure of a goal deletion plan.",
                "Further, the informal semantics of [6] do not consider parallel sub-goals (i.e., the CAN construct), since such execution is not part of Jasons language.",
                "The implementation of H¨ubner et al. [6] requires Jasons internal actions.",
                "A requirement for implementing our approach is a reflective capability in the BDI agent implementation.",
                "Suitable implementations of the BDI formalism are JACK [2], Jadex [14], and SPARK [9].",
                "All three allow meta level methods that are cued by meta events such as goal adoption or plan failure, and offer introspective capabilities over goal and intention states.",
                "Such meta level facilities are also required by the approach of Unruh et al. [21], who define goal-based semantic compensation for an agent.",
                "Failure-handling goals are invoked according to failurehandling strategy rules, by a dedicated agent Failure Handling Component (FHC) that tracks task execution.",
                "These goals are specified by the agent programmer and attached to tasks, much like our FAb(P, PF , PA) construct associates failure and abort methods with a plan P. Note, however, that in contrast to both [6] and our semantics, [21] attach the failure-handling knowledge at the goal, not plan, level.",
                "Their failure-handling goals may consist of stabilization goals that perform localized, immediate clean-up to restore the agents state to a known, stable state, and compensation goals that perform undo actions.",
                "Compensation goals are triggered on aborting a goal, and so not necessarily on goal failure (i.e., if the FHC directs the agent to retry the failed goal and the retry is successful).",
                "The FHC approach is defined at the goal level in order to facilitate abstract specification of failure-handling knowledge; the FHC decides when to address a failure and what to do (i.e., what failurehandling goals to invoke), separating this knowledge from the how of implementing corrective actions (i.e., what plan to execute to meet the adopted failure-handling goal).",
                "This contrasts with simplistic plan-level failure handling in which the what and how are intermingled in domain task knowledge.",
                "While our approach is defined at the plan level, our extended BDI semantics provides for the separation of execution and failure handling.",
                "Further, the FHC explicitly maintains data structures to track agent execution.",
                "We leverage the existing execution structures and self-reflective ability of a BDI agent to accomplish both aborting and failure handling without additional overhead.",
                "FHCs failure-handling strategy rules (e.g., whether to retry a failed goal) are replaced by instructions in our PF and PA plans, together with meta-level default failure handlers according to the agents nature (e.g., blindly committed).",
                "The FHC approach is independent of the architecture of the agent itself, in contrast to our work that is dedicated to the BDI formalism (although not tied to any one agent system).",
                "Thus no formal semantics are developed in [21]; the FHCs operation is given as 14 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) a state-based protocol.",
                "This approach, together with state checkpointing, is used for multi-agent systems in [22].",
                "The resulting architecture embeds their failure handling approach within a pair processing architecture for agent crash recovery.",
                "Other work on multi-agent exception handling includes AOEXs distributed exception handling agents [5], and the similar sentinels of [8].",
                "In both cases, failure-handling logic and knowledge are decoupled from the agents; by contrast, while separating exception handling from domain-specific knowledge, Unruh et al.s FHC and our approach both retain failure-handling logic within an agent. 6.",
                "CONCLUSION AND FUTURE WORK The tasks and plans of an agent may not successfully reach completion, either by the choice of the agent to abort them (perhaps at the request of another agent to do so), or by unbidden factors that lead to failure.",
                "In this paper we have presented a procedure-based approach that incorporates aborting tasks and plans into the deliberation cycle of a BDI-style agent, thus providing a unified approach to failure and abort.",
                "Our primary contribution is an analysis of the requirements on the operation of the agent for aborting tasks and plans, and a corresponding operational semantics for aborting in the abstract agent language CAN.",
                "We are planning to implement an instance of our approach in the SPARK agent system [9]; in particular, the work of this paper will be the basis for SPARKs abort handling mechanism.",
                "We are also developing an analysis tool for our extended version of CAN as a basis for experimentation.",
                "An intelligent agent will not only gracefully handle unsuccessful tasks and plans, but also will deliberate over its cognitive attitudes to decide its next course of action.",
                "We have assumed the default behaviour of a BDI-style agent, according to its nature: for instance, to retry alternatives to a failed plan until one succeeds or until no alternative plans remain (in which case to fail the task).",
                "Future work is to place our approach in service of more dynamic agent reasoning, such as the introspection that an agent capable of reasoning over task interaction effects and resource requirements can accomplish [19, 12].",
                "Related to this is determining the cost of aborting a task or plan, and using this as an input to the deliberation process.",
                "This would in particular influence the commitment the agent has towards a particular task: the higher the cost, the greater the commitment.",
                "Our assumption that abort-methods do not fail, as discussed above, is a pragmatic one.",
                "However, this is an issue worthy of further exploration, either to develop weaker assumptions that are also practical, or to analyze conditions under which our assumption is realistic.",
                "A further item of interest is extending our approach to failure and abort to maintenance goals [1].",
                "For such goals a different operational semantics for abort is necessary than for achievement goals, to match the difference in semantics of the goals themselves.",
                "Acknowledgements We thank Lin Padgham and the anonymous reviewers for their comments.",
                "The first author acknowledges the support of the Australian Research Council and Agent Oriented Software under grant LP0453486.",
                "The work of the two authors at SRI International was supported by the Defense Advanced Research Projects Agency (DARPA) under Contract No.",
                "NBCHD030010.",
                "Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the view of DARPA or the Department of Interior-National Business Center. 7.",
                "REFERENCES [1] L. Braubach, A. Pokahr, D. Moldt, and W. Lamersdorf.",
                "Goal representation for BDI Agent systems.",
                "In Proc. of Second Intl.",
                "Workshop on Programming Multi-Agent Systems (ProMAS04), 2004. [2] P. Busetta, R. R¨onnquist, A. Hodgson, and A. Lucas.",
                "JACK intelligent agents - components for intelligent agents in Java.",
                "AgentLink News, Issue 2, 1999. [3] M. G. Chessell, C. Vines, D. Butler, C. M. Ferreira, and P. Henderson.",
                "Extending the concept of transaction compensation.",
                "IBM Systems Journal, 41(4), 2002. [4] M. Dastani, M. B. van Riemsdijk, and J.-J.",
                "C. Meyer.",
                "Goal types in agent programming.",
                "In Proc. of AAMAS06, 2006. [5] S. Entwisle, S. Loke, S. Krishnaswamy, and E. Kendall.",
                "Aoex: An agent-based exception handling framework for building reliable, distributed, open software systems.",
                "In Proc. of Seventh Joint Conf. on Knowledge-Based Software Engineering, 2006. [6] J. F. H¨ubner, R. H. Bordini, and M. Wooldridge.",
                "Programming declarative goals using plan patterns.",
                "In Proc. of 4th Intl.",
                "Workshop on Declarative Agent Languages and Technologies, 2006. [7] D. Kinny.",
                "The Psi calculus: an algebraic agent language.",
                "In Proc. of ATAL01, 2001. [8] M. Klein, J.",
                "A. Rodr´ıguez-Aguilar, and C. Dellarocas.",
                "Using domain-independent exception handling services to enable robust open multi-agent systems: The case of agent death.",
                "Autonomous Agents and Multi-Agent Systems, 7(1-2):179-189, 2003. [9] D. Morley and K. Myers.",
                "The SPARK agent framework.",
                "In Proc. of AAMAS04, 2004. [10] D. Morley, K. L. Myers, and N. Yorke-Smith.",
                "Continuous refinement of agent resource estimates.",
                "In Proc. of AAMAS06, 2006. [11] K. Myers, P. Berry, J. Blythe, K. Conley, M. Gervasio, D. McGuinness, D. Morley, A. Pfeffer, M. Pollack, and M. Tambe.",
                "An intelligent personal assistant for task and time management.",
                "AI Magazine, 28, 2007.",
                "To appear. [12] K. L. Myers and N. Yorke-Smith.",
                "A cognitive framework for delegation to an assistive user agent.",
                "In Proc. of AAAI 2005 Fall Symposium on Mixed-Initiative Problem-Solving Assistants, 2005. [13] L. Padgham and M. Winikoff.",
                "Developing Intelligent Agent Systems: A Practical Guide.",
                "John Wiley and Sons, 2004. [14] A. Pokahr, L. Braubach, and W. Lamersdorf.",
                "Jadex: A BDI reasoning engine.",
                "In R. Bordini, M. Dastani, J. Dix, and A. E. F. Seghrouchni, editors, Multi-Agent Programming.",
                "Springer, 2005. [15] A. S. Rao.",
                "AgentSpeak(L): BDI agents speak out in a logical computable language.",
                "In Proc. of Seventh European Workshop on Modelling Autonomous Agents in a Multi-Agent World, 1996. [16] A. S. Rao and M. P. Georgeff.",
                "An abstract architecture for rational agents.",
                "In Proc. of KR92, 1992. [17] S. Sardi˜na, L. de Silva, and L. Padgham.",
                "Hierarchical planning in BDI agent programming languages: a formal approach.",
                "In Proc. of AAMAS06, 2006. [18] S. Sardina and L. Padgham.",
                "Goals in the context of bdi plan failure and planning.",
                "In Proc. of AAMAS07, 2007. [19] J. Thangarajah, L. Padgham, and M. Winikoff.",
                "Detecting and exploiting positive goal interaction in intelligent agents.",
                "In Proc. of AAMAS03, 2003. [20] J. Thangarajah, M. Winikoff, L. Padgham, and K. Fischer.",
                "Avoiding resource conflicts in intelligent agents.",
                "In Proc. of ECAI-02, 2002. [21] A. Unruh, J. Bailey, and K. Ramamohanarao.",
                "A framework for goal-based semantic compensation in agent systems.",
                "In Proc. of First Intl.",
                "Workshop on Safety and Security in Multi-Agent Systems, 2004. [22] A. Unruh, H. Harjadi, J. Bailey, and K. Ramamohanarao.",
                "Semantic-compensation-based recovery management in multi-agent systems.",
                "In Proc. of Second IEEE Symposium on Multi-Agent Security and Survivability (IEEE MAS&S05), 2005. [23] M. Winikoff, L. Padgham, J. Harland, and J. Thangarajah.",
                "Declarative and procedural goals in intelligent agent systems.",
                "In Proc. of KR02, 2002.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 15"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        }
    }
}