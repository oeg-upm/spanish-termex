{
    "id": "J-67",
    "original_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm. However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm. Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent. The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent. For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one. We then show a matching lower bound for deterministic mechanisms that never pay the agents. Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1. INTRODUCTION We consider the problem of online scheduling of jobs on a single processor. Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline. The objective is to maximize the sum of the values of the jobs completed by their respective deadlines. The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time. Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution. One interpretation of this approach is as a game between the designer of the online algorithm and an adversary. First, the designer selects the online algorithm. Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm. Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs. For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms. The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm. The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release. However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs. Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting. Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent. Instead of being released to the algorithm, each job is now released only to its owning agent. Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job. Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15]. The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents. Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]). In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome. In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center. A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline. In order to evaluate a mechanism using competitive analysis, the adversary model must be updated. In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism. Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs. The rest of the paper is structured as follows. In Section 2, we formally define and review results from the original, non-strategic setting. After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3. In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio. We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job. Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents. Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2. NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand. Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively. The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous). Each job is released at time ri, at which point its three other characteristics are known. Nothing is known about the job before its arrival. Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline. Preemption of jobs is allowed, and it takes no time to switch between jobs. Thus, job i is completed if and only if the total time it executes on the processor before di is at least li. Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i. Thus, (θi, θ−i) denotes a complete vector of tuples. Define the value density ρi = vi li of job i to be the ratio of its value to its length. For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi. The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs. The algorithm is assumed to always know an upper bound k on the importance ratio. For simplicity, we normalize the range of possible value densities so that ρmin = 1. An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o. An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle. To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise. A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline. A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li). Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument. For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ. Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time. Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t). The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ. In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm. Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ). An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ). An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration. A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li). Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1. Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4]. In this section we provide a high-level description of TD1 (version 2) using an example. TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job. The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity. For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9]. No preemption is considered during this interval, because job 2 has laxity until time 1.5. Then, a new interval starts at tb = 0.9 when job 2 becomes active. Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity. In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss. The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted). In this case, te = 17.0. The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job. The other variable, p loss, is equal to the length of the first active job of the current interval. Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio). Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion. Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Table 1: Input used to recap TD1 (version 2) [4]. The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3. MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job. For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7. At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem. In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand. Each job i is owned by a separate agent i. The characteristics of the job define the agents type θi ∈ Θi. At time ri, agent i privately observes its type θi, and has no information about job i before ri. Thus, jobs are still released over time, but now each job is revealed only to the owning agent. Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O. An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism. In a standard mechanism design setting, the outcome is enforced at the end of the mechanism. However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent. That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time. This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms. Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism. Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center. We assume that each agent is a rational, expected utility maximizer. Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed. On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job. However, we will also consider a restricted formulation in which this type of lie is not possible. The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent. The agent can declare an arbitrary deadline or value. To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri. While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job. Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax. However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting. The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism. As before, preemption of jobs is allowed, and job switching takes no time. The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i. The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality. The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration. Definition 1. A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn. From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it. For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule. In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7. However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned). Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism. While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality. The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility. The rationale behind this goal is that participation in the mechanism is assumed to be voluntary. Definition 2. A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline). An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3. An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4. RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1). After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio. We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents. Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job. Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration. By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR. We now argue why it satisfies IC with respect to the other three characteristics. Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent. However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline. This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0. However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job. The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting). On the other hand, it is less obvious why agents do not have incentive to declare a later release time. Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1. However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1. Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13. Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22. Job 3 then executes to completion, forcing job 1 to be abandoned. However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22. Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30]. Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times. Intuitively, Γ1 avoids this problem because of two properties. First, when a job becomes active, it must have a greater priority than all other available jobs. Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics. These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas. Theorem 1. Mechanism Γ1 satisfies individual rationality. Proof. For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0. On the other hand, if job i is completed, then its value must exceed agent is payment. Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition. To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li. We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed. We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline. Lemma 2. In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof. Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri. We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center. Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi). First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta . Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i. We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y . Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active. Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor. Assume by contradiction that this is not true. Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf . A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time. The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y . Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri. We now show that job i cannot be completed in this case, given that it was not completed in case I. First, we can restrict the range of ˆri that we need to consider as follows. Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes. Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release. Thus, we can restrict consideration to ˆri ∈ (ts , ta ]. In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y . Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs. We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ). First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc . Now consider an arbitrary y ∈ Y such that y = yc . In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Thus, moving to case II, job y must replace some other job before tc . Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Since w ∈ Y would contradict the definition of tc , we know that w = i. That is, the job that y replaces must be i. By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I. On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X. We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ]. Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Thus, even at this upper bound, job yc would execute instead of job x at time tc . A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz. Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof. Lemma 3. In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof. Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di. Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail. Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter. Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction. We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4. In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof. Assume by contradiction that this condition does not hold. This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not. Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction. Finally, the following lemma tells us that the completion of a job is monotonic in its declared value. Lemma 5. In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri. In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed. The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ]. We can now combine the lemmas to show that no profitable deviation is possible. Theorem 6. Mechanism Γ1 satisfies incentive compatibility. Proof. For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption. We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline. Then, because the payment function is non-negative, agent is utility could not exceed zero. By IR, this is the minimum utility it would achieve if it truthfully declared θi. Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di. Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero. If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i. On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas. Having shown IC, we can assume truthful declaration (ˆθ = θ). Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline. Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1. Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence. Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1. Also, let tbegin f be the first time that the processor is not idle in interval If . Lemma 7. For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof. Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job. Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs). Let ts i be the time that job i begins execution. Note that ts 1 = tbegin f . Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs. Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active. We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence. Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements. Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds. At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1. These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step. We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length. We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf . We now consider the possible execution of uncompleted jobs by Γoffline. Associate each job i that is not completed by Γ1 with the interval during which it was abandoned. All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F . Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism. Lemma 8. For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf . Proof. Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf . At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf . Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ]. Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf . As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job. Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines. The following lemma is Lemma 5.10 in [15], and its proof now applies directly. Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf . The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f . By Lemma 8, the value of this job is bounded by (1 + √ k) · vf . We can now combine the results of these lemmas to prove the competitive ratio. Theorem 10. Mechanism Γ1 is (1+ √ k)2+1 -competitive. Proof. Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F). Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9. Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf . Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings. For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem. Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4]. If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments. The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11. When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility. Theorem 12. When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive. Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems. Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5. COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms. To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0). Unlike IC and IR, this requirement is not standard in mechanism design. We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i. The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments. We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints. Lemma 13. For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14. There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1. Proof. Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well). Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1. First, we will construct a profile of agent types θ using an adversary argument. After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction. We now construct the original profile θ. Pick an α such that 0 < α < , and define δ = α ck+3k . The adversary uses two sequences of jobs: minor and major. Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity. The first minor job is released at time 0, and ri = di−1 for all i > 1. The sequence stops whenever Γ completes any job. Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li). The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13. Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α. The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job. The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1]. No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ). Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned. If f < m, then major job f + 1 will be released and it will be the final major job. Γ cannot complete job f +1, because rf +lf = df > rf+1. Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df . We now possibly perturb θ slightly. By IR, we know that vf ≥ pf (θ). Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf . By IC, job f must still be completed by Γ for the profile (θf , θ−f ). If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0. However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC. Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument. Thus, for the remainder of the proof, assume that vf > pf (θ). We now use a more substantial perturbation of θ to complete the proof. If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed. If f = m, then instead set df = df +lf . IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed. Assume by contradiction that this were not true. Then, at the original deadline of df , job f is not completed. Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)). Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df . Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0. Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ). Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC. While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change. If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned). Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based. Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]). Mechanism design was also applied to a scheduling problem in [18]. In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them. The private information of an agent is the time it will require to execute each job. Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem. This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements. A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay. For a survey of this and other topics in distributed algorithmic mechanism design, see [9]. Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings. For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time. In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values. Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions. The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply. It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival. The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time. A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7. CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents. We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one. We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job. We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents. Several open problems remain in this setting. One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments. Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption. Finally, randomized mechanisms provide an unexplored area for future work. 8. REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J. Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70",
    "original_translation": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. Teorema 1. El mecanismo Γ1 cumple con la racionalidad individual. Prueba. Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente. Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición. Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete. Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba. Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri. Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro. Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta. Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i. Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo. Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y. Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri. Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I. Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera. Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta. Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ]. Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y. Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo. Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc). Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc. Ahora considera un y arbitrario ∈ Y tal que y = yc. En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc. Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que y reemplaza debe ser i. Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I. Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc]. Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc). Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz. Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lema 3. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba. Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no. Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última. Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción. Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4. En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración. Supongamos por contradicción que esta condición no se cumple. Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace. Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado. Lema 5. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri. En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta]. Ahora podemos combinar los lemas para demostrar que no es posible ninguna desviación rentable. Teorema 6. El mecanismo Γ1 cumple con la compatibilidad de incentivos. Prueba. Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición. También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite. Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline. Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1. Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia. Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If. Lema 7. Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba. El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible. Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados). Que ts i sea el tiempo en que el trabajo i comienza su ejecución. Ten en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación. Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple. En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo. También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf. Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline. Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F. Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf. Prueba. Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf. En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf. Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ]. Nuevamente aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf. Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos. El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f. Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva. Teorema 10. El mecanismo Γ1 es (1+ √ k)2+1-competitivo. Prueba. Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F). Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9. Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf. Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos. Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado. Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4]. Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo. Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas. Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5. LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas. Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i. La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14. No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1. Prueba. Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR). Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1. Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario. Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción. Ahora construimos el perfil original θ. Elige un α tal que 0 < α < , y define δ = α ck+3k. El adversario utiliza dos secuencias de trabajos: menores y mayores. Los trabajos menores se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1. La secuencia se detiene cada vez que Γ completa algún trabajo. Los trabajos principales también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, están determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 Los límites en α implican que (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2, lo que nos permite aplicar el Lema 13. Sea m el número positivo más pequeño tal que lm+k· m−1 h=1 lh lm > c−1+α. El primer trabajo principal tiene un tiempo de liberación de 0, y cada trabajo principal i > 1 tiene un tiempo de liberación de ri = di−1 − δ, justo antes de la fecha límite del trabajo anterior. El adversario libera un trabajo importante i ≤ m si y solo si cada trabajo importante j < i fue ejecutado de manera continua en el rango [ri, ri+1]. No se libera ningún trabajo importante después del trabajo m. Para lograr la relación competitiva deseada, Γ debe completar algún trabajo importante f, ya que Γoffline siempre puede completar al menos el trabajo importante 1 (por un valor de 1), y Γ puede completar como máximo un trabajo menor (por un valor de α c+3 < 1 c). Además, para que este trabajo f se libere, el tiempo del procesador anterior a rf solo puede ser utilizado para ejecutar trabajos importantes que luego son abandonados. Si f < m, entonces el trabajo principal f + 1 será lanzado y será el trabajo principal final. Γ no puede completar el trabajo f +1, porque rf + lf = df > rf+1. Por lo tanto, θ consiste en trabajos principales del 1 al f + 1 (o f, si f = m), más trabajos menores desde el tiempo 0 hasta el tiempo df. Ahora posiblemente perturbamos ligeramente θ. Por IR, sabemos que vf ≥ pf (θ). Dado que más adelante necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df se incrementan todos en δ sobre sus valores respectivos en θf. Por IC, el trabajo f aún debe ser completado por Γ para el perfil (θf, θ−f). Si no, entonces por IR y NNP sabemos que pf (θf , θ−f ) = 0, y por lo tanto que uf (g(θf , θ−f ), θf ) = 0. Sin embargo, el agente f podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: uf (g(θf, θ−f), θf) = vf - pf(θ) = δ > 0, violando la CI. Además, el agente f debe ser cobrado la misma cantidad (es decir, pf (θf , θ−f ) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la demostración, asumir que vf > pf (θ). Ahora utilizamos una perturbación más sustancial de θ para completar la prueba. Si f < m, entonces define θf como idéntico a θf, excepto que df = df+1 + lf, permitiendo que el trabajo f se complete por completo después de que el trabajo f + 1 se haya completado. Si f = m, entonces en lugar de eso establece df = df + lf. IC requiere que para el perfil (θf, θ−f), Γ siga ejecutando el trabajo f de forma continua en el rango [rf, rf + lf], evitando así que el trabajo f +1 se complete. Supongamos por contradicción que esto no fuera cierto. Entonces, en la fecha límite original de df, el trabajo f no está completado. Considera el posible perfil (θf, θ−f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene laxitud cero, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Dado que este nuevo perfil es indistinguible de (θf, θ−f) para Γ antes del tiempo df, debe programar trabajos de la misma manera hasta df. Entonces, para lograr la proporción competitiva deseada, debe ejecutar el trabajo x de forma continua hasta su fecha límite, que por construcción es al menos tan tardía como la nueva fecha límite df del trabajo f. Por lo tanto, el trabajo f no se completará y, según IR y NNP, debe ser el caso que pf (θf , θ−f , θx) = 0 y uf (g(θf , θ−f , θx), θf ) = 0. Usando el hecho de que θ es indistinguible de (θf, θ−f, θx) hasta el tiempo df, si el agente f declarara falsamente su tipo como el original θf, entonces su trabajo se completaría en df y se le cobraría pf(θ). Su utilidad aumentaría a uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradiciendo la CI. Si bien la ejecución de Γ debe ser idéntica para ambos (θf, θ−f) y (θf, θ−f), Γoffline puede aprovechar el cambio. Si f < m, entonces Γ alcanza un valor de como máximo lf + δ (el valor del trabajo f si fuera perturbado), mientras que Γoffline alcanza un valor de al menos k·( f h=1 lh −2δ)+lf+1 +lf al ejecutar trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (restamos dos δ en lugar de uno porque el último trabajo menor antes de rf+1 puede tener que ser abandonado). Sustituyendo en lf+1, la proporción competitiva es entonces al menos: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. Si en cambio f = m, entonces Γ alcanza un valor de como máximo lm +δ, mientras que Γoffline alcanza un valor de al menos k · ( m h=1 lh − 2δ) + lm al completar trabajos menores hasta que dm = rm + lm, y luego completar el trabajo m. La proporción competitiva es entonces al menos: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. TRABAJO RELACIONADO En esta sección describimos trabajos relacionados distintos a los dos artículos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo fuera de línea (ver, por ejemplo, [13, 14]). El diseño de mecanismos también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno sin conexión, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este artículo también lanzó el área del diseño algorítmico de mecanismos, en el cual el mecanismo debe cumplir con los requisitos computacionales además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño de mecanismos de reparto de costos para multicast (ver, por ejemplo, [1]), en el cual el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño algorítmico de mecanismos distribuidos, consulte [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de liquidación de mercado en línea, en el cual el subastador empareja ofertas de compra y venta (que se asumen como exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es compatible con incentivos con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], los cuales abordan subastas en línea de múltiples unidades. La principal diferencia entre ambos es que el primero considera el caso de un bien digital, el cual tiene una oferta ilimitada. Se señala en [16] que sus resultados siguen siendo válidos cuando el escenario se amplía para que los postores puedan retrasar su llegada. El único otro artículo del que tenemos conocimiento que aborda el tema de la compatibilidad de incentivos en un sistema en tiempo real es [11], el cual considera varias variantes de un modelo en el que el centro asigna ancho de banda a agentes que declaran tanto su valor como su tiempo de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de estrategia Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor proporción competitiva posible, pero para el cual se requerían nuevas soluciones cuando el escenario se amplía para incluir agentes con intereses propios. Presentamos un mecanismo que es compatible con incentivos con respecto al tiempo de liberación, plazo, duración y valor, y que solo aumenta la proporción competitiva en uno. También demostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes. Quedan varios problemas abiertos en este contexto. Se trata de determinar si el límite inferior puede ser fortalecido al eliminar la restricción de pagos no negativos. Además, aunque consideramos razonable fortalecer la suposición de conocer la máxima relación posible de densidades de valor (k) en lugar de conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo de ((1 + √ k)2 + 1) bajo la suposición original. Finalmente, los mecanismos aleatorios ofrecen un área inexplorada para trabajos futuros. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en el reparto de costos de multicast, Juegos y Comportamiento Económico (por aparecer). [2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de mecanismos de verdad en línea a optimización en línea, Actas del 35º Simposio sobre Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Revista de Sistemas en Tiempo Real 4 (1992), núm. 2, 125-144. [5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para compensación de mercado, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para gestión de recursos y programación en la computación en malla, La Revista de Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan y O. Regev, El proyecto popcorn: Computación distribuida en internet en Java, 6ª Conferencia Internacional World Wide Web, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y direcciones futuras, Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Fijación de precios de wifi en Starbucks: Problemas en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Límites para ciertas anomalías multiprocesador, Revista Técnica del Sistema Bell 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, La velocidad es tan poderosa como la clarividencia, Revista de la ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan y K. To, Programación en línea con plazos ajustados, Ciencia de la Computación Teórica 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo de programación en línea óptimo para sistemas en tiempo real sobrecargados, Revista SIAM de Computación 24 (1995), núm. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Verde, Teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño algorítmico de mecanismos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e internet, STOC, 2001, pp. 749-753. 70",
    "original_sentences": [
        "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
        "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
        "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
        "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
        "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
        "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
        "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
        "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
        "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
        "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
        "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
        "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
        "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
        "First, the designer selects the online algorithm.",
        "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
        "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
        "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
        "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
        "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
        "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
        "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
        "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
        "Instead of being released to the algorithm, each job is now released only to its owning agent.",
        "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
        "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
        "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
        "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
        "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
        "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
        "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
        "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
        "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
        "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
        "The rest of the paper is structured as follows.",
        "In Section 2, we formally define and review results from the original, non-strategic setting.",
        "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
        "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
        "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
        "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
        "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
        "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
        "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
        "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
        "Each job is released at time ri, at which point its three other characteristics are known.",
        "Nothing is known about the job before its arrival.",
        "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
        "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
        "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
        "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
        "Thus, (θi, θ−i) denotes a complete vector of tuples.",
        "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
        "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
        "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
        "The algorithm is assumed to always know an upper bound k on the importance ratio.",
        "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
        "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
        "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
        "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
        "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
        "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
        "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
        "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
        "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
        "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
        "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
        "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
        "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
        "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
        "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
        "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
        "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
        "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
        "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
        "In this section we provide a high-level description of TD1 (version 2) using an example.",
        "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
        "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
        "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
        "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
        "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
        "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
        "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
        "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
        "In this case, te = 17.0.",
        "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
        "The other variable, p loss, is equal to the length of the first active job of the current interval.",
        "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
        "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
        "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
        "Table 1: Input used to recap TD1 (version 2) [4].",
        "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
        "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
        "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
        "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
        "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
        "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
        "Each job i is owned by a separate agent i.",
        "The characteristics of the job define the agents type θi ∈ Θi.",
        "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
        "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
        "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
        "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
        "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
        "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
        "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
        "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
        "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
        "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
        "We assume that each agent is a rational, expected utility maximizer.",
        "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
        "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
        "However, we will also consider a restricted formulation in which this type of lie is not possible.",
        "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
        "The agent can declare an arbitrary deadline or value.",
        "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
        "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
        "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
        "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
        "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
        "As before, preemption of jobs is allowed, and job switching takes no time.",
        "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
        "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
        "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
        "Definition 1.",
        "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
        "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
        "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
        "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
        "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
        "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
        "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
        "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
        "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
        "Definition 2.",
        "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
        "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
        "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
        "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
        "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
        "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
        "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
        "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
        "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
        "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
        "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
        "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
        "We now argue why it satisfies IC with respect to the other three characteristics.",
        "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
        "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
        "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
        "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
        "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
        "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
        "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
        "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
        "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
        "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
        "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
        "Job 3 then executes to completion, forcing job 1 to be abandoned.",
        "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
        "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
        "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
        "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
        "Intuitively, Γ1 avoids this problem because of two properties.",
        "First, when a job becomes active, it must have a greater priority than all other available jobs.",
        "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
        "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
        "Theorem 1.",
        "Mechanism Γ1 satisfies individual rationality.",
        "Proof.",
        "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
        "On the other hand, if job i is completed, then its value must exceed agent is payment.",
        "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
        "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
        "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
        "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
        "Lemma 2.",
        "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
        "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
        "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
        "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
        "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
        "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
        "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
        "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
        "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
        "Assume by contradiction that this is not true.",
        "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
        "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
        "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
        "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
        "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
        "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
        "First, we can restrict the range of ˆri that we need to consider as follows.",
        "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
        "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
        "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
        "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
        "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
        "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
        "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
        "Now consider an arbitrary y ∈ Y such that y = yc .",
        "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
        "Thus, moving to case II, job y must replace some other job before tc .",
        "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
        "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
        "That is, the job that y replaces must be i.",
        "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
        "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
        "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
        "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
        "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
        "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
        "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
        "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
        "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
        "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
        "Lemma 3.",
        "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
        "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
        "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
        "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
        "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
        "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
        "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
        "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
        "Assume by contradiction that this condition does not hold.",
        "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
        "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
        "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
        "Lemma 5.",
        "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
        "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
        "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
        "We can now combine the lemmas to show that no profitable deviation is possible.",
        "Theorem 6.",
        "Mechanism Γ1 satisfies incentive compatibility.",
        "Proof.",
        "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
        "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
        "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
        "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
        "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
        "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
        "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
        "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
        "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
        "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
        "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
        "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
        "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
        "Also, let tbegin f be the first time that the processor is not idle in interval If .",
        "Lemma 7.",
        "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
        "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
        "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
        "Let ts i be the time that job i begins execution.",
        "Note that ts 1 = tbegin f .",
        "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
        "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
        "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
        "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
        "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
        "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
        "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
        "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
        "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
        "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
        "We now consider the possible execution of uncompleted jobs by Γoffline.",
        "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
        "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
        "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
        "Lemma 8.",
        "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
        "Proof.",
        "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
        "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
        "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
        "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
        "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
        "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
        "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
        "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
        "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
        "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
        "We can now combine the results of these lemmas to prove the competitive ratio.",
        "Theorem 10.",
        "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
        "Proof.",
        "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
        "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
        "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
        "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
        "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
        "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
        "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
        "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
        "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
        "Theorem 12.",
        "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
        "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
        "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
        "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
        "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
        "Unlike IC and IR, this requirement is not standard in mechanism design.",
        "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
        "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
        "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
        "Lemma 13.",
        "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
        "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
        "Proof.",
        "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
        "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
        "First, we will construct a profile of agent types θ using an adversary argument.",
        "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
        "We now construct the original profile θ.",
        "Pick an α such that 0 < α < , and define δ = α ck+3k .",
        "The adversary uses two sequences of jobs: minor and major.",
        "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
        "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
        "The sequence stops whenever Γ completes any job.",
        "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
        "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
        "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
        "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
        "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
        "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
        "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
        "If f < m, then major job f + 1 will be released and it will be the final major job.",
        "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
        "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
        "We now possibly perturb θ slightly.",
        "By IR, we know that vf ≥ pf (θ).",
        "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
        "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
        "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
        "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
        "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
        "Thus, for the remainder of the proof, assume that vf > pf (θ).",
        "We now use a more substantial perturbation of θ to complete the proof.",
        "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
        "If f = m, then instead set df = df +lf .",
        "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
        "Assume by contradiction that this were not true.",
        "Then, at the original deadline of df , job f is not completed.",
        "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
        "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
        "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
        "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
        "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
        "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
        "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
        "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
        "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
        "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
        "Mechanism design was also applied to a scheduling problem in [18].",
        "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
        "The private information of an agent is the time it will require to execute each job.",
        "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
        "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
        "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
        "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
        "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
        "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
        "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
        "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
        "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
        "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
        "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
        "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
        "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
        "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
        "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
        "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
        "Several open problems remain in this setting.",
        "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
        "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
        "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
        "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
        "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
    ],
    "translated_text_sentences": [
        "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista.",
        "Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo.",
        "Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios.",
        "El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente.",
        "Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva.",
        "Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes.",
        "Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1.",
        "INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador.",
        "Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite.",
        "El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite.",
        "El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación.",
        "El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución.",
        "Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario.",
        "Primero, el diseñador selecciona el algoritmo en línea.",
        "Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea.",
        "Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos.",
        "Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas.",
        "El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente.",
        "El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado.",
        "Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos.",
        "Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico.",
        "Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios.",
        "En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario.",
        "Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo.",
        "Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15].",
        "La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios.",
        "En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]).",
        "En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado.",
        "En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro.",
        "Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite.",
        "Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado.",
        "En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo.",
        "Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos.",
        "El resto del documento está estructurado de la siguiente manera.",
        "En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico.",
        "Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3.",
        "En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva.",
        "También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo.",
        "Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes.",
        "Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7.",
        "CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano.",
        "Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente.",
        "El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo).",
        "Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características.",
        "No se sabe nada sobre el trabajo antes de su llegada.",
        "Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite.",
        "La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos.",
        "Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li.",
        "Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i.",
        "Así, (θi, θ−i) denota un vector completo de tuplas.",
        "Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud.",
        "Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi.",
        "La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos.",
        "Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia.",
        "Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1.",
        "Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o.",
        "Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo.",
        "Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario.",
        "La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite.",
        "Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li).",
        "Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento.",
        "Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ.",
        "Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento.",
        "Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t).",
        "La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
        "Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ.",
        "En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea.",
        "Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ).",
        "Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ).",
        "Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita.",
        "Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li).",
        "Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1.",
        "Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4].",
        "En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo.",
        "TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo.",
        "El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero.",
        "Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9].",
        "No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5.",
        "Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo.",
        "Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero.",
        "Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p.",
        "El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido).",
        "En este caso, te = 17.0.",
        "El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo.",
        "La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual.",
        "Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva).",
        "Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización.",
        "Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
        "Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4].",
        "Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3.",
        "Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo.",
        "Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7.",
        "En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
        "El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos.",
        "En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano.",
        "Cada trabajo i es propiedad de un agente i separado.",
        "Las características del trabajo definen el tipo de agente θi ∈ Θi.",
        "En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri.",
        "Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario.",
        "Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O.",
        "Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo.",
        "En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo.",
        "Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente.",
        "Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento.",
        "Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos.",
        "De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo.",
        "La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro.",
        "Suponemos que cada agente es un maximizador racional de utilidad esperada.",
        "Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo.",
        "Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea.",
        "Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible.",
        "El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente.",
        "El agente puede declarar un plazo o valor arbitrario.",
        "En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri.",
        "Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo.",
        "Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax.",
        "Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido.",
        "La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo.",
        "Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo.",
        "Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i.",
        "El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual.",
        "La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración.",
        "Definición 1.",
        "Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes.",
        "Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella.",
        "Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario.",
        "De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7.",
        "Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente).",
        "Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo.",
        "Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad.",
        "El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa.",
        "La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria.",
        "Definición 2.",
        "Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
        "Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
        "Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline).",
        "Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3.",
        "Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4.",
        "RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1).",
        "Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva.",
        "Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes.",
        "A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo.",
        "En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
        "Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración.",
        "Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR.",
        "Ahora argumentamos por qué satisface IC con respecto a las otras tres características.",
        "Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente.",
        "Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real.",
        "Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0.",
        "Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo.",
        "Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno).",
        "Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior.",
        "Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
        "Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1.",
        "Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1.",
        "La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13.",
        "Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22.",
        "El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1.",
        "Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22.",
        "Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30].",
        "Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
        "Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación.",
        "Intuitivamente, Γ1 evita este problema debido a dos propiedades.",
        "Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles.",
        "Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características.",
        "Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas.",
        "Teorema 1.",
        "El mecanismo Γ1 cumple con la racionalidad individual.",
        "Prueba.",
        "Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0.",
        "Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente.",
        "Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición.",
        "Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li.",
        "Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete.",
        "Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite.",
        "Lema 2.",
        "En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba.",
        "Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri.",
        "Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro.",
        "Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi).",
        "Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta.",
        "Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i.",
        "Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y.",
        "A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo.",
        "Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador.",
        "Supongamos por contradicción que esto no es cierto.",
        "Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
        "Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf.",
        "Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento.",
        "Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y.",
        "Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri.",
        "Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I.",
        "Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera.",
        "Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta.",
        "Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento.",
        "Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ].",
        "Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y.",
        "Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo.",
        "Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc).",
        "Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc.",
        "Ahora considera un y arbitrario ∈ Y tal que y = yc.",
        "En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
        "Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc.",
        "Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
        "Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i.",
        "Es decir, el trabajo que y reemplaza debe ser i.",
        "Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
        "Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I.",
        "Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X.",
        "Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
        "También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
        "Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc].",
        "Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc).",
        "Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc.",
        "Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz.",
        "Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba.",
        "Lema 3.",
        "En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba.",
        "Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di.",
        "Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no.",
        "Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
        "Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última.",
        "Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción.",
        "Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4.",
        "En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración.",
        "Supongamos por contradicción que esta condición no se cumple.",
        "Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace.",
        "Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción.",
        "Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado.",
        "Lema 5.",
        "En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri.",
        "En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa.",
        "El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta].",
        "Ahora podemos combinar los lemas para demostrar que no es posible ninguna desviación rentable.",
        "Teorema 6.",
        "El mecanismo Γ1 cumple con la compatibilidad de incentivos.",
        "Prueba.",
        "Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición.",
        "También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite.",
        "Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero.",
        "Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi.",
        "Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di.",
        "Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero.",
        "Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i.",
        "Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas.",
        "Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ).",
        "Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline.",
        "Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1.",
        "Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia.",
        "Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1.",
        "Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If.",
        "Lema 7.",
        "Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba.",
        "El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible.",
        "Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados).",
        "Que ts i sea el tiempo en que el trabajo i comienza su ejecución.",
        "Ten en cuenta que ts 1 = tbegin f.",
        "Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación.",
        "Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo.",
        "Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
        "Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia.",
        "Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos.",
        "Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple.",
        "En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1.",
        "Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo.",
        "También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración.",
        "Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf.",
        "Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline.",
        "Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado.",
        "Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F.",
        "Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo.",
        "Lema 8.",
        "Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf.",
        "Prueba.",
        "Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf.",
        "En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf.",
        "Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ].",
        "Nuevamente aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf.",
        "Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo.",
        "Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos.",
        "El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente.",
        "Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf.",
        "La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f.",
        "Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf.",
        "Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva.",
        "Teorema 10.",
        "El mecanismo Γ1 es (1+ √ k)2+1-competitivo.",
        "Prueba.",
        "Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F).",
        "Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9.",
        "Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf.",
        "Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos.",
        "Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado.",
        "Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4].",
        "Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos.",
        "La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11.",
        "Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos.",
        "Teorema 12.",
        "Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo.",
        "Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas.",
        "Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5.",
        "LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas.",
        "Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
        "A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos.",
        "Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i.",
        "La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados.",
        "Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio.",
        "Lema 13.",
        "Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14.",
        "No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1.",
        "Prueba.",
        "Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR).",
        "Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1.",
        "Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario.",
        "Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción.",
        "Ahora construimos el perfil original θ.",
        "Elige un α tal que 0 < α < , y define δ = α ck+3k.",
        "El adversario utiliza dos secuencias de trabajos: menores y mayores.",
        "Los trabajos menores se caracterizan por li = δ, vi = k · δ y laxitud cero.",
        "El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1.",
        "La secuencia se detiene cada vez que Γ completa algún trabajo.",
        "Los trabajos principales también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li).",
        "Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, están determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 Los límites en α implican que (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2, lo que nos permite aplicar el Lema 13.",
        "Sea m el número positivo más pequeño tal que lm+k· m−1 h=1 lh lm > c−1+α.",
        "El primer trabajo principal tiene un tiempo de liberación de 0, y cada trabajo principal i > 1 tiene un tiempo de liberación de ri = di−1 − δ, justo antes de la fecha límite del trabajo anterior.",
        "El adversario libera un trabajo importante i ≤ m si y solo si cada trabajo importante j < i fue ejecutado de manera continua en el rango [ri, ri+1].",
        "No se libera ningún trabajo importante después del trabajo m. Para lograr la relación competitiva deseada, Γ debe completar algún trabajo importante f, ya que Γoffline siempre puede completar al menos el trabajo importante 1 (por un valor de 1), y Γ puede completar como máximo un trabajo menor (por un valor de α c+3 < 1 c).",
        "Además, para que este trabajo f se libere, el tiempo del procesador anterior a rf solo puede ser utilizado para ejecutar trabajos importantes que luego son abandonados.",
        "Si f < m, entonces el trabajo principal f + 1 será lanzado y será el trabajo principal final.",
        "Γ no puede completar el trabajo f +1, porque rf + lf = df > rf+1.",
        "Por lo tanto, θ consiste en trabajos principales del 1 al f + 1 (o f, si f = m), más trabajos menores desde el tiempo 0 hasta el tiempo df.",
        "Ahora posiblemente perturbamos ligeramente θ.",
        "Por IR, sabemos que vf ≥ pf (θ).",
        "Dado que más adelante necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df se incrementan todos en δ sobre sus valores respectivos en θf.",
        "Por IC, el trabajo f aún debe ser completado por Γ para el perfil (θf, θ−f).",
        "Si no, entonces por IR y NNP sabemos que pf (θf , θ−f ) = 0, y por lo tanto que uf (g(θf , θ−f ), θf ) = 0.",
        "Sin embargo, el agente f podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: uf (g(θf, θ−f), θf) = vf - pf(θ) = δ > 0, violando la CI.",
        "Además, el agente f debe ser cobrado la misma cantidad (es decir, pf (θf , θ−f ) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar.",
        "Por lo tanto, para el resto de la demostración, asumir que vf > pf (θ).",
        "Ahora utilizamos una perturbación más sustancial de θ para completar la prueba.",
        "Si f < m, entonces define θf como idéntico a θf, excepto que df = df+1 + lf, permitiendo que el trabajo f se complete por completo después de que el trabajo f + 1 se haya completado.",
        "Si f = m, entonces en lugar de eso establece df = df + lf.",
        "IC requiere que para el perfil (θf, θ−f), Γ siga ejecutando el trabajo f de forma continua en el rango [rf, rf + lf], evitando así que el trabajo f +1 se complete.",
        "Supongamos por contradicción que esto no fuera cierto.",
        "Entonces, en la fecha límite original de df, el trabajo f no está completado.",
        "Considera el posible perfil (θf, θ−f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene laxitud cero, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)).",
        "Dado que este nuevo perfil es indistinguible de (θf, θ−f) para Γ antes del tiempo df, debe programar trabajos de la misma manera hasta df.",
        "Entonces, para lograr la proporción competitiva deseada, debe ejecutar el trabajo x de forma continua hasta su fecha límite, que por construcción es al menos tan tardía como la nueva fecha límite df del trabajo f. Por lo tanto, el trabajo f no se completará y, según IR y NNP, debe ser el caso que pf (θf , θ−f , θx) = 0 y uf (g(θf , θ−f , θx), θf ) = 0.",
        "Usando el hecho de que θ es indistinguible de (θf, θ−f, θx) hasta el tiempo df, si el agente f declarara falsamente su tipo como el original θf, entonces su trabajo se completaría en df y se le cobraría pf(θ).",
        "Su utilidad aumentaría a uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradiciendo la CI.",
        "Si bien la ejecución de Γ debe ser idéntica para ambos (θf, θ−f) y (θf, θ−f), Γoffline puede aprovechar el cambio.",
        "Si f < m, entonces Γ alcanza un valor de como máximo lf + δ (el valor del trabajo f si fuera perturbado), mientras que Γoffline alcanza un valor de al menos k·( f h=1 lh −2δ)+lf+1 +lf al ejecutar trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (restamos dos δ en lugar de uno porque el último trabajo menor antes de rf+1 puede tener que ser abandonado).",
        "Sustituyendo en lf+1, la proporción competitiva es entonces al menos: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. Si en cambio f = m, entonces Γ alcanza un valor de como máximo lm +δ, mientras que Γoffline alcanza un valor de al menos k · ( m h=1 lh − 2δ) + lm al completar trabajos menores hasta que dm = rm + lm, y luego completar el trabajo m. La proporción competitiva es entonces al menos: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
        "TRABAJO RELACIONADO En esta sección describimos trabajos relacionados distintos a los dos artículos ([4] y [15]) en los que se basa este documento.",
        "El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo fuera de línea (ver, por ejemplo, [13, 14]).",
        "El diseño de mecanismos también se aplicó a un problema de programación en [18].",
        "En su modelo, el centro posee los trabajos en un entorno sin conexión, y son los agentes quienes pueden ejecutarlos.",
        "La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo.",
        "Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable.",
        "Este artículo también lanzó el área del diseño algorítmico de mecanismos, en el cual el mecanismo debe cumplir con los requisitos computacionales además de los requisitos de incentivos estándar.",
        "Un subcampo en crecimiento en esta área es el diseño de mecanismos de reparto de costos para multicast (ver, por ejemplo, [1]), en el cual el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multicast, si el agente recibe la transmisión y el precio que debe pagar.",
        "Para una encuesta de este y otros temas en el diseño algorítmico de mecanismos distribuidos, consulte [9].",
        "La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos.",
        "Por ejemplo, [5] considera un entorno de liquidación de mercado en línea, en el cual el subastador empareja ofertas de compra y venta (que se asumen como exógenas) que llegan y expiran con el tiempo.",
        "En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es compatible con incentivos con respecto a los valores.",
        "La declaración veraz de valores también se considera en [3] y [16], los cuales abordan subastas en línea de múltiples unidades.",
        "La principal diferencia entre ambos es que el primero considera el caso de un bien digital, el cual tiene una oferta ilimitada.",
        "Se señala en [16] que sus resultados siguen siendo válidos cuando el escenario se amplía para que los postores puedan retrasar su llegada.",
        "El único otro artículo del que tenemos conocimiento que aborda el tema de la compatibilidad de incentivos en un sistema en tiempo real es [11], el cual considera varias variantes de un modelo en el que el centro asigna ancho de banda a agentes que declaran tanto su valor como su tiempo de llegada.",
        "Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de estrategia Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras. 7.",
        "CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor proporción competitiva posible, pero para el cual se requerían nuevas soluciones cuando el escenario se amplía para incluir agentes con intereses propios.",
        "Presentamos un mecanismo que es compatible con incentivos con respecto al tiempo de liberación, plazo, duración y valor, y que solo aumenta la proporción competitiva en uno.",
        "También demostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo.",
        "Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes.",
        "Quedan varios problemas abiertos en este contexto.",
        "Se trata de determinar si el límite inferior puede ser fortalecido al eliminar la restricción de pagos no negativos.",
        "Además, aunque consideramos razonable fortalecer la suposición de conocer la máxima relación posible de densidades de valor (k) en lugar de conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo de ((1 + √ k)2 + 1) bajo la suposición original.",
        "Finalmente, los mecanismos aleatorios ofrecen un área inexplorada para trabajos futuros. 8.",
        "REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en el reparto de costos de multicast, Juegos y Comportamiento Económico (por aparecer). [2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de mecanismos de verdad en línea a optimización en línea, Actas del 35º Simposio sobre Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Revista de Sistemas en Tiempo Real 4 (1992), núm. 2, 125-144. [5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para compensación de mercado, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para gestión de recursos y programación en la computación en malla, La Revista de Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan y O. Regev, El proyecto popcorn: Computación distribuida en internet en Java, 6ª Conferencia Internacional World Wide Web, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y direcciones futuras, Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Fijación de precios de wifi en Starbucks: Problemas en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Límites para ciertas anomalías multiprocesador, Revista Técnica del Sistema Bell 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, La velocidad es tan poderosa como la clarividencia, Revista de la ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan y K. To, Programación en línea con plazos ajustados, Ciencia de la Computación Teórica 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo de programación en línea óptimo para sistemas en tiempo real sobrecargados, Revista SIAM de Computación 24 (1995), núm. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J.",
        "Verde, Teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño algorítmico de mecanismos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e internet, STOC, 2001, pp. 749-753. 70"
    ],
    "error_count": 2,
    "keys": {
        "online scheduling of job": {
            "translated_key": "programación en línea de trabajos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of <br>online scheduling of job</br>s on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "INTRODUCTION We consider the problem of <br>online scheduling of job</br>s on a single processor."
            ],
            "translated_annotated_samples": [
                "INTRODUCCIÓN Consideramos el problema de la <br>programación en línea de trabajos</br> en un solo procesador."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la <br>programación en línea de trabajos</br> en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. Teorema 1. El mecanismo Γ1 cumple con la racionalidad individual. Prueba. Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente. Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición. Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete. Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba. Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri. Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro. Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta. Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i. Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo. Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y. Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri. Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I. Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera. Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta. Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ]. Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y. Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo. Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc). Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc. Ahora considera un y arbitrario ∈ Y tal que y = yc. En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc. Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que y reemplaza debe ser i. Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I. Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc]. Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc). Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz. Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lema 3. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba. Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no. Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última. Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción. Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4. En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración. Supongamos por contradicción que esta condición no se cumple. Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace. Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado. Lema 5. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri. En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta]. Ahora podemos combinar los lemas para demostrar que no es posible ninguna desviación rentable. Teorema 6. El mecanismo Γ1 cumple con la compatibilidad de incentivos. Prueba. Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición. También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite. Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline. Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1. Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia. Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If. Lema 7. Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba. El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible. Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados). Que ts i sea el tiempo en que el trabajo i comienza su ejecución. Ten en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación. Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple. En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo. También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf. Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline. Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F. Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf. Prueba. Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf. En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf. Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ]. Nuevamente aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf. Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos. El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f. Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva. Teorema 10. El mecanismo Γ1 es (1+ √ k)2+1-competitivo. Prueba. Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F). Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9. Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf. Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos. Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado. Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4]. Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo. Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas. Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5. LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas. Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i. La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14. No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1. Prueba. Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR). Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1. Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario. Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción. Ahora construimos el perfil original θ. Elige un α tal que 0 < α < , y define δ = α ck+3k. El adversario utiliza dos secuencias de trabajos: menores y mayores. Los trabajos menores se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1. La secuencia se detiene cada vez que Γ completa algún trabajo. Los trabajos principales también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, están determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 Los límites en α implican que (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2, lo que nos permite aplicar el Lema 13. Sea m el número positivo más pequeño tal que lm+k· m−1 h=1 lh lm > c−1+α. El primer trabajo principal tiene un tiempo de liberación de 0, y cada trabajo principal i > 1 tiene un tiempo de liberación de ri = di−1 − δ, justo antes de la fecha límite del trabajo anterior. El adversario libera un trabajo importante i ≤ m si y solo si cada trabajo importante j < i fue ejecutado de manera continua en el rango [ri, ri+1]. No se libera ningún trabajo importante después del trabajo m. Para lograr la relación competitiva deseada, Γ debe completar algún trabajo importante f, ya que Γoffline siempre puede completar al menos el trabajo importante 1 (por un valor de 1), y Γ puede completar como máximo un trabajo menor (por un valor de α c+3 < 1 c). Además, para que este trabajo f se libere, el tiempo del procesador anterior a rf solo puede ser utilizado para ejecutar trabajos importantes que luego son abandonados. Si f < m, entonces el trabajo principal f + 1 será lanzado y será el trabajo principal final. Γ no puede completar el trabajo f +1, porque rf + lf = df > rf+1. Por lo tanto, θ consiste en trabajos principales del 1 al f + 1 (o f, si f = m), más trabajos menores desde el tiempo 0 hasta el tiempo df. Ahora posiblemente perturbamos ligeramente θ. Por IR, sabemos que vf ≥ pf (θ). Dado que más adelante necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df se incrementan todos en δ sobre sus valores respectivos en θf. Por IC, el trabajo f aún debe ser completado por Γ para el perfil (θf, θ−f). Si no, entonces por IR y NNP sabemos que pf (θf , θ−f ) = 0, y por lo tanto que uf (g(θf , θ−f ), θf ) = 0. Sin embargo, el agente f podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: uf (g(θf, θ−f), θf) = vf - pf(θ) = δ > 0, violando la CI. Además, el agente f debe ser cobrado la misma cantidad (es decir, pf (θf , θ−f ) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la demostración, asumir que vf > pf (θ). Ahora utilizamos una perturbación más sustancial de θ para completar la prueba. Si f < m, entonces define θf como idéntico a θf, excepto que df = df+1 + lf, permitiendo que el trabajo f se complete por completo después de que el trabajo f + 1 se haya completado. Si f = m, entonces en lugar de eso establece df = df + lf. IC requiere que para el perfil (θf, θ−f), Γ siga ejecutando el trabajo f de forma continua en el rango [rf, rf + lf], evitando así que el trabajo f +1 se complete. Supongamos por contradicción que esto no fuera cierto. Entonces, en la fecha límite original de df, el trabajo f no está completado. Considera el posible perfil (θf, θ−f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene laxitud cero, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Dado que este nuevo perfil es indistinguible de (θf, θ−f) para Γ antes del tiempo df, debe programar trabajos de la misma manera hasta df. Entonces, para lograr la proporción competitiva deseada, debe ejecutar el trabajo x de forma continua hasta su fecha límite, que por construcción es al menos tan tardía como la nueva fecha límite df del trabajo f. Por lo tanto, el trabajo f no se completará y, según IR y NNP, debe ser el caso que pf (θf , θ−f , θx) = 0 y uf (g(θf , θ−f , θx), θf ) = 0. Usando el hecho de que θ es indistinguible de (θf, θ−f, θx) hasta el tiempo df, si el agente f declarara falsamente su tipo como el original θf, entonces su trabajo se completaría en df y se le cobraría pf(θ). Su utilidad aumentaría a uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradiciendo la CI. Si bien la ejecución de Γ debe ser idéntica para ambos (θf, θ−f) y (θf, θ−f), Γoffline puede aprovechar el cambio. Si f < m, entonces Γ alcanza un valor de como máximo lf + δ (el valor del trabajo f si fuera perturbado), mientras que Γoffline alcanza un valor de al menos k·( f h=1 lh −2δ)+lf+1 +lf al ejecutar trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (restamos dos δ en lugar de uno porque el último trabajo menor antes de rf+1 puede tener que ser abandonado). Sustituyendo en lf+1, la proporción competitiva es entonces al menos: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. Si en cambio f = m, entonces Γ alcanza un valor de como máximo lm +δ, mientras que Γoffline alcanza un valor de al menos k · ( m h=1 lh − 2δ) + lm al completar trabajos menores hasta que dm = rm + lm, y luego completar el trabajo m. La proporción competitiva es entonces al menos: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. TRABAJO RELACIONADO En esta sección describimos trabajos relacionados distintos a los dos artículos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo fuera de línea (ver, por ejemplo, [13, 14]). El diseño de mecanismos también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno sin conexión, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este artículo también lanzó el área del diseño algorítmico de mecanismos, en el cual el mecanismo debe cumplir con los requisitos computacionales además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño de mecanismos de reparto de costos para multicast (ver, por ejemplo, [1]), en el cual el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño algorítmico de mecanismos distribuidos, consulte [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de liquidación de mercado en línea, en el cual el subastador empareja ofertas de compra y venta (que se asumen como exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es compatible con incentivos con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], los cuales abordan subastas en línea de múltiples unidades. La principal diferencia entre ambos es que el primero considera el caso de un bien digital, el cual tiene una oferta ilimitada. Se señala en [16] que sus resultados siguen siendo válidos cuando el escenario se amplía para que los postores puedan retrasar su llegada. El único otro artículo del que tenemos conocimiento que aborda el tema de la compatibilidad de incentivos en un sistema en tiempo real es [11], el cual considera varias variantes de un modelo en el que el centro asigna ancho de banda a agentes que declaran tanto su valor como su tiempo de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de estrategia Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor proporción competitiva posible, pero para el cual se requerían nuevas soluciones cuando el escenario se amplía para incluir agentes con intereses propios. Presentamos un mecanismo que es compatible con incentivos con respecto al tiempo de liberación, plazo, duración y valor, y que solo aumenta la proporción competitiva en uno. También demostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes. Quedan varios problemas abiertos en este contexto. Se trata de determinar si el límite inferior puede ser fortalecido al eliminar la restricción de pagos no negativos. Además, aunque consideramos razonable fortalecer la suposición de conocer la máxima relación posible de densidades de valor (k) en lugar de conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo de ((1 + √ k)2 + 1) bajo la suposición original. Finalmente, los mecanismos aleatorios ofrecen un área inexplorada para trabajos futuros. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en el reparto de costos de multicast, Juegos y Comportamiento Económico (por aparecer). [2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de mecanismos de verdad en línea a optimización en línea, Actas del 35º Simposio sobre Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Revista de Sistemas en Tiempo Real 4 (1992), núm. 2, 125-144. [5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para compensación de mercado, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para gestión de recursos y programación en la computación en malla, La Revista de Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan y O. Regev, El proyecto popcorn: Computación distribuida en internet en Java, 6ª Conferencia Internacional World Wide Web, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y direcciones futuras, Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Fijación de precios de wifi en Starbucks: Problemas en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Límites para ciertas anomalías multiprocesador, Revista Técnica del Sistema Bell 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, La velocidad es tan poderosa como la clarividencia, Revista de la ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan y K. To, Programación en línea con plazos ajustados, Ciencia de la Computación Teórica 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo de programación en línea óptimo para sistemas en tiempo real sobrecargados, Revista SIAM de Computación 24 (1995), núm. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Verde, Teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño algorítmico de mecanismos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e internet, STOC, 2001, pp. 749-753. 70 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "job online scheduling": {
            "translated_key": "programación de trabajo en línea",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "competitive ratio": {
            "translated_key": "proporción competitiva",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the <br>competitive ratio</br> that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the <br>competitive ratio</br> by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the <br>competitive ratio</br>: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the <br>competitive ratio</br> for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a <br>competitive ratio</br> of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the <br>competitive ratio</br>.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this <br>competitive ratio</br> is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a <br>competitive ratio</br> of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite <br>competitive ratio</br> [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the <br>competitive ratio</br>).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the <br>competitive ratio</br>. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the <br>competitive ratio</br>.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of <br>competitive ratio</br> The proof of the <br>competitive ratio</br>, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the <br>competitive ratio</br> it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the <br>competitive ratio</br>.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the <br>competitive ratio</br> by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the <br>competitive ratio</br> holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a <br>competitive ratio</br> of 5 (which is the same <br>competitive ratio</br> as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the <br>competitive ratio</br> of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a <br>competitive ratio</br> less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a <br>competitive ratio</br> of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a <br>competitive ratio</br> of c implies a <br>competitive ratio</br> of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired <br>competitive ratio</br>, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired <br>competitive ratio</br>, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the <br>competitive ratio</br> is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The <br>competitive ratio</br> is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible <br>competitive ratio</br> had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the <br>competitive ratio</br> by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the <br>competitive ratio</br> that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the <br>competitive ratio</br> that can be achieved by a deterministic algorithm.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the <br>competitive ratio</br> by one.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the <br>competitive ratio</br>: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the <br>competitive ratio</br> for deterministic algorithms.",
                "Thus, in order to achieve a <br>competitive ratio</br> of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs."
            ],
            "translated_annotated_samples": [
                "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la <br>proporción competitiva</br> que puede lograr un algoritmo determinista.",
                "Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la <br>proporción competitiva</br>.",
                "Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la <br>proporción competitiva</br>: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea.",
                "Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la <br>relación competitiva</br> para algoritmos deterministas.",
                "Por lo tanto, para lograr una <br>proporción competitiva</br> de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la <br>proporción competitiva</br> que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la <br>proporción competitiva</br>. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la <br>proporción competitiva</br>: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la <br>relación competitiva</br> para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una <br>proporción competitiva</br> de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. ",
            "candidates": [],
            "error": [
                [
                    "proporción competitiva",
                    "proporción competitiva",
                    "proporción competitiva",
                    "relación competitiva",
                    "proporción competitiva"
                ]
            ]
        },
        "deterministic algorithm": {
            "translated_key": "algoritmo determinista",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a <br>deterministic algorithm</br>.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a <br>deterministic algorithm</br>."
            ],
            "translated_annotated_samples": [
                "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un <br>algoritmo determinista</br>."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un <br>algoritmo determinista</br>. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. Teorema 1. El mecanismo Γ1 cumple con la racionalidad individual. Prueba. Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente. Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición. Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete. Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba. Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri. Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro. Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta. Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i. Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo. Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y. Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri. Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I. Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera. Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta. Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ]. Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y. Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo. Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc). Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc. Ahora considera un y arbitrario ∈ Y tal que y = yc. En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc. Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que y reemplaza debe ser i. Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I. Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc]. Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc). Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz. Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lema 3. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba. Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no. Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última. Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción. Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4. En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración. Supongamos por contradicción que esta condición no se cumple. Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace. Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado. Lema 5. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri. En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta]. Ahora podemos combinar los lemas para demostrar que no es posible ninguna desviación rentable. Teorema 6. El mecanismo Γ1 cumple con la compatibilidad de incentivos. Prueba. Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición. También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite. Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline. Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1. Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia. Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If. Lema 7. Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba. El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible. Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados). Que ts i sea el tiempo en que el trabajo i comienza su ejecución. Ten en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación. Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple. En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo. También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf. Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline. Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F. Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf. Prueba. Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf. En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf. Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ]. Nuevamente aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf. Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos. El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f. Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva. Teorema 10. El mecanismo Γ1 es (1+ √ k)2+1-competitivo. Prueba. Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F). Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9. Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf. Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos. Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado. Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4]. Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo. Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas. Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5. LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas. Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i. La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14. No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1. Prueba. Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR). Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1. Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario. Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción. Ahora construimos el perfil original θ. Elige un α tal que 0 < α < , y define δ = α ck+3k. El adversario utiliza dos secuencias de trabajos: menores y mayores. Los trabajos menores se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1. La secuencia se detiene cada vez que Γ completa algún trabajo. Los trabajos principales también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, están determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 Los límites en α implican que (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2, lo que nos permite aplicar el Lema 13. Sea m el número positivo más pequeño tal que lm+k· m−1 h=1 lh lm > c−1+α. El primer trabajo principal tiene un tiempo de liberación de 0, y cada trabajo principal i > 1 tiene un tiempo de liberación de ri = di−1 − δ, justo antes de la fecha límite del trabajo anterior. El adversario libera un trabajo importante i ≤ m si y solo si cada trabajo importante j < i fue ejecutado de manera continua en el rango [ri, ri+1]. No se libera ningún trabajo importante después del trabajo m. Para lograr la relación competitiva deseada, Γ debe completar algún trabajo importante f, ya que Γoffline siempre puede completar al menos el trabajo importante 1 (por un valor de 1), y Γ puede completar como máximo un trabajo menor (por un valor de α c+3 < 1 c). Además, para que este trabajo f se libere, el tiempo del procesador anterior a rf solo puede ser utilizado para ejecutar trabajos importantes que luego son abandonados. Si f < m, entonces el trabajo principal f + 1 será lanzado y será el trabajo principal final. Γ no puede completar el trabajo f +1, porque rf + lf = df > rf+1. Por lo tanto, θ consiste en trabajos principales del 1 al f + 1 (o f, si f = m), más trabajos menores desde el tiempo 0 hasta el tiempo df. Ahora posiblemente perturbamos ligeramente θ. Por IR, sabemos que vf ≥ pf (θ). Dado que más adelante necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df se incrementan todos en δ sobre sus valores respectivos en θf. Por IC, el trabajo f aún debe ser completado por Γ para el perfil (θf, θ−f). Si no, entonces por IR y NNP sabemos que pf (θf , θ−f ) = 0, y por lo tanto que uf (g(θf , θ−f ), θf ) = 0. Sin embargo, el agente f podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: uf (g(θf, θ−f), θf) = vf - pf(θ) = δ > 0, violando la CI. Además, el agente f debe ser cobrado la misma cantidad (es decir, pf (θf , θ−f ) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la demostración, asumir que vf > pf (θ). Ahora utilizamos una perturbación más sustancial de θ para completar la prueba. Si f < m, entonces define θf como idéntico a θf, excepto que df = df+1 + lf, permitiendo que el trabajo f se complete por completo después de que el trabajo f + 1 se haya completado. Si f = m, entonces en lugar de eso establece df = df + lf. IC requiere que para el perfil (θf, θ−f), Γ siga ejecutando el trabajo f de forma continua en el rango [rf, rf + lf], evitando así que el trabajo f +1 se complete. Supongamos por contradicción que esto no fuera cierto. Entonces, en la fecha límite original de df, el trabajo f no está completado. Considera el posible perfil (θf, θ−f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene laxitud cero, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Dado que este nuevo perfil es indistinguible de (θf, θ−f) para Γ antes del tiempo df, debe programar trabajos de la misma manera hasta df. Entonces, para lograr la proporción competitiva deseada, debe ejecutar el trabajo x de forma continua hasta su fecha límite, que por construcción es al menos tan tardía como la nueva fecha límite df del trabajo f. Por lo tanto, el trabajo f no se completará y, según IR y NNP, debe ser el caso que pf (θf , θ−f , θx) = 0 y uf (g(θf , θ−f , θx), θf ) = 0. Usando el hecho de que θ es indistinguible de (θf, θ−f, θx) hasta el tiempo df, si el agente f declarara falsamente su tipo como el original θf, entonces su trabajo se completaría en df y se le cobraría pf(θ). Su utilidad aumentaría a uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradiciendo la CI. Si bien la ejecución de Γ debe ser idéntica para ambos (θf, θ−f) y (θf, θ−f), Γoffline puede aprovechar el cambio. Si f < m, entonces Γ alcanza un valor de como máximo lf + δ (el valor del trabajo f si fuera perturbado), mientras que Γoffline alcanza un valor de al menos k·( f h=1 lh −2δ)+lf+1 +lf al ejecutar trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (restamos dos δ en lugar de uno porque el último trabajo menor antes de rf+1 puede tener que ser abandonado). Sustituyendo en lf+1, la proporción competitiva es entonces al menos: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. Si en cambio f = m, entonces Γ alcanza un valor de como máximo lm +δ, mientras que Γoffline alcanza un valor de al menos k · ( m h=1 lh − 2δ) + lm al completar trabajos menores hasta que dm = rm + lm, y luego completar el trabajo m. La proporción competitiva es entonces al menos: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. TRABAJO RELACIONADO En esta sección describimos trabajos relacionados distintos a los dos artículos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo fuera de línea (ver, por ejemplo, [13, 14]). El diseño de mecanismos también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno sin conexión, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este artículo también lanzó el área del diseño algorítmico de mecanismos, en el cual el mecanismo debe cumplir con los requisitos computacionales además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño de mecanismos de reparto de costos para multicast (ver, por ejemplo, [1]), en el cual el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño algorítmico de mecanismos distribuidos, consulte [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de liquidación de mercado en línea, en el cual el subastador empareja ofertas de compra y venta (que se asumen como exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es compatible con incentivos con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], los cuales abordan subastas en línea de múltiples unidades. La principal diferencia entre ambos es que el primero considera el caso de un bien digital, el cual tiene una oferta ilimitada. Se señala en [16] que sus resultados siguen siendo válidos cuando el escenario se amplía para que los postores puedan retrasar su llegada. El único otro artículo del que tenemos conocimiento que aborda el tema de la compatibilidad de incentivos en un sistema en tiempo real es [11], el cual considera varias variantes de un modelo en el que el centro asigna ancho de banda a agentes que declaran tanto su valor como su tiempo de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de estrategia Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor proporción competitiva posible, pero para el cual se requerían nuevas soluciones cuando el escenario se amplía para incluir agentes con intereses propios. Presentamos un mecanismo que es compatible con incentivos con respecto al tiempo de liberación, plazo, duración y valor, y que solo aumenta la proporción competitiva en uno. También demostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes. Quedan varios problemas abiertos en este contexto. Se trata de determinar si el límite inferior puede ser fortalecido al eliminar la restricción de pagos no negativos. Además, aunque consideramos razonable fortalecer la suposición de conocer la máxima relación posible de densidades de valor (k) en lugar de conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo de ((1 + √ k)2 + 1) bajo la suposición original. Finalmente, los mecanismos aleatorios ofrecen un área inexplorada para trabajos futuros. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en el reparto de costos de multicast, Juegos y Comportamiento Económico (por aparecer). [2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de mecanismos de verdad en línea a optimización en línea, Actas del 35º Simposio sobre Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Revista de Sistemas en Tiempo Real 4 (1992), núm. 2, 125-144. [5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para compensación de mercado, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para gestión de recursos y programación en la computación en malla, La Revista de Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan y O. Regev, El proyecto popcorn: Computación distribuida en internet en Java, 6ª Conferencia Internacional World Wide Web, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y direcciones futuras, Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Fijación de precios de wifi en Starbucks: Problemas en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Límites para ciertas anomalías multiprocesador, Revista Técnica del Sistema Bell 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, La velocidad es tan poderosa como la clarividencia, Revista de la ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan y K. To, Programación en línea con plazos ajustados, Ciencia de la Computación Teórica 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo de programación en línea óptimo para sistemas en tiempo real sobrecargados, Revista SIAM de Computación 24 (1995), núm. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Verde, Teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño algorítmico de mecanismos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e internet, STOC, 2001, pp. 749-753. 70 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "non-strategic setting": {
            "translated_key": "entorno no estratégico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the <br>non-strategic setting</br> in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the <br>non-strategic setting</br>), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the <br>non-strategic setting</br>.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, <br>non-strategic setting</br>.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "<br>non-strategic setting</br> In this section, we formally define the original, <br>non-strategic setting</br>, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the <br>non-strategic setting</br>, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the <br>non-strategic setting</br> it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the <br>non-strategic setting</br>: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the <br>non-strategic setting</br>, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "However, these results only apply to the <br>non-strategic setting</br> in which the jobs are released directly to the algorithm.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the <br>non-strategic setting</br>), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the <br>non-strategic setting</br>.",
                "In Section 2, we formally define and review results from the original, <br>non-strategic setting</br>.",
                "<br>non-strategic setting</br> In this section, we formally define the original, <br>non-strategic setting</br>, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand."
            ],
            "translated_annotated_samples": [
                "Sin embargo, estos resultados solo se aplican al <br>entorno no estratégico</br> en el que los trabajos se liberan directamente al algoritmo.",
                "Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del <br>entorno no estratégico</br>), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva.",
                "Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el <br>entorno no estratégico</br>.",
                "En la Sección 2, definimos formalmente y revisamos los resultados del <br>entorno original, no estratégico</br>.",
                "CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al <br>entorno no estratégico</br> en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del <br>entorno no estratégico</br>), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el <br>entorno no estratégico</br>. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del <br>entorno original, no estratégico</br>. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. ",
            "candidates": [],
            "error": [
                [
                    "entorno no estratégico",
                    "entorno no estratégico",
                    "entorno no estratégico",
                    "entorno original, no estratégico"
                ]
            ]
        },
        "deadline": {
            "translated_key": "fecha límite",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and <br>deadline</br> for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a <br>deadline</br>, a processing time, and a value for successful completion by its <br>deadline</br>.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and <br>deadline</br> for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and <br>deadline</br>.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, <br>deadline</br>, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each <br>deadline</br> is firm (or, hard), which means that no value is obtained for a job that is completed after its <br>deadline</br>.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its <br>deadline</br>.",
                "A job is abandoned if it cannot be completed by its <br>deadline</br> (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and <br>deadline</br> both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest <br>deadline</br> of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s <br>deadline</br> were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true <br>deadline</br>) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary <br>deadline</br> or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later <br>deadline</br>) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true <br>deadline</br>.",
                "This is the reason why it is important to always return a completed job at its declared <br>deadline</br>, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared <br>deadline</br> are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and <br>deadline</br>.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true <br>deadline</br>.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the <br>deadline</br> of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original <br>deadline</br> of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its <br>deadline</br>, which is by construction at least as late as the new <br>deadline</br> df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, <br>deadline</br>, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and <br>deadline</br> for the job, while the center determines not only the schedule, but the payment of each agent.",
                "Each job is characterized by a release time, a <br>deadline</br>, a processing time, and a value for successful completion by its <br>deadline</br>.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and <br>deadline</br> for the job.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and <br>deadline</br>.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, <br>deadline</br>, length of processing time required, and value, respectively."
            ],
            "translated_annotated_samples": [
                "El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y <br>plazo</br> arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente.",
                "Cada trabajo se caracteriza por un tiempo de liberación, una <br>fecha límite</br>, un tiempo de procesamiento y un valor para su finalización exitosa antes de la <br>fecha límite</br>.",
                "Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y <br>plazo</br> arbitrarios para el trabajo.",
                "Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y <br>fecha límite</br>.",
                "Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la <br>fecha límite</br>, la duración del tiempo de procesamiento requerido y el valor, respectivamente."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y <br>plazo</br> arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una <br>fecha límite</br>, un tiempo de procesamiento y un valor para su finalización exitosa antes de la <br>fecha límite</br>. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y <br>plazo</br> arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y <br>fecha límite</br>. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la <br>fecha límite</br>, la duración del tiempo de procesamiento requerido y el valor, respectivamente. ",
            "candidates": [],
            "error": [
                [
                    "plazo",
                    "fecha límite",
                    "fecha límite",
                    "plazo",
                    "fecha límite",
                    "fecha límite"
                ]
            ]
        },
        "importance ratio": {
            "translated_key": "proporción de importancia",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The <br>importance ratio</br> is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the <br>importance ratio</br>.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "The <br>importance ratio</br> is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the <br>importance ratio</br>."
            ],
            "translated_annotated_samples": [
                "La <br>proporción de importancia</br> se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos.",
                "Se asume que el algoritmo siempre conoce un límite superior k en la <br>proporción de importancia</br>."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La <br>proporción de importancia</br> se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la <br>proporción de importancia</br>. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. Teorema 1. El mecanismo Γ1 cumple con la racionalidad individual. Prueba. Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente. Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición. Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete. Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba. Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri. Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro. Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta. Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i. Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo. Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y. Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri. Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I. Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera. Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta. Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ]. Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y. Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo. Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc). Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc. Ahora considera un y arbitrario ∈ Y tal que y = yc. En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc. Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que y reemplaza debe ser i. Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I. Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc]. Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc). Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz. Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lema 3. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba. Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no. Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última. Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción. Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4. En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración. Supongamos por contradicción que esta condición no se cumple. Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace. Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado. Lema 5. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri. En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta]. Ahora podemos combinar los lemas para demostrar que no es posible ninguna desviación rentable. Teorema 6. El mecanismo Γ1 cumple con la compatibilidad de incentivos. Prueba. Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición. También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite. Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline. Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1. Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia. Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If. Lema 7. Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba. El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible. Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados). Que ts i sea el tiempo en que el trabajo i comienza su ejecución. Ten en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación. Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple. En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo. También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf. Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline. Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F. Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf. Prueba. Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf. En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf. Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ]. Nuevamente aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf. Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos. El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f. Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva. Teorema 10. El mecanismo Γ1 es (1+ √ k)2+1-competitivo. Prueba. Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F). Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9. Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf. Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos. Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado. Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4]. Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo. Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas. Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5. LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas. Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i. La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14. No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1. Prueba. Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR). Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1. Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario. Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción. Ahora construimos el perfil original θ. Elige un α tal que 0 < α < , y define δ = α ck+3k. El adversario utiliza dos secuencias de trabajos: menores y mayores. Los trabajos menores se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1. La secuencia se detiene cada vez que Γ completa algún trabajo. Los trabajos principales también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, están determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 Los límites en α implican que (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2, lo que nos permite aplicar el Lema 13. Sea m el número positivo más pequeño tal que lm+k· m−1 h=1 lh lm > c−1+α. El primer trabajo principal tiene un tiempo de liberación de 0, y cada trabajo principal i > 1 tiene un tiempo de liberación de ri = di−1 − δ, justo antes de la fecha límite del trabajo anterior. El adversario libera un trabajo importante i ≤ m si y solo si cada trabajo importante j < i fue ejecutado de manera continua en el rango [ri, ri+1]. No se libera ningún trabajo importante después del trabajo m. Para lograr la relación competitiva deseada, Γ debe completar algún trabajo importante f, ya que Γoffline siempre puede completar al menos el trabajo importante 1 (por un valor de 1), y Γ puede completar como máximo un trabajo menor (por un valor de α c+3 < 1 c). Además, para que este trabajo f se libere, el tiempo del procesador anterior a rf solo puede ser utilizado para ejecutar trabajos importantes que luego son abandonados. Si f < m, entonces el trabajo principal f + 1 será lanzado y será el trabajo principal final. Γ no puede completar el trabajo f +1, porque rf + lf = df > rf+1. Por lo tanto, θ consiste en trabajos principales del 1 al f + 1 (o f, si f = m), más trabajos menores desde el tiempo 0 hasta el tiempo df. Ahora posiblemente perturbamos ligeramente θ. Por IR, sabemos que vf ≥ pf (θ). Dado que más adelante necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df se incrementan todos en δ sobre sus valores respectivos en θf. Por IC, el trabajo f aún debe ser completado por Γ para el perfil (θf, θ−f). Si no, entonces por IR y NNP sabemos que pf (θf , θ−f ) = 0, y por lo tanto que uf (g(θf , θ−f ), θf ) = 0. Sin embargo, el agente f podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: uf (g(θf, θ−f), θf) = vf - pf(θ) = δ > 0, violando la CI. Además, el agente f debe ser cobrado la misma cantidad (es decir, pf (θf , θ−f ) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la demostración, asumir que vf > pf (θ). Ahora utilizamos una perturbación más sustancial de θ para completar la prueba. Si f < m, entonces define θf como idéntico a θf, excepto que df = df+1 + lf, permitiendo que el trabajo f se complete por completo después de que el trabajo f + 1 se haya completado. Si f = m, entonces en lugar de eso establece df = df + lf. IC requiere que para el perfil (θf, θ−f), Γ siga ejecutando el trabajo f de forma continua en el rango [rf, rf + lf], evitando así que el trabajo f +1 se complete. Supongamos por contradicción que esto no fuera cierto. Entonces, en la fecha límite original de df, el trabajo f no está completado. Considera el posible perfil (θf, θ−f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene laxitud cero, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Dado que este nuevo perfil es indistinguible de (θf, θ−f) para Γ antes del tiempo df, debe programar trabajos de la misma manera hasta df. Entonces, para lograr la proporción competitiva deseada, debe ejecutar el trabajo x de forma continua hasta su fecha límite, que por construcción es al menos tan tardía como la nueva fecha límite df del trabajo f. Por lo tanto, el trabajo f no se completará y, según IR y NNP, debe ser el caso que pf (θf , θ−f , θx) = 0 y uf (g(θf , θ−f , θx), θf ) = 0. Usando el hecho de que θ es indistinguible de (θf, θ−f, θx) hasta el tiempo df, si el agente f declarara falsamente su tipo como el original θf, entonces su trabajo se completaría en df y se le cobraría pf(θ). Su utilidad aumentaría a uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradiciendo la CI. Si bien la ejecución de Γ debe ser idéntica para ambos (θf, θ−f) y (θf, θ−f), Γoffline puede aprovechar el cambio. Si f < m, entonces Γ alcanza un valor de como máximo lf + δ (el valor del trabajo f si fuera perturbado), mientras que Γoffline alcanza un valor de al menos k·( f h=1 lh −2δ)+lf+1 +lf al ejecutar trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (restamos dos δ en lugar de uno porque el último trabajo menor antes de rf+1 puede tener que ser abandonado). Sustituyendo en lf+1, la proporción competitiva es entonces al menos: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. Si en cambio f = m, entonces Γ alcanza un valor de como máximo lm +δ, mientras que Γoffline alcanza un valor de al menos k · ( m h=1 lh − 2δ) + lm al completar trabajos menores hasta que dm = rm + lm, y luego completar el trabajo m. La proporción competitiva es entonces al menos: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. TRABAJO RELACIONADO En esta sección describimos trabajos relacionados distintos a los dos artículos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo fuera de línea (ver, por ejemplo, [13, 14]). El diseño de mecanismos también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno sin conexión, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este artículo también lanzó el área del diseño algorítmico de mecanismos, en el cual el mecanismo debe cumplir con los requisitos computacionales además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño de mecanismos de reparto de costos para multicast (ver, por ejemplo, [1]), en el cual el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño algorítmico de mecanismos distribuidos, consulte [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de liquidación de mercado en línea, en el cual el subastador empareja ofertas de compra y venta (que se asumen como exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es compatible con incentivos con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], los cuales abordan subastas en línea de múltiples unidades. La principal diferencia entre ambos es que el primero considera el caso de un bien digital, el cual tiene una oferta ilimitada. Se señala en [16] que sus resultados siguen siendo válidos cuando el escenario se amplía para que los postores puedan retrasar su llegada. El único otro artículo del que tenemos conocimiento que aborda el tema de la compatibilidad de incentivos en un sistema en tiempo real es [11], el cual considera varias variantes de un modelo en el que el centro asigna ancho de banda a agentes que declaran tanto su valor como su tiempo de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de estrategia Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor proporción competitiva posible, pero para el cual se requerían nuevas soluciones cuando el escenario se amplía para incluir agentes con intereses propios. Presentamos un mecanismo que es compatible con incentivos con respecto al tiempo de liberación, plazo, duración y valor, y que solo aumenta la proporción competitiva en uno. También demostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes. Quedan varios problemas abiertos en este contexto. Se trata de determinar si el límite inferior puede ser fortalecido al eliminar la restricción de pagos no negativos. Además, aunque consideramos razonable fortalecer la suposición de conocer la máxima relación posible de densidades de valor (k) en lugar de conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo de ((1 + √ k)2 + 1) bajo la suposición original. Finalmente, los mecanismos aleatorios ofrecen un área inexplorada para trabajos futuros. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en el reparto de costos de multicast, Juegos y Comportamiento Económico (por aparecer). [2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de mecanismos de verdad en línea a optimización en línea, Actas del 35º Simposio sobre Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Revista de Sistemas en Tiempo Real 4 (1992), núm. 2, 125-144. [5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para compensación de mercado, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para gestión de recursos y programación en la computación en malla, La Revista de Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan y O. Regev, El proyecto popcorn: Computación distribuida en internet en Java, 6ª Conferencia Internacional World Wide Web, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y direcciones futuras, Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Fijación de precios de wifi en Starbucks: Problemas en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Límites para ciertas anomalías multiprocesador, Revista Técnica del Sistema Bell 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, La velocidad es tan poderosa como la clarividencia, Revista de la ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan y K. To, Programación en línea con plazos ajustados, Ciencia de la Computación Teórica 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo de programación en línea óptimo para sistemas en tiempo real sobrecargados, Revista SIAM de Computación 24 (1995), núm. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Verde, Teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño algorítmico de mecanismos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e internet, STOC, 2001, pp. 749-753. 70 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "zero laxity": {
            "translated_key": "holgura de cero",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has <br>zero laxity</br>.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with <br>zero laxity</br>.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have <br>zero laxity</br> at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and <br>zero laxity</br>.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have <br>zero laxity</br>, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has <br>zero laxity</br>, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has <br>zero laxity</br>.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with <br>zero laxity</br>.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have <br>zero laxity</br> at time 0.7.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and <br>zero laxity</br>.",
                "Major jobs also have <br>zero laxity</br>, but they have the smallest possible value ratio (that is, vi = li)."
            ],
            "translated_annotated_samples": [
                "El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una <br>holgura de cero</br>.",
                "Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una <br>holgura de cero</br>.",
                "Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una <br>holgura de cero</br> en el tiempo 0.7.",
                "Los trabajos menores se caracterizan por li = δ, vi = k · δ y <br>laxitud cero</br>.",
                "Los trabajos principales también tienen <br>cero laxitud</br>, pero tienen la menor relación de valor posible (es decir, vi = li)."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una <br>holgura de cero</br>. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una <br>holgura de cero</br>. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una <br>holgura de cero</br> en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. Teorema 1. El mecanismo Γ1 cumple con la racionalidad individual. Prueba. Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente. Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición. Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete. Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba. Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri. Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro. Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta. Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i. Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo. Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y. Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri. Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I. Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera. Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta. Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ]. Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y. Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo. Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc). Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc. Ahora considera un y arbitrario ∈ Y tal que y = yc. En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc. Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que y reemplaza debe ser i. Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I. Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc]. Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc). Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz. Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lema 3. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba. Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no. Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última. Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción. Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4. En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración. Supongamos por contradicción que esta condición no se cumple. Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace. Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado. Lema 5. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri. En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta]. Ahora podemos combinar los lemas para demostrar que no es posible ninguna desviación rentable. Teorema 6. El mecanismo Γ1 cumple con la compatibilidad de incentivos. Prueba. Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición. También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite. Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline. Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1. Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia. Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If. Lema 7. Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba. El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible. Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados). Que ts i sea el tiempo en que el trabajo i comienza su ejecución. Ten en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación. Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple. En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo. También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf. Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline. Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F. Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf. Prueba. Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf. En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf. Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ]. Nuevamente aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf. Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos. El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f. Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva. Teorema 10. El mecanismo Γ1 es (1+ √ k)2+1-competitivo. Prueba. Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F). Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9. Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf. Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos. Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado. Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4]. Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo. Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas. Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5. LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas. Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i. La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14. No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1. Prueba. Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR). Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1. Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario. Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción. Ahora construimos el perfil original θ. Elige un α tal que 0 < α < , y define δ = α ck+3k. El adversario utiliza dos secuencias de trabajos: menores y mayores. Los trabajos menores se caracterizan por li = δ, vi = k · δ y <br>laxitud cero</br>. El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1. La secuencia se detiene cada vez que Γ completa algún trabajo. Los trabajos principales también tienen <br>cero laxitud</br>, pero tienen la menor relación de valor posible (es decir, vi = li). ",
            "candidates": [],
            "error": [
                [
                    "holgura de cero",
                    "holgura de cero",
                    "holgura de cero",
                    "laxitud cero",
                    "cero laxitud"
                ]
            ]
        },
        "online algorithm": {
            "translated_key": "algoritmo en línea",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the <br>online algorithm</br> and an adversary.",
                "First, the designer selects the <br>online algorithm</br>.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the <br>online algorithm</br>.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An <br>online algorithm</br> is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the <br>online algorithm</br> must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an <br>online algorithm</br> is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An <br>online algorithm</br> f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the <br>online algorithm</br> uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an <br>online algorithm</br> into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "One interpretation of this approach is as a game between the designer of the <br>online algorithm</br> and an adversary.",
                "First, the designer selects the <br>online algorithm</br>.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the <br>online algorithm</br>.",
                "An <br>online algorithm</br> is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the <br>online algorithm</br> must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time."
            ],
            "translated_annotated_samples": [
                "Una interpretación de este enfoque es como un juego entre el diseñador del <br>algoritmo en línea</br> y un adversario.",
                "Primero, el diseñador selecciona el <br>algoritmo en línea</br>.",
                "Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el <br>algoritmo en línea</br>.",
                "Un <br>algoritmo en línea</br> es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o.",
                "Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el <br>algoritmo en línea</br> debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del <br>algoritmo en línea</br> y un adversario. Primero, el diseñador selecciona el <br>algoritmo en línea</br>. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el <br>algoritmo en línea</br>. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un <br>algoritmo en línea</br> es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el <br>algoritmo en línea</br> debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "quasi-linear function": {
            "translated_key": "función cuasi-lineal",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a <br>quasi-linear function</br> of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a <br>quasi-linear function</br> of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center."
            ],
            "translated_annotated_samples": [
                "La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una <br>función cuasi-lineal</br> de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una <br>función cuasi-lineal</br> de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. Teorema 1. El mecanismo Γ1 cumple con la racionalidad individual. Prueba. Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente. Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición. Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete. Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba. Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri. Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro. Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta. Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i. Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo. Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y. Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri. Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I. Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera. Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta. Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ]. Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y. Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo. Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc). Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc. Ahora considera un y arbitrario ∈ Y tal que y = yc. En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc. Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que y reemplaza debe ser i. Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I. Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc]. Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc). Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz. Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lema 3. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba. Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no. Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última. Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción. Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4. En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración. Supongamos por contradicción que esta condición no se cumple. Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace. Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado. Lema 5. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri. En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta]. Ahora podemos combinar los lemas para demostrar que no es posible ninguna desviación rentable. Teorema 6. El mecanismo Γ1 cumple con la compatibilidad de incentivos. Prueba. Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición. También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite. Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline. Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1. Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia. Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If. Lema 7. Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba. El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible. Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados). Que ts i sea el tiempo en que el trabajo i comienza su ejecución. Ten en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación. Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple. En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo. También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf. Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline. Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F. Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf. Prueba. Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf. En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf. Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ]. Nuevamente aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf. Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos. El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f. Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva. Teorema 10. El mecanismo Γ1 es (1+ √ k)2+1-competitivo. Prueba. Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F). Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9. Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf. Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos. Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado. Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4]. Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo. Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas. Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5. LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas. Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i. La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14. No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1. Prueba. Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR). Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1. Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario. Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción. Ahora construimos el perfil original θ. Elige un α tal que 0 < α < , y define δ = α ck+3k. El adversario utiliza dos secuencias de trabajos: menores y mayores. Los trabajos menores se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1. La secuencia se detiene cada vez que Γ completa algún trabajo. Los trabajos principales también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, están determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 Los límites en α implican que (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2, lo que nos permite aplicar el Lema 13. Sea m el número positivo más pequeño tal que lm+k· m−1 h=1 lh lm > c−1+α. El primer trabajo principal tiene un tiempo de liberación de 0, y cada trabajo principal i > 1 tiene un tiempo de liberación de ri = di−1 − δ, justo antes de la fecha límite del trabajo anterior. El adversario libera un trabajo importante i ≤ m si y solo si cada trabajo importante j < i fue ejecutado de manera continua en el rango [ri, ri+1]. No se libera ningún trabajo importante después del trabajo m. Para lograr la relación competitiva deseada, Γ debe completar algún trabajo importante f, ya que Γoffline siempre puede completar al menos el trabajo importante 1 (por un valor de 1), y Γ puede completar como máximo un trabajo menor (por un valor de α c+3 < 1 c). Además, para que este trabajo f se libere, el tiempo del procesador anterior a rf solo puede ser utilizado para ejecutar trabajos importantes que luego son abandonados. Si f < m, entonces el trabajo principal f + 1 será lanzado y será el trabajo principal final. Γ no puede completar el trabajo f +1, porque rf + lf = df > rf+1. Por lo tanto, θ consiste en trabajos principales del 1 al f + 1 (o f, si f = m), más trabajos menores desde el tiempo 0 hasta el tiempo df. Ahora posiblemente perturbamos ligeramente θ. Por IR, sabemos que vf ≥ pf (θ). Dado que más adelante necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df se incrementan todos en δ sobre sus valores respectivos en θf. Por IC, el trabajo f aún debe ser completado por Γ para el perfil (θf, θ−f). Si no, entonces por IR y NNP sabemos que pf (θf , θ−f ) = 0, y por lo tanto que uf (g(θf , θ−f ), θf ) = 0. Sin embargo, el agente f podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: uf (g(θf, θ−f), θf) = vf - pf(θ) = δ > 0, violando la CI. Además, el agente f debe ser cobrado la misma cantidad (es decir, pf (θf , θ−f ) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la demostración, asumir que vf > pf (θ). Ahora utilizamos una perturbación más sustancial de θ para completar la prueba. Si f < m, entonces define θf como idéntico a θf, excepto que df = df+1 + lf, permitiendo que el trabajo f se complete por completo después de que el trabajo f + 1 se haya completado. Si f = m, entonces en lugar de eso establece df = df + lf. IC requiere que para el perfil (θf, θ−f), Γ siga ejecutando el trabajo f de forma continua en el rango [rf, rf + lf], evitando así que el trabajo f +1 se complete. Supongamos por contradicción que esto no fuera cierto. Entonces, en la fecha límite original de df, el trabajo f no está completado. Considera el posible perfil (θf, θ−f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene laxitud cero, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Dado que este nuevo perfil es indistinguible de (θf, θ−f) para Γ antes del tiempo df, debe programar trabajos de la misma manera hasta df. Entonces, para lograr la proporción competitiva deseada, debe ejecutar el trabajo x de forma continua hasta su fecha límite, que por construcción es al menos tan tardía como la nueva fecha límite df del trabajo f. Por lo tanto, el trabajo f no se completará y, según IR y NNP, debe ser el caso que pf (θf , θ−f , θx) = 0 y uf (g(θf , θ−f , θx), θf ) = 0. Usando el hecho de que θ es indistinguible de (θf, θ−f, θx) hasta el tiempo df, si el agente f declarara falsamente su tipo como el original θf, entonces su trabajo se completaría en df y se le cobraría pf(θ). Su utilidad aumentaría a uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradiciendo la CI. Si bien la ejecución de Γ debe ser idéntica para ambos (θf, θ−f) y (θf, θ−f), Γoffline puede aprovechar el cambio. Si f < m, entonces Γ alcanza un valor de como máximo lf + δ (el valor del trabajo f si fuera perturbado), mientras que Γoffline alcanza un valor de al menos k·( f h=1 lh −2δ)+lf+1 +lf al ejecutar trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (restamos dos δ en lugar de uno porque el último trabajo menor antes de rf+1 puede tener que ser abandonado). Sustituyendo en lf+1, la proporción competitiva es entonces al menos: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. Si en cambio f = m, entonces Γ alcanza un valor de como máximo lm +δ, mientras que Γoffline alcanza un valor de al menos k · ( m h=1 lh − 2δ) + lm al completar trabajos menores hasta que dm = rm + lm, y luego completar el trabajo m. La proporción competitiva es entonces al menos: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. TRABAJO RELACIONADO En esta sección describimos trabajos relacionados distintos a los dos artículos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo fuera de línea (ver, por ejemplo, [13, 14]). El diseño de mecanismos también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno sin conexión, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este artículo también lanzó el área del diseño algorítmico de mecanismos, en el cual el mecanismo debe cumplir con los requisitos computacionales además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño de mecanismos de reparto de costos para multicast (ver, por ejemplo, [1]), en el cual el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño algorítmico de mecanismos distribuidos, consulte [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de liquidación de mercado en línea, en el cual el subastador empareja ofertas de compra y venta (que se asumen como exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es compatible con incentivos con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], los cuales abordan subastas en línea de múltiples unidades. La principal diferencia entre ambos es que el primero considera el caso de un bien digital, el cual tiene una oferta ilimitada. Se señala en [16] que sus resultados siguen siendo válidos cuando el escenario se amplía para que los postores puedan retrasar su llegada. El único otro artículo del que tenemos conocimiento que aborda el tema de la compatibilidad de incentivos en un sistema en tiempo real es [11], el cual considera varias variantes de un modelo en el que el centro asigna ancho de banda a agentes que declaran tanto su valor como su tiempo de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de estrategia Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor proporción competitiva posible, pero para el cual se requerían nuevas soluciones cuando el escenario se amplía para incluir agentes con intereses propios. Presentamos un mecanismo que es compatible con incentivos con respecto al tiempo de liberación, plazo, duración y valor, y que solo aumenta la proporción competitiva en uno. También demostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes. Quedan varios problemas abiertos en este contexto. Se trata de determinar si el límite inferior puede ser fortalecido al eliminar la restricción de pagos no negativos. Además, aunque consideramos razonable fortalecer la suposición de conocer la máxima relación posible de densidades de valor (k) en lugar de conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo de ((1 + √ k)2 + 1) bajo la suposición original. Finalmente, los mecanismos aleatorios ofrecen un área inexplorada para trabajos futuros. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en el reparto de costos de multicast, Juegos y Comportamiento Económico (por aparecer). [2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de mecanismos de verdad en línea a optimización en línea, Actas del 35º Simposio sobre Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Revista de Sistemas en Tiempo Real 4 (1992), núm. 2, 125-144. [5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para compensación de mercado, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para gestión de recursos y programación en la computación en malla, La Revista de Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan y O. Regev, El proyecto popcorn: Computación distribuida en internet en Java, 6ª Conferencia Internacional World Wide Web, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y direcciones futuras, Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Fijación de precios de wifi en Starbucks: Problemas en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Límites para ciertas anomalías multiprocesador, Revista Técnica del Sistema Bell 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, La velocidad es tan poderosa como la clarividencia, Revista de la ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan y K. To, Programación en línea con plazos ajustados, Ciencia de la Computación Teórica 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo de programación en línea óptimo para sistemas en tiempo real sobrecargados, Revista SIAM de Computación 24 (1995), núm. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Verde, Teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño algorítmico de mecanismos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e internet, STOC, 2001, pp. 749-753. 70 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "deterministic mechanism": {
            "translated_key": "mecanismo determinista",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a <br>deterministic mechanism</br> that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a <br>deterministic mechanism</br> that never pays the agents."
            ],
            "translated_annotated_samples": [
                "Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un <br>mecanismo determinista</br> que nunca paga a los agentes."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. Teorema 1. El mecanismo Γ1 cumple con la racionalidad individual. Prueba. Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente. Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición. Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete. Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba. Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri. Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro. Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta. Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i. Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo. Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y. Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri. Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I. Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera. Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta. Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ]. Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y. Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo. Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc). Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc. Ahora considera un y arbitrario ∈ Y tal que y = yc. En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc. Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que y reemplaza debe ser i. Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I. Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc]. Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc). Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz. Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lema 3. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba. Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no. Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última. Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción. Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4. En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración. Supongamos por contradicción que esta condición no se cumple. Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace. Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado. Lema 5. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri. En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta]. Ahora podemos combinar los lemas para demostrar que no es posible ninguna desviación rentable. Teorema 6. El mecanismo Γ1 cumple con la compatibilidad de incentivos. Prueba. Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición. También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite. Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline. Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1. Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia. Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If. Lema 7. Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba. El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible. Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados). Que ts i sea el tiempo en que el trabajo i comienza su ejecución. Ten en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación. Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple. En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo. También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf. Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline. Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F. Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf. Prueba. Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf. En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf. Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ]. Nuevamente aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf. Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos. El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f. Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva. Teorema 10. El mecanismo Γ1 es (1+ √ k)2+1-competitivo. Prueba. Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F). Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9. Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf. Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos. Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado. Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4]. Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo. Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas. Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5. LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas. Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i. La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14. No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1. Prueba. Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR). Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1. Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario. Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción. Ahora construimos el perfil original θ. Elige un α tal que 0 < α < , y define δ = α ck+3k. El adversario utiliza dos secuencias de trabajos: menores y mayores. Los trabajos menores se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1. La secuencia se detiene cada vez que Γ completa algún trabajo. Los trabajos principales también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, están determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 Los límites en α implican que (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2, lo que nos permite aplicar el Lema 13. Sea m el número positivo más pequeño tal que lm+k· m−1 h=1 lh lm > c−1+α. El primer trabajo principal tiene un tiempo de liberación de 0, y cada trabajo principal i > 1 tiene un tiempo de liberación de ri = di−1 − δ, justo antes de la fecha límite del trabajo anterior. El adversario libera un trabajo importante i ≤ m si y solo si cada trabajo importante j < i fue ejecutado de manera continua en el rango [ri, ri+1]. No se libera ningún trabajo importante después del trabajo m. Para lograr la relación competitiva deseada, Γ debe completar algún trabajo importante f, ya que Γoffline siempre puede completar al menos el trabajo importante 1 (por un valor de 1), y Γ puede completar como máximo un trabajo menor (por un valor de α c+3 < 1 c). Además, para que este trabajo f se libere, el tiempo del procesador anterior a rf solo puede ser utilizado para ejecutar trabajos importantes que luego son abandonados. Si f < m, entonces el trabajo principal f + 1 será lanzado y será el trabajo principal final. Γ no puede completar el trabajo f +1, porque rf + lf = df > rf+1. Por lo tanto, θ consiste en trabajos principales del 1 al f + 1 (o f, si f = m), más trabajos menores desde el tiempo 0 hasta el tiempo df. Ahora posiblemente perturbamos ligeramente θ. Por IR, sabemos que vf ≥ pf (θ). Dado que más adelante necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df se incrementan todos en δ sobre sus valores respectivos en θf. Por IC, el trabajo f aún debe ser completado por Γ para el perfil (θf, θ−f). Si no, entonces por IR y NNP sabemos que pf (θf , θ−f ) = 0, y por lo tanto que uf (g(θf , θ−f ), θf ) = 0. Sin embargo, el agente f podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: uf (g(θf, θ−f), θf) = vf - pf(θ) = δ > 0, violando la CI. Además, el agente f debe ser cobrado la misma cantidad (es decir, pf (θf , θ−f ) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la demostración, asumir que vf > pf (θ). Ahora utilizamos una perturbación más sustancial de θ para completar la prueba. Si f < m, entonces define θf como idéntico a θf, excepto que df = df+1 + lf, permitiendo que el trabajo f se complete por completo después de que el trabajo f + 1 se haya completado. Si f = m, entonces en lugar de eso establece df = df + lf. IC requiere que para el perfil (θf, θ−f), Γ siga ejecutando el trabajo f de forma continua en el rango [rf, rf + lf], evitando así que el trabajo f +1 se complete. Supongamos por contradicción que esto no fuera cierto. Entonces, en la fecha límite original de df, el trabajo f no está completado. Considera el posible perfil (θf, θ−f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene laxitud cero, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Dado que este nuevo perfil es indistinguible de (θf, θ−f) para Γ antes del tiempo df, debe programar trabajos de la misma manera hasta df. Entonces, para lograr la proporción competitiva deseada, debe ejecutar el trabajo x de forma continua hasta su fecha límite, que por construcción es al menos tan tardía como la nueva fecha límite df del trabajo f. Por lo tanto, el trabajo f no se completará y, según IR y NNP, debe ser el caso que pf (θf , θ−f , θx) = 0 y uf (g(θf , θ−f , θx), θf ) = 0. Usando el hecho de que θ es indistinguible de (θf, θ−f, θx) hasta el tiempo df, si el agente f declarara falsamente su tipo como el original θf, entonces su trabajo se completaría en df y se le cobraría pf(θ). Su utilidad aumentaría a uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradiciendo la CI. Si bien la ejecución de Γ debe ser idéntica para ambos (θf, θ−f) y (θf, θ−f), Γoffline puede aprovechar el cambio. Si f < m, entonces Γ alcanza un valor de como máximo lf + δ (el valor del trabajo f si fuera perturbado), mientras que Γoffline alcanza un valor de al menos k·( f h=1 lh −2δ)+lf+1 +lf al ejecutar trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (restamos dos δ en lugar de uno porque el último trabajo menor antes de rf+1 puede tener que ser abandonado). Sustituyendo en lf+1, la proporción competitiva es entonces al menos: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. Si en cambio f = m, entonces Γ alcanza un valor de como máximo lm +δ, mientras que Γoffline alcanza un valor de al menos k · ( m h=1 lh − 2δ) + lm al completar trabajos menores hasta que dm = rm + lm, y luego completar el trabajo m. La proporción competitiva es entonces al menos: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. TRABAJO RELACIONADO En esta sección describimos trabajos relacionados distintos a los dos artículos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo fuera de línea (ver, por ejemplo, [13, 14]). El diseño de mecanismos también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno sin conexión, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este artículo también lanzó el área del diseño algorítmico de mecanismos, en el cual el mecanismo debe cumplir con los requisitos computacionales además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño de mecanismos de reparto de costos para multicast (ver, por ejemplo, [1]), en el cual el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño algorítmico de mecanismos distribuidos, consulte [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de liquidación de mercado en línea, en el cual el subastador empareja ofertas de compra y venta (que se asumen como exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es compatible con incentivos con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], los cuales abordan subastas en línea de múltiples unidades. La principal diferencia entre ambos es que el primero considera el caso de un bien digital, el cual tiene una oferta ilimitada. Se señala en [16] que sus resultados siguen siendo válidos cuando el escenario se amplía para que los postores puedan retrasar su llegada. El único otro artículo del que tenemos conocimiento que aborda el tema de la compatibilidad de incentivos en un sistema en tiempo real es [11], el cual considera varias variantes de un modelo en el que el centro asigna ancho de banda a agentes que declaran tanto su valor como su tiempo de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de estrategia Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor proporción competitiva posible, pero para el cual se requerían nuevas soluciones cuando el escenario se amplía para incluir agentes con intereses propios. Presentamos un mecanismo que es compatible con incentivos con respecto al tiempo de liberación, plazo, duración y valor, y que solo aumenta la proporción competitiva en uno. También demostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un <br>mecanismo determinista</br> que nunca paga a los agentes. Quedan varios problemas abiertos en este contexto. Se trata de determinar si el límite inferior puede ser fortalecido al eliminar la restricción de pagos no negativos. Además, aunque consideramos razonable fortalecer la suposición de conocer la máxima relación posible de densidades de valor (k) en lugar de conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo de ((1 + √ k)2 + 1) bajo la suposición original. Finalmente, los mecanismos aleatorios ofrecen un área inexplorada para trabajos futuros. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en el reparto de costos de multicast, Juegos y Comportamiento Económico (por aparecer). [2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de mecanismos de verdad en línea a optimización en línea, Actas del 35º Simposio sobre Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Revista de Sistemas en Tiempo Real 4 (1992), núm. 2, 125-144. [5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para compensación de mercado, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para gestión de recursos y programación en la computación en malla, La Revista de Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan y O. Regev, El proyecto popcorn: Computación distribuida en internet en Java, 6ª Conferencia Internacional World Wide Web, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y direcciones futuras, Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Fijación de precios de wifi en Starbucks: Problemas en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Límites para ciertas anomalías multiprocesador, Revista Técnica del Sistema Bell 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, La velocidad es tan poderosa como la clarividencia, Revista de la ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan y K. To, Programación en línea con plazos ajustados, Ciencia de la Computación Teórica 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo de programación en línea óptimo para sistemas en tiempo real sobrecargados, Revista SIAM de Computación 24 (1995), núm. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Verde, Teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño algorítmico de mecanismos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e internet, STOC, 2001, pp. 749-753. 70 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "incentive compatibility": {
            "translated_key": "compatibilidad de incentivos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is <br>incentive compatibility</br>, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove <br>incentive compatibility</br> and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of <br>incentive compatibility</br> and individual rationality.",
                "The condition for (dominant strategy) <br>incentive compatibility</br> is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies <br>incentive compatibility</br> (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for <br>incentive compatibility</br> is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and <br>incentive compatibility</br>, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies <br>incentive compatibility</br> and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and <br>incentive compatibility</br> After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies <br>incentive compatibility</br>.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and <br>incentive compatibility</br>.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure <br>incentive compatibility</br>. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related <br>incentive compatibility</br> arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting <br>incentive compatibility</br> by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar <br>incentive compatibility</br> argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of <br>incentive compatibility</br> in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "A basic solution concept of mechanism design is <br>incentive compatibility</br>, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove <br>incentive compatibility</br> and the competitive ratio.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of <br>incentive compatibility</br> and individual rationality.",
                "The condition for (dominant strategy) <br>incentive compatibility</br> is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "A direct mechanism Γ satisfies <br>incentive compatibility</br> (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn."
            ],
            "translated_annotated_samples": [
                "Un concepto básico de solución en el diseño de mecanismos es la <br>compatibilidad de incentivos</br>, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite.",
                "En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la <br>compatibilidad de incentivos</br> y la relación competitiva.",
                "El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de <br>compatibilidad de incentivos</br> y racionalidad individual.",
                "La condición para la <br>compatibilidad de incentivos</br> (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración.",
                "Un mecanismo directo Γ satisface la <br>compatibilidad de incentivos</br> (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la <br>compatibilidad de incentivos</br>, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la <br>compatibilidad de incentivos</br> y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de <br>compatibilidad de incentivos</br> y racionalidad individual. La condición para la <br>compatibilidad de incentivos</br> (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la <br>compatibilidad de incentivos</br> (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "individual rationality": {
            "translated_key": "racionalidad individual",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and <br>individual rationality</br>.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, <br>individual rationality</br>, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies <br>individual rationality</br> (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies <br>individual rationality</br> and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of <br>individual rationality</br> and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies <br>individual rationality</br>.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies <br>individual rationality</br> and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and <br>individual rationality</br>.",
                "The second goal for our mechanism, <br>individual rationality</br>, requires that agents who truthfully reveal their type never have negative utility.",
                "A direct mechanism Γ satisfies <br>individual rationality</br> (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "After providing some intuition as to why Γ1 satisfies <br>individual rationality</br> and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of <br>individual rationality</br> and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas."
            ],
            "translated_annotated_samples": [
                "El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y <br>racionalidad individual</br>.",
                "El segundo objetivo de nuestro mecanismo, la <br>racionalidad individual</br>, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa.",
                "Un mecanismo directo Γ satisface la <br>racionalidad individual</br> (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la <br>racionalidad individual</br> y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva.",
                "Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de <br>Racionalidad Individual</br> y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y <br>racionalidad individual</br>. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la <br>racionalidad individual</br>, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la <br>racionalidad individual</br> (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la <br>racionalidad individual</br> y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de <br>Racionalidad Individual</br> y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "profitable deviation": {
            "translated_key": "desviación rentable",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no <br>profitable deviation</br> is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "We can now combine the lemmas to show that no <br>profitable deviation</br> is possible."
            ],
            "translated_annotated_samples": [
                "Ahora podemos combinar los lemas para demostrar que no es posible ninguna <br>desviación rentable</br>."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. Teorema 1. El mecanismo Γ1 cumple con la racionalidad individual. Prueba. Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente. Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición. Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete. Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba. Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri. Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro. Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta. Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i. Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo. Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y. Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri. Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I. Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera. Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta. Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ]. Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y. Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo. Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc). Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc. Ahora considera un y arbitrario ∈ Y tal que y = yc. En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc. Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que y reemplaza debe ser i. Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I. Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc]. Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc). Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz. Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lema 3. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba. Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no. Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última. Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción. Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4. En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración. Supongamos por contradicción que esta condición no se cumple. Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace. Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado. Lema 5. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri. En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta]. Ahora podemos combinar los lemas para demostrar que no es posible ninguna <br>desviación rentable</br>. Teorema 6. El mecanismo Γ1 cumple con la compatibilidad de incentivos. Prueba. Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición. También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite. Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline. Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1. Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia. Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If. Lema 7. Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba. El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible. Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados). Que ts i sea el tiempo en que el trabajo i comienza su ejecución. Ten en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación. Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple. En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo. También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf. Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline. Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F. Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf. Prueba. Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf. En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf. Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ]. Nuevamente aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf. Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos. El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f. Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva. Teorema 10. El mecanismo Γ1 es (1+ √ k)2+1-competitivo. Prueba. Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F). Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9. Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf. Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos. Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado. Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4]. Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo. Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas. Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5. LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas. Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i. La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14. No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1. Prueba. Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR). Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1. Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario. Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción. Ahora construimos el perfil original θ. Elige un α tal que 0 < α < , y define δ = α ck+3k. El adversario utiliza dos secuencias de trabajos: menores y mayores. Los trabajos menores se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1. La secuencia se detiene cada vez que Γ completa algún trabajo. Los trabajos principales también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, están determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 Los límites en α implican que (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2, lo que nos permite aplicar el Lema 13. Sea m el número positivo más pequeño tal que lm+k· m−1 h=1 lh lm > c−1+α. El primer trabajo principal tiene un tiempo de liberación de 0, y cada trabajo principal i > 1 tiene un tiempo de liberación de ri = di−1 − δ, justo antes de la fecha límite del trabajo anterior. El adversario libera un trabajo importante i ≤ m si y solo si cada trabajo importante j < i fue ejecutado de manera continua en el rango [ri, ri+1]. No se libera ningún trabajo importante después del trabajo m. Para lograr la relación competitiva deseada, Γ debe completar algún trabajo importante f, ya que Γoffline siempre puede completar al menos el trabajo importante 1 (por un valor de 1), y Γ puede completar como máximo un trabajo menor (por un valor de α c+3 < 1 c). Además, para que este trabajo f se libere, el tiempo del procesador anterior a rf solo puede ser utilizado para ejecutar trabajos importantes que luego son abandonados. Si f < m, entonces el trabajo principal f + 1 será lanzado y será el trabajo principal final. Γ no puede completar el trabajo f +1, porque rf + lf = df > rf+1. Por lo tanto, θ consiste en trabajos principales del 1 al f + 1 (o f, si f = m), más trabajos menores desde el tiempo 0 hasta el tiempo df. Ahora posiblemente perturbamos ligeramente θ. Por IR, sabemos que vf ≥ pf (θ). Dado que más adelante necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df se incrementan todos en δ sobre sus valores respectivos en θf. Por IC, el trabajo f aún debe ser completado por Γ para el perfil (θf, θ−f). Si no, entonces por IR y NNP sabemos que pf (θf , θ−f ) = 0, y por lo tanto que uf (g(θf , θ−f ), θf ) = 0. Sin embargo, el agente f podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: uf (g(θf, θ−f), θf) = vf - pf(θ) = δ > 0, violando la CI. Además, el agente f debe ser cobrado la misma cantidad (es decir, pf (θf , θ−f ) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la demostración, asumir que vf > pf (θ). Ahora utilizamos una perturbación más sustancial de θ para completar la prueba. Si f < m, entonces define θf como idéntico a θf, excepto que df = df+1 + lf, permitiendo que el trabajo f se complete por completo después de que el trabajo f + 1 se haya completado. Si f = m, entonces en lugar de eso establece df = df + lf. IC requiere que para el perfil (θf, θ−f), Γ siga ejecutando el trabajo f de forma continua en el rango [rf, rf + lf], evitando así que el trabajo f +1 se complete. Supongamos por contradicción que esto no fuera cierto. Entonces, en la fecha límite original de df, el trabajo f no está completado. Considera el posible perfil (θf, θ−f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene laxitud cero, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Dado que este nuevo perfil es indistinguible de (θf, θ−f) para Γ antes del tiempo df, debe programar trabajos de la misma manera hasta df. Entonces, para lograr la proporción competitiva deseada, debe ejecutar el trabajo x de forma continua hasta su fecha límite, que por construcción es al menos tan tardía como la nueva fecha límite df del trabajo f. Por lo tanto, el trabajo f no se completará y, según IR y NNP, debe ser el caso que pf (θf , θ−f , θx) = 0 y uf (g(θf , θ−f , θx), θf ) = 0. Usando el hecho de que θ es indistinguible de (θf, θ−f, θx) hasta el tiempo df, si el agente f declarara falsamente su tipo como el original θf, entonces su trabajo se completaría en df y se le cobraría pf(θ). Su utilidad aumentaría a uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradiciendo la CI. Si bien la ejecución de Γ debe ser idéntica para ambos (θf, θ−f) y (θf, θ−f), Γoffline puede aprovechar el cambio. Si f < m, entonces Γ alcanza un valor de como máximo lf + δ (el valor del trabajo f si fuera perturbado), mientras que Γoffline alcanza un valor de al menos k·( f h=1 lh −2δ)+lf+1 +lf al ejecutar trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (restamos dos δ en lugar de uno porque el último trabajo menor antes de rf+1 puede tener que ser abandonado). Sustituyendo en lf+1, la proporción competitiva es entonces al menos: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. Si en cambio f = m, entonces Γ alcanza un valor de como máximo lm +δ, mientras que Γoffline alcanza un valor de al menos k · ( m h=1 lh − 2δ) + lm al completar trabajos menores hasta que dm = rm + lm, y luego completar el trabajo m. La proporción competitiva es entonces al menos: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. TRABAJO RELACIONADO En esta sección describimos trabajos relacionados distintos a los dos artículos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo fuera de línea (ver, por ejemplo, [13, 14]). El diseño de mecanismos también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno sin conexión, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este artículo también lanzó el área del diseño algorítmico de mecanismos, en el cual el mecanismo debe cumplir con los requisitos computacionales además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño de mecanismos de reparto de costos para multicast (ver, por ejemplo, [1]), en el cual el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño algorítmico de mecanismos distribuidos, consulte [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de liquidación de mercado en línea, en el cual el subastador empareja ofertas de compra y venta (que se asumen como exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es compatible con incentivos con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], los cuales abordan subastas en línea de múltiples unidades. La principal diferencia entre ambos es que el primero considera el caso de un bien digital, el cual tiene una oferta ilimitada. Se señala en [16] que sus resultados siguen siendo válidos cuando el escenario se amplía para que los postores puedan retrasar su llegada. El único otro artículo del que tenemos conocimiento que aborda el tema de la compatibilidad de incentivos en un sistema en tiempo real es [11], el cual considera varias variantes de un modelo en el que el centro asigna ancho de banda a agentes que declaran tanto su valor como su tiempo de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de estrategia Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor proporción competitiva posible, pero para el cual se requerían nuevas soluciones cuando el escenario se amplía para incluir agentes con intereses propios. Presentamos un mecanismo que es compatible con incentivos con respecto al tiempo de liberación, plazo, duración y valor, y que solo aumenta la proporción competitiva en uno. También demostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes. Quedan varios problemas abiertos en este contexto. Se trata de determinar si el límite inferior puede ser fortalecido al eliminar la restricción de pagos no negativos. Además, aunque consideramos razonable fortalecer la suposición de conocer la máxima relación posible de densidades de valor (k) en lugar de conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo de ((1 + √ k)2 + 1) bajo la suposición original. Finalmente, los mecanismos aleatorios ofrecen un área inexplorada para trabajos futuros. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en el reparto de costos de multicast, Juegos y Comportamiento Económico (por aparecer). [2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de mecanismos de verdad en línea a optimización en línea, Actas del 35º Simposio sobre Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Revista de Sistemas en Tiempo Real 4 (1992), núm. 2, 125-144. [5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para compensación de mercado, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para gestión de recursos y programación en la computación en malla, La Revista de Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan y O. Regev, El proyecto popcorn: Computación distribuida en internet en Java, 6ª Conferencia Internacional World Wide Web, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y direcciones futuras, Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Fijación de precios de wifi en Starbucks: Problemas en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Límites para ciertas anomalías multiprocesador, Revista Técnica del Sistema Bell 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, La velocidad es tan poderosa como la clarividencia, Revista de la ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan y K. To, Programación en línea con plazos ajustados, Ciencia de la Computación Teórica 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo de programación en línea óptimo para sistemas en tiempo real sobrecargados, Revista SIAM de Computación 24 (1995), núm. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Verde, Teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño algorítmico de mecanismos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e internet, STOC, 2001, pp. 749-753. 70 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "monotonicity": {
            "translated_key": "monotonicidad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying <br>monotonicity</br>, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "Again applying <br>monotonicity</br>, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf ."
            ],
            "translated_annotated_samples": [
                "Nuevamente aplicando la <br>monotonicidad</br>, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un horario de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, utilizaremos la función ei(t) = t 0 µ(S(x) = i)dx, donde µ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero en caso contrario. La holgura de un trabajo en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún completarse antes de su fecha límite. Un trabajo se abandona si no puede completarse para su fecha límite (formalmente, si di −t+ei(t) < li). Además, sobrecargue S(·) y ei(·) para que también puedan recibir un vector θ como argumento. Por ejemplo, S(θ, t) es una abreviatura de S(t) del resultado f(θ), y denota el trabajo activo en el tiempo t cuando la entrada es θ. Dado que un trabajo no puede ejecutarse antes de su tiempo de liberación, el espacio de resultados posibles está restringido de tal manera que S(θ, t) = i implica que ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario con el tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el tiempo t para entradas que son indistinguibles en ese momento. Formalmente, sea θ(t) el subconjunto de las tuplas en θ que satisfacen ri ≤ t. La restricción es entonces que θ(t) = θ(t) implica que S(θ, t) = S(θ, t). La función objetivo es la suma de los valores de los trabajos que se completan antes de sus respectivos plazos: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Sea W∗ (θ) = maxo∈O W(o, θ) el valor total máximo posible para el perfil θ. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo óptimo fuera de línea. Debido a que el algoritmo sin conexión conoce la entrada completa θ en el tiempo 0 (pero aún no puede comenzar cada trabajo i hasta el tiempo ri), siempre logra W∗ (θ). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada θ tal que c · W(f(θ), θ) < W∗ (θ). Un algoritmo que es c-competitivo también se dice que logra una proporción competitiva de c. Suponemos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf] está sobrecargado si la suma de las duraciones de los trabajos cuyos tiempos de inicio y finalización caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf - ts ≤ Σ|(ts≤ri,di≤tf) li). Sin tal suposición, no es posible lograr una razón competitiva finita [15]. 2.2 Resultados Previos En el entorno no estratégico, [4] presenta un algoritmo 4-competitivo llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo (1+ √ k)2-competitivo llamado Dover para el caso general de k ≥ 1. Se demostraron cotas inferiores coincidentes para algoritmos deterministas en ambos casos en [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) utilizando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de estar inactivo a ocupado (llamemos a este momento tb), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener holgura; sin embargo, para el resto del intervalo, la prelación del trabajo activo solo se considera cuando algún otro trabajo tiene una holgura de cero. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 en el rango [0.0, 0.9]. No se considera la prelación durante este intervalo, ya que el trabajo 2 tiene holgura hasta el tiempo 1.5. Entonces, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se vuelve activo. Antes de que el trabajo 2 pueda terminar, se considera la prelación en el tiempo 4.8, cuando se libera el trabajo 3 con una holgura de cero. Para decidir si se debe anticipar el trabajo activo, TD1 (versión 2) utiliza dos variables adicionales: te y pérdida de p. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta hasta su finalización (o, si no existe tal trabajo, el momento en que el trabajo activo finalizará si no es interrumpido). En este caso, te = 17.0. El valor te − tb representa un límite superior en la cantidad de tiempo de ejecución posible perdido por el algoritmo óptimo fuera de línea debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la duración del primer trabajo activo del intervalo actual. Debido a que en general este trabajo podría tener laxitud, el algoritmo fuera de línea podría ser capaz de completarlo fuera del rango [tb, te]. Si el algoritmo completa el trabajo activo y la longitud de este trabajo es al menos te - tb + p pérdida 4, entonces se garantiza que el algoritmo es 4-competitivo para este intervalo (nota que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto que las longitudes pueden usarse para calcular la proporción competitiva). Dado que esto no es el caso en el tiempo 4.8 (ya que te −tb +p pérdida 4 = 17.0−0.9+4.0 4 > 4.0 = l2), el algoritmo interrumpe el trabajo 2 para el trabajo 3, que luego se ejecuta hasta su finalización. Trabajo ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Tabla 1: Entrada utilizada para resumir TD1 (versión 2) [4]. Las flechas hacia arriba y hacia abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 haría que TD1 (versión 2) completara este trabajo. Por ejemplo, si la fecha límite del trabajo 2 se declarara como ˆd2 = 4.7, entonces tendría una holgura de cero en el tiempo 0.7. En este momento, el algoritmo prevería el trabajo 1 por el trabajo 2, porque te −tb +p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. El trabajo 2 se completaría antes de la llegada del trabajo 3. Aunque sería fácil modificar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de la pérdida p. No describiremos el In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem, que es significativamente más complejo. Para abordar problemas de incentivos como este, necesitamos formalizar el escenario como un problema de diseño de mecanismos. En esta sección primero presentamos la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro que controla el procesador y N agentes, donde el valor de N es desconocido por el centro de antemano. Cada trabajo i es propiedad de un agente i separado. Las características del trabajo definen el tipo de agente θi ∈ Θi. En el tiempo ri, el agente i observa de forma privada su tipo θi y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos siguen siendo liberados con el tiempo, pero ahora cada trabajo solo se revela al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo Γ = (Θ1, . . . , ΘN , g(·)), en el cual cada agente declara un trabajo, denotado por ˆθi = (ˆri, ˆdi, ˆli, ˆvi), y g : Θ1×. . .×ΘN → O mapea los tipos declarados a un resultado o ∈ O. Un resultado o = (S(·), p1, . . . , pN) consiste en un horario y un pago de cada agente al mecanismo. En un entorno estándar de diseño de mecanismos, el resultado se hace cumplir al final del mecanismo. Sin embargo, dado que el final no está bien definido en este entorno en línea, optamos por modelar la devolución del trabajo una vez completado y la recolección de un pago de cada agente i como ocurriendo en ˆdi, que, según la declaración de los agentes, es el punto de tiempo más relevante para ese agente. Es decir, incluso si el trabajo i se completa antes de ˆdi, el centro no devuelve el trabajo al agente i hasta ese momento. Esta decisión de modelado podría ser vista en cambio como una decisión del diseñador del mecanismo dentro de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. La utilidad de cada agente, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), es una función cuasi-lineal de su valor por su trabajo (si se completa y se devuelve antes de la fecha límite real) y el pago que realiza al centro. Suponemos que cada agente es un maximizador racional de utilidad esperada. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud más corta que la longitud real, ya que el centro sería capaz de detectar tal mentira si se completara el trabajo. Por otro lado, en la formulación general permitiremos a los agentes declarar longitudes más largas, ya que en algunos contextos puede ser posible agregar trabajo innecesario a una tarea. Sin embargo, también consideraremos una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ˆri es el momento que el agente elige para enviar el trabajo i al centro, y no puede ser anterior al tiempo ri en el que el trabajo es revelado al agente. El agente puede declarar un plazo o valor arbitrario. En resumen, el agente i puede declarar cualquier tipo ˆθi = (ˆri, ˆdi, ˆli, ˆvi) tal que ˆli ≥ li y ˆri ≥ ri. Mientras que en el entorno no estratégico era suficiente que el algoritmo conociera el límite superior k en la proporción ρmax ρmin, en el entorno de diseño de mecanismos fortaleceremos esta suposición para que el mecanismo también conozca ρmin (o, de manera equivalente, el rango [ρmin, ρmax] de densidades de valor posibles). En Dover, observamos que es similar en su uso de intervalos y su preferencia por el trabajo activo. Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Nota que podríamos entonces obligar a las declaraciones de los agentes a cumplir con ρmin ≤ ˆvi ˆli ≤ ρmax. Sin embargo, esta restricción no 63 Aunque consideramos poco probable que un centro conozca k sin conocer este rango, más adelante presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario ahora es que S(ˆθ, t) = i implica que ˆri ≤ t, para capturar el hecho de que un trabajo no puede ser programado en el procesador antes de que sea declarado al mecanismo. Como antes, se permite la anticipación de trabajos y cambiar de trabajo no lleva tiempo. Las limitaciones debidas a la falta de conocimiento del futuro de los mecanismos en línea son que ˆθ(t) = ˆθ (t) implica S(ˆθ, t) = S(ˆθ , t), y ˆθ( ˆdi) = ˆθ ( ˆdi) implica pi(ˆθ) = pi(ˆθ ) para cada agente i. El escenario puede resumirse de la siguiente manera. 1. Resumen del Escenario: para todo t, el centro instancia S(ˆθ, t) ← i, para algún i tal que ˆri ≤ t si ∃i, (ri = t) entonces θi se revela al agente i si ∃i, (t ≥ ri) y el agente i no ha declarado un trabajo entonces el Agente i puede declarar cualquier trabajo ˆθi, tal que ˆri = t y ˆli ≥ li si ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) entonces el trabajo completado i se devuelve al agente i si ∃i, ( ˆdi = t) entonces el Centro establece y recoge el pago pi(ˆθ) del agente i 3.2 Objetivos del Mecanismo Nuestro objetivo como diseñadores de mecanismos es maximizar el valor de los trabajos completados, sujeto a las restricciones de compatibilidad de incentivos y racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo Γ satisface la compatibilidad de incentivos (IC) si ∀i, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi). Desde la perspectiva de un agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes ni sobre la distribución de la cual se extraen los tipos de los otros agentes. Desde la perspectiva de un diseñador de mecanismos, las estrategias dominantes son importantes porque podemos asumir razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, en lugar de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos, disminuir el límite inferior en la relación competitiva. Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que la mentira de un agente podría mejorar realmente el horario. De hecho, este fue el caso en el ejemplo que mostramos para la falsa declaración ˆd2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca se hubiera liberado, entonces el trabajo 1 se habría abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos ofrecer una garantía competitiva para nuestro mecanismo. Si bien restringirnos a mecanismos directos compatibles con incentivos puede parecer limitante al principio, el Principio de Revelación para Estrategias Dominantes (ver, por ejemplo, [17]) nos dice que si nuestro objetivo es la implementación de estrategias dominantes, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la racionalidad individual, requiere que los agentes que revelen sinceramente su tipo nunca tengan utilidad negativa. La razón detrás de este objetivo es que se asume que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo Γ satisface la racionalidad individual (RI) si ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finalmente, la función de bienestar social que buscamos maximizar es la misma que la función objetivo del escenario no estratégico: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivo para compararlo con un mecanismo óptimo fuera de línea (que denotaremos como Γoffline). Un mecanismo sin conexión conoce todos los tipos en el tiempo 0, y por lo tanto siempre puede lograr W∗ (θ).5 Definición 3. Un mecanismo en línea Γ es (estrictamente) c-competitivo si cumple con IC e IR, y si no existe un perfil de tipos de agentes θ tal que c·W(g(θ), θ) < W∗ (θ). 4. RESULTADOS En esta sección, primero presentamos nuestro principal resultado positivo: un mecanismo competitivo de (1+ √ k)2 +1 (Γ1). Después de proporcionar cierta intuición sobre por qué Γ1 cumple con la racionalidad individual y la compatibilidad de incentivos, demostramos formalmente primero estas dos propiedades y luego la razón competitiva. Luego consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de ρmin ni la recolección de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, Γ1 no da preferencia al trabajo activo. En cambio, siempre ejecuta el trabajo disponible con la mayor prioridad: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Cada agente cuyo trabajo se haya completado es entonces cobrado el valor más bajo que podría haber declarado para que su trabajo aún se hubiera completado, manteniendo constante el resto de su declaración. Mediante el uso de una regla de pago similar a la de una subasta de segundo precio, Γ1 satisface tanto la CI con respecto a los valores como la IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar una mejora en el trabajo (es decir, declarar un horario de entrega más temprano, una duración más corta o una fecha límite más tardía) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera haría que el trabajo, si se completa, sea devuelto al agente después de la fecha límite real. Esta es la razón por la cual es importante siempre devolver un trabajo completado en su fecha límite declarada, en lugar de en el momento en que se completa. Otra posibilidad es permitir que solo los agentes conozcan sus tipos en el tiempo 0, y obligar a Γoffline a ser compatible con incentivos para que los agentes declaren honestamente sus tipos en el tiempo 0. Sin embargo, esto no afectaría nuestros resultados, ya que ejecutar un mecanismo VCG (ver, por ejemplo, [17]) en el tiempo 0 satisface tanto la compatibilidad de incentivos como maximiza siempre el bienestar social. Mecanismo 1 Γ1 Ejecutar S(ˆθ, ·) de acuerdo con el Algoritmo 1 para todos los i si ei(ˆθ, ˆdi) ≥ ˆli {El agente ha completado su trabajo} entonces pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) de lo contrario pi(ˆθ) ← 0 Algoritmo 1 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Conjunto de todos los trabajos liberados, no completados, no abandonados} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Queda por argumentar por qué un agente no tiene incentivo para empeorar su trabajo. Los únicos efectos posibles de una duración inflada son retrasar la finalización del trabajo y hacer que sea abandonado, y los únicos efectos posibles de una fecha límite declarada anteriormente son hacer que sea abandonado y hacer que sea devuelto antes (lo cual no tiene efecto en la utilidad de los agentes en nuestro entorno). Por otro lado, es menos obvio por qué los agentes no tienen incentivos para declarar una hora de lanzamiento posterior. Considera un mecanismo Γ1 que difiere de Γ1 en que no interrumpe el trabajo activo i a menos que exista otro trabajo j tal que (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Ten en cuenta que a medida que un trabajo activo se acerca a su finalización en Γ1, su condición de prelación se acerca a la de Γ1. Sin embargo, los tipos en la Tabla 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su trabajo bajo Γ1. La tarea 1 se activa en el tiempo 0, y la tarea 2 se abandona al ser liberada en el tiempo 6, porque 10 + 10 = v1 + l1 > v2 = 13. Entonces, en el tiempo 8, el trabajo 1 es interrumpido por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 se ejecuta hasta completarse, obligando a abandonar el trabajo 1. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1 y habría evitado que el trabajo 3 se ejecutara si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente ˆr1 = 20, entonces el trabajo 3 habría sido abandonado en el tiempo 8, y el trabajo 1 se habría completado en el rango [20, 30]. Trabajo con los valores 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Tabla 2: Trabajos utilizados para demostrar por qué una versión ligeramente alterada de Γ1 no sería compatible con los incentivos con respecto a los tiempos de liberación. Intuitivamente, Γ1 evita este problema debido a dos propiedades. Primero, cuando un trabajo se vuelve activo, debe tener una prioridad mayor que todos los demás trabajos disponibles. Segundo, dado que la prioridad de un trabajo solo puede aumentar a través del aumento de su tiempo transcurrido, ei(ˆθ, t), la tasa de aumento de la prioridad de un trabajo es independiente de sus características. Estas dos propiedades juntas implican que, mientras un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado al ejecutarse en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad de Incentivos Después de presentar la prueba (trivial) de RI, dividimos la prueba de CI en lemas. Teorema 1. El mecanismo Γ1 cumple con la racionalidad individual. Prueba. Para i arbitrario, θi, ˆθ−i, si el trabajo i no se completa, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(θi, ˆθ−i) = 0 y ui(g(θi, ˆθ−i), θi) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el pago del agente. Formalmente, ui(g(θi, ˆθ−i), θi) = vi - arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 debe cumplirse, ya que vi = vi satisface la condición. Para demostrar IC, necesitamos mostrar que para un agente arbitrario i, y un perfil arbitrario ˆθ−i de declaraciones de los otros agentes, el agente i nunca puede beneficiarse al hacer una declaración falsa ˆθi = θi, sujeto a las restricciones de que ˆri ≥ ri y ˆli ≥ li. Comenzamos mostrando que, independientemente de ˆvi, si las declaraciones veraces de ri, di y li no hacen que el trabajo i se complete, entonces declaraciones peores de estas variables (es decir, declaraciones que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di) nunca pueden hacer que el trabajo se complete. Dividimos esta parte de la prueba en dos lemas, primero demostrando que se cumple para el tiempo de liberación, independientemente de las declaraciones de las otras variables, y luego para la longitud y la fecha límite. Lema 2. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Prueba. Supongamos por contradicción que esta condición no se cumple, es decir, el trabajo i no se completa cuando ri se declara sinceramente, pero se completa para alguna declaración falsa ˆri ≥ ri. Primero analizamos el caso en el que el tiempo de liberación se declara honestamente, y luego demostramos que el trabajo i no puede completarse cuando el agente i retrasa su presentación en el centro. Caso I: El agente i declara ˆθi = (ri, ˆdi, ˆli, ˆvi). Primero, define los siguientes tres puntos en la ejecución del trabajo i. • Sea ts = arg mint S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i comienza su ejecución por primera vez. • Sea tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i el momento en que el trabajo i es interrumpido por primera vez. • Sea ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli el momento en que el trabajo i es abandonado. Si ts y tp no están definidos porque el trabajo i nunca se vuelve activo, entonces ts = tp = ta. Además, particione los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j|(ˆrj < tp ) ∧ (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i sea interrumpido por primera vez. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen mayor prioridad que el trabajo i (tenga en cuenta que estamos utilizando la normalización). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consiste en los trabajos que llegan en el rango [tp , ta ] y que, al llegar, tienen menor prioridad que el trabajo i. Ahora demostramos que todos los trabajos activos durante el rango (tp, ta] deben ser o bien i o estar en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad se cumple trivialmente), debe ser el caso que el trabajo i tenga una prioridad más alta que un trabajo arbitrario x ∈ X en el tiempo tp, ya que en el momento justo anterior a tp el trabajo x estaba disponible y el trabajo i estaba activo. Formalmente, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) debe cumplirse. Luego podemos demostrar que, en el rango [tp, ta], ningún trabajo x ∈ X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Sea tf ∈ [tp , ta ] el tiempo más temprano en este rango en el que algún trabajo x ∈ X está activo, lo que implica que ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). Entonces podemos demostrar que el trabajo i tiene una prioridad más alta en el tiempo tf de la siguiente manera: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradiciendo el hecho de que el trabajo x está activo en el tiempo tf. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz > tp, ya que por definición el trabajo i tiene una prioridad más alta en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta] son i y aquellos en el conjunto Y. Caso II: El agente i declara ˆθi = (ˆri, ˆdi, ˆli, ˆvi), donde ˆri > ri. Ahora demostramos que el trabajo i no puede completarse en este caso, dado que no se completó en el caso I. Primero, podemos restringir el rango de ˆri que necesitamos considerar de la siguiente manera. Declarar ˆri ∈ (ri, ts ] no afectaría el horario, ya que ts seguiría siendo el primer momento en que el trabajo i se ejecuta. Además, declarar ˆri > ta no podría hacer que el trabajo se complete, ya que di − ta < ˆli se cumple, lo que implica que el trabajo i sería abandonado en su lanzamiento. Por lo tanto, podemos restringir la consideración a ˆri ∈ (ts , ta ]. Para que la declaración de ˆθi provoque que el trabajo i se complete, una condición necesaria es que la ejecución de algún trabajo yc ∈ Y debe cambiar durante el rango (tp, ta], ya que los únicos trabajos además de i que están activos durante ese rango están en Y. Que tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] sea el primer momento en que ocurre un cambio de este tipo. Ahora demostraremos que para cualquier ˆri ∈ (ts , ta], no puede existir un trabajo con una prioridad más alta que yc en el tiempo tc, contradiciendo (S((ˆθi, ˆθ−i), t) = yc). Primero, hay que tener en cuenta que el trabajo i no puede tener una prioridad más alta, ya que tendría que existir un t ∈ (tp, tc) tal que ∃y ∈ 6 Para simplificar, cuando damos la condición formal para que un trabajo x tenga una prioridad más alta que otro trabajo y, asumiremos que la prioridad del trabajo x es estrictamente mayor que la del trabajo y, porque, en caso de un empate que favorezca a x, los empates futuros también se resolverían a favor del trabajo x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradiciendo la definición de tc. Ahora considera un y arbitrario ∈ Y tal que y = yc. En caso de que, sabemos que el trabajo y tiene una prioridad más baja que yc en el tiempo tc; es decir, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Por lo tanto, al pasar al caso II, el trabajo y debe reemplazar algún otro trabajo antes de tc. Dado que ˆry ≥ tp , la condición es que debe existir algún t ∈ (tp , tc ) tal que ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Dado que w ∈ Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que y reemplaza debe ser i. Por definición del conjunto Y, sabemos que ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Por lo tanto, si ˆry ≤ t, entonces el trabajo i no podría haberse ejecutado en lugar de y en el caso I. Por otro lado, si ˆry > t, entonces el trabajo y obviamente no podría ejecutarse en el tiempo t, contradiciendo la existencia de dicho tiempo t. Ahora considera un trabajo arbitrario x ∈ X. Sabemos que en caso de que el trabajo i tenga una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). También sabemos que ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Dado que retrasar su llegada no afectará la ejecución hasta el tiempo ts, y dado que el trabajo x no puede ejecutarse en lugar de un trabajo y ∈ Y en ningún momento t ∈ (tp, tc] por definición de tc, la única forma de que la prioridad del trabajo x aumente antes de tc a medida que pasamos del caso I al caso II es reemplazar el trabajo i en el rango (ts, tc]. Por lo tanto, un límite superior en la prioridad del trabajo xs cuando el agente i declara ˆθi es: ˆvx + √ k · ex((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts) + ei((ˆθi, ˆθ−i), tc) − ei((ˆθi, ˆθ−i), ts) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc) < ˆvyc + √ k · eyc((ˆθi, ˆθ−i), tc). Por lo tanto, incluso en este límite superior, el trabajo yc se ejecutaría en lugar del trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z ∈ Z, comenzando en su tiempo de liberación ˆrz. Dado que los conjuntos {i}, X, Y, Z particionan el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutarse en lugar del trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lema 3. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Prueba. Supongamos por contradicción que existe alguna instancia de las variables anteriores tal que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algún par de declaraciones falsas ˆli ≥ li y ˆdi ≤ di. Ten en cuenta que el único efecto que ˆdi y ˆli tienen en la ejecución del algoritmo es si i ∈ Avail o no. Específicamente, afectan las dos condiciones: (ei(ˆθ, t) < ˆli) y (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Dado que el trabajo i se completa cuando ˆli y ˆdi son declarados, la condición anterior (para la finalización) debe volverse falsa antes que la última. Dado que declarar sinceramente que li ≤ ˆli y di ≥ ˆdi solo hará que la primera condición se vuelva falsa antes y la segunda condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones sinceras, y el trabajo i se completará, lo que es una contradicción. Ahora usamos estos dos lemas para demostrar que el pago por un trabajo completado solo puede aumentar al declarar falsamente peores ˆli, ˆdi y ˆri. Lema 4. En el mecanismo Γ1, se cumple la siguiente condición para todos los i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li. Demostración. Supongamos por contradicción que esta condición no se cumple. Esto implica que existe algún valor vi tal que la condición (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) se cumple, pero (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) no lo hace. Aplicando los lemas 2 y 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), una contradicción. Finalmente, el siguiente lema nos dice que la finalización de un trabajo es monótona en su valor declarado. Lema 5. En el mecanismo Γ1, la siguiente condición se cumple para todos los i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli La prueba, por contradicción, de este lema se omite porque es esencialmente idéntica a la de Lema 2 para ˆri. En el caso I, el agente i declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo no se completa, mientras que en el caso II declara (ˆri, ˆdi, ˆli, ˆvi) y el trabajo se completa. El análisis de los dos casos procede entonces como antes: la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial del trabajo i disminuye a medida que nos movemos del caso I al II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i en el rango (tp, ta]. Ahora podemos combinar los lemas para demostrar que no es posible ninguna desviación rentable. Teorema 6. El mecanismo Γ1 cumple con la compatibilidad de incentivos. Prueba. Para un agente arbitrario i, sabemos que ˆri ≥ ri y ˆli ≥ li se cumplen por suposición. También sabemos que el agente i no tiene incentivo para declarar ˆdi > di, porque el trabajo i nunca sería devuelto antes de su verdadera fecha límite. Entonces, dado que la función de pago es no negativa, la utilidad del agente no podría exceder cero. Por IR, esta es la utilidad mínima que lograría si declarara sinceramente θi. Por lo tanto, podemos restringir la consideración a ˆθi que satisfacen ˆri ≥ ri, ˆli ≥ li y ˆdi ≤ di. Nuevamente utilizando IR, podemos restringir aún más la consideración a ˆθi que hacen que el trabajo i se complete, ya que cualquier otro ˆθi produce una utilidad de cero. Si la declaración veraz de θi hace que el trabajo i se complete, entonces según el Lema 4, cualquier declaración falsa ˆθi no podría disminuir el pago del agente i. Por otro lado, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal ˆθi hará que el agente i tenga una utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli se cumple según los Lemas 5 y 4, respectivamente. 4.2 Prueba de la Razón Competitiva La prueba de la razón competitiva, que hace uso de técnicas adaptadas de las utilizadas en [15], también se divide en lemas. Habiendo demostrado IC, podemos asumir una declaración veraz (ˆθ = θ). Dado que también hemos demostrado IR, para probar la relación competitiva, queda limitar la pérdida del bienestar social frente a Γoffline. Denote por (1, 2, . . . , F) la secuencia de trabajos completados por Γ1. Divide el tiempo en intervalos If = (topen f , tclose f ], uno para cada trabajo f en esta secuencia. Establezca tclose f como el tiempo en el que el trabajo f se completa, y establezca topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, dejemos que t comience siendo el primer momento en que el procesador no esté inactivo en el intervalo If. Lema 7. Para cualquier intervalo If, la siguiente desigualdad se cumple: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Prueba. El intervalo If comienza con un período de tiempo (posiblemente de longitud cero) en el que el procesador está inactivo porque no hay ningún trabajo disponible. Entonces, ejecuta continuamente una secuencia de trabajos (1, 2, . . . , c), donde cada trabajo i en esta secuencia es interrumpido por el trabajo i + 1, excepto por el trabajo c, que se completa (por lo tanto, el trabajo c en esta secuencia es el mismo que el trabajo f en la secuencia global de trabajos completados). Que ts i sea el tiempo en que el trabajo i comienza su ejecución. Ten en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f , tclose f], la prioridad (vi+ √ k·ei(θ, t)) del trabajo activo aumenta de forma monótona con el tiempo, ya que esta función aumenta linealmente mientras un trabajo está activo, y solo puede aumentar en un punto en el tiempo cuando ocurre la prelación. Por lo tanto, cada trabajo i > 1 en esta secuencia comienza su ejecución en su tiempo de liberación (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c supera el producto de √ k y el tiempo dedicado en el intervalo a los trabajos 1 a través de c−1, o, de manera más formal, que se cumple la siguiente condición: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un i arbitrario con 1 ≤ i < c, asumimos que vi ≥ √ k i−1 h=1 eh(θ, ts h+1) se cumple. En el tiempo ts i+1, sabemos que vi+1 ≥ vi + √ k · ei(θ, ts i+1) se cumple, porque ts i+1 = ri+1. Estas dos desigualdades juntas implican que vi+1 ≥√ k i h=1 eh(θ, ts h+1), completando el paso inductivo. También sabemos que debe cumplirse tclose f − ts c ≤ lc ≤ vc, debido a la normalización simplificada de ρmin = 1 y al hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Por lo tanto, podemos limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf. Ahora consideramos la posible ejecución de trabajos incompletos por parte de Γoffline. Asocie cada trabajo i que no esté completado por Γ1 con el intervalo durante el cual fue abandonado. Todos los trabajos están ahora asociados con un intervalo, ya que no hay brechas entre los intervalos, y dado que ningún trabajo i puede ser abandonado después del cierre del último intervalo en tclose F. Dado que el procesador está inactivo después de tclose F , cualquier trabajo i de este tipo se activaría en algún momento t ≥ tclose F , lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. El siguiente lema es equivalente al Lema 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lema 8. Para cualquier intervalo If y cualquier trabajo i abandonado en If, se cumple la siguiente desigualdad: vi ≤ (1 + √ k)vf. Prueba. Supongamos por contradicción que existe un trabajo i abandonado en If tal que vi > (1 + √ k)vf. En el momento de cierre t, la prioridad del trabajo f es vf + √ k · lf < (1 + √ k)vf. Debido a que la prioridad del trabajo activo aumenta monótonamente en el rango [tbegin f , tclose f ], el trabajo i tendría una prioridad más alta que el trabajo activo (y por lo tanto comenzaría la ejecución) en algún momento t ∈ [tbegin f , tclose f ]. Nuevamente aplicando la <br>monotonicidad</br>, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + √ k)vf, contradiciendo el hecho de que sea (1 + √ k)vf. Como en [15], para cada intervalo If, damos a Γoffline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido a que Γ1 ignora los plazos. El siguiente lema es el Lema 5.10 en [15], y su demostración ahora se aplica directamente. Lema 9. [15] Con los regalos anteriores, la ganancia neta total obtenida por el algoritmo clarividente al programar los trabajos abandonados durante If no es mayor que (1 + √ k) · vf. La intuición detrás de este lema es que lo mejor que puede hacer el adversario es tomar casi todo el regalo de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a ejecutar trabajos con la máxima densidad de valor posible durante el tiempo que Γ1 está activo), y luego comenzar la ejecución de un trabajo abandonado por Γ1 justo antes de tclose f. Según el Lema 8, el valor de este trabajo está acotado por (1 + √ k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la razón competitiva. Teorema 10. El mecanismo Γ1 es (1+ √ k)2+1-competitivo. Prueba. Usando el hecho de que la forma en que los trabajos están asociados con los intervalos divide el conjunto completo de trabajos, podemos mostrar la razón competitiva al demostrar que Γ1 es competitivo con (1+ √ k)2 +1 para cada intervalo en la secuencia (1, . . . , F). Sobre un intervalo arbitrario Si, el algoritmo sin conexión puede lograr como máximo (tclose f − tbegin f)·k + vf + (1 + √ k)vf, a partir de los dos regalos y la ganancia neta limitada por el Lema 9. Aplicando el Lema 7, esta cantidad está entonces acotada por arriba por (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf. Dado que Γ1 logra vf, se cumple la proporción competitiva. 4.3 Caso especial: Longitud invariable y k=1 Hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, pero mentir sobre la longitud del trabajo no es posible en algunos contextos. Por ejemplo, un usuario puede no saber cómo modificar un problema computacional de manera que alargue la tarea y permita extraer la solución del problema original a partir de la solución al problema modificado. Otra restricción que es natural en algunos contextos es la densidad de valores uniforme (k = 1), que fue el caso considerado por [4]. Si el escenario satisface estas dos condiciones, entonces, mediante el uso del Mecanismo Γ2, podemos lograr una proporción competitiva de 5 (que es la misma proporción competitiva que Γ1 para el caso de k = 1) sin conocimiento de ρmin y sin el uso de pagos. La última propiedad puede ser necesaria en entornos más locales que la computación en red (por ejemplo, dentro de un departamento) pero en los que los usuarios siguen siendo egoístas. Mecanismo 2 Γ2 Ejecutar S(ˆθ, ·) según el Algoritmo 2 para todos los i hacer pi(ˆθ) ← 0 Algoritmo 2 para todos los t hacer Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} si Avail = ∅ entonces S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Desempatar a favor de menor ˆri} de lo contrario S(ˆθ, t) ← 0 Teorema 11. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 satisface la racionalidad individual y la compatibilidad de incentivos. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, el Mecanismo Γ2 es 5-competitivo. Dado que este mecanismo es esencialmente una simplificación de Γ1, omitimos las demostraciones de estos teoremas. Básicamente, el hecho de que k = 1 y ˆli = li se cumplan permite a Γ2 sustituir la prioridad (li +ei(ˆθ, t)) por la prioridad utilizada en Γ1; y, dado que ˆvi es ignorado, ya no se necesitan pagos para garantizar la compatibilidad de incentivos. 5. LÍMITE INFERIOR COMPETITIVO Ahora demostramos que la razón competitiva de (1 + √ k)2 + 1 lograda por Γ1 es un límite inferior para los mecanismos en línea deterministas. Para hacerlo, apelaremos al tercer requisito en un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca pague a un agente (formalmente, ∀i, ˆθ, pi(ˆθi) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Sin embargo, observamos que tanto Γ1 como Γ2 la satisfacen trivialmente, y que, en la siguiente prueba, el cero solo sirve como utilidad base para un agente, y podría ser reemplazado por cualquier función no positiva de ˆθ−i. La prueba del límite inferior utiliza un argumento del adversario similar al utilizado en [4] para mostrar un límite inferior de (1 +√ k)2 en el escenario no estratégico, siendo la principal novedad la perturbación de la secuencia de trabajos y los argumentos de compatibilidad de incentivos relacionados. Primero presentamos un lema relacionado con la recurrencia utilizada para este argumento, con la prueba omitida debido a limitaciones de espacio. Lema 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 = λ · li − k · i h=1 lh y l1 = 1, donde (1 + √ k)2 − 1 < λ < (1 + √ k)2, existe un entero m ≥ 1 tal que lm+k· m−1 h=1 lh lm > λ. Aunque los pagos no son necesarios en este escenario, Γ2 se puede modificar para recolectar pagos sin afectar la compatibilidad de incentivos al cobrar una fracción fija de li por cada trabajo i que se complete. Teorema 14. No existe un mecanismo en línea determinista que cumpla con NNP y que logre una relación competitiva menor que (1 + √ k)2 + 1. Prueba. Supongamos por contradicción que existe un mecanismo en línea determinista Γ que satisface NNP y logra una relación competitiva de c = (1 + √ k)2 + 1 − para algún > 0 (y, por implicación, también satisface IC e IR). Dado que un ratio competitivo de c implica un ratio competitivo de c + x, para cualquier x > 0, asumimos sin pérdida de generalidad que < 1. Primero, construiremos un perfil de tipos de agentes θ utilizando un argumento adversario. Después de posiblemente perturbar ligeramente θ para asegurar que se cumple una propiedad de rigurosidad, luego utilizaremos una perturbación más significativa de θ para llegar a una contradicción. Ahora construimos el perfil original θ. Elige un α tal que 0 < α < , y define δ = α ck+3k. El adversario utiliza dos secuencias de trabajos: menores y mayores. Los trabajos menores se caracterizan por li = δ, vi = k · δ y laxitud cero. El primer trabajo menor se libera en el tiempo 0, y ri = di−1 para todo i > 1. La secuencia se detiene cada vez que Γ completa algún trabajo. Los trabajos principales también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, están determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 Los límites en α implican que (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2, lo que nos permite aplicar el Lema 13. Sea m el número positivo más pequeño tal que lm+k· m−1 h=1 lh lm > c−1+α. El primer trabajo principal tiene un tiempo de liberación de 0, y cada trabajo principal i > 1 tiene un tiempo de liberación de ri = di−1 − δ, justo antes de la fecha límite del trabajo anterior. El adversario libera un trabajo importante i ≤ m si y solo si cada trabajo importante j < i fue ejecutado de manera continua en el rango [ri, ri+1]. No se libera ningún trabajo importante después del trabajo m. Para lograr la relación competitiva deseada, Γ debe completar algún trabajo importante f, ya que Γoffline siempre puede completar al menos el trabajo importante 1 (por un valor de 1), y Γ puede completar como máximo un trabajo menor (por un valor de α c+3 < 1 c). Además, para que este trabajo f se libere, el tiempo del procesador anterior a rf solo puede ser utilizado para ejecutar trabajos importantes que luego son abandonados. Si f < m, entonces el trabajo principal f + 1 será lanzado y será el trabajo principal final. Γ no puede completar el trabajo f +1, porque rf + lf = df > rf+1. Por lo tanto, θ consiste en trabajos principales del 1 al f + 1 (o f, si f = m), más trabajos menores desde el tiempo 0 hasta el tiempo df. Ahora posiblemente perturbamos ligeramente θ. Por IR, sabemos que vf ≥ pf (θ). Dado que más adelante necesitaremos que esta desigualdad sea estricta, si vf = pf (θ), entonces cambie θf a θf, donde rf = rf, pero vf, lf y df se incrementan todos en δ sobre sus valores respectivos en θf. Por IC, el trabajo f aún debe ser completado por Γ para el perfil (θf, θ−f). Si no, entonces por IR y NNP sabemos que pf (θf , θ−f ) = 0, y por lo tanto que uf (g(θf , θ−f ), θf ) = 0. Sin embargo, el agente f podría aumentar su utilidad declarando falsamente el tipo original de θf, recibiendo una utilidad de: uf (g(θf, θ−f), θf) = vf - pf(θ) = δ > 0, violando la CI. Además, el agente f debe ser cobrado la misma cantidad (es decir, pf (θf , θ−f ) = pf (θ)), debido a un argumento de compatibilidad de incentivos similar. Por lo tanto, para el resto de la demostración, asumir que vf > pf (θ). Ahora utilizamos una perturbación más sustancial de θ para completar la prueba. Si f < m, entonces define θf como idéntico a θf, excepto que df = df+1 + lf, permitiendo que el trabajo f se complete por completo después de que el trabajo f + 1 se haya completado. Si f = m, entonces en lugar de eso establece df = df + lf. IC requiere que para el perfil (θf, θ−f), Γ siga ejecutando el trabajo f de forma continua en el rango [rf, rf + lf], evitando así que el trabajo f +1 se complete. Supongamos por contradicción que esto no fuera cierto. Entonces, en la fecha límite original de df, el trabajo f no está completado. Considera el posible perfil (θf, θ−f, θx), que difiere del nuevo perfil solo en la adición de un trabajo x que tiene laxitud cero, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Dado que este nuevo perfil es indistinguible de (θf, θ−f) para Γ antes del tiempo df, debe programar trabajos de la misma manera hasta df. Entonces, para lograr la proporción competitiva deseada, debe ejecutar el trabajo x de forma continua hasta su fecha límite, que por construcción es al menos tan tardía como la nueva fecha límite df del trabajo f. Por lo tanto, el trabajo f no se completará y, según IR y NNP, debe ser el caso que pf (θf , θ−f , θx) = 0 y uf (g(θf , θ−f , θx), θf ) = 0. Usando el hecho de que θ es indistinguible de (θf, θ−f, θx) hasta el tiempo df, si el agente f declarara falsamente su tipo como el original θf, entonces su trabajo se completaría en df y se le cobraría pf(θ). Su utilidad aumentaría a uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradiciendo la CI. Si bien la ejecución de Γ debe ser idéntica para ambos (θf, θ−f) y (θf, θ−f), Γoffline puede aprovechar el cambio. Si f < m, entonces Γ alcanza un valor de como máximo lf + δ (el valor del trabajo f si fuera perturbado), mientras que Γoffline alcanza un valor de al menos k·( f h=1 lh −2δ)+lf+1 +lf al ejecutar trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (restamos dos δ en lugar de uno porque el último trabajo menor antes de rf+1 puede tener que ser abandonado). Sustituyendo en lf+1, la proporción competitiva es entonces al menos: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. Si en cambio f = m, entonces Γ alcanza un valor de como máximo lm +δ, mientras que Γoffline alcanza un valor de al menos k · ( m h=1 lh − 2δ) + lm al completar trabajos menores hasta que dm = rm + lm, y luego completar el trabajo m. La proporción competitiva es entonces al menos: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. TRABAJO RELACIONADO En esta sección describimos trabajos relacionados distintos a los dos artículos ([4] y [15]) en los que se basa este documento. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo fuera de línea (ver, por ejemplo, [13, 14]). El diseño de mecanismos también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno sin conexión, y son los agentes quienes pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este artículo también lanzó el área del diseño algorítmico de mecanismos, en el cual el mecanismo debe cumplir con los requisitos computacionales además de los requisitos de incentivos estándar. Un subcampo en crecimiento en esta área es el diseño de mecanismos de reparto de costos para multicast (ver, por ejemplo, [1]), en el cual el mecanismo debe determinar de manera eficiente, para cada agente en un árbol de multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño algorítmico de mecanismos distribuidos, consulte [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros documentos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un entorno de liquidación de mercado en línea, en el cual el subastador empareja ofertas de compra y venta (que se asumen como exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es compatible con incentivos con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], los cuales abordan subastas en línea de múltiples unidades. La principal diferencia entre ambos es que el primero considera el caso de un bien digital, el cual tiene una oferta ilimitada. Se señala en [16] que sus resultados siguen siendo válidos cuando el escenario se amplía para que los postores puedan retrasar su llegada. El único otro artículo del que tenemos conocimiento que aborda el tema de la compatibilidad de incentivos en un sistema en tiempo real es [11], el cual considera varias variantes de un modelo en el que el centro asigna ancho de banda a agentes que declaran tanto su valor como su tiempo de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que se presenta un mecanismo de estrategia Bayes-Nash IC para la variante en la que la decisión actual de los centros afecta el costo de las acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor proporción competitiva posible, pero para el cual se requerían nuevas soluciones cuando el escenario se amplía para incluir agentes con intereses propios. Presentamos un mecanismo que es compatible con incentivos con respecto al tiempo de liberación, plazo, duración y valor, y que solo aumenta la proporción competitiva en uno. También demostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego demostramos un límite inferior coincidente en la proporción competitiva que puede lograrse mediante un mecanismo determinista que nunca paga a los agentes. Quedan varios problemas abiertos en este contexto. Se trata de determinar si el límite inferior puede ser fortalecido al eliminar la restricción de pagos no negativos. Además, aunque consideramos razonable fortalecer la suposición de conocer la máxima relación posible de densidades de valor (k) en lugar de conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo de ((1 + √ k)2 + 1) bajo la suposición original. Finalmente, los mecanismos aleatorios ofrecen un área inexplorada para trabajos futuros. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami y S. Shenker, Aproximación y colusión en el reparto de costos de multicast, Juegos y Comportamiento Económico (por aparecer). [2] B. Awerbuch, Y. Azar y A. Meyerson, Reducción de mecanismos de verdad en línea a optimización en línea, Actas del 35º Simposio sobre Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum y F. Wu, Subastas en línea compatibles con incentivos para bienes digitales, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Revista de Sistemas en Tiempo Real 4 (1992), núm. 2, 125-144. [5] A. Blum, T. Sandholm y M. Zinkevich, Algoritmos en línea para compensación de mercado, Actas del 13º Simposio Anual de Algoritmos Discretos ACM-SIAM, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy y H. Stockinger, Modelos económicos para gestión de recursos y programación en la computación en malla, La Revista de Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan y O. Regev, El proyecto popcorn: Computación distribuida en internet en Java, 6ª Conferencia Internacional World Wide Web, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y direcciones futuras, Actas del 6º Taller Internacional sobre Algoritmos Discretos y Métodos para la Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Fijación de precios de wifi en Starbucks: Problemas en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Límites para ciertas anomalías multiprocesador, Revista Técnica del Sistema Bell 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, La velocidad es tan poderosa como la clarividencia, Revista de la ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan y K. To, Programación en línea con plazos ajustados, Ciencia de la Computación Teórica 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo de programación en línea óptimo para sistemas en tiempo real sobrecargados, Revista SIAM de Computación 24 (1995), núm. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston y J. Verde, Teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño algorítmico de mecanismos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e internet, STOC, 2001, pp. 749-753. 70 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "mechanism design": {
            "translated_key": "diseño de mecanismos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>mechanism design</br> for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting <br>mechanism design</br> problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of <br>mechanism design</br> [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and <br>mechanism design</br> (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of <br>mechanism design</br> is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the <br>mechanism design</br> setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "<br>mechanism design</br> SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a <br>mechanism design</br> problem.",
                "In this section we first present the <br>mechanism design</br> formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard <br>mechanism design</br> setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the <br>mechanism design</br> setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in <br>mechanism design</br>.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "<br>mechanism design</br> was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic <br>mechanism design</br>, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing <br>mechanism design</br> (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic <br>mechanism design</br>, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic <br>mechanism design</br>: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online <br>mechanism design</br>, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic <br>mechanism design</br>, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "<br>mechanism design</br> for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "For the resulting <br>mechanism design</br> problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of <br>mechanism design</br> [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and <br>mechanism design</br> (see, e.g., [9, 18, 19]).",
                "A basic solution concept of <br>mechanism design</br> is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline."
            ],
            "translated_annotated_samples": [
                "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista.",
                "Para el problema resultante de <br>diseño de mecanismos</br> (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva.",
                "La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del <br>diseño de mecanismos</br> [17], la ciencia de elaborar protocolos para agentes con intereses propios.",
                "En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el <br>diseño de mecanismos</br> (ver, por ejemplo, [9, 18, 19]).",
                "Un concepto básico de solución en el <br>diseño de mecanismos</br> es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el horario, sino también el pago de cada agente. Para el problema resultante de <br>diseño de mecanismos</br> (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el horario debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del <br>diseño de mecanismos</br> [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el <br>diseño de mecanismos</br> (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el <br>diseño de mecanismos</br> es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "game theory": {
            "translated_key": "teoría de juegos",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "schedule": {
            "translated_key": "horario",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm.",
                "However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm.",
                "Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent.",
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the <br>schedule</br>, but the payment of each agent.",
                "For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one.",
                "We then show a matching lower bound for deterministic mechanisms that never pay the agents.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1.",
                "INTRODUCTION We consider the problem of online scheduling of jobs on a single processor.",
                "Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline.",
                "The objective is to maximize the sum of the values of the jobs completed by their respective deadlines.",
                "The key challenge in this online setting is that the <br>schedule</br> must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution.",
                "One interpretation of this approach is as a game between the designer of the online algorithm and an adversary.",
                "First, the designer selects the online algorithm.",
                "Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm.",
                "Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs.",
                "For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms.",
                "The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm.",
                "The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release.",
                "However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs.",
                "Furthermore, sellers not only <br>schedule</br> jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent.",
                "Instead of being released to the algorithm, each job is now released only to its owning agent.",
                "Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job.",
                "Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15].",
                "The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents.",
                "Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]).",
                "In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome.",
                "In our setting, a mechanism will take as input a job from each agent, and return a <br>schedule</br> for the jobs, and a payment to be made by each agent to the center.",
                "A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline.",
                "In order to evaluate a mechanism using competitive analysis, the adversary model must be updated.",
                "In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism.",
                "Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs.",
                "The rest of the paper is structured as follows.",
                "In Section 2, we formally define and review results from the original, non-strategic setting.",
                "After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3.",
                "In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio.",
                "We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job.",
                "Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents.",
                "Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2.",
                "NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand.",
                "Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively.",
                "The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous).",
                "Each job is released at time ri, at which point its three other characteristics are known.",
                "Nothing is known about the job before its arrival.",
                "Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline.",
                "Preemption of jobs is allowed, and it takes no time to switch between jobs.",
                "Thus, job i is completed if and only if the total time it executes on the processor before di is at least li.",
                "Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i.",
                "Thus, (θi, θ−i) denotes a complete vector of tuples.",
                "Define the value density ρi = vi li of job i to be the ratio of its value to its length.",
                "For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi.",
                "The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs.",
                "The algorithm is assumed to always know an upper bound k on the importance ratio.",
                "For simplicity, we normalize the range of possible value densities so that ρmin = 1.",
                "An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o.",
                "An outcome o ∈ O is simply a <br>schedule</br> of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle.",
                "To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise.",
                "A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline.",
                "A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li).",
                "Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument.",
                "For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ.",
                "Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the <br>schedule</br> over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time.",
                "Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t).",
                "The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ.",
                "In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm.",
                "Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ).",
                "An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ).",
                "An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration.",
                "A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li).",
                "Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1.",
                "Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4].",
                "In this section we provide a high-level description of TD1 (version 2) using an example.",
                "TD1 (version 2) divides the <br>schedule</br> into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job.",
                "The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity.",
                "For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9].",
                "No preemption is considered during this interval, because job 2 has laxity until time 1.5.",
                "Then, a new interval starts at tb = 0.9 when job 2 becomes active.",
                "Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity.",
                "In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss.",
                "The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted).",
                "In this case, te = 17.0.",
                "The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job.",
                "The other variable, p loss, is equal to the length of the first active job of the current interval.",
                "Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio).",
                "Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion.",
                "Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ?",
                "Table 1: Input used to recap TD1 (version 2) [4].",
                "The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3.",
                "MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job.",
                "For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7.",
                "At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1.",
                "Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem.",
                "In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand.",
                "Each job i is owned by a separate agent i.",
                "The characteristics of the job define the agents type θi ∈ Θi.",
                "At time ri, agent i privately observes its type θi, and has no information about job i before ri.",
                "Thus, jobs are still released over time, but now each job is revealed only to the owning agent.",
                "Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O.",
                "An outcome o = (S(·), p1, . . . , pN ) consists of a <br>schedule</br> and a payment from each agent to the mechanism.",
                "In a standard mechanism design setting, the outcome is enforced at the end of the mechanism.",
                "However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent.",
                "That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time.",
                "This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms.",
                "Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism.",
                "Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center.",
                "We assume that each agent is a rational, expected utility maximizer.",
                "Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed.",
                "On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job.",
                "However, we will also consider a restricted formulation in which this type of lie is not possible.",
                "The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent.",
                "The agent can declare an arbitrary deadline or value.",
                "To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri.",
                "While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job.",
                "Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax.",
                "However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting.",
                "The restriction on the <br>schedule</br> is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism.",
                "As before, preemption of jobs is allowed, and job switching takes no time.",
                "The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i.",
                "The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality.",
                "The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration.",
                "Definition 1.",
                "A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn.",
                "From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it.",
                "For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the <br>schedule</br>.",
                "In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7.",
                "However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the <br>schedule</br> the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned).",
                "Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism.",
                "While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality.",
                "The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility.",
                "The rationale behind this goal is that participation in the mechanism is assumed to be voluntary.",
                "Definition 2.",
                "A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0.",
                "Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) .",
                "As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline).",
                "An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3.",
                "An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4.",
                "RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1).",
                "After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio.",
                "We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents.",
                "Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job.",
                "Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin).",
                "Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration.",
                "By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR.",
                "We now argue why it satisfies IC with respect to the other three characteristics.",
                "Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent.",
                "However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline.",
                "This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0.",
                "However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job.",
                "The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting).",
                "On the other hand, it is less obvious why agents do not have incentive to declare a later release time.",
                "Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj.",
                "Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1.",
                "However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1.",
                "Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13.",
                "Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22.",
                "Job 3 then executes to completion, forcing job 1 to be abandoned.",
                "However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22.",
                "Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30].",
                "Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ?",
                "Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times.",
                "Intuitively, Γ1 avoids this problem because of two properties.",
                "First, when a job becomes active, it must have a greater priority than all other available jobs.",
                "Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics.",
                "These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas.",
                "Theorem 1.",
                "Mechanism Γ1 satisfies individual rationality.",
                "Proof.",
                "For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0.",
                "On the other hand, if job i is completed, then its value must exceed agent is payment.",
                "Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition.",
                "To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li.",
                "We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed.",
                "We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline.",
                "Lemma 2.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof.",
                "Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri.",
                "We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center.",
                "Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi).",
                "First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta .",
                "Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i.",
                "We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y .",
                "Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active.",
                "Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor.",
                "Assume by contradiction that this is not true.",
                "Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ).",
                "We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time.",
                "The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y .",
                "Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri.",
                "We now show that job i cannot be completed in this case, given that it was not completed in case I.",
                "First, we can restrict the range of ˆri that we need to consider as follows.",
                "Declaring ˆri ∈ (ri, ts ] would not affect the <br>schedule</br>, since ts would still be the first time that job i executes.",
                "Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release.",
                "Thus, we can restrict consideration to ˆri ∈ (ts , ta ].",
                "In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y .",
                "Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs.",
                "We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ).",
                "First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc .",
                "Now consider an arbitrary y ∈ Y such that y = yc .",
                "In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, moving to case II, job y must replace some other job before tc .",
                "Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y).",
                "Since w ∈ Y would contradict the definition of tc , we know that w = i.",
                "That is, the job that y replaces must be i.",
                "By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry).",
                "Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I.",
                "On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X.",
                "We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ).",
                "We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ].",
                "Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ).",
                "Thus, even at this upper bound, job yc would execute instead of job x at time tc .",
                "A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz.",
                "Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof.",
                "Lemma 3.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof.",
                "Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di.",
                "Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail.",
                "Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli).",
                "Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter.",
                "Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction.",
                "We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4.",
                "In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof.",
                "Assume by contradiction that this condition does not hold.",
                "This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not.",
                "Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction.",
                "Finally, the following lemma tells us that the completion of a job is monotonic in its declared value.",
                "Lemma 5.",
                "In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri.",
                "In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed.",
                "The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ].",
                "We can now combine the lemmas to show that no profitable deviation is possible.",
                "Theorem 6.",
                "Mechanism Γ1 satisfies incentive compatibility.",
                "Proof.",
                "For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption.",
                "We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline.",
                "Then, because the payment function is non-negative, agent is utility could not exceed zero.",
                "By IR, this is the minimum utility it would achieve if it truthfully declared θi.",
                "Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di.",
                "Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero.",
                "If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i.",
                "On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas.",
                "Having shown IC, we can assume truthful declaration (ˆθ = θ).",
                "Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline.",
                "Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1.",
                "Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence.",
                "Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1.",
                "Also, let tbegin f be the first time that the processor is not idle in interval If .",
                "Lemma 7.",
                "For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof.",
                "Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job.",
                "Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs).",
                "Let ts i be the time that job i begins execution.",
                "Note that ts 1 = tbegin f .",
                "Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs.",
                "Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active.",
                "We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)).",
                "To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence.",
                "Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements.",
                "Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds.",
                "At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1.",
                "These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step.",
                "We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length.",
                "We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf .",
                "We now consider the possible execution of uncompleted jobs by Γoffline.",
                "Associate each job i that is not completed by Γ1 with the interval during which it was abandoned.",
                "All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F .",
                "Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism.",
                "Lemma 8.",
                "For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf .",
                "Proof.",
                "Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf .",
                "At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf .",
                "Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ].",
                "Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf .",
                "As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not <br>schedule</br> a job.",
                "Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines.",
                "The following lemma is Lemma 5.10 in [15], and its proof now applies directly.",
                "Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf .",
                "The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f .",
                "By Lemma 8, the value of this job is bounded by (1 + √ k) · vf .",
                "We can now combine the results of these lemmas to prove the competitive ratio.",
                "Theorem 10.",
                "Mechanism Γ1 is (1+ √ k)2+1 -competitive.",
                "Proof.",
                "Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F).",
                "Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9.",
                "Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf .",
                "Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings.",
                "For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem.",
                "Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4].",
                "If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments.",
                "The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility.",
                "Theorem 12.",
                "When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive.",
                "Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems.",
                "Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5.",
                "COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms.",
                "To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0).",
                "Unlike IC and IR, this requirement is not standard in mechanism design.",
                "We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i.",
                "The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments.",
                "We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints.",
                "Lemma 13.",
                "For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14.",
                "There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1.",
                "Proof.",
                "Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well).",
                "Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1.",
                "First, we will construct a profile of agent types θ using an adversary argument.",
                "After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction.",
                "We now construct the original profile θ.",
                "Pick an α such that 0 < α < , and define δ = α ck+3k .",
                "The adversary uses two sequences of jobs: minor and major.",
                "Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity.",
                "The first minor job is released at time 0, and ri = di−1 for all i > 1.",
                "The sequence stops whenever Γ completes any job.",
                "Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li).",
                "The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13.",
                "Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α.",
                "The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job.",
                "The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1].",
                "No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ).",
                "Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned.",
                "If f < m, then major job f + 1 will be released and it will be the final major job.",
                "Γ cannot complete job f +1, because rf +lf = df > rf+1.",
                "Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df .",
                "We now possibly perturb θ slightly.",
                "By IR, we know that vf ≥ pf (θ).",
                "Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf .",
                "By IC, job f must still be completed by Γ for the profile (θf , θ−f ).",
                "If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0.",
                "However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC.",
                "Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument.",
                "Thus, for the remainder of the proof, assume that vf > pf (θ).",
                "We now use a more substantial perturbation of θ to complete the proof.",
                "If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed.",
                "If f = m, then instead set df = df +lf .",
                "IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed.",
                "Assume by contradiction that this were not true.",
                "Then, at the original deadline of df , job f is not completed.",
                "Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)).",
                "Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must <br>schedule</br> jobs in the same way until df .",
                "Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0.",
                "Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ).",
                "Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC.",
                "While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change.",
                "If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned).",
                "Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6.",
                "RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based.",
                "Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]).",
                "Mechanism design was also applied to a scheduling problem in [18].",
                "In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them.",
                "The private information of an agent is the time it will require to execute each job.",
                "Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem.",
                "This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements.",
                "A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay.",
                "For a survey of this and other topics in distributed algorithmic mechanism design, see [9].",
                "Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings.",
                "For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time.",
                "In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values.",
                "Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions.",
                "The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply.",
                "It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival.",
                "The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time.",
                "A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7.",
                "CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents.",
                "We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one.",
                "We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job.",
                "We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents.",
                "Several open problems remain in this setting.",
                "One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments.",
                "Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption.",
                "Finally, randomized mechanisms provide an unexplored area for future work. 8.",
                "REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J.",
                "Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70"
            ],
            "original_annotated_samples": [
                "The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the <br>schedule</br>, but the payment of each agent.",
                "The key challenge in this online setting is that the <br>schedule</br> must be constructed in real-time, even though nothing is known about a job until its release time.",
                "Furthermore, sellers not only <br>schedule</br> jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting.",
                "In our setting, a mechanism will take as input a job from each agent, and return a <br>schedule</br> for the jobs, and a payment to be made by each agent to the center.",
                "An outcome o ∈ O is simply a <br>schedule</br> of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle."
            ],
            "translated_annotated_samples": [
                "El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el <br>horario</br>, sino también el pago de cada agente.",
                "El desafío clave en este entorno en línea es que el <br>horario</br> debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación.",
                "Además, los vendedores no solo <br>programan</br> trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico.",
                "En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un <br>horario</br> para los trabajos y un pago que cada agente debe hacer al centro.",
                "Un resultado o ∈ O es simplemente un <br>horario</br> de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo."
            ],
            "translated_text": "Diseño de mecanismos para la programación en tiempo real en línea. Ryan Porter∗ Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en tiempo real en línea de trabajos en un solo procesador, trabajos anteriores presentan límites superiores e inferiores coincidentes sobre la proporción competitiva que puede lograr un algoritmo determinista. Sin embargo, estos resultados solo se aplican al entorno no estratégico en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en malla, en cambio consideramos este problema en un entorno económico, en el que cada trabajo se asigna a un agente separado y con intereses propios. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su duración y declarar un valor y plazo arbitrarios para el trabajo, mientras que el centro determina no solo el <br>horario</br>, sino también el pago de cada agente. Para el problema resultante de diseño de mecanismos (en el cual también fortalecemos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada problema de incentivos, aumentando solo en uno la proporción competitiva. Luego mostramos una cota inferior coincidente para mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial]: Inteligencia Artificial Distribuida-Sistemas Multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por Dispositivos Abstractos]: Modos de Computación-Computación en línea Términos Generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento y un valor para su finalización exitosa antes de la fecha límite. El objetivo es maximizar la suma de los valores de los trabajos completados antes de sus respectivas fechas límite. El desafío clave en este entorno en línea es que el <br>horario</br> debe ser construido en tiempo real, aunque no se conozca nada sobre un trabajo hasta su hora de liberación. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo óptimo fuera de línea, que tiene conocimiento completo de la entrada al inicio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Entonces, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la proporción competitiva: la proporción entre el valor de los trabajos completados por un algoritmo óptimo fuera de línea y el valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este escenario, en el que se asume que el algoritmo conoce k, la máxima proporción entre las densidades de valor (valor dividido por tiempo de procesamiento) de cualquier par de trabajos. Para k = 1, [4] presenta un algoritmo 4-competitivo y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo artículo también generaliza el límite inferior a (1 + √ k)2 para cualquier k ≥ 1, y luego presenta un algoritmo competitivo de (1 + √ k)2 coincidente. El escenario abordado por estos documentos es completamente no estratégico, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo al ser liberado. Sin embargo, en dominios como la computación en malla (ver, por ejemplo, [7, 8]) esta suposición es inválida, ya que los compradores de tiempo de procesador eligen cuándo y cómo enviar sus trabajos. Además, los vendedores no solo <br>programan</br> trabajos, sino que también determinan la cantidad que cobran a los compradores, un tema que no se aborda en el entorno no estratégico. Por lo tanto, consideramos una extensión del escenario en el que cada trabajo es propiedad de un agente separado y con intereses propios. En lugar de ser liberado al algoritmo, cada trabajo ahora es liberado solo a su agente propietario. Cada agente ahora tiene cuatro formas diferentes en las que puede manipular el algoritmo: decide cuándo enviar el trabajo al algoritmo después del tiempo real de lanzamiento, puede inflar artificialmente la duración del trabajo y puede declarar un valor y plazo arbitrarios para el trabajo. Debido a que los agentes actúan en su propio interés, elegirán manipular el algoritmo si hacerlo les permite completar su trabajo; de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La incorporación de agentes con intereses propios traslada el problema del área del diseño de algoritmos al del diseño de mecanismos [17], la ciencia de elaborar protocolos para agentes con intereses propios. En los últimos años ha habido mucha actividad en la interfaz entre la ciencia de la computación y el diseño de mecanismos (ver, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo para la interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un <br>horario</br> para los trabajos y un pago que cada agente debe hacer al centro. Un concepto básico de solución en el diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro contexto, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo al ser liberado, y declarar verazmente su valor, duración y fecha límite. Para evaluar un mecanismo utilizando análisis competitivo, el modelo del adversario debe ser actualizado. En el nuevo modelo, el adversario sigue determinando la secuencia de trabajos, pero son los agentes con interés propio quienes determinan la entrada observada del mecanismo. Por lo tanto, para lograr una proporción competitiva de c, un mecanismo en línea debe ser compatible con incentivos y siempre lograr al menos 1 c del valor que el mecanismo óptimo fuera de línea logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la Sección 2, definimos formalmente y revisamos los resultados del entorno original, no estratégico. Después de introducir los problemas de incentivos a través de un ejemplo, formalizamos el entorno del diseño de mecanismos en la Sección 3. En la Sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo de ((1 + √ k)2 + 1), y demostramos formalmente la compatibilidad de incentivos y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no puede alterar la duración de su trabajo. Volviendo al escenario general, mostramos en la Sección 5 que esta proporción competitiva es una cota inferior para mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados que no son directamente relevantes a [4] y [15], antes de concluir con la Sección 7. CONFIGURACIÓN NO ESTRATÉGICA En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y N trabajos, aunque este número no se conoce de antemano. Cada trabajo i está caracterizado por una tupla θi = (ri, di, li, vi), que denota el tiempo de liberación, la fecha límite, la duración del tiempo de procesamiento requerido y el valor, respectivamente. El espacio Θi de tuplas posibles es el mismo para cada trabajo y consiste en todos los θi tales que ri, di, li, vi ∈ + (por lo tanto, el modelo de tiempo es continuo). Cada trabajo se libera en el tiempo ri, momento en el que se conocen sus otras tres características. No se sabe nada sobre el trabajo antes de su llegada. Cada fecha límite es firme, lo que significa que no se obtiene ningún valor por un trabajo que se completa después de su fecha límite. La prelación de trabajos está permitida y no se tarda tiempo en cambiar entre trabajos. Por lo tanto, el trabajo i se completa si y solo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Sea θ = (θ1, . . . , θN ) el vector de tuplas para todos los trabajos, y sea θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) el mismo vector sin la tupla para el trabajo i. Así, (θi, θ−i) denota un vector completo de tuplas. Define la densidad de valor ρi = vi li del trabajo i como la razón de su valor a su longitud. Para una entrada θ, denota las densidades de valor máximo y mínimo como ρmin = mini ρi y ρmax = maxi ρi. La proporción de importancia se define como ρmax ρmin, la proporción máxima de densidades de valor entre dos trabajos. Se asume que el algoritmo siempre conoce un límite superior k en la proporción de importancia. Para simplificar, normalizamos el rango de densidades de valor posibles de manera que ρmin = 1. Un algoritmo en línea es una función f: Θ1 × . . . × ΘN → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o ∈ O es simplemente un <br>horario</br> de trabajos en el procesador, registrado por la función S : + → {0, 1, . . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. ",
            "candidates": [],
            "error": [
                [
                    "horario",
                    "horario",
                    "programan",
                    "horario",
                    "horario"
                ]
            ]
        }
    }
}