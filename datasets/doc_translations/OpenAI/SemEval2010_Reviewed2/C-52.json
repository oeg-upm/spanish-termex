{
    "id": "C-52",
    "original_text": "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver. The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender. This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object. But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well. This leads to unfairness in game playing. In this paper, we first introduce an error measure for estimating this inaccuracy. Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time. This algorithm makes the game very fair at the expense of increasing the overall mean error of all players. To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing. We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game. We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays. An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing. Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1. INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server. Usually, in such games, the players are part of the game and in addition they may control entities that make up the game. During the course of the game, the players and the entities move within the game space. A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector. A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions. Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity. In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server. The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit. DR vectors are quantization of the real trajectory (which we refer to as real path) at a player. Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold. We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path. Therefore, at the sending player, there is a deviation between the real path and the exported path. The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same. Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest. Therefore, the receiving players can, at best, follow the exported path. Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed. Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path). We refer to this error as the export error. Note that the export error, in turn, results in a deviation between the real and the placed paths. The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error). In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero. That is, the placed and the exported paths match after the DR vector is received. We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1]. Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error. In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers. Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers. This brings in unfairness in game playing. For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered. Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players. We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender. We propose two algorithms to achieve this. Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players. At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same. The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses. The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point. Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error). The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR). To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players. At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer. Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach. It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game. In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2. PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4]. These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another. For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies. The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays. In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely. Players with a network delay larger than 100 ms simply cannot participate in the game. In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players. There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms. But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game. Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object). These additions and deletions are communicated to the game server using action messages. Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages. Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players. Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works. In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game. DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model). It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place. Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof. For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage. We emphasize that the focus of this paper is on fairness without addressing the issue of cheating. In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1]. In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag. Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing. Conclusions are presented in Section 6. 2 3. GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other. The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model). As mentioned before, we assume synchronized clocks among the participating players. Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity. We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path. Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 . Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates. Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik). Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity. For simplicity, we consider a two dimensional game space rather than a three dimensional one. Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi). The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed. Note that the computation of time difference is feasible since all the clocks are synchronized. The receiving player then uses the velocity components to project and render the trajectory of the entity. This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations. Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered. The figure shows the reception of DR vectors at a player (henceforth called the receiver). The horizontal axis shows the time which is synchronized among all the players. The vertical axis tries to conceptually capture the two-dimensional position of an entity. Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver. Assume that DR0 is received at the receiver after a delay of dt0 time units. The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E). The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path). At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 . Assume that DR1 is received at the receiver after a delay of dt1 time units. When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C). The velocity components vx1 and vy1 are used to project and render this entity further. Let us now consider the error due to network delay. Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1. This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0. Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same. The deviation between the exported and placed paths creates an error component which we refer to as the export error. A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync. We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2). In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1]. Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error. Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector. This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received. Starting from time T1 onwards, there is a deviation between the real and the exported paths. As we discussed earlier, this export error is unavoidable. The above figure and example illustrates one receiver only. But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players. Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players. The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4. SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received. We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time. Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal. However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver. Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers. In this section we provide motivations for the algorithm and describe the steps it goes through. Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers. DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers. DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2. Consider the example in Figure 2. The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2. DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path. Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0. Now consider DR1. At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2). Note that the sender includes the sending timestamp with the DR vector as shown in the figure. Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same. However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2. This is due to the fact that the sender uses the estimated delay dt1 to compute this error. Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]). Note that the above errors from the senders perspective are only estimates. In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced. This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender. The concept of relative export error is illustrated in Figure 2. Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1). This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1. We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender. The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock). Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2. Relative export errors are computed by the sender as and when it receives the feedback from the receivers. This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved. As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2. This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers. The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively. Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2. If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2). But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before). Let us represent the accumulated relative error up to DRi for receiver j as Ri j. To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i. This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector. In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed. Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively. Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant. THEOREM 4.1. When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction. Assume that the premise holds for some i. We show that it holds for i+1. The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances. In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n . Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed. From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2). Note that the values of R0 1 and R0 2 are already known at the sender. Consider the computation of Err(DR1, T1, T1 +δ1 +dt1). This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0. From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0). The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t). The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt. A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution. In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2. The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2). If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2). This equality will hold if δ1 + dt1 = δ2 + dt2. Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time. As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account. To delve deeper into this, consider the computation of the export error as illustrated in the previous section. To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt. That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt. The components R0 1, R0 2, are already known to (or estimated by) the sender. Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2. Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt. Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. Assume that E1 > E2. Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt. To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement. Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays. Then, it finds the smallest of these values. Let Ek be the smallest value. The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1. The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1). It schedules, DRi to be sent to receiver k at time Ti + δi k. 2. The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk. The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3. The sender computes Ri k as described earlier and illustrated in Figure 2. The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4. Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k . Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers. How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent? Let us consider the first scenario. We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N . Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1. This means, DRi has been sent only to receivers up to k in the scheduled order. In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1. For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later). For these receivers, Ei j, 1 ≤ j ≤ k can be computed. For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply. Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent. Refer to Figure 3. For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj]. Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj). Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed. Now consider the second scenario. Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled. In this case, Ri k cannot be computed. Thus, in the computation of δk for DRi+1, this will be assumed to be zero. We do assume that a reliable mechanism is used to send dak back to the sender. When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game. It is a first-person shooter game where the players in teams drive tanks and move within a battle field. The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area. The players shoot each others tanks using shooting bullets. The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors. We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector. We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers. The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector. NISTNet [12] was used to introduce delays across the sender and the three receivers. Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively. We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay. The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case. The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds. Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case. Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken. Observe that the standard deviation of the error with scheduling is much lower as compared to the base case. This implies that the accumulated errors of the receivers in the scheduling case are closer to one another. This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender. Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case. Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher. Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule. In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error. This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value. This flip-flop effect leads to the increase in the accumulated error for all the receivers. The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature. This led us to explore different ways of equalizing the accumulated errors. The approach discussed in the following section is a heuristic approach based on the following idea. Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time. At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case). We refer to such an algorithm as a budget based algorithm. 5. BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity. Lower the threshold, more DR vectors are generated during a given time period. Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest. In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players. The budget based algorithm is based on this idea and there are two variations of it. One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player. These steps are described below. The lowering of DR threshold is implemented as follows. Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated. Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors. Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers). Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case. We want to ensure n t = nt. Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger. In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1). This probability is based on the relative weights of the receivers accumulated errors. That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector. Consider that the accumulated error for three players are a1, a2 and a3 respectively. Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 . Similarly for the other players. Once the player is picked, the DR vector is sent to that player. To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison). As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments. This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case. The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time. In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach. We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms). The results are shown in Figures 5 and 6. As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken. Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case. This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case. The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature. When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher. At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time. This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic. The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector. Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1. If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s). If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2. For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3. If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies. This process is repeated until all the receivers have a frequency of less than or equal to 1. This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver. That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver. Credit obtained previously (explained in step 5) if any is subtracted from the schedule. Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule. For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers. However, we are constrained to send it at the 4th trigger giving us a credit of 0.5. When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5. The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6. For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger. Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time. Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector. At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers. This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm. We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case. Results from our experiments are shown in Figures 5 and 6. It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case. This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm. In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach. With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6. CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors. Due to the variable delay between players, these DR vectors reach different players at different times. There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time. In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers. We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players. This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players. To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated). We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7. REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K. Singhal and D.R. Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C. Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10",
    "original_translation": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la precisión del juego. Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores. Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado. El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de sincronización de cubo estático para compensar las variaciones en los retrasos de la red. En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota. Los jugadores con un retraso de red mayor a 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la sincronización de cubetas dependen de imponer un retraso máximo en todos los jugadores. Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados. Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto). Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción. Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización. La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras. En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego. Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor). Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la sincronización de cubos no son a prueba de trampas a menos que se implementen mecanismos adicionales. Tanto el algoritmo de programación como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas. Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida. Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño. En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1]. En la Sección 4, describimos el algoritmo de programación de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFlag. La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de precisión en el juego. Las conclusiones se presentan en la Sección 6.2.3. MODELO DE JUEGO La arquitectura del juego se basa en jugadores distribuidos a través de Internet que intercambian vectores DR entre sí. Los vectores de DR podrían ser enviados directamente de un jugador a otro (modelo peer-to-peer) o podrían ser enviados a través de un servidor de juego que recibe el vector de DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor). Como se mencionó anteriormente, asumimos que los relojes de los jugadores participantes están sincronizados. Cada vector DR enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad. Suponemos un vector DR lineal en el que la información contenida en el vector DR es solo suficiente para que el jugador receptor calcule la trayectoria y represente la entidad en un camino en línea recta. Un vector DR de este tipo contiene información sobre la posición inicial y la velocidad del jugador/entidad, donde la velocidad es constante. Por lo tanto, los vectores DR enviados por un jugador especifican el tiempo actual en el jugador cuando se calcula el vector DR (no el tiempo en el que este vector DR se envía a los otros jugadores, como explicaremos más adelante), la posición actual del jugador/entidad en términos de las coordenadas x, y, z y el vector de velocidad en la dirección de las coordenadas x, y, z. Específicamente, el vector DRi enviado por el jugador j sobre la k-ésima entidad se denota como DRj ik y está representado por la siguiente tupla (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik). Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y para una sola entidad. Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional. Por lo tanto, usamos DRi para denotar el i-ésimo vector DR representado como la tupla (Ti, xi, yi, vxi, vyi). El jugador receptor calcula la posición inicial para la entidad basándose en xi, yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo Ti en el que fue calculado. Ten en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados. El jugador receptor luego utiliza los componentes de velocidad para proyectar y representar la trayectoria de la entidad. Esta trayectoria se sigue hasta que se recibe un nuevo vector DR que cambia la posición y/o velocidad de la entidad. tiempoT1 Real Exportado Colocado dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) calculado en el tiempo T1 y enviado al receptor DR0 = (T0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptor T0 dt0 Colocado E Figura 1: Trayectorias y desviaciones. Basado en este modelo, la Figura 1 ilustra el envío y recepción de vectores DR y los diferentes errores que se encuentran. Otros tipos de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y vectores DR de spline cúbico que consideran la posición y velocidad inicial y la posición y velocidad final de la entidad. La figura muestra la recepción de vectores de DR en un jugador (en adelante llamado receptor). El eje horizontal muestra el tiempo que está sincronizado entre todos los jugadores. El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad. Suponga que en el tiempo T0 se calcula un vector DR0 por el remitente y se envía inmediatamente al receptor. Supongamos que DR0 es recibido por el receptor después de un retraso de dt0 unidades de tiempo. El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (mostrado como punto E). La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor basada en los componentes de velocidad vx0 y vy0 (ruta colocada). En el tiempo T1 se calcula un vector DR1 de enrutamiento dinámico para la misma entidad y se envía inmediatamente al receptor2. Suponga que DR1 es recibido por el receptor después de un retraso de dt1 unidades de tiempo. Cuando se recibe este vector DR, se asume que la entidad está en el punto D. Se calcula una nueva posición para la entidad como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto C). Los componentes de velocidad vx1 y vy1 se utilizan para proyectar y representar esta entidad más lejos. Ahora consideremos el error debido al retraso de la red. Aunque DR1 se calculó en el tiempo T1 y se envió al receptor, no llegó al receptor hasta el tiempo T1 + dt1. Esto significa que, aunque la ruta exportada basada en DR1 en el remitente en el tiempo T1 es la trayectoria AC, hasta el tiempo T1 + dt1, en el receptor, esta entidad estaba siendo representada en la trayectoria BD basada en DR0. Solo en el momento T1 + dt1 la entidad se movió al punto C, a partir del cual los caminos exportados y colocados son iguales. La desviación entre las rutas exportadas y colocadas crea un componente de error al que nos referimos como el error de exportación. Una forma de representar el error de exportación es calcular la integral de la distancia entre las dos trayectorias durante el tiempo en que están desincronizadas. Representamos la integral de las distancias entre las rutas colocadas y exportadas debido a algunos DR DRi en un intervalo de tiempo [t1, t2] como Err(DRi, t1, t2). En la figura, el error de exportación debido a DR1 se calcula como la integral de la distancia entre las trayectorias AC y BD en el intervalo de tiempo [T1, T1 + dt1]. Ten en cuenta que también podría haber otras formas de representar este error, pero en este artículo utilizamos la integral de la distancia entre las dos trayectorias como medida del error de exportación. Tenga en cuenta que se habría producido un error de exportación debido a la recepción de DR0, momento en el que la ruta colocada se basaría en un vector DR anterior. Esto no se muestra en la figura, pero sirve para recordar al lector que el error de exportación es acumulativo cuando se reciben una secuencia de vectores DR. A partir del tiempo T1 en adelante, hay una desviación entre las trayectorias reales y las exportadas. Como discutimos anteriormente, este error de exportación es inevitable. La figura y el ejemplo anterior ilustran solo un receptor. Pero en realidad, los vectores DR DR0 y DR1 son enviados por el remitente a todos los jugadores participantes. Cada uno de estos jugadores recibe DR0 y DR1 después de diferentes retrasos, creando así diferentes valores de error de exportación en cada jugador. El objetivo del algoritmo de programación de vectores DR que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual en cada jugador de forma independiente para cada una de las entidades que conforman el juego. ALGORITMO DE PROGRAMACIÓN PARA EL ENVÍO DE VECTORES DR En la Sección 3 mostramos cómo el retraso desde el remitente de un nuevo vector DR 2 Normalmente, los vectores DR no se calculan de forma periódica, sino bajo demanda, donde la decisión de calcular un nuevo vector DR se basa en la superación de un umbral en la desviación entre la ruta real y la ruta exportada por el vector DR anterior. 3 vector al receptor del vector DR podría llevar a un error de exportación debido a la desviación de la ruta colocada de la ruta exportada en el receptor hasta que se reciba este nuevo vector DR. También mencionamos que el objetivo del algoritmo de programación de vectores DR es igualar el error de exportación en todos los receptores durante un período de tiempo. Dado que el juego se juega en un entorno distribuido, tiene sentido que el remitente de una entidad lleve un registro de todos los errores en los receptores e intente igualarlos. Sin embargo, el remitente no puede conocer el error real en un receptor hasta que reciba alguna información sobre el error del receptor. Nuestro algoritmo estima el error para calcular un horario para enviar vectores DR a los receptores y corrige el error cuando recibe retroalimentación de los receptores. En esta sección proporcionamos las motivaciones para el algoritmo y describimos los pasos por los que atraviesa. A lo largo de esta sección, utilizaremos el siguiente ejemplo para ilustrar el algoritmo. tiempoT1 Ruta exportada Ruta colocada en el receptor 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 enviado al receptor 1 DR1 enviado al receptor 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimado para ser recibido por el receptor 2 DR1 estimado para ser recibido por el receptor 1 DR1 recibido realmente por el receptor 1 DR1 recibido realmente por el receptor 2 DR0 enviado a ambos receptores DR1 calculado por el remitente Ruta colocada en el receptor 1 Figura 2: Flujo de vector DR entre un remitente y dos receptores y la evolución de las rutas colocadas estimadas y reales en los receptores. DR0 = (T0, T0, x0, y0, vx0, vy0), enviado en el tiempo T0 a ambos receptores. DR1 = (T1, T1 1 , x1, y1, vx1, vy1) enviado en el tiempo T1 1 = T1+δ1 al receptor 1 y DR1 = (T1, T2 1 , x1, y1, vx1, vy1) enviado en el tiempo T2 1 = T1 + δ2 al receptor 2. Considera el ejemplo en la Figura 2. La figura muestra un único emisor enviando vectores DR para una entidad a dos receptores diferentes 1 y 2. DR0 calculado en T0 es enviado y recibido por los receptores en algún momento entre T0 y T1, momento en el cual mueven la ubicación de la entidad para que coincida con la ruta exportada. Por lo tanto, la trayectoria de la entidad se muestra solo desde el punto en que la trayectoria colocada coincide con la trayectoria exportada para DR0. Ahora considera DR1. En el tiempo T1, DR1 es calculado por el remitente, pero se asume que no es enviado inmediatamente a los receptores y solo se envía después de un tiempo δ1 al receptor 1 (en el tiempo T1 1 = T1 + δ1) y después de un tiempo δ2 al receptor 2 (en el tiempo T2 1 = T1 + δ2). Ten en cuenta que el remitente incluye la marca de tiempo de envío con el vector DR como se muestra en la figura. Supongamos que el remitente estima (pronto quedará claro por qué el remitente tiene que estimar el retraso) que después de un retraso de dt1, el receptor 1 lo recibirá, utilizará los parámetros de coordenadas y velocidad para calcular la ubicación actual de la entidad y moverla allí (punto C) y a partir de ese momento, los caminos exportado y colocado serán iguales. Sin embargo, en realidad, el receptor 1 recibe DR1 después de un retraso de da1 (que es menor que las estimaciones de los remitentes de dt1), y mueve la entidad correspondiente al punto H. De manera similar, el remitente estima que después de un retraso de dt2, el receptor 2 recibirá DR1, calculará la ubicación actual de la entidad y la moverá a ese punto (punto E), mientras que en realidad recibe DR1 después de un retraso de da2 > dt2 y mueve la entidad al punto N. Los otros puntos mostrados en las rutas colocadas y exportadas se utilizarán más adelante en la discusión para describir diferentes componentes de error. 4.1 Cálculo del Error de Exportación Relativo Volviendo a la discusión de la Sección 3, desde la perspectiva de los remitentes, el error de exportación en el receptor 1 debido a DR1 se da por Err(DR1, T1, T1 + δ1 + dt1) (la integral de la distancia entre las trayectorias AC y DB en el intervalo de tiempo [T1, T1 + δ1 + dt1]) de la Figura 2. Esto se debe a que el remitente utiliza el retraso estimado dt1 para calcular este error. De manera similar, el error de exportación desde la perspectiva del remitente en el recibido 2 debido a DR1 se da por Err(DR1, T1, T1 + δ2 + dt2) (la integral de la distancia entre las trayectorias AE y DF en el intervalo de tiempo [T1, T1 + δ2 + dt2]). Ten en cuenta que los errores anteriores desde la perspectiva del remitente son solo estimaciones. En realidad, el error de exportación será tanto menor como mayor que el valor estimado, dependiendo de si la estimación de retraso fue mayor o menor que el retraso real experimentado por DR1. La diferencia entre el error de exportación estimado y el real es el error de exportación relativo (que puede ser positivo o negativo) que ocurre para cada vector de DR que se envía y se acumula en el remitente. El concepto de error relativo de exportación se ilustra en la Figura 2. Dado que el retraso actual al receptor 1 es da1, el error de exportación inducido por DR1 en el receptor 1 es Err(DR1, T1, T1 + δ1 + da1). Esto significa que hay un error en el error estimado de exportación y el remitente solo puede calcular este error después de recibir un comentario del receptor sobre la demora real en la entrega de DR1, es decir, el valor de da1. Proponemos que una vez que el receptor 1 reciba DR1, envíe el valor de da1 de vuelta al remitente. El receptor puede calcular esta información ya que conoce el momento en que se envió DR1 (T1 1 = T1 + δ1, que se añade al vector DR como se muestra en la Figura 2) y el tiempo local de recepción (que está sincronizado con el reloj del emisor). Por lo tanto, el remitente calcula el error relativo de exportación para el receptor 1, representado como R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1). De manera similar, el error relativo de exportación para el receptor 2 se calcula como R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2). Nótese que R1 > 0 ya que da1 < dt1, y R2 < 0 ya que da2 > dt2. Los errores relativos de exportación son calculados por el remitente en el momento en que recibe la retroalimentación de los destinatarios. Este ejemplo muestra los 4 valores relativos de error de exportación después de que se envía DR1 y se reciben los comentarios correspondientes. 4.2 Igualación del Error Entre Receptores Ahora explicamos lo que queremos decir al hacer que los errores sean iguales en todos los receptores y cómo se puede lograr esto. Como se mencionó anteriormente, el remitente mantiene estimaciones de los retrasos a los receptores, dt1 y dt2 en el ejemplo de la Figura 2. Esto indica que en el momento T1 cuando se calcula DR1, el remitente ya sabe cuánto tiempo pueden tardar los mensajes que llevan este vector DR en llegar a los receptores. El remitente utiliza esta información para calcular los errores de exportación, que son Err(DR1, T1, T1 + δ1 + dt1) y Err(DR1, T1, T1 + δ2 + dt2) para los receptores 1 y 2, respectivamente. Ten en cuenta que las áreas de estos componentes de error son una función de δ1 y δ2, así como de las demoras de red dt1 y dt2. Si queremos que los errores de exportación debido a DR1 sean iguales en ambos receptores, el remitente debe elegir δ1 y δ2 de manera que Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2). Pero cuando se calculó T1, ya podría haberse acumulado errores relativos de exportación debido a los vectores DR anteriores (DR0 y los anteriores). Representemos el error relativo acumulado hasta DRi para el receptor j como Ri j. Para acomodar estos errores relativos acumulados, el remitente debe elegir ahora δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Los δi determinan el instante de programación del vector DR en el remitente para el receptor i. Este método de cálculo de δs garantiza que el error de exportación acumulado (es decir, el error total real) para cada receptor se iguala en la transmisión de cada vector DR. Para establecer esto, asuma que la retroalimentación para el vector DR Di de un receptor llega al remitente antes de que se calcule el horario para Di+1. Que Si m y Ai m denoten el error estimado para el receptor m utilizado para calcular el horario para Di y el error acumulado para el receptor m calculado después de recibir retroalimentación para Di, respectivamente. Entonces Ri m = Ai m − Si m. Para calcular las instancias de programación (es decir, δs) para Di, para cualquier par de receptores m y n, hacemos Ri−1 m + Si m = Ri−1 n + Si n. El siguiente teorema establece el hecho de que el error acumulado de exportación se iguala en cada instante de programación. TEOREMA 4.1. Cuando se calculan las instancias de horario para enviar Di a cualquier par de receptores m y n, se cumple la siguiente condición: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Prueba: Por inducción. Supongamos que la premisa se cumple para algún i. Mostramos que se cumple para i+1. El caso base para i = 1 se cumple ya que inicialmente R0 m = R0 n = 0, y se utiliza S1 m = S1 n para calcular las instancias de programación. Para calcular el horario de Di+1, primero calculamos los errores relativos como Ri m = Ai m − Si m y Ri n = Ai n − Si n. Luego, para calcular δs, ejecutamos Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n. Añadiendo la condición de la premisa en ambos lados obtenemos, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n. 4.3 Cálculo del Error de Exportación. Ahora consideremos cómo se pueden calcular los errores de exportación. De la sección anterior, para encontrar δ1 y δ2 necesitamos encontrar Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2). Se debe tener en cuenta que los valores de R0 1 y R0 2 ya son conocidos en el remitente. Considera el cálculo de Err(DR1, T1, T1 +δ1 +dt1). Esta es la integral de la distancia entre las trayectorias AC debido a DR1 y BD debido a DR0. A partir de DR0 y DR1, el punto A es (X1, Y1) = (x1, y1) y el punto B es (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0). La trayectoria AC puede ser representada como una función del tiempo como (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) y la trayectoria de BD puede ser representada como (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t). La distancia entre las dos trayectorias como función del tiempo se convierte entonces en, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Sea a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Entonces dist(t) se puede escribir como dist(t) = a × t2 + b × t + c. Luego Err(DR1, t1, t2) para algún intervalo de tiempo [t1, t2] se convierte en t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt. Una solución en forma cerrada para la integral indefinida a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2) pueden entonces ser calculadas aplicando los límites apropiados a la solución anterior. En la siguiente sección, consideramos el cálculo de los δs para N receptores. 5 4.4 Cálculo de Instantes de Programación Volvemos a analizar el cálculo de los δs haciendo referencia a la Figura 2. El remitente elige δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 + Err(DR1, T1, T1 + δ2 +dt2). Si R0 1 y R0 2 ambos son cero, entonces δ1 y δ2 deben ser elegidos de tal manera que Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2). Esta igualdad se mantendrá si δ1 + dt1 = δ2 + dt2. Por lo tanto, si no hay error acumulado relativo de exportación, todo lo que el remitente necesita hacer es elegir los δs de tal manera que contrarresten la diferencia en el retraso a los dos receptores, para que reciban el vector DR al mismo tiempo. Como se discutió anteriormente, dado que el remitente no puede aprender de antemano el retraso, siempre habrá un error relativo acumulado de exportación de un vector DR previo que debe tenerse en cuenta. Para profundizar en esto, considera el cálculo del error de exportación como se ilustra en la sección anterior. Para calcular los δs necesitamos que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Es decir, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt. Eso es R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt. Los componentes R0 1, R0 2, ya son conocidos por (o estimados por) el remitente. Además, los componentes de error T1+dt1 T1 dist(t) dt y T1+dt2 T1 dist(t) dt pueden ser calculados a priori por el remitente utilizando valores estimados de dt1 y dt2. Usemos E1 para denotar R0 1 + T1+dt1 T1 dist(t) dt y E2 para denotar R0 2 + T1+dt2 T1 dist(t) dt. Entonces, requerimos que E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. Suponga que E1 > E2. Entonces, para que la ecuación anterior se cumpla, requerimos que T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt. Para hacer el juego lo más rápido posible dentro de este marco, los valores de δ deben ser lo más pequeños posible para que los vectores DR se envíen a los receptores lo antes posible, sujeto al requisito de equidad. Dado esto, elegiríamos δ1 como cero y calcularíamos δ2 a partir de la ecuación E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. En general, si hay N receptores 1, . . . , N, cuando un emisor genera un vector DR y decide programarlos para ser enviados, primero calcula los valores de Ei para todos ellos a partir de los errores relativos acumulados en la exportación y las estimaciones de los retrasos. Luego, encuentra el valor más pequeño de estos valores. Que Ek sea el valor más pequeño. El remitente hace que δk sea cero y calcula el resto de los δs a partir de la igualdad Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) Los δs así obtenidos dan los instantes de programación del vector DR para los receptores. 4.5 Pasos del Algoritmo de Programación Para los fines de la discusión a continuación, como antes, vamos a denotar el error relativo acumulado en un remitente para el receptor k hasta DRi como Ri k. Vamos a denotar el retraso programado en el remitente antes de que DRi sea enviado al receptor k como δi k. Dada la discusión anterior, los pasos del algoritmo son los siguientes: 1. El remitente calcula DRi en el tiempo Ti y luego calcula δi k y Ri−1 k, ∀k, 1 ≤ k ≤ N basándose en la estimación de los retrasos dtk, ∀k, 1 ≤ k ≤ N según la Ecuación (1). Programa que DRi se envíe al receptor k en el tiempo Ti + δi k. 2. Los vectores DR se envían a los receptores en los horarios programados, los cuales se reciben después de un retraso de dak, ∀k, 1 ≤ k ≤ N donde dak ≤ o > dtk. Los receptores envían el valor de dak de vuelta al remitente (el receptor puede calcular este valor basándose en las marcas de tiempo en el vector DR como se describió anteriormente). 3. El remitente calcula Ri k como se describe anteriormente e ilustra en la Figura 2. El remitente también recalcula (utilizando un método de promedio exponencial similar a la estimación del tiempo de ida y vuelta por TCP [10]) la estimación del retraso dtk a partir del nuevo valor de dak para el receptor k. 4. Vuelve al Paso 1 para calcular DRi+1 cuando sea necesario y sigue los pasos del algoritmo para programar y enviar este vector DR a los receptores. 4.6 Manejo de Casos en la Práctica Hasta ahora asumimos implícitamente que DRi se envía a todos los receptores antes de tomar una decisión para calcular el siguiente vector DR DRi+1, y los receptores envían el valor de dak correspondiente a DRi y esta información llega al remitente antes de que calcule DRi+1 para que pueda calcular Ri+1 k y luego usarlo en el cálculo de δi+1 k. Dos cuestiones deben tenerse en cuenta con respecto al algoritmo anterior cuando se utiliza en la práctica. • Puede suceder que se calcule un nuevo vector DR incluso antes de que el vector DR anterior se envíe a todos los receptores. ¿Cómo se manejará esta situación? • ¿Qué sucede si la retroalimentación no llega antes de que se calcule y programe el envío de DRi+1? Consideremos el primer escenario. Suponemos que DRi ha sido programado para ser enviado y los instantes de programación son tales que δi 1 < δi 2 < · · · < δi N. Suponga que se va a calcular DRi+1 (porque la trayectoria real se ha desviado excediendo un umbral de la trayectoria exportada por DRi) en el tiempo Ti+1 donde Ti + δi k < Ti+1 < Ti + δi k+1. Esto significa que DRi ha sido enviado solo a receptores hasta k en el orden programado. En nuestro algoritmo, en este caso, se vacía la cola de ordenación de retrasos programados, lo que significa que DRi no se envía a los receptores que aún están en cola para recibirlo, pero se calcula un nuevo orden de programación para que todos los receptores envíen DRi+1. Para aquellos receptores a quienes se les ha enviado DRi, asumir por ahora que se ha recibido de todos los receptores daj, 1 ≤ j ≤ k (el escenario donde daj no ha sido recibido se considerará como parte del segundo escenario más tarde). Para estos receptores, Ei j, 1 ≤ j ≤ k se pueden calcular. Para aquellos receptores j, k + 1 ≤ j ≤ N a quienes no se les envió DRi, Ei j no aplica. Considera un receptor j, k + 1 ≤ j ≤ N a quien no se le envió DRi. Consulte la Figura 3. Para un receptor j dado, cuando se programa DRi+1 y se exporta la ruta dtj A B C D Ti-1 Gi j, DRi+1 calculado por el remitente y DRi para el receptor k+1 a N se eliminan de la cola. DRi+1 programado para el receptor k+1, Ti+1 G H E F, DRi programado para el receptor j, DRi calculado por el remitente, se coloca la ruta en el receptor k+1, Gi+1 j. Figura 3: Cálculo de programación cuando DRi no se envía al receptor j, k + 1 ≤ j ≤ N. Se necesita calcular δi+1 j, el error total de exportación es el error de exportación relativo acumulado en el tiempo Ti cuando se programó el DRi, más la integral de la distancia entre las dos trayectorias AC y BD de la Figura 3 en el intervalo de tiempo [Ti, Ti+1 + δi+1 j + dtj]. Ten en cuenta que esta integral está dada por Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj). Por lo tanto, en lugar de Ei j de la Ecuación (1), utilizamos el valor Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) donde Ri−1 j es el error relativo de exportación utilizado cuando se calculó el horario para DRi. Ahora considera el segundo escenario. Aquí el dak de retroalimentación correspondiente a DRi no ha llegado antes de que se calcule y programe DRi+1. En este caso, Ri k no se puede calcular. Por lo tanto, en el cálculo de δk para DRi+1, se asumirá que es cero. Suponemos que se utiliza un mecanismo confiable para enviar el dak de vuelta al remitente. Cuando esta información llegue en un momento posterior, Ri k se calculará y acumulará a los errores relativos de exportación futuros (por ejemplo, Ri+1 k si dak se recibe antes de que se calcule DRi+2) y se utilizará en el cálculo de δk cuando se programe un vector DR futuro (por ejemplo, DRi+2). 4.7 Resultados Experimentales Para evaluar la efectividad y cuantificar los beneficios obtenidos a través del uso del algoritmo de programación, implementamos el algoritmo propuesto en el juego BZFlag (Battle Zone Flag) [11]. Es un juego de disparos en primera persona donde los jugadores en equipos conducen tanques y se mueven dentro de un campo de batalla. El objetivo de los jugadores es navegar y capturar las banderas pertenecientes al otro equipo y llevarlas de vuelta a su propia área. Los jugadores disparan a los tanques de los demás usando balas de disparo. El movimiento de los tanques, así como el de los disparos, se intercambian entre los jugadores utilizando vectores DR. Hemos modificado la implementación de BZFlag para incorporar relojes sincronizados entre los jugadores y el servidor, y intercambiar marcas de tiempo con el vector DR. Establecimos un banco de pruebas con cuatro jugadores ejecutando la versión instrumentada de BZFlag, con uno como emisor y el resto como receptores. El enfoque de programación y el caso base en el que cada vector de DR se envió a todos los receptores simultáneamente en cada punto de activación se implementaron en la misma ejecución etiquetando los vectores de DR según el tipo de enfoque utilizado para enviar el vector de DR. NISTNet [12] se utilizó para introducir retrasos en el emisor y los tres receptores. Se introdujeron retrasos medios de 800 ms, 500 ms y 200 ms entre el emisor y el primer, segundo y tercer receptor, respectivamente. Introducimos una variación de 100 milisegundos (al retraso medio de cada receptor) para modelar la variabilidad en el retraso. El remitente registró los errores de cada receptor cada 100 milisegundos tanto para el enfoque de programación como para el caso base. El remitente también calculó la desviación estándar y la media del error de exportación acumulado de todos los receptores cada 100 milisegundos. La Figura 4 representa la media y la desviación estándar del error acumulado de exportación de todos los receptores en el caso de programación frente al caso base. Ten en cuenta que el eje x de estos gráficos (y de los demás gráficos que siguen) representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe que la desviación estándar del error con la programación es mucho menor en comparación con el caso base. Esto implica que los errores acumulados de los receptores en el caso de programación están más cerca unos de otros. Esto demuestra que el enfoque de programación logra equidad entre los receptores incluso si se encuentran a diferentes distancias (es decir, latencias) del emisor. Observe que la media del error acumulado aumentó varias veces con la programación en comparación con el caso base. La exploración adicional de la razón del aumento en la media llevó a la conclusión de que cada vez que los vectores de DR se programan de manera que igualen el error total, empuja el error total de cada receptor hacia arriba. Además, dado que el error acumulado tiene un componente estimado, el horario no es preciso para igualar los errores de los receptores, lo que provoca que el vector de DR llegue antes o después de la programación real. En cualquier caso, el error no se iguala y si el vector de DR llega tarde, en realidad aumenta el error para un receptor más allá del error acumulado más alto. Esto significa que en el próximo disparo, este receptor será el que tenga el error más alto y el error de todos los demás receptores se ajustará a este valor de error. Este efecto de cambio repentino conlleva un aumento en el error acumulado para todos los receptores. La programación para la equidad conduce a la disminución de la desviación estándar (es decir, aumenta la equidad entre los diferentes jugadores), pero esto conlleva un mayor error medio, lo cual puede no ser una característica deseable. Esto nos llevó a explorar diferentes formas de igualar los errores acumulados. El enfoque discutido en la siguiente sección es un enfoque heurístico basado en la siguiente idea. Utilizando la misma cantidad de vectores de DR a lo largo del tiempo que en el caso base, en lugar de enviar los vectores de DR a todos los receptores con la misma frecuencia que en el caso base, si podemos aumentar la frecuencia de envío de los vectores de DR al receptor con un error acumulado más alto y disminuir la frecuencia de envío de los vectores de DR al receptor con un error acumulado más bajo, podemos igualar el error de exportación de todos los receptores a lo largo del tiempo. Al mismo tiempo, deseamos disminuir el error del receptor con el error acumulado más alto en el caso base (por supuesto, este receptor recibiría más vectores DR que en el caso base). Nos referimos a dicho algoritmo como un algoritmo basado en presupuesto. ALGORITMO BASADO EN PRESUPUESTO En un juego, el remitente de una entidad envía vectores DR a todos los receptores cada vez que la entidad cruza un umbral. Al reducir el umbral, se generan más vectores de DR durante un período de tiempo dado. Dado que los vectores DR se envían a todos los receptores y el retraso de red entre los pares emisor-receptor no se puede evitar, el error antes de la exportación 3 con el jugador más distante siempre será 3. Tenga en cuenta que después de la exportación, el error se elimina mediante el uso de un reloj sincronizado entre los jugadores. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 Error acumulado promedio en segundos Algoritmo de programación del caso base #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 Desviación estándar del error acumulado en segundos Algoritmo de programación del caso base #1 Figura 4: Promedio y desviación estándar del error con programación y sin ella (es decir, caso base) serán más altos que el resto. Para mitigar el desequilibrio en el error, proponemos enviar vectores de DR selectivamente a diferentes jugadores basándonos en los errores acumulados de estos jugadores. El algoritmo basado en presupuesto se fundamenta en esta idea y existen dos variaciones de él. Uno es un esquema de presupuesto probabilístico y el otro, un esquema de presupuesto determinístico. 5.1 Esquema de presupuesto probabilístico El esquema de presupuesto probabilístico tiene tres pasos principales: a) reducir el umbral de navegación inercial pero al mismo tiempo mantener el número total de DR enviados igual que en el caso base, b) en cada disparador, elegir probabilísticamente a un jugador para enviarle el vector de DR, y c) enviar el vector de DR al jugador elegido. Estos pasos se describen a continuación. La reducción del umbral de DR se implementa de la siguiente manera. Reducir el umbral es equivalente a aumentar el número de puntos de activación donde se generan los vectores de DR. Supongamos que el umbral es tal que el número de disparadores causados por él en el caso base es t y en cada disparador se envían n vectores DR por el remitente, lo que resulta en un total de nt vectores DR. Nuestro objetivo es mantener el número total de vectores DR enviados por el remitente fijo en nt, pero reducir el número de vectores DR enviados en cada activación (es decir, no enviar el vector DR a todos los receptores). Que n y t sean el número de vectores DR enviados en cada disparo y el número de disparos respectivamente en el caso modificado. Queremos asegurarnos de que n t = nt. Dado que queremos aumentar el número de puntos de activación, es decir, t > t, esto significaría que n < n. Es decir, no todos los receptores recibirán el vector DR en cada activación. En el esquema de presupuesto probabilístico, en cada activación, se calcula una probabilidad para que cada receptor reciba un vector DR y solo un receptor recibe el DR (n = 1). Esta probabilidad se basa en los pesos relativos de los errores acumulados de los receptores. Es decir, un receptor con un error acumulado más alto tendrá una probabilidad más alta de recibir el vector DR. Ten en cuenta que el error acumulado para tres jugadores es a1, a2 y a3 respectivamente. Entonces, la probabilidad de que el jugador 1 reciba el vector DR sería a1 a1+a2+a3. Del mismo modo para los otros jugadores. Una vez que se elige al jugador, el vector DR se envía a ese jugador. Para comparar el algoritmo basado en presupuesto probabilístico con el caso base, necesitábamos reducir el umbral para el caso base (para una comparación justa). Dado que el umbral de cálculo de la posición muerta en el caso base ya era muy fino, se decidió que en lugar de reducir el umbral, se compararía el enfoque basado en el presupuesto probabilístico con un caso base modificado que utilizaría el umbral normal como algoritmo basado en el presupuesto, pero el caso base se modificó de tal manera que cada tercer disparador se usaría realmente para enviar un vector de cálculo de la posición muerta a los tres receptores utilizados en nuestros experimentos. Esto fue llamado como el caso base 1/3 ya que resultó en el envío de 1/3 del número de vectores DR en comparación con el caso base. El presupuesto por disparador para el enfoque basado en la probabilidad se calculó como un vector de DR en cada disparador en comparación con tres vectores de DR en cada tercer disparador en el caso base de 1/3; por lo tanto, los dos casos resultan en el mismo número de vectores de DR enviados con el tiempo. Para evaluar la efectividad del algoritmo de presupuesto probabilístico, instrumentamos el juego BZFlag para utilizar este enfoque. Utilizamos el mismo banco de pruebas que consistía en un emisor y tres receptores con retardos de 800ms, 500ms y 200ms desde el emisor y con baja varianza de retardo (100ms) y moderada varianza de retardo (180ms). Los resultados se muestran en las Figuras 5 y 6. Como se mencionó anteriormente, el eje x de estos gráficos representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe de las figuras que la desviación estándar del error acumulado entre los receptores con el algoritmo basado en presupuesto probabilístico es menor que el caso base de 1/3 y la media es un poco más alta que el caso base de 1/3. Esto implica que el juego es más justo en comparación con el caso base de 1/3 a costa de aumentar ligeramente el error medio en comparación con el caso base de 1/3. El aumento en el error medio en el caso probabilístico en comparación con el caso base de 1/3 se puede atribuir al hecho de que, aunque en promedio el enfoque probabilístico envía el mismo número de vectores DR que el caso base de 1/3, a veces envía vectores DR a un receptor con menos frecuencia y a veces con más frecuencia que el caso base de 1/3 debido a su naturaleza probabilística. Cuando un receptor no recibe un vector DR durante mucho tiempo, la trayectoria del receptor se aleja cada vez más de la trayectoria del emisor y, por lo tanto, la tasa de acumulación del error en el receptor es mayor. En ocasiones, cuando un receptor recibe vectores de DR con más frecuencia, acumula errores a un ritmo más bajo, pero no hay forma de revertir el error acumulado cuando no recibió un vector de DR durante mucho tiempo. Esto lleva a que los receptores acumulen más error en el caso probabilístico en comparación con el caso base de 1/3 donde los receptores reciben un vector DR casi periódicamente. Para limitar el aumento en el error medio, decidimos modificar el algoritmo basado en presupuesto para que sea determinista. Los dos primeros pasos del algoritmo son los mismos que en el algoritmo probabilístico; los puntos de activación se incrementan para reducir el umbral y los errores acumulados se utilizan para calcular la probabilidad de que un receptor reciba un vector DR. Una vez que se completen estos pasos, se calcula un horario determinista para el receptor de la siguiente manera: 1. Si hay algún receptor etiquetado para recibir un vector DR en el disparador actual, el remitente envía el vector DR al(s) receptor(es) respectivo(s). Si al menos un receptor recibió un vector DR, el remitente calcula las probabilidades de que cada receptor reciba un vector DR como se explicó anteriormente y sigue los pasos del 2 al 6; de lo contrario, no hace nada. 2. Para cada receptor, el valor de probabilidad se multiplica por el presupuesto disponible en cada activador (que se establece en 1 como se explica a continuación) para dar la frecuencia de envío del vector DR a cada receptor. Si alguna de las frecuencias de los receptores, después de multiplicarse por el presupuesto, supera 1, la frecuencia del receptor se establece en 1 y la cantidad excedente se distribuye equitativamente entre todos los receptores sumando la cantidad a sus frecuencias existentes. Este proceso se repite hasta que todos los receptores tengan una frecuencia menor o igual a 1. Esto se debe a que en un disparador no podemos enviar más de un vector DR al receptor respectivo. Eso sería un desperdicio de vectores DR al enviar información redundante. 4. (1/frecuencia) nos da el horario en el que el remitente debe enviar vectores DR al receptor respectivo. El crédito obtenido previamente (explicado en el paso 5), si lo hubiera, se resta del horario. Observe que el valor resultante del horario podría no ser un número entero; por lo tanto, el valor se redondea hacia arriba tomando el techo del horario. Por ejemplo, si la frecuencia es de 1/3.5, esto implica que nos gustaría que se enviara un vector de DR cada 3.5 disparadores. Sin embargo, estamos obligados a enviarlo en el cuarto disparo, lo que nos otorga un crédito de 0.5. Cuando enviemos el vector DR la próxima vez, podremos enviarlo en el 3er disparo debido al crédito de 0.5. La diferencia entre el horario y el límite del horario es el crédito que el receptor ha obtenido, que se recuerda para el futuro y se utiliza en el próximo momento, como se explica en el paso 4. 6. Para cada uno de esos receptores a quienes se les envió un vector DR en el disparador actual, los receptores están etiquetados para recibir el próximo vector DR en el disparador que ocurre exactamente el número de veces programado (el techo del programa) lejos del disparador actual. Observe que en este punto no se modifica el horario de ningún otro receptor, ya que todos están ejecutando un horario calculado en algún punto anterior en el tiempo. Esos horarios se modificarán automáticamente en el disparador cuando estén programados para recibir el siguiente vector de DR. En el primer disparador, el remitente envía el vector DR a todos los receptores y utiliza una probabilidad relativa de 1/n para cada receptor y sigue los pasos 2 al 6 para calcular el próximo horario para cada receptor de la misma manera que se menciona para otros disparadores. Este algoritmo garantiza que cada receptor tenga un horario garantizado para recibir vectores DR y, por lo tanto, no haya irregularidades en el envío del vector DR a ningún receptor, como se observó en el algoritmo probabilístico basado en presupuesto. Utilizamos el banco de pruebas descrito anteriormente (tres receptores con retardos variables) para evaluar el algoritmo determinista utilizando el presupuesto de 1 vector DR por activación para así utilizar el mismo número de vectores DR que en el caso base 1/3. Los resultados de nuestros experimentos se muestran en las Figuras 5 y 6. Se puede observar que la desviación estándar del error en el algoritmo basado en presupuesto determinista es menor que el caso base de 1/3 y también tiene el mismo error medio que el caso base de 1/3. Esto indica que el algoritmo determinista es más justo que el caso base de 1/3 y al mismo tiempo no aumenta el error medio, lo que conduce a una mejor calidad de juego en comparación con el algoritmo probabilístico. En general, al comparar el enfoque determinista con el enfoque probabilístico, encontramos que el error acumulado promedio siempre fue menor en el enfoque determinista. Con respecto a la desviación estándar del error acumulado, encontramos que en los casos de varianza fija o baja, el enfoque determinista fue generalmente menor, pero en casos de mayor varianza, era más difícil sacar conclusiones ya que a veces el enfoque probabilístico era mejor que el determinista. CONCLUSIONES Y TRABAJO FUTURO En los juegos multijugador distribuidos que se juegan a través de Internet, los objetos y la trayectoria de los jugadores dentro del espacio de juego se intercambian en términos de vectores DR. Debido al retraso variable entre jugadores, estos vectores DR llegan a diferentes jugadores en momentos distintos. Existe una ventaja injusta obtenida por los receptores que están más cerca del remitente del DR, ya que pueden representar la posición del remitente de manera más precisa en tiempo real. En este documento, primero desarrollamos un modelo para estimar el error en la representación de las trayectorias de los jugadores en los receptores. Luego presentamos un algoritmo basado en programar los vectores de DR para ser enviados a diferentes jugadores en diferentes momentos, igualando así el error en los diferentes jugadores. Este algoritmo tiene como objetivo hacer que el juego sea justo para todos los jugadores, pero tiende a aumentar el error promedio de los jugadores. Para contrarrestar este efecto, presentamos algoritmos basados en presupuestos donde los vectores de DR aún se programan para ser enviados a diferentes jugadores en diferentes momentos, pero el algoritmo equilibra la necesidad de equidad con el requisito de que el error de los jugadores en el peor caso (que están más lejos del remitente) no se incremente en comparación con el caso base (donde todos los vectores de DR se envían a todos los jugadores cada vez que se genera un vector de DR). Presentamos dos variaciones de los algoritmos basados en el presupuesto y, a través de experimentación, demostramos que los algoritmos reducen la desviación estándar del error, haciendo así el juego más justo y al mismo tiempo manteniendo un error medio comparable al caso base. REFERENCIAS [1] S. Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee y S. Rangarajan, Precisión en juegos distribuidos multijugador basados en Dead-Reckoning, Actas del Taller ACM SIGCOMM 2004 sobre Soporte de Redes y Sistemas para Juegos (NetGames 2004), agosto de 2004. [2] L. Gautier y C. Diot, Diseño y Evaluación de MiMaze, un juego multijugador en Internet, en Actas de IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistencia en medios interactivos continuos replicados, en Actas de la Conferencia ACM sobre Trabajo Cooperativo Asistido por Computadora (CSCW00), 2000, pp. 181-190. [4] S.K. Singhal y D.R. Cheriton, Explotando el historial de posición para una representación remota eficiente en la realidad virtual en red, Presencia: Teleoperadores y Entornos Virtuales, vol. 4, núm. 2, pp. 169-193, 1995. [5] C. Diot y L. Gautier, Una arquitectura distribuida para aplicaciones interactivas multijugador en Internet, en la revista IEEE Network, 1999, vol. 13, pp. 6-15. [6] L. Pantel y L.C. Wolf, Sobre el impacto del retraso en los juegos multijugador en tiempo real, en Actas de ACM NOSSDAV02, mayo de 2002. [7] Y. Lin, K. Guo y S. Paul, Sync-MS: Servicio de mensajería sincronizada para juegos distribuidos multijugador en tiempo real, en Actas de la 10ª Conferencia Internacional de Protocolos de Red de IEEE (ICNP), noviembre de 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan y S. Paul, Un marco de intercambio de mensajes justo para juegos distribuidos multijugador, en Actas de NetGames2003, mayo de 2003. [9] N. E. Baughman y B. N. Levine, Reproducción a prueba de trampas para juegos en línea centralizados y distribuidos, en Actas de IEEE INFOCOM01, abril de 2001. [10] M. Allman y V. Paxson, Sobre la estimación de propiedades de la ruta de red de extremo a extremo, en Actas de ACM SIGCOMM99, septiembre de 1999. [11] Foro de BZFlag, Juego de BZFlag, URL: http://www.bzflag.org. [12] Instituto Nacional de Estándares y Tecnología, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/.",
    "original_sentences": [
        "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
        "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
        "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
        "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
        "This leads to unfairness in game playing.",
        "In this paper, we first introduce an error measure for estimating this inaccuracy.",
        "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
        "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
        "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
        "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
        "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
        "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
        "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
        "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
        "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
        "During the course of the game, the players and the entities move within the game space.",
        "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
        "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
        "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
        "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
        "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
        "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
        "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
        "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
        "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
        "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
        "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
        "Therefore, the receiving players can, at best, follow the exported path.",
        "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
        "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
        "We refer to this error as the export error.",
        "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
        "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
        "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
        "That is, the placed and the exported paths match after the DR vector is received.",
        "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
        "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
        "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
        "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
        "This brings in unfairness in game playing.",
        "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
        "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
        "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
        "We propose two algorithms to achieve this.",
        "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
        "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
        "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
        "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
        "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
        "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
        "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
        "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
        "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
        "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
        "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
        "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
        "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
        "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
        "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
        "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
        "Players with a network delay larger than 100 ms simply cannot participate in the game.",
        "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
        "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
        "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
        "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
        "These additions and deletions are communicated to the game server using action messages.",
        "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
        "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
        "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
        "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
        "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
        "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
        "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
        "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
        "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
        "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
        "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
        "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
        "Conclusions are presented in Section 6. 2 3.",
        "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
        "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
        "As mentioned before, we assume synchronized clocks among the participating players.",
        "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
        "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
        "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
        "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
        "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
        "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
        "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
        "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
        "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
        "Note that the computation of time difference is feasible since all the clocks are synchronized.",
        "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
        "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
        "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
        "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
        "The horizontal axis shows the time which is synchronized among all the players.",
        "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
        "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
        "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
        "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
        "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
        "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
        "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
        "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
        "The velocity components vx1 and vy1 are used to project and render this entity further.",
        "Let us now consider the error due to network delay.",
        "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
        "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
        "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
        "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
        "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
        "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
        "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
        "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
        "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
        "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
        "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
        "As we discussed earlier, this export error is unavoidable.",
        "The above figure and example illustrates one receiver only.",
        "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
        "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
        "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
        "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
        "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
        "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
        "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
        "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
        "In this section we provide motivations for the algorithm and describe the steps it goes through.",
        "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
        "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
        "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
        "Consider the example in Figure 2.",
        "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
        "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
        "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
        "Now consider DR1.",
        "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
        "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
        "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
        "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
        "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
        "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
        "Note that the above errors from the senders perspective are only estimates.",
        "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
        "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
        "The concept of relative export error is illustrated in Figure 2.",
        "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
        "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
        "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
        "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
        "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
        "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
        "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
        "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
        "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
        "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
        "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
        "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
        "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
        "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
        "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
        "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
        "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
        "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
        "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
        "THEOREM 4.1.",
        "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
        "Assume that the premise holds for some i.",
        "We show that it holds for i+1.",
        "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
        "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
        "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
        "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
        "Note that the values of R0 1 and R0 2 are already known at the sender.",
        "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
        "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
        "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
        "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
        "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
        "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
        "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
        "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
        "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
        "This equality will hold if δ1 + dt1 = δ2 + dt2.",
        "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
        "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
        "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
        "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
        "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
        "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
        "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
        "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
        "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
        "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
        "Assume that E1 > E2.",
        "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
        "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
        "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
        "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
        "Then, it finds the smallest of these values.",
        "Let Ek be the smallest value.",
        "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
        "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
        "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
        "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
        "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
        "The sender computes Ri k as described earlier and illustrated in Figure 2.",
        "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
        "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
        "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
        "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
        "Let us consider the first scenario.",
        "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
        "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
        "This means, DRi has been sent only to receivers up to k in the scheduled order.",
        "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
        "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
        "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
        "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
        "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
        "Refer to Figure 3.",
        "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
        "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
        "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
        "Now consider the second scenario.",
        "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
        "In this case, Ri k cannot be computed.",
        "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
        "We do assume that a reliable mechanism is used to send dak back to the sender.",
        "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
        "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
        "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
        "The players shoot each others tanks using shooting bullets.",
        "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
        "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
        "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
        "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
        "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
        "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
        "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
        "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
        "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
        "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
        "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
        "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
        "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
        "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
        "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
        "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
        "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
        "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
        "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
        "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
        "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
        "This led us to explore different ways of equalizing the accumulated errors.",
        "The approach discussed in the following section is a heuristic approach based on the following idea.",
        "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
        "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
        "We refer to such an algorithm as a budget based algorithm. 5.",
        "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
        "Lower the threshold, more DR vectors are generated during a given time period.",
        "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
        "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
        "The budget based algorithm is based on this idea and there are two variations of it.",
        "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
        "These steps are described below.",
        "The lowering of DR threshold is implemented as follows.",
        "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
        "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
        "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
        "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
        "We want to ensure n t = nt.",
        "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
        "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
        "This probability is based on the relative weights of the receivers accumulated errors.",
        "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
        "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
        "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
        "Similarly for the other players.",
        "Once the player is picked, the DR vector is sent to that player.",
        "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
        "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
        "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
        "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
        "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
        "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
        "The results are shown in Figures 5 and 6.",
        "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
        "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
        "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
        "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
        "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
        "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
        "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
        "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
        "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
        "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
        "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
        "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
        "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
        "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
        "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
        "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
        "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
        "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
        "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
        "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
        "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
        "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
        "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
        "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
        "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
        "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
        "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
        "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
        "Results from our experiments are shown in Figures 5 and 6.",
        "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
        "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
        "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
        "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
        "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
        "Due to the variable delay between players, these DR vectors reach different players at different times.",
        "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
        "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
        "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
        "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
        "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
        "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
        "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
        "Singhal and D.R.",
        "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
        "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
    ],
    "translated_text_sentences": [
        "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor.",
        "El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor.",
        "Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto.",
        "Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores.",
        "Esto conduce a la injusticia en el juego.",
        "En este documento, primero presentamos una medida de error para estimar esta inexactitud.",
        "Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo.",
        "Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores.",
        "Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego.",
        "Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido.",
        "Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red.",
        "Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego.",
        "Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1.",
        "En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego.",
        "Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen.",
        "Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego.",
        "Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR).",
        "Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones.",
        "Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad.",
        "En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego.",
        "La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo.",
        "Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador.",
        "Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral.",
        "Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada.",
        "Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada.",
        "El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales.",
        "Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico.",
        "Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada.",
        "Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya.",
        "Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada).",
        "Nos referimos a este error como el error de exportación.",
        "Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas.",
        "El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación).",
        "En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero.",
        "Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR.",
        "También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1].",
        "De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño.",
        "En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores.",
        "Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores.",
        "Esto introduce injusticia en el juego.",
        "Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada.",
        "Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores.",
        "Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente.",
        "Proponemos dos algoritmos para lograr esto.",
        "Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores.",
        "A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales.",
        "El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo.",
        "El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR.",
        "A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error).",
        "La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR).",
        "Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores.",
        "A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca.",
        "Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado.",
        "Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la precisión del juego.",
        "Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2.",
        "Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4].",
        "Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores.",
        "Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado.",
        "El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de sincronización de cubo estático para compensar las variaciones en los retrasos de la red.",
        "En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota.",
        "Los jugadores con un retraso de red mayor a 100 ms simplemente no pueden participar en el juego.",
        "En general, las técnicas basadas en la sincronización de cubetas dependen de imponer un retraso máximo en todos los jugadores.",
        "Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados.",
        "Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego.",
        "Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto).",
        "Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción.",
        "Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización.",
        "La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores.",
        "Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras.",
        "En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego.",
        "Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor).",
        "Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la sincronización de cubos no son a prueba de trampas a menos que se implementen mecanismos adicionales.",
        "Tanto el algoritmo de programación como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas.",
        "Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida.",
        "Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño.",
        "En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1].",
        "En la Sección 4, describimos el algoritmo de programación de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFlag.",
        "La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de precisión en el juego.",
        "Las conclusiones se presentan en la Sección 6.2.3.",
        "MODELO DE JUEGO La arquitectura del juego se basa en jugadores distribuidos a través de Internet que intercambian vectores DR entre sí.",
        "Los vectores de DR podrían ser enviados directamente de un jugador a otro (modelo peer-to-peer) o podrían ser enviados a través de un servidor de juego que recibe el vector de DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor).",
        "Como se mencionó anteriormente, asumimos que los relojes de los jugadores participantes están sincronizados.",
        "Cada vector DR enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad.",
        "Suponemos un vector DR lineal en el que la información contenida en el vector DR es solo suficiente para que el jugador receptor calcule la trayectoria y represente la entidad en un camino en línea recta.",
        "Un vector DR de este tipo contiene información sobre la posición inicial y la velocidad del jugador/entidad, donde la velocidad es constante.",
        "Por lo tanto, los vectores DR enviados por un jugador especifican el tiempo actual en el jugador cuando se calcula el vector DR (no el tiempo en el que este vector DR se envía a los otros jugadores, como explicaremos más adelante), la posición actual del jugador/entidad en términos de las coordenadas x, y, z y el vector de velocidad en la dirección de las coordenadas x, y, z.",
        "Específicamente, el vector DRi enviado por el jugador j sobre la k-ésima entidad se denota como DRj ik y está representado por la siguiente tupla (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
        "Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y para una sola entidad.",
        "Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional.",
        "Por lo tanto, usamos DRi para denotar el i-ésimo vector DR representado como la tupla (Ti, xi, yi, vxi, vyi).",
        "El jugador receptor calcula la posición inicial para la entidad basándose en xi, yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo Ti en el que fue calculado.",
        "Ten en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados.",
        "El jugador receptor luego utiliza los componentes de velocidad para proyectar y representar la trayectoria de la entidad.",
        "Esta trayectoria se sigue hasta que se recibe un nuevo vector DR que cambia la posición y/o velocidad de la entidad. tiempoT1 Real Exportado Colocado dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) calculado en el tiempo T1 y enviado al receptor DR0 = (T0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptor T0 dt0 Colocado E Figura 1: Trayectorias y desviaciones.",
        "Basado en este modelo, la Figura 1 ilustra el envío y recepción de vectores DR y los diferentes errores que se encuentran. Otros tipos de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y vectores DR de spline cúbico que consideran la posición y velocidad inicial y la posición y velocidad final de la entidad.",
        "La figura muestra la recepción de vectores de DR en un jugador (en adelante llamado receptor).",
        "El eje horizontal muestra el tiempo que está sincronizado entre todos los jugadores.",
        "El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad.",
        "Suponga que en el tiempo T0 se calcula un vector DR0 por el remitente y se envía inmediatamente al receptor.",
        "Supongamos que DR0 es recibido por el receptor después de un retraso de dt0 unidades de tiempo.",
        "El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (mostrado como punto E).",
        "La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor basada en los componentes de velocidad vx0 y vy0 (ruta colocada).",
        "En el tiempo T1 se calcula un vector DR1 de enrutamiento dinámico para la misma entidad y se envía inmediatamente al receptor2.",
        "Suponga que DR1 es recibido por el receptor después de un retraso de dt1 unidades de tiempo.",
        "Cuando se recibe este vector DR, se asume que la entidad está en el punto D. Se calcula una nueva posición para la entidad como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto C).",
        "Los componentes de velocidad vx1 y vy1 se utilizan para proyectar y representar esta entidad más lejos.",
        "Ahora consideremos el error debido al retraso de la red.",
        "Aunque DR1 se calculó en el tiempo T1 y se envió al receptor, no llegó al receptor hasta el tiempo T1 + dt1.",
        "Esto significa que, aunque la ruta exportada basada en DR1 en el remitente en el tiempo T1 es la trayectoria AC, hasta el tiempo T1 + dt1, en el receptor, esta entidad estaba siendo representada en la trayectoria BD basada en DR0.",
        "Solo en el momento T1 + dt1 la entidad se movió al punto C, a partir del cual los caminos exportados y colocados son iguales.",
        "La desviación entre las rutas exportadas y colocadas crea un componente de error al que nos referimos como el error de exportación.",
        "Una forma de representar el error de exportación es calcular la integral de la distancia entre las dos trayectorias durante el tiempo en que están desincronizadas.",
        "Representamos la integral de las distancias entre las rutas colocadas y exportadas debido a algunos DR DRi en un intervalo de tiempo [t1, t2] como Err(DRi, t1, t2).",
        "En la figura, el error de exportación debido a DR1 se calcula como la integral de la distancia entre las trayectorias AC y BD en el intervalo de tiempo [T1, T1 + dt1].",
        "Ten en cuenta que también podría haber otras formas de representar este error, pero en este artículo utilizamos la integral de la distancia entre las dos trayectorias como medida del error de exportación.",
        "Tenga en cuenta que se habría producido un error de exportación debido a la recepción de DR0, momento en el que la ruta colocada se basaría en un vector DR anterior.",
        "Esto no se muestra en la figura, pero sirve para recordar al lector que el error de exportación es acumulativo cuando se reciben una secuencia de vectores DR.",
        "A partir del tiempo T1 en adelante, hay una desviación entre las trayectorias reales y las exportadas.",
        "Como discutimos anteriormente, este error de exportación es inevitable.",
        "La figura y el ejemplo anterior ilustran solo un receptor.",
        "Pero en realidad, los vectores DR DR0 y DR1 son enviados por el remitente a todos los jugadores participantes.",
        "Cada uno de estos jugadores recibe DR0 y DR1 después de diferentes retrasos, creando así diferentes valores de error de exportación en cada jugador.",
        "El objetivo del algoritmo de programación de vectores DR que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual en cada jugador de forma independiente para cada una de las entidades que conforman el juego.",
        "ALGORITMO DE PROGRAMACIÓN PARA EL ENVÍO DE VECTORES DR En la Sección 3 mostramos cómo el retraso desde el remitente de un nuevo vector DR 2 Normalmente, los vectores DR no se calculan de forma periódica, sino bajo demanda, donde la decisión de calcular un nuevo vector DR se basa en la superación de un umbral en la desviación entre la ruta real y la ruta exportada por el vector DR anterior. 3 vector al receptor del vector DR podría llevar a un error de exportación debido a la desviación de la ruta colocada de la ruta exportada en el receptor hasta que se reciba este nuevo vector DR.",
        "También mencionamos que el objetivo del algoritmo de programación de vectores DR es igualar el error de exportación en todos los receptores durante un período de tiempo.",
        "Dado que el juego se juega en un entorno distribuido, tiene sentido que el remitente de una entidad lleve un registro de todos los errores en los receptores e intente igualarlos.",
        "Sin embargo, el remitente no puede conocer el error real en un receptor hasta que reciba alguna información sobre el error del receptor.",
        "Nuestro algoritmo estima el error para calcular un horario para enviar vectores DR a los receptores y corrige el error cuando recibe retroalimentación de los receptores.",
        "En esta sección proporcionamos las motivaciones para el algoritmo y describimos los pasos por los que atraviesa.",
        "A lo largo de esta sección, utilizaremos el siguiente ejemplo para ilustrar el algoritmo. tiempoT1 Ruta exportada Ruta colocada en el receptor 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 enviado al receptor 1 DR1 enviado al receptor 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimado para ser recibido por el receptor 2 DR1 estimado para ser recibido por el receptor 1 DR1 recibido realmente por el receptor 1 DR1 recibido realmente por el receptor 2 DR0 enviado a ambos receptores DR1 calculado por el remitente Ruta colocada en el receptor 1 Figura 2: Flujo de vector DR entre un remitente y dos receptores y la evolución de las rutas colocadas estimadas y reales en los receptores.",
        "DR0 = (T0, T0, x0, y0, vx0, vy0), enviado en el tiempo T0 a ambos receptores.",
        "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) enviado en el tiempo T1 1 = T1+δ1 al receptor 1 y DR1 = (T1, T2 1 , x1, y1, vx1, vy1) enviado en el tiempo T2 1 = T1 + δ2 al receptor 2.",
        "Considera el ejemplo en la Figura 2.",
        "La figura muestra un único emisor enviando vectores DR para una entidad a dos receptores diferentes 1 y 2.",
        "DR0 calculado en T0 es enviado y recibido por los receptores en algún momento entre T0 y T1, momento en el cual mueven la ubicación de la entidad para que coincida con la ruta exportada.",
        "Por lo tanto, la trayectoria de la entidad se muestra solo desde el punto en que la trayectoria colocada coincide con la trayectoria exportada para DR0.",
        "Ahora considera DR1.",
        "En el tiempo T1, DR1 es calculado por el remitente, pero se asume que no es enviado inmediatamente a los receptores y solo se envía después de un tiempo δ1 al receptor 1 (en el tiempo T1 1 = T1 + δ1) y después de un tiempo δ2 al receptor 2 (en el tiempo T2 1 = T1 + δ2).",
        "Ten en cuenta que el remitente incluye la marca de tiempo de envío con el vector DR como se muestra en la figura.",
        "Supongamos que el remitente estima (pronto quedará claro por qué el remitente tiene que estimar el retraso) que después de un retraso de dt1, el receptor 1 lo recibirá, utilizará los parámetros de coordenadas y velocidad para calcular la ubicación actual de la entidad y moverla allí (punto C) y a partir de ese momento, los caminos exportado y colocado serán iguales.",
        "Sin embargo, en realidad, el receptor 1 recibe DR1 después de un retraso de da1 (que es menor que las estimaciones de los remitentes de dt1), y mueve la entidad correspondiente al punto H. De manera similar, el remitente estima que después de un retraso de dt2, el receptor 2 recibirá DR1, calculará la ubicación actual de la entidad y la moverá a ese punto (punto E), mientras que en realidad recibe DR1 después de un retraso de da2 > dt2 y mueve la entidad al punto N. Los otros puntos mostrados en las rutas colocadas y exportadas se utilizarán más adelante en la discusión para describir diferentes componentes de error. 4.1 Cálculo del Error de Exportación Relativo Volviendo a la discusión de la Sección 3, desde la perspectiva de los remitentes, el error de exportación en el receptor 1 debido a DR1 se da por Err(DR1, T1, T1 + δ1 + dt1) (la integral de la distancia entre las trayectorias AC y DB en el intervalo de tiempo [T1, T1 + δ1 + dt1]) de la Figura 2.",
        "Esto se debe a que el remitente utiliza el retraso estimado dt1 para calcular este error.",
        "De manera similar, el error de exportación desde la perspectiva del remitente en el recibido 2 debido a DR1 se da por Err(DR1, T1, T1 + δ2 + dt2) (la integral de la distancia entre las trayectorias AE y DF en el intervalo de tiempo [T1, T1 + δ2 + dt2]).",
        "Ten en cuenta que los errores anteriores desde la perspectiva del remitente son solo estimaciones.",
        "En realidad, el error de exportación será tanto menor como mayor que el valor estimado, dependiendo de si la estimación de retraso fue mayor o menor que el retraso real experimentado por DR1.",
        "La diferencia entre el error de exportación estimado y el real es el error de exportación relativo (que puede ser positivo o negativo) que ocurre para cada vector de DR que se envía y se acumula en el remitente.",
        "El concepto de error relativo de exportación se ilustra en la Figura 2.",
        "Dado que el retraso actual al receptor 1 es da1, el error de exportación inducido por DR1 en el receptor 1 es Err(DR1, T1, T1 + δ1 + da1).",
        "Esto significa que hay un error en el error estimado de exportación y el remitente solo puede calcular este error después de recibir un comentario del receptor sobre la demora real en la entrega de DR1, es decir, el valor de da1.",
        "Proponemos que una vez que el receptor 1 reciba DR1, envíe el valor de da1 de vuelta al remitente.",
        "El receptor puede calcular esta información ya que conoce el momento en que se envió DR1 (T1 1 = T1 + δ1, que se añade al vector DR como se muestra en la Figura 2) y el tiempo local de recepción (que está sincronizado con el reloj del emisor).",
        "Por lo tanto, el remitente calcula el error relativo de exportación para el receptor 1, representado como R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1). De manera similar, el error relativo de exportación para el receptor 2 se calcula como R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2). Nótese que R1 > 0 ya que da1 < dt1, y R2 < 0 ya que da2 > dt2.",
        "Los errores relativos de exportación son calculados por el remitente en el momento en que recibe la retroalimentación de los destinatarios.",
        "Este ejemplo muestra los 4 valores relativos de error de exportación después de que se envía DR1 y se reciben los comentarios correspondientes. 4.2 Igualación del Error Entre Receptores Ahora explicamos lo que queremos decir al hacer que los errores sean iguales en todos los receptores y cómo se puede lograr esto.",
        "Como se mencionó anteriormente, el remitente mantiene estimaciones de los retrasos a los receptores, dt1 y dt2 en el ejemplo de la Figura 2.",
        "Esto indica que en el momento T1 cuando se calcula DR1, el remitente ya sabe cuánto tiempo pueden tardar los mensajes que llevan este vector DR en llegar a los receptores.",
        "El remitente utiliza esta información para calcular los errores de exportación, que son Err(DR1, T1, T1 + δ1 + dt1) y Err(DR1, T1, T1 + δ2 + dt2) para los receptores 1 y 2, respectivamente.",
        "Ten en cuenta que las áreas de estos componentes de error son una función de δ1 y δ2, así como de las demoras de red dt1 y dt2.",
        "Si queremos que los errores de exportación debido a DR1 sean iguales en ambos receptores, el remitente debe elegir δ1 y δ2 de manera que Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
        "Pero cuando se calculó T1, ya podría haberse acumulado errores relativos de exportación debido a los vectores DR anteriores (DR0 y los anteriores).",
        "Representemos el error relativo acumulado hasta DRi para el receptor j como Ri j.",
        "Para acomodar estos errores relativos acumulados, el remitente debe elegir ahora δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Los δi determinan el instante de programación del vector DR en el remitente para el receptor i.",
        "Este método de cálculo de δs garantiza que el error de exportación acumulado (es decir, el error total real) para cada receptor se iguala en la transmisión de cada vector DR.",
        "Para establecer esto, asuma que la retroalimentación para el vector DR Di de un receptor llega al remitente antes de que se calcule el horario para Di+1.",
        "Que Si m y Ai m denoten el error estimado para el receptor m utilizado para calcular el horario para Di y el error acumulado para el receptor m calculado después de recibir retroalimentación para Di, respectivamente.",
        "Entonces Ri m = Ai m − Si m. Para calcular las instancias de programación (es decir, δs) para Di, para cualquier par de receptores m y n, hacemos Ri−1 m + Si m = Ri−1 n + Si n. El siguiente teorema establece el hecho de que el error acumulado de exportación se iguala en cada instante de programación.",
        "TEOREMA 4.1.",
        "Cuando se calculan las instancias de horario para enviar Di a cualquier par de receptores m y n, se cumple la siguiente condición: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Prueba: Por inducción.",
        "Supongamos que la premisa se cumple para algún i.",
        "Mostramos que se cumple para i+1.",
        "El caso base para i = 1 se cumple ya que inicialmente R0 m = R0 n = 0, y se utiliza S1 m = S1 n para calcular las instancias de programación.",
        "Para calcular el horario de Di+1, primero calculamos los errores relativos como Ri m = Ai m − Si m y Ri n = Ai n − Si n. Luego, para calcular δs, ejecutamos Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n.",
        "Añadiendo la condición de la premisa en ambos lados obtenemos, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n. 4.3 Cálculo del Error de Exportación. Ahora consideremos cómo se pueden calcular los errores de exportación.",
        "De la sección anterior, para encontrar δ1 y δ2 necesitamos encontrar Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2).",
        "Se debe tener en cuenta que los valores de R0 1 y R0 2 ya son conocidos en el remitente.",
        "Considera el cálculo de Err(DR1, T1, T1 +δ1 +dt1).",
        "Esta es la integral de la distancia entre las trayectorias AC debido a DR1 y BD debido a DR0.",
        "A partir de DR0 y DR1, el punto A es (X1, Y1) = (x1, y1) y el punto B es (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
        "La trayectoria AC puede ser representada como una función del tiempo como (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) y la trayectoria de BD puede ser representada como (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
        "La distancia entre las dos trayectorias como función del tiempo se convierte entonces en, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Sea a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Entonces dist(t) se puede escribir como dist(t) = a × t2 + b × t + c. Luego Err(DR1, t1, t2) para algún intervalo de tiempo [t1, t2] se convierte en t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
        "Una solución en forma cerrada para la integral indefinida a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2) pueden entonces ser calculadas aplicando los límites apropiados a la solución anterior.",
        "En la siguiente sección, consideramos el cálculo de los δs para N receptores. 5 4.4 Cálculo de Instantes de Programación Volvemos a analizar el cálculo de los δs haciendo referencia a la Figura 2.",
        "El remitente elige δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 + Err(DR1, T1, T1 + δ2 +dt2).",
        "Si R0 1 y R0 2 ambos son cero, entonces δ1 y δ2 deben ser elegidos de tal manera que Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
        "Esta igualdad se mantendrá si δ1 + dt1 = δ2 + dt2.",
        "Por lo tanto, si no hay error acumulado relativo de exportación, todo lo que el remitente necesita hacer es elegir los δs de tal manera que contrarresten la diferencia en el retraso a los dos receptores, para que reciban el vector DR al mismo tiempo.",
        "Como se discutió anteriormente, dado que el remitente no puede aprender de antemano el retraso, siempre habrá un error relativo acumulado de exportación de un vector DR previo que debe tenerse en cuenta.",
        "Para profundizar en esto, considera el cálculo del error de exportación como se ilustra en la sección anterior.",
        "Para calcular los δs necesitamos que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
        "Es decir, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
        "Eso es R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
        "Los componentes R0 1, R0 2, ya son conocidos por (o estimados por) el remitente.",
        "Además, los componentes de error T1+dt1 T1 dist(t) dt y T1+dt2 T1 dist(t) dt pueden ser calculados a priori por el remitente utilizando valores estimados de dt1 y dt2.",
        "Usemos E1 para denotar R0 1 + T1+dt1 T1 dist(t) dt y E2 para denotar R0 2 + T1+dt2 T1 dist(t) dt.",
        "Entonces, requerimos que E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
        "Suponga que E1 > E2.",
        "Entonces, para que la ecuación anterior se cumpla, requerimos que T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
        "Para hacer el juego lo más rápido posible dentro de este marco, los valores de δ deben ser lo más pequeños posible para que los vectores DR se envíen a los receptores lo antes posible, sujeto al requisito de equidad.",
        "Dado esto, elegiríamos δ1 como cero y calcularíamos δ2 a partir de la ecuación E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
        "En general, si hay N receptores 1, . . . , N, cuando un emisor genera un vector DR y decide programarlos para ser enviados, primero calcula los valores de Ei para todos ellos a partir de los errores relativos acumulados en la exportación y las estimaciones de los retrasos.",
        "Luego, encuentra el valor más pequeño de estos valores.",
        "Que Ek sea el valor más pequeño.",
        "El remitente hace que δk sea cero y calcula el resto de los δs a partir de la igualdad Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) Los δs así obtenidos dan los instantes de programación del vector DR para los receptores. 4.5 Pasos del Algoritmo de Programación Para los fines de la discusión a continuación, como antes, vamos a denotar el error relativo acumulado en un remitente para el receptor k hasta DRi como Ri k. Vamos a denotar el retraso programado en el remitente antes de que DRi sea enviado al receptor k como δi k. Dada la discusión anterior, los pasos del algoritmo son los siguientes: 1.",
        "El remitente calcula DRi en el tiempo Ti y luego calcula δi k y Ri−1 k, ∀k, 1 ≤ k ≤ N basándose en la estimación de los retrasos dtk, ∀k, 1 ≤ k ≤ N según la Ecuación (1).",
        "Programa que DRi se envíe al receptor k en el tiempo Ti + δi k. 2.",
        "Los vectores DR se envían a los receptores en los horarios programados, los cuales se reciben después de un retraso de dak, ∀k, 1 ≤ k ≤ N donde dak ≤ o > dtk.",
        "Los receptores envían el valor de dak de vuelta al remitente (el receptor puede calcular este valor basándose en las marcas de tiempo en el vector DR como se describió anteriormente). 3.",
        "El remitente calcula Ri k como se describe anteriormente e ilustra en la Figura 2.",
        "El remitente también recalcula (utilizando un método de promedio exponencial similar a la estimación del tiempo de ida y vuelta por TCP [10]) la estimación del retraso dtk a partir del nuevo valor de dak para el receptor k. 4.",
        "Vuelve al Paso 1 para calcular DRi+1 cuando sea necesario y sigue los pasos del algoritmo para programar y enviar este vector DR a los receptores. 4.6 Manejo de Casos en la Práctica Hasta ahora asumimos implícitamente que DRi se envía a todos los receptores antes de tomar una decisión para calcular el siguiente vector DR DRi+1, y los receptores envían el valor de dak correspondiente a DRi y esta información llega al remitente antes de que calcule DRi+1 para que pueda calcular Ri+1 k y luego usarlo en el cálculo de δi+1 k.",
        "Dos cuestiones deben tenerse en cuenta con respecto al algoritmo anterior cuando se utiliza en la práctica. • Puede suceder que se calcule un nuevo vector DR incluso antes de que el vector DR anterior se envíe a todos los receptores.",
        "¿Cómo se manejará esta situación? • ¿Qué sucede si la retroalimentación no llega antes de que se calcule y programe el envío de DRi+1?",
        "Consideremos el primer escenario.",
        "Suponemos que DRi ha sido programado para ser enviado y los instantes de programación son tales que δi 1 < δi 2 < · · · < δi N.",
        "Suponga que se va a calcular DRi+1 (porque la trayectoria real se ha desviado excediendo un umbral de la trayectoria exportada por DRi) en el tiempo Ti+1 donde Ti + δi k < Ti+1 < Ti + δi k+1.",
        "Esto significa que DRi ha sido enviado solo a receptores hasta k en el orden programado.",
        "En nuestro algoritmo, en este caso, se vacía la cola de ordenación de retrasos programados, lo que significa que DRi no se envía a los receptores que aún están en cola para recibirlo, pero se calcula un nuevo orden de programación para que todos los receptores envíen DRi+1.",
        "Para aquellos receptores a quienes se les ha enviado DRi, asumir por ahora que se ha recibido de todos los receptores daj, 1 ≤ j ≤ k (el escenario donde daj no ha sido recibido se considerará como parte del segundo escenario más tarde).",
        "Para estos receptores, Ei j, 1 ≤ j ≤ k se pueden calcular.",
        "Para aquellos receptores j, k + 1 ≤ j ≤ N a quienes no se les envió DRi, Ei j no aplica.",
        "Considera un receptor j, k + 1 ≤ j ≤ N a quien no se le envió DRi.",
        "Consulte la Figura 3.",
        "Para un receptor j dado, cuando se programa DRi+1 y se exporta la ruta dtj A B C D Ti-1 Gi j, DRi+1 calculado por el remitente y DRi para el receptor k+1 a N se eliminan de la cola. DRi+1 programado para el receptor k+1, Ti+1 G H E F, DRi programado para el receptor j, DRi calculado por el remitente, se coloca la ruta en el receptor k+1, Gi+1 j. Figura 3: Cálculo de programación cuando DRi no se envía al receptor j, k + 1 ≤ j ≤ N. Se necesita calcular δi+1 j, el error total de exportación es el error de exportación relativo acumulado en el tiempo Ti cuando se programó el DRi, más la integral de la distancia entre las dos trayectorias AC y BD de la Figura 3 en el intervalo de tiempo [Ti, Ti+1 + δi+1 j + dtj].",
        "Ten en cuenta que esta integral está dada por Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
        "Por lo tanto, en lugar de Ei j de la Ecuación (1), utilizamos el valor Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) donde Ri−1 j es el error relativo de exportación utilizado cuando se calculó el horario para DRi.",
        "Ahora considera el segundo escenario.",
        "Aquí el dak de retroalimentación correspondiente a DRi no ha llegado antes de que se calcule y programe DRi+1.",
        "En este caso, Ri k no se puede calcular.",
        "Por lo tanto, en el cálculo de δk para DRi+1, se asumirá que es cero.",
        "Suponemos que se utiliza un mecanismo confiable para enviar el dak de vuelta al remitente.",
        "Cuando esta información llegue en un momento posterior, Ri k se calculará y acumulará a los errores relativos de exportación futuros (por ejemplo, Ri+1 k si dak se recibe antes de que se calcule DRi+2) y se utilizará en el cálculo de δk cuando se programe un vector DR futuro (por ejemplo, DRi+2). 4.7 Resultados Experimentales Para evaluar la efectividad y cuantificar los beneficios obtenidos a través del uso del algoritmo de programación, implementamos el algoritmo propuesto en el juego BZFlag (Battle Zone Flag) [11].",
        "Es un juego de disparos en primera persona donde los jugadores en equipos conducen tanques y se mueven dentro de un campo de batalla.",
        "El objetivo de los jugadores es navegar y capturar las banderas pertenecientes al otro equipo y llevarlas de vuelta a su propia área.",
        "Los jugadores disparan a los tanques de los demás usando balas de disparo.",
        "El movimiento de los tanques, así como el de los disparos, se intercambian entre los jugadores utilizando vectores DR.",
        "Hemos modificado la implementación de BZFlag para incorporar relojes sincronizados entre los jugadores y el servidor, y intercambiar marcas de tiempo con el vector DR.",
        "Establecimos un banco de pruebas con cuatro jugadores ejecutando la versión instrumentada de BZFlag, con uno como emisor y el resto como receptores.",
        "El enfoque de programación y el caso base en el que cada vector de DR se envió a todos los receptores simultáneamente en cada punto de activación se implementaron en la misma ejecución etiquetando los vectores de DR según el tipo de enfoque utilizado para enviar el vector de DR.",
        "NISTNet [12] se utilizó para introducir retrasos en el emisor y los tres receptores.",
        "Se introdujeron retrasos medios de 800 ms, 500 ms y 200 ms entre el emisor y el primer, segundo y tercer receptor, respectivamente.",
        "Introducimos una variación de 100 milisegundos (al retraso medio de cada receptor) para modelar la variabilidad en el retraso.",
        "El remitente registró los errores de cada receptor cada 100 milisegundos tanto para el enfoque de programación como para el caso base.",
        "El remitente también calculó la desviación estándar y la media del error de exportación acumulado de todos los receptores cada 100 milisegundos.",
        "La Figura 4 representa la media y la desviación estándar del error acumulado de exportación de todos los receptores en el caso de programación frente al caso base.",
        "Ten en cuenta que el eje x de estos gráficos (y de los demás gráficos que siguen) representa el tiempo del sistema cuando se tomó la instantánea del juego.",
        "Observe que la desviación estándar del error con la programación es mucho menor en comparación con el caso base.",
        "Esto implica que los errores acumulados de los receptores en el caso de programación están más cerca unos de otros.",
        "Esto demuestra que el enfoque de programación logra equidad entre los receptores incluso si se encuentran a diferentes distancias (es decir, latencias) del emisor.",
        "Observe que la media del error acumulado aumentó varias veces con la programación en comparación con el caso base.",
        "La exploración adicional de la razón del aumento en la media llevó a la conclusión de que cada vez que los vectores de DR se programan de manera que igualen el error total, empuja el error total de cada receptor hacia arriba.",
        "Además, dado que el error acumulado tiene un componente estimado, el horario no es preciso para igualar los errores de los receptores, lo que provoca que el vector de DR llegue antes o después de la programación real.",
        "En cualquier caso, el error no se iguala y si el vector de DR llega tarde, en realidad aumenta el error para un receptor más allá del error acumulado más alto.",
        "Esto significa que en el próximo disparo, este receptor será el que tenga el error más alto y el error de todos los demás receptores se ajustará a este valor de error.",
        "Este efecto de cambio repentino conlleva un aumento en el error acumulado para todos los receptores.",
        "La programación para la equidad conduce a la disminución de la desviación estándar (es decir, aumenta la equidad entre los diferentes jugadores), pero esto conlleva un mayor error medio, lo cual puede no ser una característica deseable.",
        "Esto nos llevó a explorar diferentes formas de igualar los errores acumulados.",
        "El enfoque discutido en la siguiente sección es un enfoque heurístico basado en la siguiente idea.",
        "Utilizando la misma cantidad de vectores de DR a lo largo del tiempo que en el caso base, en lugar de enviar los vectores de DR a todos los receptores con la misma frecuencia que en el caso base, si podemos aumentar la frecuencia de envío de los vectores de DR al receptor con un error acumulado más alto y disminuir la frecuencia de envío de los vectores de DR al receptor con un error acumulado más bajo, podemos igualar el error de exportación de todos los receptores a lo largo del tiempo.",
        "Al mismo tiempo, deseamos disminuir el error del receptor con el error acumulado más alto en el caso base (por supuesto, este receptor recibiría más vectores DR que en el caso base).",
        "Nos referimos a dicho algoritmo como un algoritmo basado en presupuesto.",
        "ALGORITMO BASADO EN PRESUPUESTO En un juego, el remitente de una entidad envía vectores DR a todos los receptores cada vez que la entidad cruza un umbral.",
        "Al reducir el umbral, se generan más vectores de DR durante un período de tiempo dado.",
        "Dado que los vectores DR se envían a todos los receptores y el retraso de red entre los pares emisor-receptor no se puede evitar, el error antes de la exportación 3 con el jugador más distante siempre será 3. Tenga en cuenta que después de la exportación, el error se elimina mediante el uso de un reloj sincronizado entre los jugadores. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 Error acumulado promedio en segundos Algoritmo de programación del caso base #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 Desviación estándar del error acumulado en segundos Algoritmo de programación del caso base #1 Figura 4: Promedio y desviación estándar del error con programación y sin ella (es decir, caso base) serán más altos que el resto.",
        "Para mitigar el desequilibrio en el error, proponemos enviar vectores de DR selectivamente a diferentes jugadores basándonos en los errores acumulados de estos jugadores.",
        "El algoritmo basado en presupuesto se fundamenta en esta idea y existen dos variaciones de él.",
        "Uno es un esquema de presupuesto probabilístico y el otro, un esquema de presupuesto determinístico. 5.1 Esquema de presupuesto probabilístico El esquema de presupuesto probabilístico tiene tres pasos principales: a) reducir el umbral de navegación inercial pero al mismo tiempo mantener el número total de DR enviados igual que en el caso base, b) en cada disparador, elegir probabilísticamente a un jugador para enviarle el vector de DR, y c) enviar el vector de DR al jugador elegido.",
        "Estos pasos se describen a continuación.",
        "La reducción del umbral de DR se implementa de la siguiente manera.",
        "Reducir el umbral es equivalente a aumentar el número de puntos de activación donde se generan los vectores de DR.",
        "Supongamos que el umbral es tal que el número de disparadores causados por él en el caso base es t y en cada disparador se envían n vectores DR por el remitente, lo que resulta en un total de nt vectores DR.",
        "Nuestro objetivo es mantener el número total de vectores DR enviados por el remitente fijo en nt, pero reducir el número de vectores DR enviados en cada activación (es decir, no enviar el vector DR a todos los receptores).",
        "Que n y t sean el número de vectores DR enviados en cada disparo y el número de disparos respectivamente en el caso modificado.",
        "Queremos asegurarnos de que n t = nt.",
        "Dado que queremos aumentar el número de puntos de activación, es decir, t > t, esto significaría que n < n. Es decir, no todos los receptores recibirán el vector DR en cada activación.",
        "En el esquema de presupuesto probabilístico, en cada activación, se calcula una probabilidad para que cada receptor reciba un vector DR y solo un receptor recibe el DR (n = 1).",
        "Esta probabilidad se basa en los pesos relativos de los errores acumulados de los receptores.",
        "Es decir, un receptor con un error acumulado más alto tendrá una probabilidad más alta de recibir el vector DR.",
        "Ten en cuenta que el error acumulado para tres jugadores es a1, a2 y a3 respectivamente.",
        "Entonces, la probabilidad de que el jugador 1 reciba el vector DR sería a1 a1+a2+a3.",
        "Del mismo modo para los otros jugadores.",
        "Una vez que se elige al jugador, el vector DR se envía a ese jugador.",
        "Para comparar el algoritmo basado en presupuesto probabilístico con el caso base, necesitábamos reducir el umbral para el caso base (para una comparación justa).",
        "Dado que el umbral de cálculo de la posición muerta en el caso base ya era muy fino, se decidió que en lugar de reducir el umbral, se compararía el enfoque basado en el presupuesto probabilístico con un caso base modificado que utilizaría el umbral normal como algoritmo basado en el presupuesto, pero el caso base se modificó de tal manera que cada tercer disparador se usaría realmente para enviar un vector de cálculo de la posición muerta a los tres receptores utilizados en nuestros experimentos.",
        "Esto fue llamado como el caso base 1/3 ya que resultó en el envío de 1/3 del número de vectores DR en comparación con el caso base.",
        "El presupuesto por disparador para el enfoque basado en la probabilidad se calculó como un vector de DR en cada disparador en comparación con tres vectores de DR en cada tercer disparador en el caso base de 1/3; por lo tanto, los dos casos resultan en el mismo número de vectores de DR enviados con el tiempo.",
        "Para evaluar la efectividad del algoritmo de presupuesto probabilístico, instrumentamos el juego BZFlag para utilizar este enfoque.",
        "Utilizamos el mismo banco de pruebas que consistía en un emisor y tres receptores con retardos de 800ms, 500ms y 200ms desde el emisor y con baja varianza de retardo (100ms) y moderada varianza de retardo (180ms).",
        "Los resultados se muestran en las Figuras 5 y 6.",
        "Como se mencionó anteriormente, el eje x de estos gráficos representa el tiempo del sistema cuando se tomó la instantánea del juego.",
        "Observe de las figuras que la desviación estándar del error acumulado entre los receptores con el algoritmo basado en presupuesto probabilístico es menor que el caso base de 1/3 y la media es un poco más alta que el caso base de 1/3.",
        "Esto implica que el juego es más justo en comparación con el caso base de 1/3 a costa de aumentar ligeramente el error medio en comparación con el caso base de 1/3.",
        "El aumento en el error medio en el caso probabilístico en comparación con el caso base de 1/3 se puede atribuir al hecho de que, aunque en promedio el enfoque probabilístico envía el mismo número de vectores DR que el caso base de 1/3, a veces envía vectores DR a un receptor con menos frecuencia y a veces con más frecuencia que el caso base de 1/3 debido a su naturaleza probabilística.",
        "Cuando un receptor no recibe un vector DR durante mucho tiempo, la trayectoria del receptor se aleja cada vez más de la trayectoria del emisor y, por lo tanto, la tasa de acumulación del error en el receptor es mayor.",
        "En ocasiones, cuando un receptor recibe vectores de DR con más frecuencia, acumula errores a un ritmo más bajo, pero no hay forma de revertir el error acumulado cuando no recibió un vector de DR durante mucho tiempo.",
        "Esto lleva a que los receptores acumulen más error en el caso probabilístico en comparación con el caso base de 1/3 donde los receptores reciben un vector DR casi periódicamente. Para limitar el aumento en el error medio, decidimos modificar el algoritmo basado en presupuesto para que sea determinista.",
        "Los dos primeros pasos del algoritmo son los mismos que en el algoritmo probabilístico; los puntos de activación se incrementan para reducir el umbral y los errores acumulados se utilizan para calcular la probabilidad de que un receptor reciba un vector DR.",
        "Una vez que se completen estos pasos, se calcula un horario determinista para el receptor de la siguiente manera: 1.",
        "Si hay algún receptor etiquetado para recibir un vector DR en el disparador actual, el remitente envía el vector DR al(s) receptor(es) respectivo(s).",
        "Si al menos un receptor recibió un vector DR, el remitente calcula las probabilidades de que cada receptor reciba un vector DR como se explicó anteriormente y sigue los pasos del 2 al 6; de lo contrario, no hace nada. 2.",
        "Para cada receptor, el valor de probabilidad se multiplica por el presupuesto disponible en cada activador (que se establece en 1 como se explica a continuación) para dar la frecuencia de envío del vector DR a cada receptor.",
        "Si alguna de las frecuencias de los receptores, después de multiplicarse por el presupuesto, supera 1, la frecuencia del receptor se establece en 1 y la cantidad excedente se distribuye equitativamente entre todos los receptores sumando la cantidad a sus frecuencias existentes.",
        "Este proceso se repite hasta que todos los receptores tengan una frecuencia menor o igual a 1.",
        "Esto se debe a que en un disparador no podemos enviar más de un vector DR al receptor respectivo.",
        "Eso sería un desperdicio de vectores DR al enviar información redundante. 4. (1/frecuencia) nos da el horario en el que el remitente debe enviar vectores DR al receptor respectivo.",
        "El crédito obtenido previamente (explicado en el paso 5), si lo hubiera, se resta del horario.",
        "Observe que el valor resultante del horario podría no ser un número entero; por lo tanto, el valor se redondea hacia arriba tomando el techo del horario.",
        "Por ejemplo, si la frecuencia es de 1/3.5, esto implica que nos gustaría que se enviara un vector de DR cada 3.5 disparadores.",
        "Sin embargo, estamos obligados a enviarlo en el cuarto disparo, lo que nos otorga un crédito de 0.5.",
        "Cuando enviemos el vector DR la próxima vez, podremos enviarlo en el 3er disparo debido al crédito de 0.5.",
        "La diferencia entre el horario y el límite del horario es el crédito que el receptor ha obtenido, que se recuerda para el futuro y se utiliza en el próximo momento, como se explica en el paso 4. 6.",
        "Para cada uno de esos receptores a quienes se les envió un vector DR en el disparador actual, los receptores están etiquetados para recibir el próximo vector DR en el disparador que ocurre exactamente el número de veces programado (el techo del programa) lejos del disparador actual.",
        "Observe que en este punto no se modifica el horario de ningún otro receptor, ya que todos están ejecutando un horario calculado en algún punto anterior en el tiempo.",
        "Esos horarios se modificarán automáticamente en el disparador cuando estén programados para recibir el siguiente vector de DR.",
        "En el primer disparador, el remitente envía el vector DR a todos los receptores y utiliza una probabilidad relativa de 1/n para cada receptor y sigue los pasos 2 al 6 para calcular el próximo horario para cada receptor de la misma manera que se menciona para otros disparadores.",
        "Este algoritmo garantiza que cada receptor tenga un horario garantizado para recibir vectores DR y, por lo tanto, no haya irregularidades en el envío del vector DR a ningún receptor, como se observó en el algoritmo probabilístico basado en presupuesto.",
        "Utilizamos el banco de pruebas descrito anteriormente (tres receptores con retardos variables) para evaluar el algoritmo determinista utilizando el presupuesto de 1 vector DR por activación para así utilizar el mismo número de vectores DR que en el caso base 1/3.",
        "Los resultados de nuestros experimentos se muestran en las Figuras 5 y 6.",
        "Se puede observar que la desviación estándar del error en el algoritmo basado en presupuesto determinista es menor que el caso base de 1/3 y también tiene el mismo error medio que el caso base de 1/3.",
        "Esto indica que el algoritmo determinista es más justo que el caso base de 1/3 y al mismo tiempo no aumenta el error medio, lo que conduce a una mejor calidad de juego en comparación con el algoritmo probabilístico.",
        "En general, al comparar el enfoque determinista con el enfoque probabilístico, encontramos que el error acumulado promedio siempre fue menor en el enfoque determinista.",
        "Con respecto a la desviación estándar del error acumulado, encontramos que en los casos de varianza fija o baja, el enfoque determinista fue generalmente menor, pero en casos de mayor varianza, era más difícil sacar conclusiones ya que a veces el enfoque probabilístico era mejor que el determinista.",
        "CONCLUSIONES Y TRABAJO FUTURO En los juegos multijugador distribuidos que se juegan a través de Internet, los objetos y la trayectoria de los jugadores dentro del espacio de juego se intercambian en términos de vectores DR.",
        "Debido al retraso variable entre jugadores, estos vectores DR llegan a diferentes jugadores en momentos distintos.",
        "Existe una ventaja injusta obtenida por los receptores que están más cerca del remitente del DR, ya que pueden representar la posición del remitente de manera más precisa en tiempo real.",
        "En este documento, primero desarrollamos un modelo para estimar el error en la representación de las trayectorias de los jugadores en los receptores.",
        "Luego presentamos un algoritmo basado en programar los vectores de DR para ser enviados a diferentes jugadores en diferentes momentos, igualando así el error en los diferentes jugadores.",
        "Este algoritmo tiene como objetivo hacer que el juego sea justo para todos los jugadores, pero tiende a aumentar el error promedio de los jugadores.",
        "Para contrarrestar este efecto, presentamos algoritmos basados en presupuestos donde los vectores de DR aún se programan para ser enviados a diferentes jugadores en diferentes momentos, pero el algoritmo equilibra la necesidad de equidad con el requisito de que el error de los jugadores en el peor caso (que están más lejos del remitente) no se incremente en comparación con el caso base (donde todos los vectores de DR se envían a todos los jugadores cada vez que se genera un vector de DR).",
        "Presentamos dos variaciones de los algoritmos basados en el presupuesto y, a través de experimentación, demostramos que los algoritmos reducen la desviación estándar del error, haciendo así el juego más justo y al mismo tiempo manteniendo un error medio comparable al caso base.",
        "REFERENCIAS [1] S. Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee y S. Rangarajan, Precisión en juegos distribuidos multijugador basados en Dead-Reckoning, Actas del Taller ACM SIGCOMM 2004 sobre Soporte de Redes y Sistemas para Juegos (NetGames 2004), agosto de 2004. [2] L. Gautier y C. Diot, Diseño y Evaluación de MiMaze, un juego multijugador en Internet, en Actas de IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistencia en medios interactivos continuos replicados, en Actas de la Conferencia ACM sobre Trabajo Cooperativo Asistido por Computadora (CSCW00), 2000, pp. 181-190. [4] S.K.",
        "Singhal y D.R.",
        "Cheriton, Explotando el historial de posición para una representación remota eficiente en la realidad virtual en red, Presencia: Teleoperadores y Entornos Virtuales, vol. 4, núm. 2, pp. 169-193, 1995. [5] C. Diot y L. Gautier, Una arquitectura distribuida para aplicaciones interactivas multijugador en Internet, en la revista IEEE Network, 1999, vol. 13, pp. 6-15. [6] L. Pantel y L.C.",
        "Wolf, Sobre el impacto del retraso en los juegos multijugador en tiempo real, en Actas de ACM NOSSDAV02, mayo de 2002. [7] Y. Lin, K. Guo y S. Paul, Sync-MS: Servicio de mensajería sincronizada para juegos distribuidos multijugador en tiempo real, en Actas de la 10ª Conferencia Internacional de Protocolos de Red de IEEE (ICNP), noviembre de 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan y S. Paul, Un marco de intercambio de mensajes justo para juegos distribuidos multijugador, en Actas de NetGames2003, mayo de 2003. [9] N. E. Baughman y B. N. Levine, Reproducción a prueba de trampas para juegos en línea centralizados y distribuidos, en Actas de IEEE INFOCOM01, abril de 2001. [10] M. Allman y V. Paxson, Sobre la estimación de propiedades de la ruta de red de extremo a extremo, en Actas de ACM SIGCOMM99, septiembre de 1999. [11] Foro de BZFlag, Juego de BZFlag, URL: http://www.bzflag.org. [12] Instituto Nacional de Estándares y Tecnología, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/."
    ],
    "error_count": 2,
    "keys": {
        "fairness": {
            "translated_key": "equidad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>fairness</br> in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved <br>fairness</br> without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide <br>fairness</br> among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the <br>fairness</br> of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure <br>fairness</br> in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the <br>fairness</br> of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of <br>fairness</br> in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "<br>fairness</br> is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on <br>fairness</br> without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved <br>fairness</br> but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the <br>fairness</br> requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves <br>fairness</br> among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for <br>fairness</br> leads to the decrease in standard deviation (i.e., increases the <br>fairness</br> among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for <br>fairness</br> with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "<br>fairness</br> in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved <br>fairness</br> without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We show through experiments that these algorithms provide <br>fairness</br> among players in spite of widely varying network delays.",
                "Our goal in this paper is to improve the <br>fairness</br> of these games in spite of the varying network delays by equalizing the export error at the players.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure <br>fairness</br> in terms of the standard deviation of the error)."
            ],
            "translated_annotated_samples": [
                "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor.",
                "Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor <br>equidad</br> sin aumentar el error medio, manteniendo así la precisión del juego.",
                "Mostramos a través de experimentos que estos algoritmos proporcionan <br>equidad</br> entre los jugadores a pesar de las variaciones amplias en los retrasos de red.",
                "Nuestro objetivo en este artículo es mejorar la <br>equidad</br> de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores.",
                "A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la <br>equidad</br> en términos de la desviación estándar del error)."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor <br>equidad</br> sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan <br>equidad</br> entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la <br>equidad</br> de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la <br>equidad</br> en términos de la desviación estándar del error). ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "dead-reckoning vector": {
            "translated_key": "vector de navegación inercial",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the <br>dead-reckoning vector</br>, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "The object is placed at the receiver at the position indicated by the <br>dead-reckoning vector</br>, but by that time, the real position could have changed considerably at the sender."
            ],
            "translated_annotated_samples": [
                "El objeto se coloca en el receptor en la posición indicada por el <br>vector de navegación inercial</br>, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el <br>vector de navegación inercial</br>, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la precisión del juego. Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores. Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado. El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de sincronización de cubo estático para compensar las variaciones en los retrasos de la red. En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota. Los jugadores con un retraso de red mayor a 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la sincronización de cubetas dependen de imponer un retraso máximo en todos los jugadores. Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados. Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto). Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción. Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización. La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras. En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego. Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor). Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la sincronización de cubos no son a prueba de trampas a menos que se implementen mecanismos adicionales. Tanto el algoritmo de programación como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas. Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida. Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño. En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1]. En la Sección 4, describimos el algoritmo de programación de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFlag. La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de precisión en el juego. Las conclusiones se presentan en la Sección 6.2.3. MODELO DE JUEGO La arquitectura del juego se basa en jugadores distribuidos a través de Internet que intercambian vectores DR entre sí. Los vectores de DR podrían ser enviados directamente de un jugador a otro (modelo peer-to-peer) o podrían ser enviados a través de un servidor de juego que recibe el vector de DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor). Como se mencionó anteriormente, asumimos que los relojes de los jugadores participantes están sincronizados. Cada vector DR enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad. Suponemos un vector DR lineal en el que la información contenida en el vector DR es solo suficiente para que el jugador receptor calcule la trayectoria y represente la entidad en un camino en línea recta. Un vector DR de este tipo contiene información sobre la posición inicial y la velocidad del jugador/entidad, donde la velocidad es constante. Por lo tanto, los vectores DR enviados por un jugador especifican el tiempo actual en el jugador cuando se calcula el vector DR (no el tiempo en el que este vector DR se envía a los otros jugadores, como explicaremos más adelante), la posición actual del jugador/entidad en términos de las coordenadas x, y, z y el vector de velocidad en la dirección de las coordenadas x, y, z. Específicamente, el vector DRi enviado por el jugador j sobre la k-ésima entidad se denota como DRj ik y está representado por la siguiente tupla (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik). Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y para una sola entidad. Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional. Por lo tanto, usamos DRi para denotar el i-ésimo vector DR representado como la tupla (Ti, xi, yi, vxi, vyi). El jugador receptor calcula la posición inicial para la entidad basándose en xi, yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo Ti en el que fue calculado. Ten en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados. El jugador receptor luego utiliza los componentes de velocidad para proyectar y representar la trayectoria de la entidad. Esta trayectoria se sigue hasta que se recibe un nuevo vector DR que cambia la posición y/o velocidad de la entidad. tiempoT1 Real Exportado Colocado dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) calculado en el tiempo T1 y enviado al receptor DR0 = (T0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptor T0 dt0 Colocado E Figura 1: Trayectorias y desviaciones. Basado en este modelo, la Figura 1 ilustra el envío y recepción de vectores DR y los diferentes errores que se encuentran. Otros tipos de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y vectores DR de spline cúbico que consideran la posición y velocidad inicial y la posición y velocidad final de la entidad. La figura muestra la recepción de vectores de DR en un jugador (en adelante llamado receptor). El eje horizontal muestra el tiempo que está sincronizado entre todos los jugadores. El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad. Suponga que en el tiempo T0 se calcula un vector DR0 por el remitente y se envía inmediatamente al receptor. Supongamos que DR0 es recibido por el receptor después de un retraso de dt0 unidades de tiempo. El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (mostrado como punto E). La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor basada en los componentes de velocidad vx0 y vy0 (ruta colocada). En el tiempo T1 se calcula un vector DR1 de enrutamiento dinámico para la misma entidad y se envía inmediatamente al receptor2. Suponga que DR1 es recibido por el receptor después de un retraso de dt1 unidades de tiempo. Cuando se recibe este vector DR, se asume que la entidad está en el punto D. Se calcula una nueva posición para la entidad como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto C). Los componentes de velocidad vx1 y vy1 se utilizan para proyectar y representar esta entidad más lejos. Ahora consideremos el error debido al retraso de la red. Aunque DR1 se calculó en el tiempo T1 y se envió al receptor, no llegó al receptor hasta el tiempo T1 + dt1. Esto significa que, aunque la ruta exportada basada en DR1 en el remitente en el tiempo T1 es la trayectoria AC, hasta el tiempo T1 + dt1, en el receptor, esta entidad estaba siendo representada en la trayectoria BD basada en DR0. Solo en el momento T1 + dt1 la entidad se movió al punto C, a partir del cual los caminos exportados y colocados son iguales. La desviación entre las rutas exportadas y colocadas crea un componente de error al que nos referimos como el error de exportación. Una forma de representar el error de exportación es calcular la integral de la distancia entre las dos trayectorias durante el tiempo en que están desincronizadas. Representamos la integral de las distancias entre las rutas colocadas y exportadas debido a algunos DR DRi en un intervalo de tiempo [t1, t2] como Err(DRi, t1, t2). En la figura, el error de exportación debido a DR1 se calcula como la integral de la distancia entre las trayectorias AC y BD en el intervalo de tiempo [T1, T1 + dt1]. Ten en cuenta que también podría haber otras formas de representar este error, pero en este artículo utilizamos la integral de la distancia entre las dos trayectorias como medida del error de exportación. Tenga en cuenta que se habría producido un error de exportación debido a la recepción de DR0, momento en el que la ruta colocada se basaría en un vector DR anterior. Esto no se muestra en la figura, pero sirve para recordar al lector que el error de exportación es acumulativo cuando se reciben una secuencia de vectores DR. A partir del tiempo T1 en adelante, hay una desviación entre las trayectorias reales y las exportadas. Como discutimos anteriormente, este error de exportación es inevitable. La figura y el ejemplo anterior ilustran solo un receptor. Pero en realidad, los vectores DR DR0 y DR1 son enviados por el remitente a todos los jugadores participantes. Cada uno de estos jugadores recibe DR0 y DR1 después de diferentes retrasos, creando así diferentes valores de error de exportación en cada jugador. El objetivo del algoritmo de programación de vectores DR que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual en cada jugador de forma independiente para cada una de las entidades que conforman el juego. ALGORITMO DE PROGRAMACIÓN PARA EL ENVÍO DE VECTORES DR En la Sección 3 mostramos cómo el retraso desde el remitente de un nuevo vector DR 2 Normalmente, los vectores DR no se calculan de forma periódica, sino bajo demanda, donde la decisión de calcular un nuevo vector DR se basa en la superación de un umbral en la desviación entre la ruta real y la ruta exportada por el vector DR anterior. 3 vector al receptor del vector DR podría llevar a un error de exportación debido a la desviación de la ruta colocada de la ruta exportada en el receptor hasta que se reciba este nuevo vector DR. También mencionamos que el objetivo del algoritmo de programación de vectores DR es igualar el error de exportación en todos los receptores durante un período de tiempo. Dado que el juego se juega en un entorno distribuido, tiene sentido que el remitente de una entidad lleve un registro de todos los errores en los receptores e intente igualarlos. Sin embargo, el remitente no puede conocer el error real en un receptor hasta que reciba alguna información sobre el error del receptor. Nuestro algoritmo estima el error para calcular un horario para enviar vectores DR a los receptores y corrige el error cuando recibe retroalimentación de los receptores. En esta sección proporcionamos las motivaciones para el algoritmo y describimos los pasos por los que atraviesa. A lo largo de esta sección, utilizaremos el siguiente ejemplo para ilustrar el algoritmo. tiempoT1 Ruta exportada Ruta colocada en el receptor 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 enviado al receptor 1 DR1 enviado al receptor 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimado para ser recibido por el receptor 2 DR1 estimado para ser recibido por el receptor 1 DR1 recibido realmente por el receptor 1 DR1 recibido realmente por el receptor 2 DR0 enviado a ambos receptores DR1 calculado por el remitente Ruta colocada en el receptor 1 Figura 2: Flujo de vector DR entre un remitente y dos receptores y la evolución de las rutas colocadas estimadas y reales en los receptores. DR0 = (T0, T0, x0, y0, vx0, vy0), enviado en el tiempo T0 a ambos receptores. DR1 = (T1, T1 1 , x1, y1, vx1, vy1) enviado en el tiempo T1 1 = T1+δ1 al receptor 1 y DR1 = (T1, T2 1 , x1, y1, vx1, vy1) enviado en el tiempo T2 1 = T1 + δ2 al receptor 2. Considera el ejemplo en la Figura 2. La figura muestra un único emisor enviando vectores DR para una entidad a dos receptores diferentes 1 y 2. DR0 calculado en T0 es enviado y recibido por los receptores en algún momento entre T0 y T1, momento en el cual mueven la ubicación de la entidad para que coincida con la ruta exportada. Por lo tanto, la trayectoria de la entidad se muestra solo desde el punto en que la trayectoria colocada coincide con la trayectoria exportada para DR0. Ahora considera DR1. En el tiempo T1, DR1 es calculado por el remitente, pero se asume que no es enviado inmediatamente a los receptores y solo se envía después de un tiempo δ1 al receptor 1 (en el tiempo T1 1 = T1 + δ1) y después de un tiempo δ2 al receptor 2 (en el tiempo T2 1 = T1 + δ2). Ten en cuenta que el remitente incluye la marca de tiempo de envío con el vector DR como se muestra en la figura. Supongamos que el remitente estima (pronto quedará claro por qué el remitente tiene que estimar el retraso) que después de un retraso de dt1, el receptor 1 lo recibirá, utilizará los parámetros de coordenadas y velocidad para calcular la ubicación actual de la entidad y moverla allí (punto C) y a partir de ese momento, los caminos exportado y colocado serán iguales. Sin embargo, en realidad, el receptor 1 recibe DR1 después de un retraso de da1 (que es menor que las estimaciones de los remitentes de dt1), y mueve la entidad correspondiente al punto H. De manera similar, el remitente estima que después de un retraso de dt2, el receptor 2 recibirá DR1, calculará la ubicación actual de la entidad y la moverá a ese punto (punto E), mientras que en realidad recibe DR1 después de un retraso de da2 > dt2 y mueve la entidad al punto N. Los otros puntos mostrados en las rutas colocadas y exportadas se utilizarán más adelante en la discusión para describir diferentes componentes de error. 4.1 Cálculo del Error de Exportación Relativo Volviendo a la discusión de la Sección 3, desde la perspectiva de los remitentes, el error de exportación en el receptor 1 debido a DR1 se da por Err(DR1, T1, T1 + δ1 + dt1) (la integral de la distancia entre las trayectorias AC y DB en el intervalo de tiempo [T1, T1 + δ1 + dt1]) de la Figura 2. Esto se debe a que el remitente utiliza el retraso estimado dt1 para calcular este error. De manera similar, el error de exportación desde la perspectiva del remitente en el recibido 2 debido a DR1 se da por Err(DR1, T1, T1 + δ2 + dt2) (la integral de la distancia entre las trayectorias AE y DF en el intervalo de tiempo [T1, T1 + δ2 + dt2]). Ten en cuenta que los errores anteriores desde la perspectiva del remitente son solo estimaciones. En realidad, el error de exportación será tanto menor como mayor que el valor estimado, dependiendo de si la estimación de retraso fue mayor o menor que el retraso real experimentado por DR1. La diferencia entre el error de exportación estimado y el real es el error de exportación relativo (que puede ser positivo o negativo) que ocurre para cada vector de DR que se envía y se acumula en el remitente. El concepto de error relativo de exportación se ilustra en la Figura 2. Dado que el retraso actual al receptor 1 es da1, el error de exportación inducido por DR1 en el receptor 1 es Err(DR1, T1, T1 + δ1 + da1). Esto significa que hay un error en el error estimado de exportación y el remitente solo puede calcular este error después de recibir un comentario del receptor sobre la demora real en la entrega de DR1, es decir, el valor de da1. Proponemos que una vez que el receptor 1 reciba DR1, envíe el valor de da1 de vuelta al remitente. El receptor puede calcular esta información ya que conoce el momento en que se envió DR1 (T1 1 = T1 + δ1, que se añade al vector DR como se muestra en la Figura 2) y el tiempo local de recepción (que está sincronizado con el reloj del emisor). Por lo tanto, el remitente calcula el error relativo de exportación para el receptor 1, representado como R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1). De manera similar, el error relativo de exportación para el receptor 2 se calcula como R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2). Nótese que R1 > 0 ya que da1 < dt1, y R2 < 0 ya que da2 > dt2. Los errores relativos de exportación son calculados por el remitente en el momento en que recibe la retroalimentación de los destinatarios. Este ejemplo muestra los 4 valores relativos de error de exportación después de que se envía DR1 y se reciben los comentarios correspondientes. 4.2 Igualación del Error Entre Receptores Ahora explicamos lo que queremos decir al hacer que los errores sean iguales en todos los receptores y cómo se puede lograr esto. Como se mencionó anteriormente, el remitente mantiene estimaciones de los retrasos a los receptores, dt1 y dt2 en el ejemplo de la Figura 2. Esto indica que en el momento T1 cuando se calcula DR1, el remitente ya sabe cuánto tiempo pueden tardar los mensajes que llevan este vector DR en llegar a los receptores. El remitente utiliza esta información para calcular los errores de exportación, que son Err(DR1, T1, T1 + δ1 + dt1) y Err(DR1, T1, T1 + δ2 + dt2) para los receptores 1 y 2, respectivamente. Ten en cuenta que las áreas de estos componentes de error son una función de δ1 y δ2, así como de las demoras de red dt1 y dt2. Si queremos que los errores de exportación debido a DR1 sean iguales en ambos receptores, el remitente debe elegir δ1 y δ2 de manera que Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2). Pero cuando se calculó T1, ya podría haberse acumulado errores relativos de exportación debido a los vectores DR anteriores (DR0 y los anteriores). Representemos el error relativo acumulado hasta DRi para el receptor j como Ri j. Para acomodar estos errores relativos acumulados, el remitente debe elegir ahora δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Los δi determinan el instante de programación del vector DR en el remitente para el receptor i. Este método de cálculo de δs garantiza que el error de exportación acumulado (es decir, el error total real) para cada receptor se iguala en la transmisión de cada vector DR. Para establecer esto, asuma que la retroalimentación para el vector DR Di de un receptor llega al remitente antes de que se calcule el horario para Di+1. Que Si m y Ai m denoten el error estimado para el receptor m utilizado para calcular el horario para Di y el error acumulado para el receptor m calculado después de recibir retroalimentación para Di, respectivamente. Entonces Ri m = Ai m − Si m. Para calcular las instancias de programación (es decir, δs) para Di, para cualquier par de receptores m y n, hacemos Ri−1 m + Si m = Ri−1 n + Si n. El siguiente teorema establece el hecho de que el error acumulado de exportación se iguala en cada instante de programación. TEOREMA 4.1. Cuando se calculan las instancias de horario para enviar Di a cualquier par de receptores m y n, se cumple la siguiente condición: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Prueba: Por inducción. Supongamos que la premisa se cumple para algún i. Mostramos que se cumple para i+1. El caso base para i = 1 se cumple ya que inicialmente R0 m = R0 n = 0, y se utiliza S1 m = S1 n para calcular las instancias de programación. Para calcular el horario de Di+1, primero calculamos los errores relativos como Ri m = Ai m − Si m y Ri n = Ai n − Si n. Luego, para calcular δs, ejecutamos Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n. Añadiendo la condición de la premisa en ambos lados obtenemos, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n. 4.3 Cálculo del Error de Exportación. Ahora consideremos cómo se pueden calcular los errores de exportación. De la sección anterior, para encontrar δ1 y δ2 necesitamos encontrar Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2). Se debe tener en cuenta que los valores de R0 1 y R0 2 ya son conocidos en el remitente. Considera el cálculo de Err(DR1, T1, T1 +δ1 +dt1). Esta es la integral de la distancia entre las trayectorias AC debido a DR1 y BD debido a DR0. A partir de DR0 y DR1, el punto A es (X1, Y1) = (x1, y1) y el punto B es (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0). La trayectoria AC puede ser representada como una función del tiempo como (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) y la trayectoria de BD puede ser representada como (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t). La distancia entre las dos trayectorias como función del tiempo se convierte entonces en, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Sea a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Entonces dist(t) se puede escribir como dist(t) = a × t2 + b × t + c. Luego Err(DR1, t1, t2) para algún intervalo de tiempo [t1, t2] se convierte en t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt. Una solución en forma cerrada para la integral indefinida a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2) pueden entonces ser calculadas aplicando los límites apropiados a la solución anterior. En la siguiente sección, consideramos el cálculo de los δs para N receptores. 5 4.4 Cálculo de Instantes de Programación Volvemos a analizar el cálculo de los δs haciendo referencia a la Figura 2. El remitente elige δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 + Err(DR1, T1, T1 + δ2 +dt2). Si R0 1 y R0 2 ambos son cero, entonces δ1 y δ2 deben ser elegidos de tal manera que Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2). Esta igualdad se mantendrá si δ1 + dt1 = δ2 + dt2. Por lo tanto, si no hay error acumulado relativo de exportación, todo lo que el remitente necesita hacer es elegir los δs de tal manera que contrarresten la diferencia en el retraso a los dos receptores, para que reciban el vector DR al mismo tiempo. Como se discutió anteriormente, dado que el remitente no puede aprender de antemano el retraso, siempre habrá un error relativo acumulado de exportación de un vector DR previo que debe tenerse en cuenta. Para profundizar en esto, considera el cálculo del error de exportación como se ilustra en la sección anterior. Para calcular los δs necesitamos que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Es decir, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt. Eso es R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt. Los componentes R0 1, R0 2, ya son conocidos por (o estimados por) el remitente. Además, los componentes de error T1+dt1 T1 dist(t) dt y T1+dt2 T1 dist(t) dt pueden ser calculados a priori por el remitente utilizando valores estimados de dt1 y dt2. Usemos E1 para denotar R0 1 + T1+dt1 T1 dist(t) dt y E2 para denotar R0 2 + T1+dt2 T1 dist(t) dt. Entonces, requerimos que E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. Suponga que E1 > E2. Entonces, para que la ecuación anterior se cumpla, requerimos que T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt. Para hacer el juego lo más rápido posible dentro de este marco, los valores de δ deben ser lo más pequeños posible para que los vectores DR se envíen a los receptores lo antes posible, sujeto al requisito de equidad. Dado esto, elegiríamos δ1 como cero y calcularíamos δ2 a partir de la ecuación E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. En general, si hay N receptores 1, . . . , N, cuando un emisor genera un vector DR y decide programarlos para ser enviados, primero calcula los valores de Ei para todos ellos a partir de los errores relativos acumulados en la exportación y las estimaciones de los retrasos. Luego, encuentra el valor más pequeño de estos valores. Que Ek sea el valor más pequeño. El remitente hace que δk sea cero y calcula el resto de los δs a partir de la igualdad Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) Los δs así obtenidos dan los instantes de programación del vector DR para los receptores. 4.5 Pasos del Algoritmo de Programación Para los fines de la discusión a continuación, como antes, vamos a denotar el error relativo acumulado en un remitente para el receptor k hasta DRi como Ri k. Vamos a denotar el retraso programado en el remitente antes de que DRi sea enviado al receptor k como δi k. Dada la discusión anterior, los pasos del algoritmo son los siguientes: 1. El remitente calcula DRi en el tiempo Ti y luego calcula δi k y Ri−1 k, ∀k, 1 ≤ k ≤ N basándose en la estimación de los retrasos dtk, ∀k, 1 ≤ k ≤ N según la Ecuación (1). Programa que DRi se envíe al receptor k en el tiempo Ti + δi k. 2. Los vectores DR se envían a los receptores en los horarios programados, los cuales se reciben después de un retraso de dak, ∀k, 1 ≤ k ≤ N donde dak ≤ o > dtk. Los receptores envían el valor de dak de vuelta al remitente (el receptor puede calcular este valor basándose en las marcas de tiempo en el vector DR como se describió anteriormente). 3. El remitente calcula Ri k como se describe anteriormente e ilustra en la Figura 2. El remitente también recalcula (utilizando un método de promedio exponencial similar a la estimación del tiempo de ida y vuelta por TCP [10]) la estimación del retraso dtk a partir del nuevo valor de dak para el receptor k. 4. Vuelve al Paso 1 para calcular DRi+1 cuando sea necesario y sigue los pasos del algoritmo para programar y enviar este vector DR a los receptores. 4.6 Manejo de Casos en la Práctica Hasta ahora asumimos implícitamente que DRi se envía a todos los receptores antes de tomar una decisión para calcular el siguiente vector DR DRi+1, y los receptores envían el valor de dak correspondiente a DRi y esta información llega al remitente antes de que calcule DRi+1 para que pueda calcular Ri+1 k y luego usarlo en el cálculo de δi+1 k. Dos cuestiones deben tenerse en cuenta con respecto al algoritmo anterior cuando se utiliza en la práctica. • Puede suceder que se calcule un nuevo vector DR incluso antes de que el vector DR anterior se envíe a todos los receptores. ¿Cómo se manejará esta situación? • ¿Qué sucede si la retroalimentación no llega antes de que se calcule y programe el envío de DRi+1? Consideremos el primer escenario. Suponemos que DRi ha sido programado para ser enviado y los instantes de programación son tales que δi 1 < δi 2 < · · · < δi N. Suponga que se va a calcular DRi+1 (porque la trayectoria real se ha desviado excediendo un umbral de la trayectoria exportada por DRi) en el tiempo Ti+1 donde Ti + δi k < Ti+1 < Ti + δi k+1. Esto significa que DRi ha sido enviado solo a receptores hasta k en el orden programado. En nuestro algoritmo, en este caso, se vacía la cola de ordenación de retrasos programados, lo que significa que DRi no se envía a los receptores que aún están en cola para recibirlo, pero se calcula un nuevo orden de programación para que todos los receptores envíen DRi+1. Para aquellos receptores a quienes se les ha enviado DRi, asumir por ahora que se ha recibido de todos los receptores daj, 1 ≤ j ≤ k (el escenario donde daj no ha sido recibido se considerará como parte del segundo escenario más tarde). Para estos receptores, Ei j, 1 ≤ j ≤ k se pueden calcular. Para aquellos receptores j, k + 1 ≤ j ≤ N a quienes no se les envió DRi, Ei j no aplica. Considera un receptor j, k + 1 ≤ j ≤ N a quien no se le envió DRi. Consulte la Figura 3. Para un receptor j dado, cuando se programa DRi+1 y se exporta la ruta dtj A B C D Ti-1 Gi j, DRi+1 calculado por el remitente y DRi para el receptor k+1 a N se eliminan de la cola. DRi+1 programado para el receptor k+1, Ti+1 G H E F, DRi programado para el receptor j, DRi calculado por el remitente, se coloca la ruta en el receptor k+1, Gi+1 j. Figura 3: Cálculo de programación cuando DRi no se envía al receptor j, k + 1 ≤ j ≤ N. Se necesita calcular δi+1 j, el error total de exportación es el error de exportación relativo acumulado en el tiempo Ti cuando se programó el DRi, más la integral de la distancia entre las dos trayectorias AC y BD de la Figura 3 en el intervalo de tiempo [Ti, Ti+1 + δi+1 j + dtj]. Ten en cuenta que esta integral está dada por Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj). Por lo tanto, en lugar de Ei j de la Ecuación (1), utilizamos el valor Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) donde Ri−1 j es el error relativo de exportación utilizado cuando se calculó el horario para DRi. Ahora considera el segundo escenario. Aquí el dak de retroalimentación correspondiente a DRi no ha llegado antes de que se calcule y programe DRi+1. En este caso, Ri k no se puede calcular. Por lo tanto, en el cálculo de δk para DRi+1, se asumirá que es cero. Suponemos que se utiliza un mecanismo confiable para enviar el dak de vuelta al remitente. Cuando esta información llegue en un momento posterior, Ri k se calculará y acumulará a los errores relativos de exportación futuros (por ejemplo, Ri+1 k si dak se recibe antes de que se calcule DRi+2) y se utilizará en el cálculo de δk cuando se programe un vector DR futuro (por ejemplo, DRi+2). 4.7 Resultados Experimentales Para evaluar la efectividad y cuantificar los beneficios obtenidos a través del uso del algoritmo de programación, implementamos el algoritmo propuesto en el juego BZFlag (Battle Zone Flag) [11]. Es un juego de disparos en primera persona donde los jugadores en equipos conducen tanques y se mueven dentro de un campo de batalla. El objetivo de los jugadores es navegar y capturar las banderas pertenecientes al otro equipo y llevarlas de vuelta a su propia área. Los jugadores disparan a los tanques de los demás usando balas de disparo. El movimiento de los tanques, así como el de los disparos, se intercambian entre los jugadores utilizando vectores DR. Hemos modificado la implementación de BZFlag para incorporar relojes sincronizados entre los jugadores y el servidor, y intercambiar marcas de tiempo con el vector DR. Establecimos un banco de pruebas con cuatro jugadores ejecutando la versión instrumentada de BZFlag, con uno como emisor y el resto como receptores. El enfoque de programación y el caso base en el que cada vector de DR se envió a todos los receptores simultáneamente en cada punto de activación se implementaron en la misma ejecución etiquetando los vectores de DR según el tipo de enfoque utilizado para enviar el vector de DR. NISTNet [12] se utilizó para introducir retrasos en el emisor y los tres receptores. Se introdujeron retrasos medios de 800 ms, 500 ms y 200 ms entre el emisor y el primer, segundo y tercer receptor, respectivamente. Introducimos una variación de 100 milisegundos (al retraso medio de cada receptor) para modelar la variabilidad en el retraso. El remitente registró los errores de cada receptor cada 100 milisegundos tanto para el enfoque de programación como para el caso base. El remitente también calculó la desviación estándar y la media del error de exportación acumulado de todos los receptores cada 100 milisegundos. La Figura 4 representa la media y la desviación estándar del error acumulado de exportación de todos los receptores en el caso de programación frente al caso base. Ten en cuenta que el eje x de estos gráficos (y de los demás gráficos que siguen) representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe que la desviación estándar del error con la programación es mucho menor en comparación con el caso base. Esto implica que los errores acumulados de los receptores en el caso de programación están más cerca unos de otros. Esto demuestra que el enfoque de programación logra equidad entre los receptores incluso si se encuentran a diferentes distancias (es decir, latencias) del emisor. Observe que la media del error acumulado aumentó varias veces con la programación en comparación con el caso base. La exploración adicional de la razón del aumento en la media llevó a la conclusión de que cada vez que los vectores de DR se programan de manera que igualen el error total, empuja el error total de cada receptor hacia arriba. Además, dado que el error acumulado tiene un componente estimado, el horario no es preciso para igualar los errores de los receptores, lo que provoca que el vector de DR llegue antes o después de la programación real. En cualquier caso, el error no se iguala y si el vector de DR llega tarde, en realidad aumenta el error para un receptor más allá del error acumulado más alto. Esto significa que en el próximo disparo, este receptor será el que tenga el error más alto y el error de todos los demás receptores se ajustará a este valor de error. Este efecto de cambio repentino conlleva un aumento en el error acumulado para todos los receptores. La programación para la equidad conduce a la disminución de la desviación estándar (es decir, aumenta la equidad entre los diferentes jugadores), pero esto conlleva un mayor error medio, lo cual puede no ser una característica deseable. Esto nos llevó a explorar diferentes formas de igualar los errores acumulados. El enfoque discutido en la siguiente sección es un enfoque heurístico basado en la siguiente idea. Utilizando la misma cantidad de vectores de DR a lo largo del tiempo que en el caso base, en lugar de enviar los vectores de DR a todos los receptores con la misma frecuencia que en el caso base, si podemos aumentar la frecuencia de envío de los vectores de DR al receptor con un error acumulado más alto y disminuir la frecuencia de envío de los vectores de DR al receptor con un error acumulado más bajo, podemos igualar el error de exportación de todos los receptores a lo largo del tiempo. Al mismo tiempo, deseamos disminuir el error del receptor con el error acumulado más alto en el caso base (por supuesto, este receptor recibiría más vectores DR que en el caso base). Nos referimos a dicho algoritmo como un algoritmo basado en presupuesto. ALGORITMO BASADO EN PRESUPUESTO En un juego, el remitente de una entidad envía vectores DR a todos los receptores cada vez que la entidad cruza un umbral. Al reducir el umbral, se generan más vectores de DR durante un período de tiempo dado. Dado que los vectores DR se envían a todos los receptores y el retraso de red entre los pares emisor-receptor no se puede evitar, el error antes de la exportación 3 con el jugador más distante siempre será 3. Tenga en cuenta que después de la exportación, el error se elimina mediante el uso de un reloj sincronizado entre los jugadores. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 Error acumulado promedio en segundos Algoritmo de programación del caso base #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 Desviación estándar del error acumulado en segundos Algoritmo de programación del caso base #1 Figura 4: Promedio y desviación estándar del error con programación y sin ella (es decir, caso base) serán más altos que el resto. Para mitigar el desequilibrio en el error, proponemos enviar vectores de DR selectivamente a diferentes jugadores basándonos en los errores acumulados de estos jugadores. El algoritmo basado en presupuesto se fundamenta en esta idea y existen dos variaciones de él. Uno es un esquema de presupuesto probabilístico y el otro, un esquema de presupuesto determinístico. 5.1 Esquema de presupuesto probabilístico El esquema de presupuesto probabilístico tiene tres pasos principales: a) reducir el umbral de navegación inercial pero al mismo tiempo mantener el número total de DR enviados igual que en el caso base, b) en cada disparador, elegir probabilísticamente a un jugador para enviarle el vector de DR, y c) enviar el vector de DR al jugador elegido. Estos pasos se describen a continuación. La reducción del umbral de DR se implementa de la siguiente manera. Reducir el umbral es equivalente a aumentar el número de puntos de activación donde se generan los vectores de DR. Supongamos que el umbral es tal que el número de disparadores causados por él en el caso base es t y en cada disparador se envían n vectores DR por el remitente, lo que resulta en un total de nt vectores DR. Nuestro objetivo es mantener el número total de vectores DR enviados por el remitente fijo en nt, pero reducir el número de vectores DR enviados en cada activación (es decir, no enviar el vector DR a todos los receptores). Que n y t sean el número de vectores DR enviados en cada disparo y el número de disparos respectivamente en el caso modificado. Queremos asegurarnos de que n t = nt. Dado que queremos aumentar el número de puntos de activación, es decir, t > t, esto significaría que n < n. Es decir, no todos los receptores recibirán el vector DR en cada activación. En el esquema de presupuesto probabilístico, en cada activación, se calcula una probabilidad para que cada receptor reciba un vector DR y solo un receptor recibe el DR (n = 1). Esta probabilidad se basa en los pesos relativos de los errores acumulados de los receptores. Es decir, un receptor con un error acumulado más alto tendrá una probabilidad más alta de recibir el vector DR. Ten en cuenta que el error acumulado para tres jugadores es a1, a2 y a3 respectivamente. Entonces, la probabilidad de que el jugador 1 reciba el vector DR sería a1 a1+a2+a3. Del mismo modo para los otros jugadores. Una vez que se elige al jugador, el vector DR se envía a ese jugador. Para comparar el algoritmo basado en presupuesto probabilístico con el caso base, necesitábamos reducir el umbral para el caso base (para una comparación justa). Dado que el umbral de cálculo de la posición muerta en el caso base ya era muy fino, se decidió que en lugar de reducir el umbral, se compararía el enfoque basado en el presupuesto probabilístico con un caso base modificado que utilizaría el umbral normal como algoritmo basado en el presupuesto, pero el caso base se modificó de tal manera que cada tercer disparador se usaría realmente para enviar un vector de cálculo de la posición muerta a los tres receptores utilizados en nuestros experimentos. Esto fue llamado como el caso base 1/3 ya que resultó en el envío de 1/3 del número de vectores DR en comparación con el caso base. El presupuesto por disparador para el enfoque basado en la probabilidad se calculó como un vector de DR en cada disparador en comparación con tres vectores de DR en cada tercer disparador en el caso base de 1/3; por lo tanto, los dos casos resultan en el mismo número de vectores de DR enviados con el tiempo. Para evaluar la efectividad del algoritmo de presupuesto probabilístico, instrumentamos el juego BZFlag para utilizar este enfoque. Utilizamos el mismo banco de pruebas que consistía en un emisor y tres receptores con retardos de 800ms, 500ms y 200ms desde el emisor y con baja varianza de retardo (100ms) y moderada varianza de retardo (180ms). Los resultados se muestran en las Figuras 5 y 6. Como se mencionó anteriormente, el eje x de estos gráficos representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe de las figuras que la desviación estándar del error acumulado entre los receptores con el algoritmo basado en presupuesto probabilístico es menor que el caso base de 1/3 y la media es un poco más alta que el caso base de 1/3. Esto implica que el juego es más justo en comparación con el caso base de 1/3 a costa de aumentar ligeramente el error medio en comparación con el caso base de 1/3. El aumento en el error medio en el caso probabilístico en comparación con el caso base de 1/3 se puede atribuir al hecho de que, aunque en promedio el enfoque probabilístico envía el mismo número de vectores DR que el caso base de 1/3, a veces envía vectores DR a un receptor con menos frecuencia y a veces con más frecuencia que el caso base de 1/3 debido a su naturaleza probabilística. Cuando un receptor no recibe un vector DR durante mucho tiempo, la trayectoria del receptor se aleja cada vez más de la trayectoria del emisor y, por lo tanto, la tasa de acumulación del error en el receptor es mayor. En ocasiones, cuando un receptor recibe vectores de DR con más frecuencia, acumula errores a un ritmo más bajo, pero no hay forma de revertir el error acumulado cuando no recibió un vector de DR durante mucho tiempo. Esto lleva a que los receptores acumulen más error en el caso probabilístico en comparación con el caso base de 1/3 donde los receptores reciben un vector DR casi periódicamente. Para limitar el aumento en el error medio, decidimos modificar el algoritmo basado en presupuesto para que sea determinista. Los dos primeros pasos del algoritmo son los mismos que en el algoritmo probabilístico; los puntos de activación se incrementan para reducir el umbral y los errores acumulados se utilizan para calcular la probabilidad de que un receptor reciba un vector DR. Una vez que se completen estos pasos, se calcula un horario determinista para el receptor de la siguiente manera: 1. Si hay algún receptor etiquetado para recibir un vector DR en el disparador actual, el remitente envía el vector DR al(s) receptor(es) respectivo(s). Si al menos un receptor recibió un vector DR, el remitente calcula las probabilidades de que cada receptor reciba un vector DR como se explicó anteriormente y sigue los pasos del 2 al 6; de lo contrario, no hace nada. 2. Para cada receptor, el valor de probabilidad se multiplica por el presupuesto disponible en cada activador (que se establece en 1 como se explica a continuación) para dar la frecuencia de envío del vector DR a cada receptor. Si alguna de las frecuencias de los receptores, después de multiplicarse por el presupuesto, supera 1, la frecuencia del receptor se establece en 1 y la cantidad excedente se distribuye equitativamente entre todos los receptores sumando la cantidad a sus frecuencias existentes. Este proceso se repite hasta que todos los receptores tengan una frecuencia menor o igual a 1. Esto se debe a que en un disparador no podemos enviar más de un vector DR al receptor respectivo. Eso sería un desperdicio de vectores DR al enviar información redundante. 4. (1/frecuencia) nos da el horario en el que el remitente debe enviar vectores DR al receptor respectivo. El crédito obtenido previamente (explicado en el paso 5), si lo hubiera, se resta del horario. Observe que el valor resultante del horario podría no ser un número entero; por lo tanto, el valor se redondea hacia arriba tomando el techo del horario. Por ejemplo, si la frecuencia es de 1/3.5, esto implica que nos gustaría que se enviara un vector de DR cada 3.5 disparadores. Sin embargo, estamos obligados a enviarlo en el cuarto disparo, lo que nos otorga un crédito de 0.5. Cuando enviemos el vector DR la próxima vez, podremos enviarlo en el 3er disparo debido al crédito de 0.5. La diferencia entre el horario y el límite del horario es el crédito que el receptor ha obtenido, que se recuerda para el futuro y se utiliza en el próximo momento, como se explica en el paso 4. 6. Para cada uno de esos receptores a quienes se les envió un vector DR en el disparador actual, los receptores están etiquetados para recibir el próximo vector DR en el disparador que ocurre exactamente el número de veces programado (el techo del programa) lejos del disparador actual. Observe que en este punto no se modifica el horario de ningún otro receptor, ya que todos están ejecutando un horario calculado en algún punto anterior en el tiempo. Esos horarios se modificarán automáticamente en el disparador cuando estén programados para recibir el siguiente vector de DR. En el primer disparador, el remitente envía el vector DR a todos los receptores y utiliza una probabilidad relativa de 1/n para cada receptor y sigue los pasos 2 al 6 para calcular el próximo horario para cada receptor de la misma manera que se menciona para otros disparadores. Este algoritmo garantiza que cada receptor tenga un horario garantizado para recibir vectores DR y, por lo tanto, no haya irregularidades en el envío del vector DR a ningún receptor, como se observó en el algoritmo probabilístico basado en presupuesto. Utilizamos el banco de pruebas descrito anteriormente (tres receptores con retardos variables) para evaluar el algoritmo determinista utilizando el presupuesto de 1 vector DR por activación para así utilizar el mismo número de vectores DR que en el caso base 1/3. Los resultados de nuestros experimentos se muestran en las Figuras 5 y 6. Se puede observar que la desviación estándar del error en el algoritmo basado en presupuesto determinista es menor que el caso base de 1/3 y también tiene el mismo error medio que el caso base de 1/3. Esto indica que el algoritmo determinista es más justo que el caso base de 1/3 y al mismo tiempo no aumenta el error medio, lo que conduce a una mejor calidad de juego en comparación con el algoritmo probabilístico. En general, al comparar el enfoque determinista con el enfoque probabilístico, encontramos que el error acumulado promedio siempre fue menor en el enfoque determinista. Con respecto a la desviación estándar del error acumulado, encontramos que en los casos de varianza fija o baja, el enfoque determinista fue generalmente menor, pero en casos de mayor varianza, era más difícil sacar conclusiones ya que a veces el enfoque probabilístico era mejor que el determinista. CONCLUSIONES Y TRABAJO FUTURO En los juegos multijugador distribuidos que se juegan a través de Internet, los objetos y la trayectoria de los jugadores dentro del espacio de juego se intercambian en términos de vectores DR. Debido al retraso variable entre jugadores, estos vectores DR llegan a diferentes jugadores en momentos distintos. Existe una ventaja injusta obtenida por los receptores que están más cerca del remitente del DR, ya que pueden representar la posición del remitente de manera más precisa en tiempo real. En este documento, primero desarrollamos un modelo para estimar el error en la representación de las trayectorias de los jugadores en los receptores. Luego presentamos un algoritmo basado en programar los vectores de DR para ser enviados a diferentes jugadores en diferentes momentos, igualando así el error en los diferentes jugadores. Este algoritmo tiene como objetivo hacer que el juego sea justo para todos los jugadores, pero tiende a aumentar el error promedio de los jugadores. Para contrarrestar este efecto, presentamos algoritmos basados en presupuestos donde los vectores de DR aún se programan para ser enviados a diferentes jugadores en diferentes momentos, pero el algoritmo equilibra la necesidad de equidad con el requisito de que el error de los jugadores en el peor caso (que están más lejos del remitente) no se incremente en comparación con el caso base (donde todos los vectores de DR se envían a todos los jugadores cada vez que se genera un vector de DR). Presentamos dos variaciones de los algoritmos basados en el presupuesto y, a través de experimentación, demostramos que los algoritmos reducen la desviación estándar del error, haciendo así el juego más justo y al mismo tiempo manteniendo un error medio comparable al caso base. REFERENCIAS [1] S. Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee y S. Rangarajan, Precisión en juegos distribuidos multijugador basados en Dead-Reckoning, Actas del Taller ACM SIGCOMM 2004 sobre Soporte de Redes y Sistemas para Juegos (NetGames 2004), agosto de 2004. [2] L. Gautier y C. Diot, Diseño y Evaluación de MiMaze, un juego multijugador en Internet, en Actas de IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistencia en medios interactivos continuos replicados, en Actas de la Conferencia ACM sobre Trabajo Cooperativo Asistido por Computadora (CSCW00), 2000, pp. 181-190. [4] S.K. Singhal y D.R. Cheriton, Explotando el historial de posición para una representación remota eficiente en la realidad virtual en red, Presencia: Teleoperadores y Entornos Virtuales, vol. 4, núm. 2, pp. 169-193, 1995. [5] C. Diot y L. Gautier, Una arquitectura distribuida para aplicaciones interactivas multijugador en Internet, en la revista IEEE Network, 1999, vol. 13, pp. 6-15. [6] L. Pantel y L.C. Wolf, Sobre el impacto del retraso en los juegos multijugador en tiempo real, en Actas de ACM NOSSDAV02, mayo de 2002. [7] Y. Lin, K. Guo y S. Paul, Sync-MS: Servicio de mensajería sincronizada para juegos distribuidos multijugador en tiempo real, en Actas de la 10ª Conferencia Internacional de Protocolos de Red de IEEE (ICNP), noviembre de 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan y S. Paul, Un marco de intercambio de mensajes justo para juegos distribuidos multijugador, en Actas de NetGames2003, mayo de 2003. [9] N. E. Baughman y B. N. Levine, Reproducción a prueba de trampas para juegos en línea centralizados y distribuidos, en Actas de IEEE INFOCOM01, abril de 2001. [10] M. Allman y V. Paxson, Sobre la estimación de propiedades de la ruta de red de extremo a extremo, en Actas de ACM SIGCOMM99, septiembre de 1999. [11] Foro de BZFlag, Juego de BZFlag, URL: http://www.bzflag.org. [12] Instituto Nacional de Estándares y Tecnología, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "distributed multi-player game": {
            "translated_key": "juego multijugador distribuido",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a <br>distributed multi-player game</br> that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular <br>distributed multi-player game</br>.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a <br>distributed multi-player game</br>, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a <br>distributed multi-player game</br> that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular <br>distributed multi-player game</br>.",
                "INTRODUCTION In a <br>distributed multi-player game</br>, players are normally distributed across the Internet and have varying delays to each other or to a central game server."
            ],
            "translated_annotated_samples": [
                "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un <br>juego multijugador distribuido</br> que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor.",
                "Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular <br>juego multijugador distribuido</br>.",
                "En un <br>juego multijugador distribuido</br>, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un <br>juego multijugador distribuido</br> que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular <br>juego multijugador distribuido</br>. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un <br>juego multijugador distribuido</br>, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la precisión del juego. Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores. Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado. El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de sincronización de cubo estático para compensar las variaciones en los retrasos de la red. En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota. Los jugadores con un retraso de red mayor a 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la sincronización de cubetas dependen de imponer un retraso máximo en todos los jugadores. Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados. Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto). Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción. Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización. La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras. En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego. Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor). Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la sincronización de cubos no son a prueba de trampas a menos que se implementen mecanismos adicionales. Tanto el algoritmo de programación como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas. Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida. Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño. En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1]. En la Sección 4, describimos el algoritmo de programación de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFlag. La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de precisión en el juego. Las conclusiones se presentan en la Sección 6.2.3. MODELO DE JUEGO La arquitectura del juego se basa en jugadores distribuidos a través de Internet que intercambian vectores DR entre sí. Los vectores de DR podrían ser enviados directamente de un jugador a otro (modelo peer-to-peer) o podrían ser enviados a través de un servidor de juego que recibe el vector de DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor). Como se mencionó anteriormente, asumimos que los relojes de los jugadores participantes están sincronizados. Cada vector DR enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad. Suponemos un vector DR lineal en el que la información contenida en el vector DR es solo suficiente para que el jugador receptor calcule la trayectoria y represente la entidad en un camino en línea recta. Un vector DR de este tipo contiene información sobre la posición inicial y la velocidad del jugador/entidad, donde la velocidad es constante. Por lo tanto, los vectores DR enviados por un jugador especifican el tiempo actual en el jugador cuando se calcula el vector DR (no el tiempo en el que este vector DR se envía a los otros jugadores, como explicaremos más adelante), la posición actual del jugador/entidad en términos de las coordenadas x, y, z y el vector de velocidad en la dirección de las coordenadas x, y, z. Específicamente, el vector DRi enviado por el jugador j sobre la k-ésima entidad se denota como DRj ik y está representado por la siguiente tupla (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik). Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y para una sola entidad. Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional. Por lo tanto, usamos DRi para denotar el i-ésimo vector DR representado como la tupla (Ti, xi, yi, vxi, vyi). El jugador receptor calcula la posición inicial para la entidad basándose en xi, yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo Ti en el que fue calculado. Ten en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados. El jugador receptor luego utiliza los componentes de velocidad para proyectar y representar la trayectoria de la entidad. Esta trayectoria se sigue hasta que se recibe un nuevo vector DR que cambia la posición y/o velocidad de la entidad. tiempoT1 Real Exportado Colocado dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) calculado en el tiempo T1 y enviado al receptor DR0 = (T0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptor T0 dt0 Colocado E Figura 1: Trayectorias y desviaciones. Basado en este modelo, la Figura 1 ilustra el envío y recepción de vectores DR y los diferentes errores que se encuentran. Otros tipos de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y vectores DR de spline cúbico que consideran la posición y velocidad inicial y la posición y velocidad final de la entidad. La figura muestra la recepción de vectores de DR en un jugador (en adelante llamado receptor). El eje horizontal muestra el tiempo que está sincronizado entre todos los jugadores. El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad. Suponga que en el tiempo T0 se calcula un vector DR0 por el remitente y se envía inmediatamente al receptor. Supongamos que DR0 es recibido por el receptor después de un retraso de dt0 unidades de tiempo. El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (mostrado como punto E). La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor basada en los componentes de velocidad vx0 y vy0 (ruta colocada). En el tiempo T1 se calcula un vector DR1 de enrutamiento dinámico para la misma entidad y se envía inmediatamente al receptor2. Suponga que DR1 es recibido por el receptor después de un retraso de dt1 unidades de tiempo. Cuando se recibe este vector DR, se asume que la entidad está en el punto D. Se calcula una nueva posición para la entidad como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto C). Los componentes de velocidad vx1 y vy1 se utilizan para proyectar y representar esta entidad más lejos. Ahora consideremos el error debido al retraso de la red. Aunque DR1 se calculó en el tiempo T1 y se envió al receptor, no llegó al receptor hasta el tiempo T1 + dt1. Esto significa que, aunque la ruta exportada basada en DR1 en el remitente en el tiempo T1 es la trayectoria AC, hasta el tiempo T1 + dt1, en el receptor, esta entidad estaba siendo representada en la trayectoria BD basada en DR0. Solo en el momento T1 + dt1 la entidad se movió al punto C, a partir del cual los caminos exportados y colocados son iguales. La desviación entre las rutas exportadas y colocadas crea un componente de error al que nos referimos como el error de exportación. Una forma de representar el error de exportación es calcular la integral de la distancia entre las dos trayectorias durante el tiempo en que están desincronizadas. Representamos la integral de las distancias entre las rutas colocadas y exportadas debido a algunos DR DRi en un intervalo de tiempo [t1, t2] como Err(DRi, t1, t2). En la figura, el error de exportación debido a DR1 se calcula como la integral de la distancia entre las trayectorias AC y BD en el intervalo de tiempo [T1, T1 + dt1]. Ten en cuenta que también podría haber otras formas de representar este error, pero en este artículo utilizamos la integral de la distancia entre las dos trayectorias como medida del error de exportación. Tenga en cuenta que se habría producido un error de exportación debido a la recepción de DR0, momento en el que la ruta colocada se basaría en un vector DR anterior. Esto no se muestra en la figura, pero sirve para recordar al lector que el error de exportación es acumulativo cuando se reciben una secuencia de vectores DR. A partir del tiempo T1 en adelante, hay una desviación entre las trayectorias reales y las exportadas. Como discutimos anteriormente, este error de exportación es inevitable. La figura y el ejemplo anterior ilustran solo un receptor. Pero en realidad, los vectores DR DR0 y DR1 son enviados por el remitente a todos los jugadores participantes. Cada uno de estos jugadores recibe DR0 y DR1 después de diferentes retrasos, creando así diferentes valores de error de exportación en cada jugador. El objetivo del algoritmo de programación de vectores DR que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual en cada jugador de forma independiente para cada una de las entidades que conforman el juego. ALGORITMO DE PROGRAMACIÓN PARA EL ENVÍO DE VECTORES DR En la Sección 3 mostramos cómo el retraso desde el remitente de un nuevo vector DR 2 Normalmente, los vectores DR no se calculan de forma periódica, sino bajo demanda, donde la decisión de calcular un nuevo vector DR se basa en la superación de un umbral en la desviación entre la ruta real y la ruta exportada por el vector DR anterior. 3 vector al receptor del vector DR podría llevar a un error de exportación debido a la desviación de la ruta colocada de la ruta exportada en el receptor hasta que se reciba este nuevo vector DR. También mencionamos que el objetivo del algoritmo de programación de vectores DR es igualar el error de exportación en todos los receptores durante un período de tiempo. Dado que el juego se juega en un entorno distribuido, tiene sentido que el remitente de una entidad lleve un registro de todos los errores en los receptores e intente igualarlos. Sin embargo, el remitente no puede conocer el error real en un receptor hasta que reciba alguna información sobre el error del receptor. Nuestro algoritmo estima el error para calcular un horario para enviar vectores DR a los receptores y corrige el error cuando recibe retroalimentación de los receptores. En esta sección proporcionamos las motivaciones para el algoritmo y describimos los pasos por los que atraviesa. A lo largo de esta sección, utilizaremos el siguiente ejemplo para ilustrar el algoritmo. tiempoT1 Ruta exportada Ruta colocada en el receptor 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 enviado al receptor 1 DR1 enviado al receptor 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimado para ser recibido por el receptor 2 DR1 estimado para ser recibido por el receptor 1 DR1 recibido realmente por el receptor 1 DR1 recibido realmente por el receptor 2 DR0 enviado a ambos receptores DR1 calculado por el remitente Ruta colocada en el receptor 1 Figura 2: Flujo de vector DR entre un remitente y dos receptores y la evolución de las rutas colocadas estimadas y reales en los receptores. DR0 = (T0, T0, x0, y0, vx0, vy0), enviado en el tiempo T0 a ambos receptores. DR1 = (T1, T1 1 , x1, y1, vx1, vy1) enviado en el tiempo T1 1 = T1+δ1 al receptor 1 y DR1 = (T1, T2 1 , x1, y1, vx1, vy1) enviado en el tiempo T2 1 = T1 + δ2 al receptor 2. Considera el ejemplo en la Figura 2. La figura muestra un único emisor enviando vectores DR para una entidad a dos receptores diferentes 1 y 2. DR0 calculado en T0 es enviado y recibido por los receptores en algún momento entre T0 y T1, momento en el cual mueven la ubicación de la entidad para que coincida con la ruta exportada. Por lo tanto, la trayectoria de la entidad se muestra solo desde el punto en que la trayectoria colocada coincide con la trayectoria exportada para DR0. Ahora considera DR1. En el tiempo T1, DR1 es calculado por el remitente, pero se asume que no es enviado inmediatamente a los receptores y solo se envía después de un tiempo δ1 al receptor 1 (en el tiempo T1 1 = T1 + δ1) y después de un tiempo δ2 al receptor 2 (en el tiempo T2 1 = T1 + δ2). Ten en cuenta que el remitente incluye la marca de tiempo de envío con el vector DR como se muestra en la figura. Supongamos que el remitente estima (pronto quedará claro por qué el remitente tiene que estimar el retraso) que después de un retraso de dt1, el receptor 1 lo recibirá, utilizará los parámetros de coordenadas y velocidad para calcular la ubicación actual de la entidad y moverla allí (punto C) y a partir de ese momento, los caminos exportado y colocado serán iguales. Sin embargo, en realidad, el receptor 1 recibe DR1 después de un retraso de da1 (que es menor que las estimaciones de los remitentes de dt1), y mueve la entidad correspondiente al punto H. De manera similar, el remitente estima que después de un retraso de dt2, el receptor 2 recibirá DR1, calculará la ubicación actual de la entidad y la moverá a ese punto (punto E), mientras que en realidad recibe DR1 después de un retraso de da2 > dt2 y mueve la entidad al punto N. Los otros puntos mostrados en las rutas colocadas y exportadas se utilizarán más adelante en la discusión para describir diferentes componentes de error. 4.1 Cálculo del Error de Exportación Relativo Volviendo a la discusión de la Sección 3, desde la perspectiva de los remitentes, el error de exportación en el receptor 1 debido a DR1 se da por Err(DR1, T1, T1 + δ1 + dt1) (la integral de la distancia entre las trayectorias AC y DB en el intervalo de tiempo [T1, T1 + δ1 + dt1]) de la Figura 2. Esto se debe a que el remitente utiliza el retraso estimado dt1 para calcular este error. De manera similar, el error de exportación desde la perspectiva del remitente en el recibido 2 debido a DR1 se da por Err(DR1, T1, T1 + δ2 + dt2) (la integral de la distancia entre las trayectorias AE y DF en el intervalo de tiempo [T1, T1 + δ2 + dt2]). Ten en cuenta que los errores anteriores desde la perspectiva del remitente son solo estimaciones. En realidad, el error de exportación será tanto menor como mayor que el valor estimado, dependiendo de si la estimación de retraso fue mayor o menor que el retraso real experimentado por DR1. La diferencia entre el error de exportación estimado y el real es el error de exportación relativo (que puede ser positivo o negativo) que ocurre para cada vector de DR que se envía y se acumula en el remitente. El concepto de error relativo de exportación se ilustra en la Figura 2. Dado que el retraso actual al receptor 1 es da1, el error de exportación inducido por DR1 en el receptor 1 es Err(DR1, T1, T1 + δ1 + da1). Esto significa que hay un error en el error estimado de exportación y el remitente solo puede calcular este error después de recibir un comentario del receptor sobre la demora real en la entrega de DR1, es decir, el valor de da1. Proponemos que una vez que el receptor 1 reciba DR1, envíe el valor de da1 de vuelta al remitente. El receptor puede calcular esta información ya que conoce el momento en que se envió DR1 (T1 1 = T1 + δ1, que se añade al vector DR como se muestra en la Figura 2) y el tiempo local de recepción (que está sincronizado con el reloj del emisor). Por lo tanto, el remitente calcula el error relativo de exportación para el receptor 1, representado como R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1). De manera similar, el error relativo de exportación para el receptor 2 se calcula como R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2). Nótese que R1 > 0 ya que da1 < dt1, y R2 < 0 ya que da2 > dt2. Los errores relativos de exportación son calculados por el remitente en el momento en que recibe la retroalimentación de los destinatarios. Este ejemplo muestra los 4 valores relativos de error de exportación después de que se envía DR1 y se reciben los comentarios correspondientes. 4.2 Igualación del Error Entre Receptores Ahora explicamos lo que queremos decir al hacer que los errores sean iguales en todos los receptores y cómo se puede lograr esto. Como se mencionó anteriormente, el remitente mantiene estimaciones de los retrasos a los receptores, dt1 y dt2 en el ejemplo de la Figura 2. Esto indica que en el momento T1 cuando se calcula DR1, el remitente ya sabe cuánto tiempo pueden tardar los mensajes que llevan este vector DR en llegar a los receptores. El remitente utiliza esta información para calcular los errores de exportación, que son Err(DR1, T1, T1 + δ1 + dt1) y Err(DR1, T1, T1 + δ2 + dt2) para los receptores 1 y 2, respectivamente. Ten en cuenta que las áreas de estos componentes de error son una función de δ1 y δ2, así como de las demoras de red dt1 y dt2. Si queremos que los errores de exportación debido a DR1 sean iguales en ambos receptores, el remitente debe elegir δ1 y δ2 de manera que Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2). Pero cuando se calculó T1, ya podría haberse acumulado errores relativos de exportación debido a los vectores DR anteriores (DR0 y los anteriores). Representemos el error relativo acumulado hasta DRi para el receptor j como Ri j. Para acomodar estos errores relativos acumulados, el remitente debe elegir ahora δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Los δi determinan el instante de programación del vector DR en el remitente para el receptor i. Este método de cálculo de δs garantiza que el error de exportación acumulado (es decir, el error total real) para cada receptor se iguala en la transmisión de cada vector DR. Para establecer esto, asuma que la retroalimentación para el vector DR Di de un receptor llega al remitente antes de que se calcule el horario para Di+1. Que Si m y Ai m denoten el error estimado para el receptor m utilizado para calcular el horario para Di y el error acumulado para el receptor m calculado después de recibir retroalimentación para Di, respectivamente. Entonces Ri m = Ai m − Si m. Para calcular las instancias de programación (es decir, δs) para Di, para cualquier par de receptores m y n, hacemos Ri−1 m + Si m = Ri−1 n + Si n. El siguiente teorema establece el hecho de que el error acumulado de exportación se iguala en cada instante de programación. TEOREMA 4.1. Cuando se calculan las instancias de horario para enviar Di a cualquier par de receptores m y n, se cumple la siguiente condición: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Prueba: Por inducción. Supongamos que la premisa se cumple para algún i. Mostramos que se cumple para i+1. El caso base para i = 1 se cumple ya que inicialmente R0 m = R0 n = 0, y se utiliza S1 m = S1 n para calcular las instancias de programación. Para calcular el horario de Di+1, primero calculamos los errores relativos como Ri m = Ai m − Si m y Ri n = Ai n − Si n. Luego, para calcular δs, ejecutamos Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n. Añadiendo la condición de la premisa en ambos lados obtenemos, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n. 4.3 Cálculo del Error de Exportación. Ahora consideremos cómo se pueden calcular los errores de exportación. De la sección anterior, para encontrar δ1 y δ2 necesitamos encontrar Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2). Se debe tener en cuenta que los valores de R0 1 y R0 2 ya son conocidos en el remitente. Considera el cálculo de Err(DR1, T1, T1 +δ1 +dt1). Esta es la integral de la distancia entre las trayectorias AC debido a DR1 y BD debido a DR0. A partir de DR0 y DR1, el punto A es (X1, Y1) = (x1, y1) y el punto B es (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0). La trayectoria AC puede ser representada como una función del tiempo como (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) y la trayectoria de BD puede ser representada como (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t). La distancia entre las dos trayectorias como función del tiempo se convierte entonces en, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Sea a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Entonces dist(t) se puede escribir como dist(t) = a × t2 + b × t + c. Luego Err(DR1, t1, t2) para algún intervalo de tiempo [t1, t2] se convierte en t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt. Una solución en forma cerrada para la integral indefinida a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2) pueden entonces ser calculadas aplicando los límites apropiados a la solución anterior. En la siguiente sección, consideramos el cálculo de los δs para N receptores. 5 4.4 Cálculo de Instantes de Programación Volvemos a analizar el cálculo de los δs haciendo referencia a la Figura 2. El remitente elige δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 + Err(DR1, T1, T1 + δ2 +dt2). Si R0 1 y R0 2 ambos son cero, entonces δ1 y δ2 deben ser elegidos de tal manera que Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2). Esta igualdad se mantendrá si δ1 + dt1 = δ2 + dt2. Por lo tanto, si no hay error acumulado relativo de exportación, todo lo que el remitente necesita hacer es elegir los δs de tal manera que contrarresten la diferencia en el retraso a los dos receptores, para que reciban el vector DR al mismo tiempo. Como se discutió anteriormente, dado que el remitente no puede aprender de antemano el retraso, siempre habrá un error relativo acumulado de exportación de un vector DR previo que debe tenerse en cuenta. Para profundizar en esto, considera el cálculo del error de exportación como se ilustra en la sección anterior. Para calcular los δs necesitamos que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Es decir, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt. Eso es R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt. Los componentes R0 1, R0 2, ya son conocidos por (o estimados por) el remitente. Además, los componentes de error T1+dt1 T1 dist(t) dt y T1+dt2 T1 dist(t) dt pueden ser calculados a priori por el remitente utilizando valores estimados de dt1 y dt2. Usemos E1 para denotar R0 1 + T1+dt1 T1 dist(t) dt y E2 para denotar R0 2 + T1+dt2 T1 dist(t) dt. Entonces, requerimos que E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. Suponga que E1 > E2. Entonces, para que la ecuación anterior se cumpla, requerimos que T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt. Para hacer el juego lo más rápido posible dentro de este marco, los valores de δ deben ser lo más pequeños posible para que los vectores DR se envíen a los receptores lo antes posible, sujeto al requisito de equidad. Dado esto, elegiríamos δ1 como cero y calcularíamos δ2 a partir de la ecuación E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. En general, si hay N receptores 1, . . . , N, cuando un emisor genera un vector DR y decide programarlos para ser enviados, primero calcula los valores de Ei para todos ellos a partir de los errores relativos acumulados en la exportación y las estimaciones de los retrasos. Luego, encuentra el valor más pequeño de estos valores. Que Ek sea el valor más pequeño. El remitente hace que δk sea cero y calcula el resto de los δs a partir de la igualdad Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) Los δs así obtenidos dan los instantes de programación del vector DR para los receptores. 4.5 Pasos del Algoritmo de Programación Para los fines de la discusión a continuación, como antes, vamos a denotar el error relativo acumulado en un remitente para el receptor k hasta DRi como Ri k. Vamos a denotar el retraso programado en el remitente antes de que DRi sea enviado al receptor k como δi k. Dada la discusión anterior, los pasos del algoritmo son los siguientes: 1. El remitente calcula DRi en el tiempo Ti y luego calcula δi k y Ri−1 k, ∀k, 1 ≤ k ≤ N basándose en la estimación de los retrasos dtk, ∀k, 1 ≤ k ≤ N según la Ecuación (1). Programa que DRi se envíe al receptor k en el tiempo Ti + δi k. 2. Los vectores DR se envían a los receptores en los horarios programados, los cuales se reciben después de un retraso de dak, ∀k, 1 ≤ k ≤ N donde dak ≤ o > dtk. Los receptores envían el valor de dak de vuelta al remitente (el receptor puede calcular este valor basándose en las marcas de tiempo en el vector DR como se describió anteriormente). 3. El remitente calcula Ri k como se describe anteriormente e ilustra en la Figura 2. El remitente también recalcula (utilizando un método de promedio exponencial similar a la estimación del tiempo de ida y vuelta por TCP [10]) la estimación del retraso dtk a partir del nuevo valor de dak para el receptor k. 4. Vuelve al Paso 1 para calcular DRi+1 cuando sea necesario y sigue los pasos del algoritmo para programar y enviar este vector DR a los receptores. 4.6 Manejo de Casos en la Práctica Hasta ahora asumimos implícitamente que DRi se envía a todos los receptores antes de tomar una decisión para calcular el siguiente vector DR DRi+1, y los receptores envían el valor de dak correspondiente a DRi y esta información llega al remitente antes de que calcule DRi+1 para que pueda calcular Ri+1 k y luego usarlo en el cálculo de δi+1 k. Dos cuestiones deben tenerse en cuenta con respecto al algoritmo anterior cuando se utiliza en la práctica. • Puede suceder que se calcule un nuevo vector DR incluso antes de que el vector DR anterior se envíe a todos los receptores. ¿Cómo se manejará esta situación? • ¿Qué sucede si la retroalimentación no llega antes de que se calcule y programe el envío de DRi+1? Consideremos el primer escenario. Suponemos que DRi ha sido programado para ser enviado y los instantes de programación son tales que δi 1 < δi 2 < · · · < δi N. Suponga que se va a calcular DRi+1 (porque la trayectoria real se ha desviado excediendo un umbral de la trayectoria exportada por DRi) en el tiempo Ti+1 donde Ti + δi k < Ti+1 < Ti + δi k+1. Esto significa que DRi ha sido enviado solo a receptores hasta k en el orden programado. En nuestro algoritmo, en este caso, se vacía la cola de ordenación de retrasos programados, lo que significa que DRi no se envía a los receptores que aún están en cola para recibirlo, pero se calcula un nuevo orden de programación para que todos los receptores envíen DRi+1. Para aquellos receptores a quienes se les ha enviado DRi, asumir por ahora que se ha recibido de todos los receptores daj, 1 ≤ j ≤ k (el escenario donde daj no ha sido recibido se considerará como parte del segundo escenario más tarde). Para estos receptores, Ei j, 1 ≤ j ≤ k se pueden calcular. Para aquellos receptores j, k + 1 ≤ j ≤ N a quienes no se les envió DRi, Ei j no aplica. Considera un receptor j, k + 1 ≤ j ≤ N a quien no se le envió DRi. Consulte la Figura 3. Para un receptor j dado, cuando se programa DRi+1 y se exporta la ruta dtj A B C D Ti-1 Gi j, DRi+1 calculado por el remitente y DRi para el receptor k+1 a N se eliminan de la cola. DRi+1 programado para el receptor k+1, Ti+1 G H E F, DRi programado para el receptor j, DRi calculado por el remitente, se coloca la ruta en el receptor k+1, Gi+1 j. Figura 3: Cálculo de programación cuando DRi no se envía al receptor j, k + 1 ≤ j ≤ N. Se necesita calcular δi+1 j, el error total de exportación es el error de exportación relativo acumulado en el tiempo Ti cuando se programó el DRi, más la integral de la distancia entre las dos trayectorias AC y BD de la Figura 3 en el intervalo de tiempo [Ti, Ti+1 + δi+1 j + dtj]. Ten en cuenta que esta integral está dada por Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj). Por lo tanto, en lugar de Ei j de la Ecuación (1), utilizamos el valor Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) donde Ri−1 j es el error relativo de exportación utilizado cuando se calculó el horario para DRi. Ahora considera el segundo escenario. Aquí el dak de retroalimentación correspondiente a DRi no ha llegado antes de que se calcule y programe DRi+1. En este caso, Ri k no se puede calcular. Por lo tanto, en el cálculo de δk para DRi+1, se asumirá que es cero. Suponemos que se utiliza un mecanismo confiable para enviar el dak de vuelta al remitente. Cuando esta información llegue en un momento posterior, Ri k se calculará y acumulará a los errores relativos de exportación futuros (por ejemplo, Ri+1 k si dak se recibe antes de que se calcule DRi+2) y se utilizará en el cálculo de δk cuando se programe un vector DR futuro (por ejemplo, DRi+2). 4.7 Resultados Experimentales Para evaluar la efectividad y cuantificar los beneficios obtenidos a través del uso del algoritmo de programación, implementamos el algoritmo propuesto en el juego BZFlag (Battle Zone Flag) [11]. Es un juego de disparos en primera persona donde los jugadores en equipos conducen tanques y se mueven dentro de un campo de batalla. El objetivo de los jugadores es navegar y capturar las banderas pertenecientes al otro equipo y llevarlas de vuelta a su propia área. Los jugadores disparan a los tanques de los demás usando balas de disparo. El movimiento de los tanques, así como el de los disparos, se intercambian entre los jugadores utilizando vectores DR. Hemos modificado la implementación de BZFlag para incorporar relojes sincronizados entre los jugadores y el servidor, y intercambiar marcas de tiempo con el vector DR. Establecimos un banco de pruebas con cuatro jugadores ejecutando la versión instrumentada de BZFlag, con uno como emisor y el resto como receptores. El enfoque de programación y el caso base en el que cada vector de DR se envió a todos los receptores simultáneamente en cada punto de activación se implementaron en la misma ejecución etiquetando los vectores de DR según el tipo de enfoque utilizado para enviar el vector de DR. NISTNet [12] se utilizó para introducir retrasos en el emisor y los tres receptores. Se introdujeron retrasos medios de 800 ms, 500 ms y 200 ms entre el emisor y el primer, segundo y tercer receptor, respectivamente. Introducimos una variación de 100 milisegundos (al retraso medio de cada receptor) para modelar la variabilidad en el retraso. El remitente registró los errores de cada receptor cada 100 milisegundos tanto para el enfoque de programación como para el caso base. El remitente también calculó la desviación estándar y la media del error de exportación acumulado de todos los receptores cada 100 milisegundos. La Figura 4 representa la media y la desviación estándar del error acumulado de exportación de todos los receptores en el caso de programación frente al caso base. Ten en cuenta que el eje x de estos gráficos (y de los demás gráficos que siguen) representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe que la desviación estándar del error con la programación es mucho menor en comparación con el caso base. Esto implica que los errores acumulados de los receptores en el caso de programación están más cerca unos de otros. Esto demuestra que el enfoque de programación logra equidad entre los receptores incluso si se encuentran a diferentes distancias (es decir, latencias) del emisor. Observe que la media del error acumulado aumentó varias veces con la programación en comparación con el caso base. La exploración adicional de la razón del aumento en la media llevó a la conclusión de que cada vez que los vectores de DR se programan de manera que igualen el error total, empuja el error total de cada receptor hacia arriba. Además, dado que el error acumulado tiene un componente estimado, el horario no es preciso para igualar los errores de los receptores, lo que provoca que el vector de DR llegue antes o después de la programación real. En cualquier caso, el error no se iguala y si el vector de DR llega tarde, en realidad aumenta el error para un receptor más allá del error acumulado más alto. Esto significa que en el próximo disparo, este receptor será el que tenga el error más alto y el error de todos los demás receptores se ajustará a este valor de error. Este efecto de cambio repentino conlleva un aumento en el error acumulado para todos los receptores. La programación para la equidad conduce a la disminución de la desviación estándar (es decir, aumenta la equidad entre los diferentes jugadores), pero esto conlleva un mayor error medio, lo cual puede no ser una característica deseable. Esto nos llevó a explorar diferentes formas de igualar los errores acumulados. El enfoque discutido en la siguiente sección es un enfoque heurístico basado en la siguiente idea. Utilizando la misma cantidad de vectores de DR a lo largo del tiempo que en el caso base, en lugar de enviar los vectores de DR a todos los receptores con la misma frecuencia que en el caso base, si podemos aumentar la frecuencia de envío de los vectores de DR al receptor con un error acumulado más alto y disminuir la frecuencia de envío de los vectores de DR al receptor con un error acumulado más bajo, podemos igualar el error de exportación de todos los receptores a lo largo del tiempo. Al mismo tiempo, deseamos disminuir el error del receptor con el error acumulado más alto en el caso base (por supuesto, este receptor recibiría más vectores DR que en el caso base). Nos referimos a dicho algoritmo como un algoritmo basado en presupuesto. ALGORITMO BASADO EN PRESUPUESTO En un juego, el remitente de una entidad envía vectores DR a todos los receptores cada vez que la entidad cruza un umbral. Al reducir el umbral, se generan más vectores de DR durante un período de tiempo dado. Dado que los vectores DR se envían a todos los receptores y el retraso de red entre los pares emisor-receptor no se puede evitar, el error antes de la exportación 3 con el jugador más distante siempre será 3. Tenga en cuenta que después de la exportación, el error se elimina mediante el uso de un reloj sincronizado entre los jugadores. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 Error acumulado promedio en segundos Algoritmo de programación del caso base #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 Desviación estándar del error acumulado en segundos Algoritmo de programación del caso base #1 Figura 4: Promedio y desviación estándar del error con programación y sin ella (es decir, caso base) serán más altos que el resto. Para mitigar el desequilibrio en el error, proponemos enviar vectores de DR selectivamente a diferentes jugadores basándonos en los errores acumulados de estos jugadores. El algoritmo basado en presupuesto se fundamenta en esta idea y existen dos variaciones de él. Uno es un esquema de presupuesto probabilístico y el otro, un esquema de presupuesto determinístico. 5.1 Esquema de presupuesto probabilístico El esquema de presupuesto probabilístico tiene tres pasos principales: a) reducir el umbral de navegación inercial pero al mismo tiempo mantener el número total de DR enviados igual que en el caso base, b) en cada disparador, elegir probabilísticamente a un jugador para enviarle el vector de DR, y c) enviar el vector de DR al jugador elegido. Estos pasos se describen a continuación. La reducción del umbral de DR se implementa de la siguiente manera. Reducir el umbral es equivalente a aumentar el número de puntos de activación donde se generan los vectores de DR. Supongamos que el umbral es tal que el número de disparadores causados por él en el caso base es t y en cada disparador se envían n vectores DR por el remitente, lo que resulta en un total de nt vectores DR. Nuestro objetivo es mantener el número total de vectores DR enviados por el remitente fijo en nt, pero reducir el número de vectores DR enviados en cada activación (es decir, no enviar el vector DR a todos los receptores). Que n y t sean el número de vectores DR enviados en cada disparo y el número de disparos respectivamente en el caso modificado. Queremos asegurarnos de que n t = nt. Dado que queremos aumentar el número de puntos de activación, es decir, t > t, esto significaría que n < n. Es decir, no todos los receptores recibirán el vector DR en cada activación. En el esquema de presupuesto probabilístico, en cada activación, se calcula una probabilidad para que cada receptor reciba un vector DR y solo un receptor recibe el DR (n = 1). Esta probabilidad se basa en los pesos relativos de los errores acumulados de los receptores. Es decir, un receptor con un error acumulado más alto tendrá una probabilidad más alta de recibir el vector DR. Ten en cuenta que el error acumulado para tres jugadores es a1, a2 y a3 respectivamente. Entonces, la probabilidad de que el jugador 1 reciba el vector DR sería a1 a1+a2+a3. Del mismo modo para los otros jugadores. Una vez que se elige al jugador, el vector DR se envía a ese jugador. Para comparar el algoritmo basado en presupuesto probabilístico con el caso base, necesitábamos reducir el umbral para el caso base (para una comparación justa). Dado que el umbral de cálculo de la posición muerta en el caso base ya era muy fino, se decidió que en lugar de reducir el umbral, se compararía el enfoque basado en el presupuesto probabilístico con un caso base modificado que utilizaría el umbral normal como algoritmo basado en el presupuesto, pero el caso base se modificó de tal manera que cada tercer disparador se usaría realmente para enviar un vector de cálculo de la posición muerta a los tres receptores utilizados en nuestros experimentos. Esto fue llamado como el caso base 1/3 ya que resultó en el envío de 1/3 del número de vectores DR en comparación con el caso base. El presupuesto por disparador para el enfoque basado en la probabilidad se calculó como un vector de DR en cada disparador en comparación con tres vectores de DR en cada tercer disparador en el caso base de 1/3; por lo tanto, los dos casos resultan en el mismo número de vectores de DR enviados con el tiempo. Para evaluar la efectividad del algoritmo de presupuesto probabilístico, instrumentamos el juego BZFlag para utilizar este enfoque. Utilizamos el mismo banco de pruebas que consistía en un emisor y tres receptores con retardos de 800ms, 500ms y 200ms desde el emisor y con baja varianza de retardo (100ms) y moderada varianza de retardo (180ms). Los resultados se muestran en las Figuras 5 y 6. Como se mencionó anteriormente, el eje x de estos gráficos representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe de las figuras que la desviación estándar del error acumulado entre los receptores con el algoritmo basado en presupuesto probabilístico es menor que el caso base de 1/3 y la media es un poco más alta que el caso base de 1/3. Esto implica que el juego es más justo en comparación con el caso base de 1/3 a costa de aumentar ligeramente el error medio en comparación con el caso base de 1/3. El aumento en el error medio en el caso probabilístico en comparación con el caso base de 1/3 se puede atribuir al hecho de que, aunque en promedio el enfoque probabilístico envía el mismo número de vectores DR que el caso base de 1/3, a veces envía vectores DR a un receptor con menos frecuencia y a veces con más frecuencia que el caso base de 1/3 debido a su naturaleza probabilística. Cuando un receptor no recibe un vector DR durante mucho tiempo, la trayectoria del receptor se aleja cada vez más de la trayectoria del emisor y, por lo tanto, la tasa de acumulación del error en el receptor es mayor. En ocasiones, cuando un receptor recibe vectores de DR con más frecuencia, acumula errores a un ritmo más bajo, pero no hay forma de revertir el error acumulado cuando no recibió un vector de DR durante mucho tiempo. Esto lleva a que los receptores acumulen más error en el caso probabilístico en comparación con el caso base de 1/3 donde los receptores reciben un vector DR casi periódicamente. Para limitar el aumento en el error medio, decidimos modificar el algoritmo basado en presupuesto para que sea determinista. Los dos primeros pasos del algoritmo son los mismos que en el algoritmo probabilístico; los puntos de activación se incrementan para reducir el umbral y los errores acumulados se utilizan para calcular la probabilidad de que un receptor reciba un vector DR. Una vez que se completen estos pasos, se calcula un horario determinista para el receptor de la siguiente manera: 1. Si hay algún receptor etiquetado para recibir un vector DR en el disparador actual, el remitente envía el vector DR al(s) receptor(es) respectivo(s). Si al menos un receptor recibió un vector DR, el remitente calcula las probabilidades de que cada receptor reciba un vector DR como se explicó anteriormente y sigue los pasos del 2 al 6; de lo contrario, no hace nada. 2. Para cada receptor, el valor de probabilidad se multiplica por el presupuesto disponible en cada activador (que se establece en 1 como se explica a continuación) para dar la frecuencia de envío del vector DR a cada receptor. Si alguna de las frecuencias de los receptores, después de multiplicarse por el presupuesto, supera 1, la frecuencia del receptor se establece en 1 y la cantidad excedente se distribuye equitativamente entre todos los receptores sumando la cantidad a sus frecuencias existentes. Este proceso se repite hasta que todos los receptores tengan una frecuencia menor o igual a 1. Esto se debe a que en un disparador no podemos enviar más de un vector DR al receptor respectivo. Eso sería un desperdicio de vectores DR al enviar información redundante. 4. (1/frecuencia) nos da el horario en el que el remitente debe enviar vectores DR al receptor respectivo. El crédito obtenido previamente (explicado en el paso 5), si lo hubiera, se resta del horario. Observe que el valor resultante del horario podría no ser un número entero; por lo tanto, el valor se redondea hacia arriba tomando el techo del horario. Por ejemplo, si la frecuencia es de 1/3.5, esto implica que nos gustaría que se enviara un vector de DR cada 3.5 disparadores. Sin embargo, estamos obligados a enviarlo en el cuarto disparo, lo que nos otorga un crédito de 0.5. Cuando enviemos el vector DR la próxima vez, podremos enviarlo en el 3er disparo debido al crédito de 0.5. La diferencia entre el horario y el límite del horario es el crédito que el receptor ha obtenido, que se recuerda para el futuro y se utiliza en el próximo momento, como se explica en el paso 4. 6. Para cada uno de esos receptores a quienes se les envió un vector DR en el disparador actual, los receptores están etiquetados para recibir el próximo vector DR en el disparador que ocurre exactamente el número de veces programado (el techo del programa) lejos del disparador actual. Observe que en este punto no se modifica el horario de ningún otro receptor, ya que todos están ejecutando un horario calculado en algún punto anterior en el tiempo. Esos horarios se modificarán automáticamente en el disparador cuando estén programados para recibir el siguiente vector de DR. En el primer disparador, el remitente envía el vector DR a todos los receptores y utiliza una probabilidad relativa de 1/n para cada receptor y sigue los pasos 2 al 6 para calcular el próximo horario para cada receptor de la misma manera que se menciona para otros disparadores. Este algoritmo garantiza que cada receptor tenga un horario garantizado para recibir vectores DR y, por lo tanto, no haya irregularidades en el envío del vector DR a ningún receptor, como se observó en el algoritmo probabilístico basado en presupuesto. Utilizamos el banco de pruebas descrito anteriormente (tres receptores con retardos variables) para evaluar el algoritmo determinista utilizando el presupuesto de 1 vector DR por activación para así utilizar el mismo número de vectores DR que en el caso base 1/3. Los resultados de nuestros experimentos se muestran en las Figuras 5 y 6. Se puede observar que la desviación estándar del error en el algoritmo basado en presupuesto determinista es menor que el caso base de 1/3 y también tiene el mismo error medio que el caso base de 1/3. Esto indica que el algoritmo determinista es más justo que el caso base de 1/3 y al mismo tiempo no aumenta el error medio, lo que conduce a una mejor calidad de juego en comparación con el algoritmo probabilístico. En general, al comparar el enfoque determinista con el enfoque probabilístico, encontramos que el error acumulado promedio siempre fue menor en el enfoque determinista. Con respecto a la desviación estándar del error acumulado, encontramos que en los casos de varianza fija o baja, el enfoque determinista fue generalmente menor, pero en casos de mayor varianza, era más difícil sacar conclusiones ya que a veces el enfoque probabilístico era mejor que el determinista. CONCLUSIONES Y TRABAJO FUTURO En los juegos multijugador distribuidos que se juegan a través de Internet, los objetos y la trayectoria de los jugadores dentro del espacio de juego se intercambian en términos de vectores DR. Debido al retraso variable entre jugadores, estos vectores DR llegan a diferentes jugadores en momentos distintos. Existe una ventaja injusta obtenida por los receptores que están más cerca del remitente del DR, ya que pueden representar la posición del remitente de manera más precisa en tiempo real. En este documento, primero desarrollamos un modelo para estimar el error en la representación de las trayectorias de los jugadores en los receptores. Luego presentamos un algoritmo basado en programar los vectores de DR para ser enviados a diferentes jugadores en diferentes momentos, igualando así el error en los diferentes jugadores. Este algoritmo tiene como objetivo hacer que el juego sea justo para todos los jugadores, pero tiende a aumentar el error promedio de los jugadores. Para contrarrestar este efecto, presentamos algoritmos basados en presupuestos donde los vectores de DR aún se programan para ser enviados a diferentes jugadores en diferentes momentos, pero el algoritmo equilibra la necesidad de equidad con el requisito de que el error de los jugadores en el peor caso (que están más lejos del remitente) no se incremente en comparación con el caso base (donde todos los vectores de DR se envían a todos los jugadores cada vez que se genera un vector de DR). Presentamos dos variaciones de los algoritmos basados en el presupuesto y, a través de experimentación, demostramos que los algoritmos reducen la desviación estándar del error, haciendo así el juego más justo y al mismo tiempo manteniendo un error medio comparable al caso base. REFERENCIAS [1] S. Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee y S. Rangarajan, Precisión en juegos distribuidos multijugador basados en Dead-Reckoning, Actas del Taller ACM SIGCOMM 2004 sobre Soporte de Redes y Sistemas para Juegos (NetGames 2004), agosto de 2004. [2] L. Gautier y C. Diot, Diseño y Evaluación de MiMaze, un juego multijugador en Internet, en Actas de IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistencia en medios interactivos continuos replicados, en Actas de la Conferencia ACM sobre Trabajo Cooperativo Asistido por Computadora (CSCW00), 2000, pp. 181-190. [4] S.K. Singhal y D.R. Cheriton, Explotando el historial de posición para una representación remota eficiente en la realidad virtual en red, Presencia: Teleoperadores y Entornos Virtuales, vol. 4, núm. 2, pp. 169-193, 1995. [5] C. Diot y L. Gautier, Una arquitectura distribuida para aplicaciones interactivas multijugador en Internet, en la revista IEEE Network, 1999, vol. 13, pp. 6-15. [6] L. Pantel y L.C. Wolf, Sobre el impacto del retraso en los juegos multijugador en tiempo real, en Actas de ACM NOSSDAV02, mayo de 2002. [7] Y. Lin, K. Guo y S. Paul, Sync-MS: Servicio de mensajería sincronizada para juegos distribuidos multijugador en tiempo real, en Actas de la 10ª Conferencia Internacional de Protocolos de Red de IEEE (ICNP), noviembre de 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan y S. Paul, Un marco de intercambio de mensajes justo para juegos distribuidos multijugador, en Actas de NetGames2003, mayo de 2003. [9] N. E. Baughman y B. N. Levine, Reproducción a prueba de trampas para juegos en línea centralizados y distribuidos, en Actas de IEEE INFOCOM01, abril de 2001. [10] M. Allman y V. Paxson, Sobre la estimación de propiedades de la ruta de red de extremo a extremo, en Actas de ACM SIGCOMM99, septiembre de 1999. [11] Foro de BZFlag, Juego de BZFlag, URL: http://www.bzflag.org. [12] Instituto Nacional de Estándares y Tecnología, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "budget based algorithm": {
            "translated_key": "algoritmo basado en presupuesto",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a <br>budget based algorithm</br> that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the <br>budget based algorithm</br> as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a <br>budget based algorithm</br> which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the <br>budget based algorithm</br> follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the <br>budget based algorithm</br> is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the <br>budget based algorithm</br> that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a <br>budget based algorithm</br>. 5.",
                "<br>budget based algorithm</br> In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The <br>budget based algorithm</br> is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic <br>budget based algorithm</br> with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the <br>budget based algorithm</br> but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic <br>budget based algorithm</br>, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic <br>budget based algorithm</br> is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the <br>budget based algorithm</br> to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic <br>budget based algorithm</br> is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "To mitigate this effect, we propose a <br>budget based algorithm</br> that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the <br>budget based algorithm</br> as part of BZFlag, a popular distributed multi-player game.",
                "To alleviate this effect, we propose a <br>budget based algorithm</br> which budgets how the DRs are sent to different players.",
                "Experimental results from BZflag illustrates that the <br>budget based algorithm</br> follows a more balanced approach.",
                "In addition, the <br>budget based algorithm</br> is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2."
            ],
            "translated_annotated_samples": [
                "Para mitigar este efecto, proponemos un <br>algoritmo basado en presupuesto</br> que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego.",
                "Hemos implementado tanto el algoritmo de programación como el <br>algoritmo basado en presupuesto</br> como parte de BZFlag, un popular juego multijugador distribuido.",
                "Para aliviar este efecto, proponemos un <br>algoritmo basado en presupuesto</br> que asigna un presupuesto para enviar los DRs a diferentes jugadores.",
                "Los resultados experimentales de BZflag ilustran que el <br>algoritmo basado en presupuesto</br> sigue un enfoque más equilibrado.",
                "Además, se ha demostrado que el <br>algoritmo basado en presupuesto</br> logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un <br>algoritmo basado en presupuesto</br> que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el <br>algoritmo basado en presupuesto</br> como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un <br>algoritmo basado en presupuesto</br> que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el <br>algoritmo basado en presupuesto</br> sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la precisión del juego. Además, se ha demostrado que el <br>algoritmo basado en presupuesto</br> logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "mean error": {
            "translated_key": "error medio",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall <br>mean error</br> of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the <br>mean error</br> thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the <br>mean error</br> of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher <br>mean error</br>, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the <br>mean error</br> by a small amount as compared to the 1/3 base case.",
                "The increase in <br>mean error</br> in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in <br>mean error</br> we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same <br>mean error</br> as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the <br>mean error</br> thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the <br>mean error</br> of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable <br>mean error</br> to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "This algorithm makes the game very fair at the expense of increasing the overall <br>mean error</br> of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the <br>mean error</br> thereby maintaining the accuracy of game playing.",
                "It improves the fairness of the game but at the same time does so without pushing up the <br>mean error</br> of the players thereby maintaining the accuracy of the game.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher <br>mean error</br>, which may not be a desirable feature.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the <br>mean error</br> by a small amount as compared to the 1/3 base case."
            ],
            "translated_annotated_samples": [
                "Este algoritmo hace que el juego sea muy justo a expensas de aumentar el <br>error medio</br> general de todos los jugadores.",
                "Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el <br>error medio</br>, manteniendo así la precisión del juego.",
                "Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el <br>error promedio</br> de los jugadores, manteniendo así la precisión del juego.",
                "La programación para la equidad conduce a la disminución de la desviación estándar (es decir, aumenta la equidad entre los diferentes jugadores), pero esto conlleva un mayor <br>error medio</br>, lo cual puede no ser una característica deseable.",
                "Esto implica que el juego es más justo en comparación con el caso base de 1/3 a costa de aumentar ligeramente el <br>error medio</br> en comparación con el caso base de 1/3."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el <br>error medio</br> general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el <br>error medio</br>, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el <br>error promedio</br> de los jugadores, manteniendo así la precisión del juego. Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores. Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado. El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de sincronización de cubo estático para compensar las variaciones en los retrasos de la red. En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota. Los jugadores con un retraso de red mayor a 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la sincronización de cubetas dependen de imponer un retraso máximo en todos los jugadores. Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados. Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto). Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción. Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización. La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras. En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego. Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor). Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la sincronización de cubos no son a prueba de trampas a menos que se implementen mecanismos adicionales. Tanto el algoritmo de programación como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas. Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida. Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño. En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1]. En la Sección 4, describimos el algoritmo de programación de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFlag. La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de precisión en el juego. Las conclusiones se presentan en la Sección 6.2.3. MODELO DE JUEGO La arquitectura del juego se basa en jugadores distribuidos a través de Internet que intercambian vectores DR entre sí. Los vectores de DR podrían ser enviados directamente de un jugador a otro (modelo peer-to-peer) o podrían ser enviados a través de un servidor de juego que recibe el vector de DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor). Como se mencionó anteriormente, asumimos que los relojes de los jugadores participantes están sincronizados. Cada vector DR enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad. Suponemos un vector DR lineal en el que la información contenida en el vector DR es solo suficiente para que el jugador receptor calcule la trayectoria y represente la entidad en un camino en línea recta. Un vector DR de este tipo contiene información sobre la posición inicial y la velocidad del jugador/entidad, donde la velocidad es constante. Por lo tanto, los vectores DR enviados por un jugador especifican el tiempo actual en el jugador cuando se calcula el vector DR (no el tiempo en el que este vector DR se envía a los otros jugadores, como explicaremos más adelante), la posición actual del jugador/entidad en términos de las coordenadas x, y, z y el vector de velocidad en la dirección de las coordenadas x, y, z. Específicamente, el vector DRi enviado por el jugador j sobre la k-ésima entidad se denota como DRj ik y está representado por la siguiente tupla (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik). Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y para una sola entidad. Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional. Por lo tanto, usamos DRi para denotar el i-ésimo vector DR representado como la tupla (Ti, xi, yi, vxi, vyi). El jugador receptor calcula la posición inicial para la entidad basándose en xi, yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo Ti en el que fue calculado. Ten en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados. El jugador receptor luego utiliza los componentes de velocidad para proyectar y representar la trayectoria de la entidad. Esta trayectoria se sigue hasta que se recibe un nuevo vector DR que cambia la posición y/o velocidad de la entidad. tiempoT1 Real Exportado Colocado dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) calculado en el tiempo T1 y enviado al receptor DR0 = (T0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptor T0 dt0 Colocado E Figura 1: Trayectorias y desviaciones. Basado en este modelo, la Figura 1 ilustra el envío y recepción de vectores DR y los diferentes errores que se encuentran. Otros tipos de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y vectores DR de spline cúbico que consideran la posición y velocidad inicial y la posición y velocidad final de la entidad. La figura muestra la recepción de vectores de DR en un jugador (en adelante llamado receptor). El eje horizontal muestra el tiempo que está sincronizado entre todos los jugadores. El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad. Suponga que en el tiempo T0 se calcula un vector DR0 por el remitente y se envía inmediatamente al receptor. Supongamos que DR0 es recibido por el receptor después de un retraso de dt0 unidades de tiempo. El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (mostrado como punto E). La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor basada en los componentes de velocidad vx0 y vy0 (ruta colocada). En el tiempo T1 se calcula un vector DR1 de enrutamiento dinámico para la misma entidad y se envía inmediatamente al receptor2. Suponga que DR1 es recibido por el receptor después de un retraso de dt1 unidades de tiempo. Cuando se recibe este vector DR, se asume que la entidad está en el punto D. Se calcula una nueva posición para la entidad como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto C). Los componentes de velocidad vx1 y vy1 se utilizan para proyectar y representar esta entidad más lejos. Ahora consideremos el error debido al retraso de la red. Aunque DR1 se calculó en el tiempo T1 y se envió al receptor, no llegó al receptor hasta el tiempo T1 + dt1. Esto significa que, aunque la ruta exportada basada en DR1 en el remitente en el tiempo T1 es la trayectoria AC, hasta el tiempo T1 + dt1, en el receptor, esta entidad estaba siendo representada en la trayectoria BD basada en DR0. Solo en el momento T1 + dt1 la entidad se movió al punto C, a partir del cual los caminos exportados y colocados son iguales. La desviación entre las rutas exportadas y colocadas crea un componente de error al que nos referimos como el error de exportación. Una forma de representar el error de exportación es calcular la integral de la distancia entre las dos trayectorias durante el tiempo en que están desincronizadas. Representamos la integral de las distancias entre las rutas colocadas y exportadas debido a algunos DR DRi en un intervalo de tiempo [t1, t2] como Err(DRi, t1, t2). En la figura, el error de exportación debido a DR1 se calcula como la integral de la distancia entre las trayectorias AC y BD en el intervalo de tiempo [T1, T1 + dt1]. Ten en cuenta que también podría haber otras formas de representar este error, pero en este artículo utilizamos la integral de la distancia entre las dos trayectorias como medida del error de exportación. Tenga en cuenta que se habría producido un error de exportación debido a la recepción de DR0, momento en el que la ruta colocada se basaría en un vector DR anterior. Esto no se muestra en la figura, pero sirve para recordar al lector que el error de exportación es acumulativo cuando se reciben una secuencia de vectores DR. A partir del tiempo T1 en adelante, hay una desviación entre las trayectorias reales y las exportadas. Como discutimos anteriormente, este error de exportación es inevitable. La figura y el ejemplo anterior ilustran solo un receptor. Pero en realidad, los vectores DR DR0 y DR1 son enviados por el remitente a todos los jugadores participantes. Cada uno de estos jugadores recibe DR0 y DR1 después de diferentes retrasos, creando así diferentes valores de error de exportación en cada jugador. El objetivo del algoritmo de programación de vectores DR que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual en cada jugador de forma independiente para cada una de las entidades que conforman el juego. ALGORITMO DE PROGRAMACIÓN PARA EL ENVÍO DE VECTORES DR En la Sección 3 mostramos cómo el retraso desde el remitente de un nuevo vector DR 2 Normalmente, los vectores DR no se calculan de forma periódica, sino bajo demanda, donde la decisión de calcular un nuevo vector DR se basa en la superación de un umbral en la desviación entre la ruta real y la ruta exportada por el vector DR anterior. 3 vector al receptor del vector DR podría llevar a un error de exportación debido a la desviación de la ruta colocada de la ruta exportada en el receptor hasta que se reciba este nuevo vector DR. También mencionamos que el objetivo del algoritmo de programación de vectores DR es igualar el error de exportación en todos los receptores durante un período de tiempo. Dado que el juego se juega en un entorno distribuido, tiene sentido que el remitente de una entidad lleve un registro de todos los errores en los receptores e intente igualarlos. Sin embargo, el remitente no puede conocer el error real en un receptor hasta que reciba alguna información sobre el error del receptor. Nuestro algoritmo estima el error para calcular un horario para enviar vectores DR a los receptores y corrige el error cuando recibe retroalimentación de los receptores. En esta sección proporcionamos las motivaciones para el algoritmo y describimos los pasos por los que atraviesa. A lo largo de esta sección, utilizaremos el siguiente ejemplo para ilustrar el algoritmo. tiempoT1 Ruta exportada Ruta colocada en el receptor 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 enviado al receptor 1 DR1 enviado al receptor 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimado para ser recibido por el receptor 2 DR1 estimado para ser recibido por el receptor 1 DR1 recibido realmente por el receptor 1 DR1 recibido realmente por el receptor 2 DR0 enviado a ambos receptores DR1 calculado por el remitente Ruta colocada en el receptor 1 Figura 2: Flujo de vector DR entre un remitente y dos receptores y la evolución de las rutas colocadas estimadas y reales en los receptores. DR0 = (T0, T0, x0, y0, vx0, vy0), enviado en el tiempo T0 a ambos receptores. DR1 = (T1, T1 1 , x1, y1, vx1, vy1) enviado en el tiempo T1 1 = T1+δ1 al receptor 1 y DR1 = (T1, T2 1 , x1, y1, vx1, vy1) enviado en el tiempo T2 1 = T1 + δ2 al receptor 2. Considera el ejemplo en la Figura 2. La figura muestra un único emisor enviando vectores DR para una entidad a dos receptores diferentes 1 y 2. DR0 calculado en T0 es enviado y recibido por los receptores en algún momento entre T0 y T1, momento en el cual mueven la ubicación de la entidad para que coincida con la ruta exportada. Por lo tanto, la trayectoria de la entidad se muestra solo desde el punto en que la trayectoria colocada coincide con la trayectoria exportada para DR0. Ahora considera DR1. En el tiempo T1, DR1 es calculado por el remitente, pero se asume que no es enviado inmediatamente a los receptores y solo se envía después de un tiempo δ1 al receptor 1 (en el tiempo T1 1 = T1 + δ1) y después de un tiempo δ2 al receptor 2 (en el tiempo T2 1 = T1 + δ2). Ten en cuenta que el remitente incluye la marca de tiempo de envío con el vector DR como se muestra en la figura. Supongamos que el remitente estima (pronto quedará claro por qué el remitente tiene que estimar el retraso) que después de un retraso de dt1, el receptor 1 lo recibirá, utilizará los parámetros de coordenadas y velocidad para calcular la ubicación actual de la entidad y moverla allí (punto C) y a partir de ese momento, los caminos exportado y colocado serán iguales. Sin embargo, en realidad, el receptor 1 recibe DR1 después de un retraso de da1 (que es menor que las estimaciones de los remitentes de dt1), y mueve la entidad correspondiente al punto H. De manera similar, el remitente estima que después de un retraso de dt2, el receptor 2 recibirá DR1, calculará la ubicación actual de la entidad y la moverá a ese punto (punto E), mientras que en realidad recibe DR1 después de un retraso de da2 > dt2 y mueve la entidad al punto N. Los otros puntos mostrados en las rutas colocadas y exportadas se utilizarán más adelante en la discusión para describir diferentes componentes de error. 4.1 Cálculo del Error de Exportación Relativo Volviendo a la discusión de la Sección 3, desde la perspectiva de los remitentes, el error de exportación en el receptor 1 debido a DR1 se da por Err(DR1, T1, T1 + δ1 + dt1) (la integral de la distancia entre las trayectorias AC y DB en el intervalo de tiempo [T1, T1 + δ1 + dt1]) de la Figura 2. Esto se debe a que el remitente utiliza el retraso estimado dt1 para calcular este error. De manera similar, el error de exportación desde la perspectiva del remitente en el recibido 2 debido a DR1 se da por Err(DR1, T1, T1 + δ2 + dt2) (la integral de la distancia entre las trayectorias AE y DF en el intervalo de tiempo [T1, T1 + δ2 + dt2]). Ten en cuenta que los errores anteriores desde la perspectiva del remitente son solo estimaciones. En realidad, el error de exportación será tanto menor como mayor que el valor estimado, dependiendo de si la estimación de retraso fue mayor o menor que el retraso real experimentado por DR1. La diferencia entre el error de exportación estimado y el real es el error de exportación relativo (que puede ser positivo o negativo) que ocurre para cada vector de DR que se envía y se acumula en el remitente. El concepto de error relativo de exportación se ilustra en la Figura 2. Dado que el retraso actual al receptor 1 es da1, el error de exportación inducido por DR1 en el receptor 1 es Err(DR1, T1, T1 + δ1 + da1). Esto significa que hay un error en el error estimado de exportación y el remitente solo puede calcular este error después de recibir un comentario del receptor sobre la demora real en la entrega de DR1, es decir, el valor de da1. Proponemos que una vez que el receptor 1 reciba DR1, envíe el valor de da1 de vuelta al remitente. El receptor puede calcular esta información ya que conoce el momento en que se envió DR1 (T1 1 = T1 + δ1, que se añade al vector DR como se muestra en la Figura 2) y el tiempo local de recepción (que está sincronizado con el reloj del emisor). Por lo tanto, el remitente calcula el error relativo de exportación para el receptor 1, representado como R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1). De manera similar, el error relativo de exportación para el receptor 2 se calcula como R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2). Nótese que R1 > 0 ya que da1 < dt1, y R2 < 0 ya que da2 > dt2. Los errores relativos de exportación son calculados por el remitente en el momento en que recibe la retroalimentación de los destinatarios. Este ejemplo muestra los 4 valores relativos de error de exportación después de que se envía DR1 y se reciben los comentarios correspondientes. 4.2 Igualación del Error Entre Receptores Ahora explicamos lo que queremos decir al hacer que los errores sean iguales en todos los receptores y cómo se puede lograr esto. Como se mencionó anteriormente, el remitente mantiene estimaciones de los retrasos a los receptores, dt1 y dt2 en el ejemplo de la Figura 2. Esto indica que en el momento T1 cuando se calcula DR1, el remitente ya sabe cuánto tiempo pueden tardar los mensajes que llevan este vector DR en llegar a los receptores. El remitente utiliza esta información para calcular los errores de exportación, que son Err(DR1, T1, T1 + δ1 + dt1) y Err(DR1, T1, T1 + δ2 + dt2) para los receptores 1 y 2, respectivamente. Ten en cuenta que las áreas de estos componentes de error son una función de δ1 y δ2, así como de las demoras de red dt1 y dt2. Si queremos que los errores de exportación debido a DR1 sean iguales en ambos receptores, el remitente debe elegir δ1 y δ2 de manera que Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2). Pero cuando se calculó T1, ya podría haberse acumulado errores relativos de exportación debido a los vectores DR anteriores (DR0 y los anteriores). Representemos el error relativo acumulado hasta DRi para el receptor j como Ri j. Para acomodar estos errores relativos acumulados, el remitente debe elegir ahora δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Los δi determinan el instante de programación del vector DR en el remitente para el receptor i. Este método de cálculo de δs garantiza que el error de exportación acumulado (es decir, el error total real) para cada receptor se iguala en la transmisión de cada vector DR. Para establecer esto, asuma que la retroalimentación para el vector DR Di de un receptor llega al remitente antes de que se calcule el horario para Di+1. Que Si m y Ai m denoten el error estimado para el receptor m utilizado para calcular el horario para Di y el error acumulado para el receptor m calculado después de recibir retroalimentación para Di, respectivamente. Entonces Ri m = Ai m − Si m. Para calcular las instancias de programación (es decir, δs) para Di, para cualquier par de receptores m y n, hacemos Ri−1 m + Si m = Ri−1 n + Si n. El siguiente teorema establece el hecho de que el error acumulado de exportación se iguala en cada instante de programación. TEOREMA 4.1. Cuando se calculan las instancias de horario para enviar Di a cualquier par de receptores m y n, se cumple la siguiente condición: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Prueba: Por inducción. Supongamos que la premisa se cumple para algún i. Mostramos que se cumple para i+1. El caso base para i = 1 se cumple ya que inicialmente R0 m = R0 n = 0, y se utiliza S1 m = S1 n para calcular las instancias de programación. Para calcular el horario de Di+1, primero calculamos los errores relativos como Ri m = Ai m − Si m y Ri n = Ai n − Si n. Luego, para calcular δs, ejecutamos Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n. Añadiendo la condición de la premisa en ambos lados obtenemos, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n. 4.3 Cálculo del Error de Exportación. Ahora consideremos cómo se pueden calcular los errores de exportación. De la sección anterior, para encontrar δ1 y δ2 necesitamos encontrar Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2). Se debe tener en cuenta que los valores de R0 1 y R0 2 ya son conocidos en el remitente. Considera el cálculo de Err(DR1, T1, T1 +δ1 +dt1). Esta es la integral de la distancia entre las trayectorias AC debido a DR1 y BD debido a DR0. A partir de DR0 y DR1, el punto A es (X1, Y1) = (x1, y1) y el punto B es (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0). La trayectoria AC puede ser representada como una función del tiempo como (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) y la trayectoria de BD puede ser representada como (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t). La distancia entre las dos trayectorias como función del tiempo se convierte entonces en, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Sea a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Entonces dist(t) se puede escribir como dist(t) = a × t2 + b × t + c. Luego Err(DR1, t1, t2) para algún intervalo de tiempo [t1, t2] se convierte en t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt. Una solución en forma cerrada para la integral indefinida a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2) pueden entonces ser calculadas aplicando los límites apropiados a la solución anterior. En la siguiente sección, consideramos el cálculo de los δs para N receptores. 5 4.4 Cálculo de Instantes de Programación Volvemos a analizar el cálculo de los δs haciendo referencia a la Figura 2. El remitente elige δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 + Err(DR1, T1, T1 + δ2 +dt2). Si R0 1 y R0 2 ambos son cero, entonces δ1 y δ2 deben ser elegidos de tal manera que Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2). Esta igualdad se mantendrá si δ1 + dt1 = δ2 + dt2. Por lo tanto, si no hay error acumulado relativo de exportación, todo lo que el remitente necesita hacer es elegir los δs de tal manera que contrarresten la diferencia en el retraso a los dos receptores, para que reciban el vector DR al mismo tiempo. Como se discutió anteriormente, dado que el remitente no puede aprender de antemano el retraso, siempre habrá un error relativo acumulado de exportación de un vector DR previo que debe tenerse en cuenta. Para profundizar en esto, considera el cálculo del error de exportación como se ilustra en la sección anterior. Para calcular los δs necesitamos que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Es decir, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt. Eso es R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt. Los componentes R0 1, R0 2, ya son conocidos por (o estimados por) el remitente. Además, los componentes de error T1+dt1 T1 dist(t) dt y T1+dt2 T1 dist(t) dt pueden ser calculados a priori por el remitente utilizando valores estimados de dt1 y dt2. Usemos E1 para denotar R0 1 + T1+dt1 T1 dist(t) dt y E2 para denotar R0 2 + T1+dt2 T1 dist(t) dt. Entonces, requerimos que E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. Suponga que E1 > E2. Entonces, para que la ecuación anterior se cumpla, requerimos que T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt. Para hacer el juego lo más rápido posible dentro de este marco, los valores de δ deben ser lo más pequeños posible para que los vectores DR se envíen a los receptores lo antes posible, sujeto al requisito de equidad. Dado esto, elegiríamos δ1 como cero y calcularíamos δ2 a partir de la ecuación E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. En general, si hay N receptores 1, . . . , N, cuando un emisor genera un vector DR y decide programarlos para ser enviados, primero calcula los valores de Ei para todos ellos a partir de los errores relativos acumulados en la exportación y las estimaciones de los retrasos. Luego, encuentra el valor más pequeño de estos valores. Que Ek sea el valor más pequeño. El remitente hace que δk sea cero y calcula el resto de los δs a partir de la igualdad Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) Los δs así obtenidos dan los instantes de programación del vector DR para los receptores. 4.5 Pasos del Algoritmo de Programación Para los fines de la discusión a continuación, como antes, vamos a denotar el error relativo acumulado en un remitente para el receptor k hasta DRi como Ri k. Vamos a denotar el retraso programado en el remitente antes de que DRi sea enviado al receptor k como δi k. Dada la discusión anterior, los pasos del algoritmo son los siguientes: 1. El remitente calcula DRi en el tiempo Ti y luego calcula δi k y Ri−1 k, ∀k, 1 ≤ k ≤ N basándose en la estimación de los retrasos dtk, ∀k, 1 ≤ k ≤ N según la Ecuación (1). Programa que DRi se envíe al receptor k en el tiempo Ti + δi k. 2. Los vectores DR se envían a los receptores en los horarios programados, los cuales se reciben después de un retraso de dak, ∀k, 1 ≤ k ≤ N donde dak ≤ o > dtk. Los receptores envían el valor de dak de vuelta al remitente (el receptor puede calcular este valor basándose en las marcas de tiempo en el vector DR como se describió anteriormente). 3. El remitente calcula Ri k como se describe anteriormente e ilustra en la Figura 2. El remitente también recalcula (utilizando un método de promedio exponencial similar a la estimación del tiempo de ida y vuelta por TCP [10]) la estimación del retraso dtk a partir del nuevo valor de dak para el receptor k. 4. Vuelve al Paso 1 para calcular DRi+1 cuando sea necesario y sigue los pasos del algoritmo para programar y enviar este vector DR a los receptores. 4.6 Manejo de Casos en la Práctica Hasta ahora asumimos implícitamente que DRi se envía a todos los receptores antes de tomar una decisión para calcular el siguiente vector DR DRi+1, y los receptores envían el valor de dak correspondiente a DRi y esta información llega al remitente antes de que calcule DRi+1 para que pueda calcular Ri+1 k y luego usarlo en el cálculo de δi+1 k. Dos cuestiones deben tenerse en cuenta con respecto al algoritmo anterior cuando se utiliza en la práctica. • Puede suceder que se calcule un nuevo vector DR incluso antes de que el vector DR anterior se envíe a todos los receptores. ¿Cómo se manejará esta situación? • ¿Qué sucede si la retroalimentación no llega antes de que se calcule y programe el envío de DRi+1? Consideremos el primer escenario. Suponemos que DRi ha sido programado para ser enviado y los instantes de programación son tales que δi 1 < δi 2 < · · · < δi N. Suponga que se va a calcular DRi+1 (porque la trayectoria real se ha desviado excediendo un umbral de la trayectoria exportada por DRi) en el tiempo Ti+1 donde Ti + δi k < Ti+1 < Ti + δi k+1. Esto significa que DRi ha sido enviado solo a receptores hasta k en el orden programado. En nuestro algoritmo, en este caso, se vacía la cola de ordenación de retrasos programados, lo que significa que DRi no se envía a los receptores que aún están en cola para recibirlo, pero se calcula un nuevo orden de programación para que todos los receptores envíen DRi+1. Para aquellos receptores a quienes se les ha enviado DRi, asumir por ahora que se ha recibido de todos los receptores daj, 1 ≤ j ≤ k (el escenario donde daj no ha sido recibido se considerará como parte del segundo escenario más tarde). Para estos receptores, Ei j, 1 ≤ j ≤ k se pueden calcular. Para aquellos receptores j, k + 1 ≤ j ≤ N a quienes no se les envió DRi, Ei j no aplica. Considera un receptor j, k + 1 ≤ j ≤ N a quien no se le envió DRi. Consulte la Figura 3. Para un receptor j dado, cuando se programa DRi+1 y se exporta la ruta dtj A B C D Ti-1 Gi j, DRi+1 calculado por el remitente y DRi para el receptor k+1 a N se eliminan de la cola. DRi+1 programado para el receptor k+1, Ti+1 G H E F, DRi programado para el receptor j, DRi calculado por el remitente, se coloca la ruta en el receptor k+1, Gi+1 j. Figura 3: Cálculo de programación cuando DRi no se envía al receptor j, k + 1 ≤ j ≤ N. Se necesita calcular δi+1 j, el error total de exportación es el error de exportación relativo acumulado en el tiempo Ti cuando se programó el DRi, más la integral de la distancia entre las dos trayectorias AC y BD de la Figura 3 en el intervalo de tiempo [Ti, Ti+1 + δi+1 j + dtj]. Ten en cuenta que esta integral está dada por Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj). Por lo tanto, en lugar de Ei j de la Ecuación (1), utilizamos el valor Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) donde Ri−1 j es el error relativo de exportación utilizado cuando se calculó el horario para DRi. Ahora considera el segundo escenario. Aquí el dak de retroalimentación correspondiente a DRi no ha llegado antes de que se calcule y programe DRi+1. En este caso, Ri k no se puede calcular. Por lo tanto, en el cálculo de δk para DRi+1, se asumirá que es cero. Suponemos que se utiliza un mecanismo confiable para enviar el dak de vuelta al remitente. Cuando esta información llegue en un momento posterior, Ri k se calculará y acumulará a los errores relativos de exportación futuros (por ejemplo, Ri+1 k si dak se recibe antes de que se calcule DRi+2) y se utilizará en el cálculo de δk cuando se programe un vector DR futuro (por ejemplo, DRi+2). 4.7 Resultados Experimentales Para evaluar la efectividad y cuantificar los beneficios obtenidos a través del uso del algoritmo de programación, implementamos el algoritmo propuesto en el juego BZFlag (Battle Zone Flag) [11]. Es un juego de disparos en primera persona donde los jugadores en equipos conducen tanques y se mueven dentro de un campo de batalla. El objetivo de los jugadores es navegar y capturar las banderas pertenecientes al otro equipo y llevarlas de vuelta a su propia área. Los jugadores disparan a los tanques de los demás usando balas de disparo. El movimiento de los tanques, así como el de los disparos, se intercambian entre los jugadores utilizando vectores DR. Hemos modificado la implementación de BZFlag para incorporar relojes sincronizados entre los jugadores y el servidor, y intercambiar marcas de tiempo con el vector DR. Establecimos un banco de pruebas con cuatro jugadores ejecutando la versión instrumentada de BZFlag, con uno como emisor y el resto como receptores. El enfoque de programación y el caso base en el que cada vector de DR se envió a todos los receptores simultáneamente en cada punto de activación se implementaron en la misma ejecución etiquetando los vectores de DR según el tipo de enfoque utilizado para enviar el vector de DR. NISTNet [12] se utilizó para introducir retrasos en el emisor y los tres receptores. Se introdujeron retrasos medios de 800 ms, 500 ms y 200 ms entre el emisor y el primer, segundo y tercer receptor, respectivamente. Introducimos una variación de 100 milisegundos (al retraso medio de cada receptor) para modelar la variabilidad en el retraso. El remitente registró los errores de cada receptor cada 100 milisegundos tanto para el enfoque de programación como para el caso base. El remitente también calculó la desviación estándar y la media del error de exportación acumulado de todos los receptores cada 100 milisegundos. La Figura 4 representa la media y la desviación estándar del error acumulado de exportación de todos los receptores en el caso de programación frente al caso base. Ten en cuenta que el eje x de estos gráficos (y de los demás gráficos que siguen) representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe que la desviación estándar del error con la programación es mucho menor en comparación con el caso base. Esto implica que los errores acumulados de los receptores en el caso de programación están más cerca unos de otros. Esto demuestra que el enfoque de programación logra equidad entre los receptores incluso si se encuentran a diferentes distancias (es decir, latencias) del emisor. Observe que la media del error acumulado aumentó varias veces con la programación en comparación con el caso base. La exploración adicional de la razón del aumento en la media llevó a la conclusión de que cada vez que los vectores de DR se programan de manera que igualen el error total, empuja el error total de cada receptor hacia arriba. Además, dado que el error acumulado tiene un componente estimado, el horario no es preciso para igualar los errores de los receptores, lo que provoca que el vector de DR llegue antes o después de la programación real. En cualquier caso, el error no se iguala y si el vector de DR llega tarde, en realidad aumenta el error para un receptor más allá del error acumulado más alto. Esto significa que en el próximo disparo, este receptor será el que tenga el error más alto y el error de todos los demás receptores se ajustará a este valor de error. Este efecto de cambio repentino conlleva un aumento en el error acumulado para todos los receptores. La programación para la equidad conduce a la disminución de la desviación estándar (es decir, aumenta la equidad entre los diferentes jugadores), pero esto conlleva un mayor <br>error medio</br>, lo cual puede no ser una característica deseable. Esto nos llevó a explorar diferentes formas de igualar los errores acumulados. El enfoque discutido en la siguiente sección es un enfoque heurístico basado en la siguiente idea. Utilizando la misma cantidad de vectores de DR a lo largo del tiempo que en el caso base, en lugar de enviar los vectores de DR a todos los receptores con la misma frecuencia que en el caso base, si podemos aumentar la frecuencia de envío de los vectores de DR al receptor con un error acumulado más alto y disminuir la frecuencia de envío de los vectores de DR al receptor con un error acumulado más bajo, podemos igualar el error de exportación de todos los receptores a lo largo del tiempo. Al mismo tiempo, deseamos disminuir el error del receptor con el error acumulado más alto en el caso base (por supuesto, este receptor recibiría más vectores DR que en el caso base). Nos referimos a dicho algoritmo como un algoritmo basado en presupuesto. ALGORITMO BASADO EN PRESUPUESTO En un juego, el remitente de una entidad envía vectores DR a todos los receptores cada vez que la entidad cruza un umbral. Al reducir el umbral, se generan más vectores de DR durante un período de tiempo dado. Dado que los vectores DR se envían a todos los receptores y el retraso de red entre los pares emisor-receptor no se puede evitar, el error antes de la exportación 3 con el jugador más distante siempre será 3. Tenga en cuenta que después de la exportación, el error se elimina mediante el uso de un reloj sincronizado entre los jugadores. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 Error acumulado promedio en segundos Algoritmo de programación del caso base #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 Desviación estándar del error acumulado en segundos Algoritmo de programación del caso base #1 Figura 4: Promedio y desviación estándar del error con programación y sin ella (es decir, caso base) serán más altos que el resto. Para mitigar el desequilibrio en el error, proponemos enviar vectores de DR selectivamente a diferentes jugadores basándonos en los errores acumulados de estos jugadores. El algoritmo basado en presupuesto se fundamenta en esta idea y existen dos variaciones de él. Uno es un esquema de presupuesto probabilístico y el otro, un esquema de presupuesto determinístico. 5.1 Esquema de presupuesto probabilístico El esquema de presupuesto probabilístico tiene tres pasos principales: a) reducir el umbral de navegación inercial pero al mismo tiempo mantener el número total de DR enviados igual que en el caso base, b) en cada disparador, elegir probabilísticamente a un jugador para enviarle el vector de DR, y c) enviar el vector de DR al jugador elegido. Estos pasos se describen a continuación. La reducción del umbral de DR se implementa de la siguiente manera. Reducir el umbral es equivalente a aumentar el número de puntos de activación donde se generan los vectores de DR. Supongamos que el umbral es tal que el número de disparadores causados por él en el caso base es t y en cada disparador se envían n vectores DR por el remitente, lo que resulta en un total de nt vectores DR. Nuestro objetivo es mantener el número total de vectores DR enviados por el remitente fijo en nt, pero reducir el número de vectores DR enviados en cada activación (es decir, no enviar el vector DR a todos los receptores). Que n y t sean el número de vectores DR enviados en cada disparo y el número de disparos respectivamente en el caso modificado. Queremos asegurarnos de que n t = nt. Dado que queremos aumentar el número de puntos de activación, es decir, t > t, esto significaría que n < n. Es decir, no todos los receptores recibirán el vector DR en cada activación. En el esquema de presupuesto probabilístico, en cada activación, se calcula una probabilidad para que cada receptor reciba un vector DR y solo un receptor recibe el DR (n = 1). Esta probabilidad se basa en los pesos relativos de los errores acumulados de los receptores. Es decir, un receptor con un error acumulado más alto tendrá una probabilidad más alta de recibir el vector DR. Ten en cuenta que el error acumulado para tres jugadores es a1, a2 y a3 respectivamente. Entonces, la probabilidad de que el jugador 1 reciba el vector DR sería a1 a1+a2+a3. Del mismo modo para los otros jugadores. Una vez que se elige al jugador, el vector DR se envía a ese jugador. Para comparar el algoritmo basado en presupuesto probabilístico con el caso base, necesitábamos reducir el umbral para el caso base (para una comparación justa). Dado que el umbral de cálculo de la posición muerta en el caso base ya era muy fino, se decidió que en lugar de reducir el umbral, se compararía el enfoque basado en el presupuesto probabilístico con un caso base modificado que utilizaría el umbral normal como algoritmo basado en el presupuesto, pero el caso base se modificó de tal manera que cada tercer disparador se usaría realmente para enviar un vector de cálculo de la posición muerta a los tres receptores utilizados en nuestros experimentos. Esto fue llamado como el caso base 1/3 ya que resultó en el envío de 1/3 del número de vectores DR en comparación con el caso base. El presupuesto por disparador para el enfoque basado en la probabilidad se calculó como un vector de DR en cada disparador en comparación con tres vectores de DR en cada tercer disparador en el caso base de 1/3; por lo tanto, los dos casos resultan en el mismo número de vectores de DR enviados con el tiempo. Para evaluar la efectividad del algoritmo de presupuesto probabilístico, instrumentamos el juego BZFlag para utilizar este enfoque. Utilizamos el mismo banco de pruebas que consistía en un emisor y tres receptores con retardos de 800ms, 500ms y 200ms desde el emisor y con baja varianza de retardo (100ms) y moderada varianza de retardo (180ms). Los resultados se muestran en las Figuras 5 y 6. Como se mencionó anteriormente, el eje x de estos gráficos representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe de las figuras que la desviación estándar del error acumulado entre los receptores con el algoritmo basado en presupuesto probabilístico es menor que el caso base de 1/3 y la media es un poco más alta que el caso base de 1/3. Esto implica que el juego es más justo en comparación con el caso base de 1/3 a costa de aumentar ligeramente el <br>error medio</br> en comparación con el caso base de 1/3. ",
            "candidates": [],
            "error": [
                [
                    "error medio",
                    "error medio",
                    "error promedio",
                    "error medio",
                    "error medio"
                ]
            ]
        },
        "accuracy": {
            "translated_key": "precisión",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the <br>accuracy</br> of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of <br>accuracy</br> in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the <br>accuracy</br> of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of <br>accuracy</br> of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level <br>accuracy</br> of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, <br>accuracy</br> in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the <br>accuracy</br> of game playing.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of <br>accuracy</br> in game playing.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the <br>accuracy</br> of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of <br>accuracy</br> of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level <br>accuracy</br> of game playing."
            ],
            "translated_annotated_samples": [
                "Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la <br>precisión</br> del juego.",
                "Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de <br>precisión</br> en el juego.",
                "Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la <br>precisión</br> del juego.",
                "Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de <br>precisión</br> en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2.",
                "La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de <br>precisión</br> en el juego."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la <br>precisión</br> del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de <br>precisión</br> en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la <br>precisión</br> del juego. Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de <br>precisión</br> en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores. Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado. El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de sincronización de cubo estático para compensar las variaciones en los retrasos de la red. En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota. Los jugadores con un retraso de red mayor a 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la sincronización de cubetas dependen de imponer un retraso máximo en todos los jugadores. Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados. Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto). Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción. Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización. La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras. En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego. Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor). Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la sincronización de cubos no son a prueba de trampas a menos que se implementen mecanismos adicionales. Tanto el algoritmo de programación como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas. Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida. Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño. En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1]. En la Sección 4, describimos el algoritmo de programación de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFlag. La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de <br>precisión</br> en el juego. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "scheduling algorithm": {
            "translated_key": "algoritmo de programación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the <br>scheduling algorithm</br> and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the <br>scheduling algorithm</br>) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the <br>scheduling algorithm</br> and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector <br>scheduling algorithm</br> that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the <br>scheduling algorithm</br> on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector <br>scheduling algorithm</br> to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "<br>scheduling algorithm</br> FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector <br>scheduling algorithm</br> is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the <br>scheduling algorithm</br> For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the <br>scheduling algorithm</br>, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case <br>scheduling algorithm</br> #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case <br>scheduling algorithm</br> #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "We have implemented both the <br>scheduling algorithm</br> and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "The first algorithm (which we refer to as the <br>scheduling algorithm</br>) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Both the <br>scheduling algorithm</br> and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "In Section 4, we describe the DR vector <br>scheduling algorithm</br> that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the <br>scheduling algorithm</br> on the open source game BZFlag.",
                "The goal of the DR vector <br>scheduling algorithm</br> to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4."
            ],
            "translated_annotated_samples": [
                "Hemos implementado tanto el <br>algoritmo de programación</br> como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido.",
                "El primer algoritmo (al que nos referimos como <br>algoritmo de programación</br>) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR.",
                "Tanto el <br>algoritmo de programación</br> como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas.",
                "En la Sección 4, describimos el <br>algoritmo de programación</br> de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del <br>algoritmo de programación</br> en el juego de código abierto BZFlag.",
                "El objetivo del <br>algoritmo de programación de vectores</br> DR que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual en cada jugador de forma independiente para cada una de las entidades que conforman el juego."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el <br>algoritmo de programación</br> como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como <br>algoritmo de programación</br>) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la precisión del juego. Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores. Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado. El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de sincronización de cubo estático para compensar las variaciones en los retrasos de la red. En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota. Los jugadores con un retraso de red mayor a 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la sincronización de cubetas dependen de imponer un retraso máximo en todos los jugadores. Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados. Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto). Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción. Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización. La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras. En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego. Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor). Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la sincronización de cubos no son a prueba de trampas a menos que se implementen mecanismos adicionales. Tanto el <br>algoritmo de programación</br> como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas. Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida. Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño. En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1]. En la Sección 4, describimos el <br>algoritmo de programación</br> de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del <br>algoritmo de programación</br> en el juego de código abierto BZFlag. La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de precisión en el juego. Las conclusiones se presentan en la Sección 6.2.3. MODELO DE JUEGO La arquitectura del juego se basa en jugadores distribuidos a través de Internet que intercambian vectores DR entre sí. Los vectores de DR podrían ser enviados directamente de un jugador a otro (modelo peer-to-peer) o podrían ser enviados a través de un servidor de juego que recibe el vector de DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor). Como se mencionó anteriormente, asumimos que los relojes de los jugadores participantes están sincronizados. Cada vector DR enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad. Suponemos un vector DR lineal en el que la información contenida en el vector DR es solo suficiente para que el jugador receptor calcule la trayectoria y represente la entidad en un camino en línea recta. Un vector DR de este tipo contiene información sobre la posición inicial y la velocidad del jugador/entidad, donde la velocidad es constante. Por lo tanto, los vectores DR enviados por un jugador especifican el tiempo actual en el jugador cuando se calcula el vector DR (no el tiempo en el que este vector DR se envía a los otros jugadores, como explicaremos más adelante), la posición actual del jugador/entidad en términos de las coordenadas x, y, z y el vector de velocidad en la dirección de las coordenadas x, y, z. Específicamente, el vector DRi enviado por el jugador j sobre la k-ésima entidad se denota como DRj ik y está representado por la siguiente tupla (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik). Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y para una sola entidad. Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional. Por lo tanto, usamos DRi para denotar el i-ésimo vector DR representado como la tupla (Ti, xi, yi, vxi, vyi). El jugador receptor calcula la posición inicial para la entidad basándose en xi, yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo Ti en el que fue calculado. Ten en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados. El jugador receptor luego utiliza los componentes de velocidad para proyectar y representar la trayectoria de la entidad. Esta trayectoria se sigue hasta que se recibe un nuevo vector DR que cambia la posición y/o velocidad de la entidad. tiempoT1 Real Exportado Colocado dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) calculado en el tiempo T1 y enviado al receptor DR0 = (T0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptor T0 dt0 Colocado E Figura 1: Trayectorias y desviaciones. Basado en este modelo, la Figura 1 ilustra el envío y recepción de vectores DR y los diferentes errores que se encuentran. Otros tipos de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y vectores DR de spline cúbico que consideran la posición y velocidad inicial y la posición y velocidad final de la entidad. La figura muestra la recepción de vectores de DR en un jugador (en adelante llamado receptor). El eje horizontal muestra el tiempo que está sincronizado entre todos los jugadores. El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad. Suponga que en el tiempo T0 se calcula un vector DR0 por el remitente y se envía inmediatamente al receptor. Supongamos que DR0 es recibido por el receptor después de un retraso de dt0 unidades de tiempo. El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (mostrado como punto E). La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor basada en los componentes de velocidad vx0 y vy0 (ruta colocada). En el tiempo T1 se calcula un vector DR1 de enrutamiento dinámico para la misma entidad y se envía inmediatamente al receptor2. Suponga que DR1 es recibido por el receptor después de un retraso de dt1 unidades de tiempo. Cuando se recibe este vector DR, se asume que la entidad está en el punto D. Se calcula una nueva posición para la entidad como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto C). Los componentes de velocidad vx1 y vy1 se utilizan para proyectar y representar esta entidad más lejos. Ahora consideremos el error debido al retraso de la red. Aunque DR1 se calculó en el tiempo T1 y se envió al receptor, no llegó al receptor hasta el tiempo T1 + dt1. Esto significa que, aunque la ruta exportada basada en DR1 en el remitente en el tiempo T1 es la trayectoria AC, hasta el tiempo T1 + dt1, en el receptor, esta entidad estaba siendo representada en la trayectoria BD basada en DR0. Solo en el momento T1 + dt1 la entidad se movió al punto C, a partir del cual los caminos exportados y colocados son iguales. La desviación entre las rutas exportadas y colocadas crea un componente de error al que nos referimos como el error de exportación. Una forma de representar el error de exportación es calcular la integral de la distancia entre las dos trayectorias durante el tiempo en que están desincronizadas. Representamos la integral de las distancias entre las rutas colocadas y exportadas debido a algunos DR DRi en un intervalo de tiempo [t1, t2] como Err(DRi, t1, t2). En la figura, el error de exportación debido a DR1 se calcula como la integral de la distancia entre las trayectorias AC y BD en el intervalo de tiempo [T1, T1 + dt1]. Ten en cuenta que también podría haber otras formas de representar este error, pero en este artículo utilizamos la integral de la distancia entre las dos trayectorias como medida del error de exportación. Tenga en cuenta que se habría producido un error de exportación debido a la recepción de DR0, momento en el que la ruta colocada se basaría en un vector DR anterior. Esto no se muestra en la figura, pero sirve para recordar al lector que el error de exportación es acumulativo cuando se reciben una secuencia de vectores DR. A partir del tiempo T1 en adelante, hay una desviación entre las trayectorias reales y las exportadas. Como discutimos anteriormente, este error de exportación es inevitable. La figura y el ejemplo anterior ilustran solo un receptor. Pero en realidad, los vectores DR DR0 y DR1 son enviados por el remitente a todos los jugadores participantes. Cada uno de estos jugadores recibe DR0 y DR1 después de diferentes retrasos, creando así diferentes valores de error de exportación en cada jugador. El objetivo del <br>algoritmo de programación de vectores</br> DR que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual en cada jugador de forma independiente para cada una de las entidades que conforman el juego. ",
            "candidates": [],
            "error": [
                [
                    "algoritmo de programación",
                    "algoritmo de programación",
                    "algoritmo de programación",
                    "algoritmo de programación",
                    "algoritmo de programación",
                    "algoritmo de programación de vectores"
                ]
            ]
        },
        "quantization": {
            "translated_key": "cuantificación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are <br>quantization</br> of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "DR vectors are <br>quantization</br> of the real trajectory (which we refer to as real path) at a player."
            ],
            "translated_annotated_samples": [
                "Los vectores DR son la <br>cuantificación</br> de la trayectoria real (a la que nos referimos como camino real) de un jugador."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la <br>cuantificación</br> de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la precisión del juego. Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores. Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado. El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de sincronización de cubo estático para compensar las variaciones en los retrasos de la red. En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota. Los jugadores con un retraso de red mayor a 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la sincronización de cubetas dependen de imponer un retraso máximo en todos los jugadores. Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados. Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto). Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción. Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización. La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras. En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego. Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor). Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la sincronización de cubos no son a prueba de trampas a menos que se implementen mecanismos adicionales. Tanto el algoritmo de programación como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas. Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida. Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño. En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1]. En la Sección 4, describimos el algoritmo de programación de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFlag. La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de precisión en el juego. Las conclusiones se presentan en la Sección 6.2.3. MODELO DE JUEGO La arquitectura del juego se basa en jugadores distribuidos a través de Internet que intercambian vectores DR entre sí. Los vectores de DR podrían ser enviados directamente de un jugador a otro (modelo peer-to-peer) o podrían ser enviados a través de un servidor de juego que recibe el vector de DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor). Como se mencionó anteriormente, asumimos que los relojes de los jugadores participantes están sincronizados. Cada vector DR enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad. Suponemos un vector DR lineal en el que la información contenida en el vector DR es solo suficiente para que el jugador receptor calcule la trayectoria y represente la entidad en un camino en línea recta. Un vector DR de este tipo contiene información sobre la posición inicial y la velocidad del jugador/entidad, donde la velocidad es constante. Por lo tanto, los vectores DR enviados por un jugador especifican el tiempo actual en el jugador cuando se calcula el vector DR (no el tiempo en el que este vector DR se envía a los otros jugadores, como explicaremos más adelante), la posición actual del jugador/entidad en términos de las coordenadas x, y, z y el vector de velocidad en la dirección de las coordenadas x, y, z. Específicamente, el vector DRi enviado por el jugador j sobre la k-ésima entidad se denota como DRj ik y está representado por la siguiente tupla (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik). Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y para una sola entidad. Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional. Por lo tanto, usamos DRi para denotar el i-ésimo vector DR representado como la tupla (Ti, xi, yi, vxi, vyi). El jugador receptor calcula la posición inicial para la entidad basándose en xi, yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo Ti en el que fue calculado. Ten en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados. El jugador receptor luego utiliza los componentes de velocidad para proyectar y representar la trayectoria de la entidad. Esta trayectoria se sigue hasta que se recibe un nuevo vector DR que cambia la posición y/o velocidad de la entidad. tiempoT1 Real Exportado Colocado dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) calculado en el tiempo T1 y enviado al receptor DR0 = (T0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptor T0 dt0 Colocado E Figura 1: Trayectorias y desviaciones. Basado en este modelo, la Figura 1 ilustra el envío y recepción de vectores DR y los diferentes errores que se encuentran. Otros tipos de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y vectores DR de spline cúbico que consideran la posición y velocidad inicial y la posición y velocidad final de la entidad. La figura muestra la recepción de vectores de DR en un jugador (en adelante llamado receptor). El eje horizontal muestra el tiempo que está sincronizado entre todos los jugadores. El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad. Suponga que en el tiempo T0 se calcula un vector DR0 por el remitente y se envía inmediatamente al receptor. Supongamos que DR0 es recibido por el receptor después de un retraso de dt0 unidades de tiempo. El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (mostrado como punto E). La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor basada en los componentes de velocidad vx0 y vy0 (ruta colocada). En el tiempo T1 se calcula un vector DR1 de enrutamiento dinámico para la misma entidad y se envía inmediatamente al receptor2. Suponga que DR1 es recibido por el receptor después de un retraso de dt1 unidades de tiempo. Cuando se recibe este vector DR, se asume que la entidad está en el punto D. Se calcula una nueva posición para la entidad como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto C). Los componentes de velocidad vx1 y vy1 se utilizan para proyectar y representar esta entidad más lejos. Ahora consideremos el error debido al retraso de la red. Aunque DR1 se calculó en el tiempo T1 y se envió al receptor, no llegó al receptor hasta el tiempo T1 + dt1. Esto significa que, aunque la ruta exportada basada en DR1 en el remitente en el tiempo T1 es la trayectoria AC, hasta el tiempo T1 + dt1, en el receptor, esta entidad estaba siendo representada en la trayectoria BD basada en DR0. Solo en el momento T1 + dt1 la entidad se movió al punto C, a partir del cual los caminos exportados y colocados son iguales. La desviación entre las rutas exportadas y colocadas crea un componente de error al que nos referimos como el error de exportación. Una forma de representar el error de exportación es calcular la integral de la distancia entre las dos trayectorias durante el tiempo en que están desincronizadas. Representamos la integral de las distancias entre las rutas colocadas y exportadas debido a algunos DR DRi en un intervalo de tiempo [t1, t2] como Err(DRi, t1, t2). En la figura, el error de exportación debido a DR1 se calcula como la integral de la distancia entre las trayectorias AC y BD en el intervalo de tiempo [T1, T1 + dt1]. Ten en cuenta que también podría haber otras formas de representar este error, pero en este artículo utilizamos la integral de la distancia entre las dos trayectorias como medida del error de exportación. Tenga en cuenta que se habría producido un error de exportación debido a la recepción de DR0, momento en el que la ruta colocada se basaría en un vector DR anterior. Esto no se muestra en la figura, pero sirve para recordar al lector que el error de exportación es acumulativo cuando se reciben una secuencia de vectores DR. A partir del tiempo T1 en adelante, hay una desviación entre las trayectorias reales y las exportadas. Como discutimos anteriormente, este error de exportación es inevitable. La figura y el ejemplo anterior ilustran solo un receptor. Pero en realidad, los vectores DR DR0 y DR1 son enviados por el remitente a todos los jugadores participantes. Cada uno de estos jugadores recibe DR0 y DR1 después de diferentes retrasos, creando así diferentes valores de error de exportación en cada jugador. El objetivo del algoritmo de programación de vectores DR que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual en cada jugador de forma independiente para cada una de las entidades que conforman el juego. ALGORITMO DE PROGRAMACIÓN PARA EL ENVÍO DE VECTORES DR En la Sección 3 mostramos cómo el retraso desde el remitente de un nuevo vector DR 2 Normalmente, los vectores DR no se calculan de forma periódica, sino bajo demanda, donde la decisión de calcular un nuevo vector DR se basa en la superación de un umbral en la desviación entre la ruta real y la ruta exportada por el vector DR anterior. 3 vector al receptor del vector DR podría llevar a un error de exportación debido a la desviación de la ruta colocada de la ruta exportada en el receptor hasta que se reciba este nuevo vector DR. También mencionamos que el objetivo del algoritmo de programación de vectores DR es igualar el error de exportación en todos los receptores durante un período de tiempo. Dado que el juego se juega en un entorno distribuido, tiene sentido que el remitente de una entidad lleve un registro de todos los errores en los receptores e intente igualarlos. Sin embargo, el remitente no puede conocer el error real en un receptor hasta que reciba alguna información sobre el error del receptor. Nuestro algoritmo estima el error para calcular un horario para enviar vectores DR a los receptores y corrige el error cuando recibe retroalimentación de los receptores. En esta sección proporcionamos las motivaciones para el algoritmo y describimos los pasos por los que atraviesa. A lo largo de esta sección, utilizaremos el siguiente ejemplo para ilustrar el algoritmo. tiempoT1 Ruta exportada Ruta colocada en el receptor 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 enviado al receptor 1 DR1 enviado al receptor 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimado para ser recibido por el receptor 2 DR1 estimado para ser recibido por el receptor 1 DR1 recibido realmente por el receptor 1 DR1 recibido realmente por el receptor 2 DR0 enviado a ambos receptores DR1 calculado por el remitente Ruta colocada en el receptor 1 Figura 2: Flujo de vector DR entre un remitente y dos receptores y la evolución de las rutas colocadas estimadas y reales en los receptores. DR0 = (T0, T0, x0, y0, vx0, vy0), enviado en el tiempo T0 a ambos receptores. DR1 = (T1, T1 1 , x1, y1, vx1, vy1) enviado en el tiempo T1 1 = T1+δ1 al receptor 1 y DR1 = (T1, T2 1 , x1, y1, vx1, vy1) enviado en el tiempo T2 1 = T1 + δ2 al receptor 2. Considera el ejemplo en la Figura 2. La figura muestra un único emisor enviando vectores DR para una entidad a dos receptores diferentes 1 y 2. DR0 calculado en T0 es enviado y recibido por los receptores en algún momento entre T0 y T1, momento en el cual mueven la ubicación de la entidad para que coincida con la ruta exportada. Por lo tanto, la trayectoria de la entidad se muestra solo desde el punto en que la trayectoria colocada coincide con la trayectoria exportada para DR0. Ahora considera DR1. En el tiempo T1, DR1 es calculado por el remitente, pero se asume que no es enviado inmediatamente a los receptores y solo se envía después de un tiempo δ1 al receptor 1 (en el tiempo T1 1 = T1 + δ1) y después de un tiempo δ2 al receptor 2 (en el tiempo T2 1 = T1 + δ2). Ten en cuenta que el remitente incluye la marca de tiempo de envío con el vector DR como se muestra en la figura. Supongamos que el remitente estima (pronto quedará claro por qué el remitente tiene que estimar el retraso) que después de un retraso de dt1, el receptor 1 lo recibirá, utilizará los parámetros de coordenadas y velocidad para calcular la ubicación actual de la entidad y moverla allí (punto C) y a partir de ese momento, los caminos exportado y colocado serán iguales. Sin embargo, en realidad, el receptor 1 recibe DR1 después de un retraso de da1 (que es menor que las estimaciones de los remitentes de dt1), y mueve la entidad correspondiente al punto H. De manera similar, el remitente estima que después de un retraso de dt2, el receptor 2 recibirá DR1, calculará la ubicación actual de la entidad y la moverá a ese punto (punto E), mientras que en realidad recibe DR1 después de un retraso de da2 > dt2 y mueve la entidad al punto N. Los otros puntos mostrados en las rutas colocadas y exportadas se utilizarán más adelante en la discusión para describir diferentes componentes de error. 4.1 Cálculo del Error de Exportación Relativo Volviendo a la discusión de la Sección 3, desde la perspectiva de los remitentes, el error de exportación en el receptor 1 debido a DR1 se da por Err(DR1, T1, T1 + δ1 + dt1) (la integral de la distancia entre las trayectorias AC y DB en el intervalo de tiempo [T1, T1 + δ1 + dt1]) de la Figura 2. Esto se debe a que el remitente utiliza el retraso estimado dt1 para calcular este error. De manera similar, el error de exportación desde la perspectiva del remitente en el recibido 2 debido a DR1 se da por Err(DR1, T1, T1 + δ2 + dt2) (la integral de la distancia entre las trayectorias AE y DF en el intervalo de tiempo [T1, T1 + δ2 + dt2]). Ten en cuenta que los errores anteriores desde la perspectiva del remitente son solo estimaciones. En realidad, el error de exportación será tanto menor como mayor que el valor estimado, dependiendo de si la estimación de retraso fue mayor o menor que el retraso real experimentado por DR1. La diferencia entre el error de exportación estimado y el real es el error de exportación relativo (que puede ser positivo o negativo) que ocurre para cada vector de DR que se envía y se acumula en el remitente. El concepto de error relativo de exportación se ilustra en la Figura 2. Dado que el retraso actual al receptor 1 es da1, el error de exportación inducido por DR1 en el receptor 1 es Err(DR1, T1, T1 + δ1 + da1). Esto significa que hay un error en el error estimado de exportación y el remitente solo puede calcular este error después de recibir un comentario del receptor sobre la demora real en la entrega de DR1, es decir, el valor de da1. Proponemos que una vez que el receptor 1 reciba DR1, envíe el valor de da1 de vuelta al remitente. El receptor puede calcular esta información ya que conoce el momento en que se envió DR1 (T1 1 = T1 + δ1, que se añade al vector DR como se muestra en la Figura 2) y el tiempo local de recepción (que está sincronizado con el reloj del emisor). Por lo tanto, el remitente calcula el error relativo de exportación para el receptor 1, representado como R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1). De manera similar, el error relativo de exportación para el receptor 2 se calcula como R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2). Nótese que R1 > 0 ya que da1 < dt1, y R2 < 0 ya que da2 > dt2. Los errores relativos de exportación son calculados por el remitente en el momento en que recibe la retroalimentación de los destinatarios. Este ejemplo muestra los 4 valores relativos de error de exportación después de que se envía DR1 y se reciben los comentarios correspondientes. 4.2 Igualación del Error Entre Receptores Ahora explicamos lo que queremos decir al hacer que los errores sean iguales en todos los receptores y cómo se puede lograr esto. Como se mencionó anteriormente, el remitente mantiene estimaciones de los retrasos a los receptores, dt1 y dt2 en el ejemplo de la Figura 2. Esto indica que en el momento T1 cuando se calcula DR1, el remitente ya sabe cuánto tiempo pueden tardar los mensajes que llevan este vector DR en llegar a los receptores. El remitente utiliza esta información para calcular los errores de exportación, que son Err(DR1, T1, T1 + δ1 + dt1) y Err(DR1, T1, T1 + δ2 + dt2) para los receptores 1 y 2, respectivamente. Ten en cuenta que las áreas de estos componentes de error son una función de δ1 y δ2, así como de las demoras de red dt1 y dt2. Si queremos que los errores de exportación debido a DR1 sean iguales en ambos receptores, el remitente debe elegir δ1 y δ2 de manera que Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2). Pero cuando se calculó T1, ya podría haberse acumulado errores relativos de exportación debido a los vectores DR anteriores (DR0 y los anteriores). Representemos el error relativo acumulado hasta DRi para el receptor j como Ri j. Para acomodar estos errores relativos acumulados, el remitente debe elegir ahora δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Los δi determinan el instante de programación del vector DR en el remitente para el receptor i. Este método de cálculo de δs garantiza que el error de exportación acumulado (es decir, el error total real) para cada receptor se iguala en la transmisión de cada vector DR. Para establecer esto, asuma que la retroalimentación para el vector DR Di de un receptor llega al remitente antes de que se calcule el horario para Di+1. Que Si m y Ai m denoten el error estimado para el receptor m utilizado para calcular el horario para Di y el error acumulado para el receptor m calculado después de recibir retroalimentación para Di, respectivamente. Entonces Ri m = Ai m − Si m. Para calcular las instancias de programación (es decir, δs) para Di, para cualquier par de receptores m y n, hacemos Ri−1 m + Si m = Ri−1 n + Si n. El siguiente teorema establece el hecho de que el error acumulado de exportación se iguala en cada instante de programación. TEOREMA 4.1. Cuando se calculan las instancias de horario para enviar Di a cualquier par de receptores m y n, se cumple la siguiente condición: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Prueba: Por inducción. Supongamos que la premisa se cumple para algún i. Mostramos que se cumple para i+1. El caso base para i = 1 se cumple ya que inicialmente R0 m = R0 n = 0, y se utiliza S1 m = S1 n para calcular las instancias de programación. Para calcular el horario de Di+1, primero calculamos los errores relativos como Ri m = Ai m − Si m y Ri n = Ai n − Si n. Luego, para calcular δs, ejecutamos Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n. Añadiendo la condición de la premisa en ambos lados obtenemos, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n. 4.3 Cálculo del Error de Exportación. Ahora consideremos cómo se pueden calcular los errores de exportación. De la sección anterior, para encontrar δ1 y δ2 necesitamos encontrar Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2). Se debe tener en cuenta que los valores de R0 1 y R0 2 ya son conocidos en el remitente. Considera el cálculo de Err(DR1, T1, T1 +δ1 +dt1). Esta es la integral de la distancia entre las trayectorias AC debido a DR1 y BD debido a DR0. A partir de DR0 y DR1, el punto A es (X1, Y1) = (x1, y1) y el punto B es (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0). La trayectoria AC puede ser representada como una función del tiempo como (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) y la trayectoria de BD puede ser representada como (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t). La distancia entre las dos trayectorias como función del tiempo se convierte entonces en, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Sea a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Entonces dist(t) se puede escribir como dist(t) = a × t2 + b × t + c. Luego Err(DR1, t1, t2) para algún intervalo de tiempo [t1, t2] se convierte en t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt. Una solución en forma cerrada para la integral indefinida a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2) pueden entonces ser calculadas aplicando los límites apropiados a la solución anterior. En la siguiente sección, consideramos el cálculo de los δs para N receptores. 5 4.4 Cálculo de Instantes de Programación Volvemos a analizar el cálculo de los δs haciendo referencia a la Figura 2. El remitente elige δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 + Err(DR1, T1, T1 + δ2 +dt2). Si R0 1 y R0 2 ambos son cero, entonces δ1 y δ2 deben ser elegidos de tal manera que Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2). Esta igualdad se mantendrá si δ1 + dt1 = δ2 + dt2. Por lo tanto, si no hay error acumulado relativo de exportación, todo lo que el remitente necesita hacer es elegir los δs de tal manera que contrarresten la diferencia en el retraso a los dos receptores, para que reciban el vector DR al mismo tiempo. Como se discutió anteriormente, dado que el remitente no puede aprender de antemano el retraso, siempre habrá un error relativo acumulado de exportación de un vector DR previo que debe tenerse en cuenta. Para profundizar en esto, considera el cálculo del error de exportación como se ilustra en la sección anterior. Para calcular los δs necesitamos que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Es decir, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt. Eso es R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt. Los componentes R0 1, R0 2, ya son conocidos por (o estimados por) el remitente. Además, los componentes de error T1+dt1 T1 dist(t) dt y T1+dt2 T1 dist(t) dt pueden ser calculados a priori por el remitente utilizando valores estimados de dt1 y dt2. Usemos E1 para denotar R0 1 + T1+dt1 T1 dist(t) dt y E2 para denotar R0 2 + T1+dt2 T1 dist(t) dt. Entonces, requerimos que E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. Suponga que E1 > E2. Entonces, para que la ecuación anterior se cumpla, requerimos que T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt. Para hacer el juego lo más rápido posible dentro de este marco, los valores de δ deben ser lo más pequeños posible para que los vectores DR se envíen a los receptores lo antes posible, sujeto al requisito de equidad. Dado esto, elegiríamos δ1 como cero y calcularíamos δ2 a partir de la ecuación E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. En general, si hay N receptores 1, . . . , N, cuando un emisor genera un vector DR y decide programarlos para ser enviados, primero calcula los valores de Ei para todos ellos a partir de los errores relativos acumulados en la exportación y las estimaciones de los retrasos. Luego, encuentra el valor más pequeño de estos valores. Que Ek sea el valor más pequeño. El remitente hace que δk sea cero y calcula el resto de los δs a partir de la igualdad Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) Los δs así obtenidos dan los instantes de programación del vector DR para los receptores. 4.5 Pasos del Algoritmo de Programación Para los fines de la discusión a continuación, como antes, vamos a denotar el error relativo acumulado en un remitente para el receptor k hasta DRi como Ri k. Vamos a denotar el retraso programado en el remitente antes de que DRi sea enviado al receptor k como δi k. Dada la discusión anterior, los pasos del algoritmo son los siguientes: 1. El remitente calcula DRi en el tiempo Ti y luego calcula δi k y Ri−1 k, ∀k, 1 ≤ k ≤ N basándose en la estimación de los retrasos dtk, ∀k, 1 ≤ k ≤ N según la Ecuación (1). Programa que DRi se envíe al receptor k en el tiempo Ti + δi k. 2. Los vectores DR se envían a los receptores en los horarios programados, los cuales se reciben después de un retraso de dak, ∀k, 1 ≤ k ≤ N donde dak ≤ o > dtk. Los receptores envían el valor de dak de vuelta al remitente (el receptor puede calcular este valor basándose en las marcas de tiempo en el vector DR como se describió anteriormente). 3. El remitente calcula Ri k como se describe anteriormente e ilustra en la Figura 2. El remitente también recalcula (utilizando un método de promedio exponencial similar a la estimación del tiempo de ida y vuelta por TCP [10]) la estimación del retraso dtk a partir del nuevo valor de dak para el receptor k. 4. Vuelve al Paso 1 para calcular DRi+1 cuando sea necesario y sigue los pasos del algoritmo para programar y enviar este vector DR a los receptores. 4.6 Manejo de Casos en la Práctica Hasta ahora asumimos implícitamente que DRi se envía a todos los receptores antes de tomar una decisión para calcular el siguiente vector DR DRi+1, y los receptores envían el valor de dak correspondiente a DRi y esta información llega al remitente antes de que calcule DRi+1 para que pueda calcular Ri+1 k y luego usarlo en el cálculo de δi+1 k. Dos cuestiones deben tenerse en cuenta con respecto al algoritmo anterior cuando se utiliza en la práctica. • Puede suceder que se calcule un nuevo vector DR incluso antes de que el vector DR anterior se envíe a todos los receptores. ¿Cómo se manejará esta situación? • ¿Qué sucede si la retroalimentación no llega antes de que se calcule y programe el envío de DRi+1? Consideremos el primer escenario. Suponemos que DRi ha sido programado para ser enviado y los instantes de programación son tales que δi 1 < δi 2 < · · · < δi N. Suponga que se va a calcular DRi+1 (porque la trayectoria real se ha desviado excediendo un umbral de la trayectoria exportada por DRi) en el tiempo Ti+1 donde Ti + δi k < Ti+1 < Ti + δi k+1. Esto significa que DRi ha sido enviado solo a receptores hasta k en el orden programado. En nuestro algoritmo, en este caso, se vacía la cola de ordenación de retrasos programados, lo que significa que DRi no se envía a los receptores que aún están en cola para recibirlo, pero se calcula un nuevo orden de programación para que todos los receptores envíen DRi+1. Para aquellos receptores a quienes se les ha enviado DRi, asumir por ahora que se ha recibido de todos los receptores daj, 1 ≤ j ≤ k (el escenario donde daj no ha sido recibido se considerará como parte del segundo escenario más tarde). Para estos receptores, Ei j, 1 ≤ j ≤ k se pueden calcular. Para aquellos receptores j, k + 1 ≤ j ≤ N a quienes no se les envió DRi, Ei j no aplica. Considera un receptor j, k + 1 ≤ j ≤ N a quien no se le envió DRi. Consulte la Figura 3. Para un receptor j dado, cuando se programa DRi+1 y se exporta la ruta dtj A B C D Ti-1 Gi j, DRi+1 calculado por el remitente y DRi para el receptor k+1 a N se eliminan de la cola. DRi+1 programado para el receptor k+1, Ti+1 G H E F, DRi programado para el receptor j, DRi calculado por el remitente, se coloca la ruta en el receptor k+1, Gi+1 j. Figura 3: Cálculo de programación cuando DRi no se envía al receptor j, k + 1 ≤ j ≤ N. Se necesita calcular δi+1 j, el error total de exportación es el error de exportación relativo acumulado en el tiempo Ti cuando se programó el DRi, más la integral de la distancia entre las dos trayectorias AC y BD de la Figura 3 en el intervalo de tiempo [Ti, Ti+1 + δi+1 j + dtj]. Ten en cuenta que esta integral está dada por Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj). Por lo tanto, en lugar de Ei j de la Ecuación (1), utilizamos el valor Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) donde Ri−1 j es el error relativo de exportación utilizado cuando se calculó el horario para DRi. Ahora considera el segundo escenario. Aquí el dak de retroalimentación correspondiente a DRi no ha llegado antes de que se calcule y programe DRi+1. En este caso, Ri k no se puede calcular. Por lo tanto, en el cálculo de δk para DRi+1, se asumirá que es cero. Suponemos que se utiliza un mecanismo confiable para enviar el dak de vuelta al remitente. Cuando esta información llegue en un momento posterior, Ri k se calculará y acumulará a los errores relativos de exportación futuros (por ejemplo, Ri+1 k si dak se recibe antes de que se calcule DRi+2) y se utilizará en el cálculo de δk cuando se programe un vector DR futuro (por ejemplo, DRi+2). 4.7 Resultados Experimentales Para evaluar la efectividad y cuantificar los beneficios obtenidos a través del uso del algoritmo de programación, implementamos el algoritmo propuesto en el juego BZFlag (Battle Zone Flag) [11]. Es un juego de disparos en primera persona donde los jugadores en equipos conducen tanques y se mueven dentro de un campo de batalla. El objetivo de los jugadores es navegar y capturar las banderas pertenecientes al otro equipo y llevarlas de vuelta a su propia área. Los jugadores disparan a los tanques de los demás usando balas de disparo. El movimiento de los tanques, así como el de los disparos, se intercambian entre los jugadores utilizando vectores DR. Hemos modificado la implementación de BZFlag para incorporar relojes sincronizados entre los jugadores y el servidor, y intercambiar marcas de tiempo con el vector DR. Establecimos un banco de pruebas con cuatro jugadores ejecutando la versión instrumentada de BZFlag, con uno como emisor y el resto como receptores. El enfoque de programación y el caso base en el que cada vector de DR se envió a todos los receptores simultáneamente en cada punto de activación se implementaron en la misma ejecución etiquetando los vectores de DR según el tipo de enfoque utilizado para enviar el vector de DR. NISTNet [12] se utilizó para introducir retrasos en el emisor y los tres receptores. Se introdujeron retrasos medios de 800 ms, 500 ms y 200 ms entre el emisor y el primer, segundo y tercer receptor, respectivamente. Introducimos una variación de 100 milisegundos (al retraso medio de cada receptor) para modelar la variabilidad en el retraso. El remitente registró los errores de cada receptor cada 100 milisegundos tanto para el enfoque de programación como para el caso base. El remitente también calculó la desviación estándar y la media del error de exportación acumulado de todos los receptores cada 100 milisegundos. La Figura 4 representa la media y la desviación estándar del error acumulado de exportación de todos los receptores en el caso de programación frente al caso base. Ten en cuenta que el eje x de estos gráficos (y de los demás gráficos que siguen) representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe que la desviación estándar del error con la programación es mucho menor en comparación con el caso base. Esto implica que los errores acumulados de los receptores en el caso de programación están más cerca unos de otros. Esto demuestra que el enfoque de programación logra equidad entre los receptores incluso si se encuentran a diferentes distancias (es decir, latencias) del emisor. Observe que la media del error acumulado aumentó varias veces con la programación en comparación con el caso base. La exploración adicional de la razón del aumento en la media llevó a la conclusión de que cada vez que los vectores de DR se programan de manera que igualen el error total, empuja el error total de cada receptor hacia arriba. Además, dado que el error acumulado tiene un componente estimado, el horario no es preciso para igualar los errores de los receptores, lo que provoca que el vector de DR llegue antes o después de la programación real. En cualquier caso, el error no se iguala y si el vector de DR llega tarde, en realidad aumenta el error para un receptor más allá del error acumulado más alto. Esto significa que en el próximo disparo, este receptor será el que tenga el error más alto y el error de todos los demás receptores se ajustará a este valor de error. Este efecto de cambio repentino conlleva un aumento en el error acumulado para todos los receptores. La programación para la equidad conduce a la disminución de la desviación estándar (es decir, aumenta la equidad entre los diferentes jugadores), pero esto conlleva un mayor error medio, lo cual puede no ser una característica deseable. Esto nos llevó a explorar diferentes formas de igualar los errores acumulados. El enfoque discutido en la siguiente sección es un enfoque heurístico basado en la siguiente idea. Utilizando la misma cantidad de vectores de DR a lo largo del tiempo que en el caso base, en lugar de enviar los vectores de DR a todos los receptores con la misma frecuencia que en el caso base, si podemos aumentar la frecuencia de envío de los vectores de DR al receptor con un error acumulado más alto y disminuir la frecuencia de envío de los vectores de DR al receptor con un error acumulado más bajo, podemos igualar el error de exportación de todos los receptores a lo largo del tiempo. Al mismo tiempo, deseamos disminuir el error del receptor con el error acumulado más alto en el caso base (por supuesto, este receptor recibiría más vectores DR que en el caso base). Nos referimos a dicho algoritmo como un algoritmo basado en presupuesto. ALGORITMO BASADO EN PRESUPUESTO En un juego, el remitente de una entidad envía vectores DR a todos los receptores cada vez que la entidad cruza un umbral. Al reducir el umbral, se generan más vectores de DR durante un período de tiempo dado. Dado que los vectores DR se envían a todos los receptores y el retraso de red entre los pares emisor-receptor no se puede evitar, el error antes de la exportación 3 con el jugador más distante siempre será 3. Tenga en cuenta que después de la exportación, el error se elimina mediante el uso de un reloj sincronizado entre los jugadores. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 Error acumulado promedio en segundos Algoritmo de programación del caso base #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 Desviación estándar del error acumulado en segundos Algoritmo de programación del caso base #1 Figura 4: Promedio y desviación estándar del error con programación y sin ella (es decir, caso base) serán más altos que el resto. Para mitigar el desequilibrio en el error, proponemos enviar vectores de DR selectivamente a diferentes jugadores basándonos en los errores acumulados de estos jugadores. El algoritmo basado en presupuesto se fundamenta en esta idea y existen dos variaciones de él. Uno es un esquema de presupuesto probabilístico y el otro, un esquema de presupuesto determinístico. 5.1 Esquema de presupuesto probabilístico El esquema de presupuesto probabilístico tiene tres pasos principales: a) reducir el umbral de navegación inercial pero al mismo tiempo mantener el número total de DR enviados igual que en el caso base, b) en cada disparador, elegir probabilísticamente a un jugador para enviarle el vector de DR, y c) enviar el vector de DR al jugador elegido. Estos pasos se describen a continuación. La reducción del umbral de DR se implementa de la siguiente manera. Reducir el umbral es equivalente a aumentar el número de puntos de activación donde se generan los vectores de DR. Supongamos que el umbral es tal que el número de disparadores causados por él en el caso base es t y en cada disparador se envían n vectores DR por el remitente, lo que resulta en un total de nt vectores DR. Nuestro objetivo es mantener el número total de vectores DR enviados por el remitente fijo en nt, pero reducir el número de vectores DR enviados en cada activación (es decir, no enviar el vector DR a todos los receptores). Que n y t sean el número de vectores DR enviados en cada disparo y el número de disparos respectivamente en el caso modificado. Queremos asegurarnos de que n t = nt. Dado que queremos aumentar el número de puntos de activación, es decir, t > t, esto significaría que n < n. Es decir, no todos los receptores recibirán el vector DR en cada activación. En el esquema de presupuesto probabilístico, en cada activación, se calcula una probabilidad para que cada receptor reciba un vector DR y solo un receptor recibe el DR (n = 1). Esta probabilidad se basa en los pesos relativos de los errores acumulados de los receptores. Es decir, un receptor con un error acumulado más alto tendrá una probabilidad más alta de recibir el vector DR. Ten en cuenta que el error acumulado para tres jugadores es a1, a2 y a3 respectivamente. Entonces, la probabilidad de que el jugador 1 reciba el vector DR sería a1 a1+a2+a3. Del mismo modo para los otros jugadores. Una vez que se elige al jugador, el vector DR se envía a ese jugador. Para comparar el algoritmo basado en presupuesto probabilístico con el caso base, necesitábamos reducir el umbral para el caso base (para una comparación justa). Dado que el umbral de cálculo de la posición muerta en el caso base ya era muy fino, se decidió que en lugar de reducir el umbral, se compararía el enfoque basado en el presupuesto probabilístico con un caso base modificado que utilizaría el umbral normal como algoritmo basado en el presupuesto, pero el caso base se modificó de tal manera que cada tercer disparador se usaría realmente para enviar un vector de cálculo de la posición muerta a los tres receptores utilizados en nuestros experimentos. Esto fue llamado como el caso base 1/3 ya que resultó en el envío de 1/3 del número de vectores DR en comparación con el caso base. El presupuesto por disparador para el enfoque basado en la probabilidad se calculó como un vector de DR en cada disparador en comparación con tres vectores de DR en cada tercer disparador en el caso base de 1/3; por lo tanto, los dos casos resultan en el mismo número de vectores de DR enviados con el tiempo. Para evaluar la efectividad del algoritmo de presupuesto probabilístico, instrumentamos el juego BZFlag para utilizar este enfoque. Utilizamos el mismo banco de pruebas que consistía en un emisor y tres receptores con retardos de 800ms, 500ms y 200ms desde el emisor y con baja varianza de retardo (100ms) y moderada varianza de retardo (180ms). Los resultados se muestran en las Figuras 5 y 6. Como se mencionó anteriormente, el eje x de estos gráficos representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe de las figuras que la desviación estándar del error acumulado entre los receptores con el algoritmo basado en presupuesto probabilístico es menor que el caso base de 1/3 y la media es un poco más alta que el caso base de 1/3. Esto implica que el juego es más justo en comparación con el caso base de 1/3 a costa de aumentar ligeramente el error medio en comparación con el caso base de 1/3. El aumento en el error medio en el caso probabilístico en comparación con el caso base de 1/3 se puede atribuir al hecho de que, aunque en promedio el enfoque probabilístico envía el mismo número de vectores DR que el caso base de 1/3, a veces envía vectores DR a un receptor con menos frecuencia y a veces con más frecuencia que el caso base de 1/3 debido a su naturaleza probabilística. Cuando un receptor no recibe un vector DR durante mucho tiempo, la trayectoria del receptor se aleja cada vez más de la trayectoria del emisor y, por lo tanto, la tasa de acumulación del error en el receptor es mayor. En ocasiones, cuando un receptor recibe vectores de DR con más frecuencia, acumula errores a un ritmo más bajo, pero no hay forma de revertir el error acumulado cuando no recibió un vector de DR durante mucho tiempo. Esto lleva a que los receptores acumulen más error en el caso probabilístico en comparación con el caso base de 1/3 donde los receptores reciben un vector DR casi periódicamente. Para limitar el aumento en el error medio, decidimos modificar el algoritmo basado en presupuesto para que sea determinista. Los dos primeros pasos del algoritmo son los mismos que en el algoritmo probabilístico; los puntos de activación se incrementan para reducir el umbral y los errores acumulados se utilizan para calcular la probabilidad de que un receptor reciba un vector DR. Una vez que se completen estos pasos, se calcula un horario determinista para el receptor de la siguiente manera: 1. Si hay algún receptor etiquetado para recibir un vector DR en el disparador actual, el remitente envía el vector DR al(s) receptor(es) respectivo(s). Si al menos un receptor recibió un vector DR, el remitente calcula las probabilidades de que cada receptor reciba un vector DR como se explicó anteriormente y sigue los pasos del 2 al 6; de lo contrario, no hace nada. 2. Para cada receptor, el valor de probabilidad se multiplica por el presupuesto disponible en cada activador (que se establece en 1 como se explica a continuación) para dar la frecuencia de envío del vector DR a cada receptor. Si alguna de las frecuencias de los receptores, después de multiplicarse por el presupuesto, supera 1, la frecuencia del receptor se establece en 1 y la cantidad excedente se distribuye equitativamente entre todos los receptores sumando la cantidad a sus frecuencias existentes. Este proceso se repite hasta que todos los receptores tengan una frecuencia menor o igual a 1. Esto se debe a que en un disparador no podemos enviar más de un vector DR al receptor respectivo. Eso sería un desperdicio de vectores DR al enviar información redundante. 4. (1/frecuencia) nos da el horario en el que el remitente debe enviar vectores DR al receptor respectivo. El crédito obtenido previamente (explicado en el paso 5), si lo hubiera, se resta del horario. Observe que el valor resultante del horario podría no ser un número entero; por lo tanto, el valor se redondea hacia arriba tomando el techo del horario. Por ejemplo, si la frecuencia es de 1/3.5, esto implica que nos gustaría que se enviara un vector de DR cada 3.5 disparadores. Sin embargo, estamos obligados a enviarlo en el cuarto disparo, lo que nos otorga un crédito de 0.5. Cuando enviemos el vector DR la próxima vez, podremos enviarlo en el 3er disparo debido al crédito de 0.5. La diferencia entre el horario y el límite del horario es el crédito que el receptor ha obtenido, que se recuerda para el futuro y se utiliza en el próximo momento, como se explica en el paso 4. 6. Para cada uno de esos receptores a quienes se les envió un vector DR en el disparador actual, los receptores están etiquetados para recibir el próximo vector DR en el disparador que ocurre exactamente el número de veces programado (el techo del programa) lejos del disparador actual. Observe que en este punto no se modifica el horario de ningún otro receptor, ya que todos están ejecutando un horario calculado en algún punto anterior en el tiempo. Esos horarios se modificarán automáticamente en el disparador cuando estén programados para recibir el siguiente vector de DR. En el primer disparador, el remitente envía el vector DR a todos los receptores y utiliza una probabilidad relativa de 1/n para cada receptor y sigue los pasos 2 al 6 para calcular el próximo horario para cada receptor de la misma manera que se menciona para otros disparadores. Este algoritmo garantiza que cada receptor tenga un horario garantizado para recibir vectores DR y, por lo tanto, no haya irregularidades en el envío del vector DR a ningún receptor, como se observó en el algoritmo probabilístico basado en presupuesto. Utilizamos el banco de pruebas descrito anteriormente (tres receptores con retardos variables) para evaluar el algoritmo determinista utilizando el presupuesto de 1 vector DR por activación para así utilizar el mismo número de vectores DR que en el caso base 1/3. Los resultados de nuestros experimentos se muestran en las Figuras 5 y 6. Se puede observar que la desviación estándar del error en el algoritmo basado en presupuesto determinista es menor que el caso base de 1/3 y también tiene el mismo error medio que el caso base de 1/3. Esto indica que el algoritmo determinista es más justo que el caso base de 1/3 y al mismo tiempo no aumenta el error medio, lo que conduce a una mejor calidad de juego en comparación con el algoritmo probabilístico. En general, al comparar el enfoque determinista con el enfoque probabilístico, encontramos que el error acumulado promedio siempre fue menor en el enfoque determinista. Con respecto a la desviación estándar del error acumulado, encontramos que en los casos de varianza fija o baja, el enfoque determinista fue generalmente menor, pero en casos de mayor varianza, era más difícil sacar conclusiones ya que a veces el enfoque probabilístico era mejor que el determinista. CONCLUSIONES Y TRABAJO FUTURO En los juegos multijugador distribuidos que se juegan a través de Internet, los objetos y la trayectoria de los jugadores dentro del espacio de juego se intercambian en términos de vectores DR. Debido al retraso variable entre jugadores, estos vectores DR llegan a diferentes jugadores en momentos distintos. Existe una ventaja injusta obtenida por los receptores que están más cerca del remitente del DR, ya que pueden representar la posición del remitente de manera más precisa en tiempo real. En este documento, primero desarrollamos un modelo para estimar el error en la representación de las trayectorias de los jugadores en los receptores. Luego presentamos un algoritmo basado en programar los vectores de DR para ser enviados a diferentes jugadores en diferentes momentos, igualando así el error en los diferentes jugadores. Este algoritmo tiene como objetivo hacer que el juego sea justo para todos los jugadores, pero tiende a aumentar el error promedio de los jugadores. Para contrarrestar este efecto, presentamos algoritmos basados en presupuestos donde los vectores de DR aún se programan para ser enviados a diferentes jugadores en diferentes momentos, pero el algoritmo equilibra la necesidad de equidad con el requisito de que el error de los jugadores en el peor caso (que están más lejos del remitente) no se incremente en comparación con el caso base (donde todos los vectores de DR se envían a todos los jugadores cada vez que se genera un vector de DR). Presentamos dos variaciones de los algoritmos basados en el presupuesto y, a través de experimentación, demostramos que los algoritmos reducen la desviación estándar del error, haciendo así el juego más justo y al mismo tiempo manteniendo un error medio comparable al caso base. REFERENCIAS [1] S. Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee y S. Rangarajan, Precisión en juegos distribuidos multijugador basados en Dead-Reckoning, Actas del Taller ACM SIGCOMM 2004 sobre Soporte de Redes y Sistemas para Juegos (NetGames 2004), agosto de 2004. [2] L. Gautier y C. Diot, Diseño y Evaluación de MiMaze, un juego multijugador en Internet, en Actas de IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistencia en medios interactivos continuos replicados, en Actas de la Conferencia ACM sobre Trabajo Cooperativo Asistido por Computadora (CSCW00), 2000, pp. 181-190. [4] S.K. Singhal y D.R. Cheriton, Explotando el historial de posición para una representación remota eficiente en la realidad virtual en red, Presencia: Teleoperadores y Entornos Virtuales, vol. 4, núm. 2, pp. 169-193, 1995. [5] C. Diot y L. Gautier, Una arquitectura distribuida para aplicaciones interactivas multijugador en Internet, en la revista IEEE Network, 1999, vol. 13, pp. 6-15. [6] L. Pantel y L.C. Wolf, Sobre el impacto del retraso en los juegos multijugador en tiempo real, en Actas de ACM NOSSDAV02, mayo de 2002. [7] Y. Lin, K. Guo y S. Paul, Sync-MS: Servicio de mensajería sincronizada para juegos distribuidos multijugador en tiempo real, en Actas de la 10ª Conferencia Internacional de Protocolos de Red de IEEE (ICNP), noviembre de 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan y S. Paul, Un marco de intercambio de mensajes justo para juegos distribuidos multijugador, en Actas de NetGames2003, mayo de 2003. [9] N. E. Baughman y B. N. Levine, Reproducción a prueba de trampas para juegos en línea centralizados y distribuidos, en Actas de IEEE INFOCOM01, abril de 2001. [10] M. Allman y V. Paxson, Sobre la estimación de propiedades de la ruta de red de extremo a extremo, en Actas de ACM SIGCOMM99, septiembre de 1999. [11] Foro de BZFlag, Juego de BZFlag, URL: http://www.bzflag.org. [12] Instituto Nacional de Estándares y Tecnología, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "export error": {
            "translated_key": "error de exportación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the <br>export error</br>.",
                "Note that the <br>export error</br>, in turn, results in a deviation between the real and the placed paths.",
                "The <br>export error</br> manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before <br>export error</br>, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after <br>export error</br> is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before <br>export error</br> can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall <br>export error</br>.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the <br>export error</br> at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative <br>export error</br> over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the <br>export error</br> the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the <br>export error</br> due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the <br>export error</br> equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the <br>export error</br>.",
                "A way to represent the <br>export error</br> is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the <br>export error</br> due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the <br>export error</br>.",
                "Note that there would have been an <br>export error</br> created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the <br>export error</br> is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this <br>export error</br> is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different <br>export error</br> values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) <br>export error</br> equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to <br>export error</br> because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the <br>export error</br> equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative <br>export error</br> Referring back to the discussion from Section 3, from the senders perspective, the <br>export error</br> at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the <br>export error</br> from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the <br>export error</br> will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual <br>export error</br> is the relative <br>export error</br> (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative <br>export error</br> is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the <br>export error</br> induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated <br>export error</br> and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative <br>export error</br> for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative <br>export error</br> for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative <br>export error</br> values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated <br>export error</br> (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated <br>export error</br> is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the <br>export error</br> Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative <br>export error</br>, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative <br>export error</br> from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the <br>export error</br> as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative <br>export error</br> at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total <br>export error</br> is the accumulated relative <br>export error</br> at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative <br>export error</br> used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated <br>export error</br> of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated <br>export error</br> of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the <br>export error</br> of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before <br>export error</br> 3 with the most distant player will always 3 Note that after <br>export error</br> is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "We refer to this error as the <br>export error</br>.",
                "Note that the <br>export error</br>, in turn, results in a deviation between the real and the placed paths.",
                "The <br>export error</br> manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before <br>export error</br>, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after <br>export error</br> is made zero.",
                "We also showed that the before <br>export error</br> can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1]."
            ],
            "translated_annotated_samples": [
                "Nos referimos a este error como el <br>error de exportación</br>.",
                "Ten en cuenta que el <br>error de exportación</br>, a su vez, resulta en una desviación entre las rutas reales y las colocadas.",
                "El <br>error de exportación</br> se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación).",
                "En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el <br>error después de la exportación</br> se reduce a cero.",
                "También demostramos que el <br>error antes de la exportación</br> nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el <br>error de exportación</br>. Ten en cuenta que el <br>error de exportación</br>, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El <br>error de exportación</br> se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el <br>error después de la exportación</br> se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el <br>error antes de la exportación</br> nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. ",
            "candidates": [],
            "error": [
                [
                    "error de exportación",
                    "error de exportación",
                    "error de exportación",
                    "error después de la exportación",
                    "error antes de la exportación"
                ]
            ]
        },
        "bucket synchronization": {
            "translated_key": "sincronización de cubo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static <br>bucket synchronization</br> approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on <br>bucket synchronization</br> depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with <br>bucket synchronization</br> are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static <br>bucket synchronization</br> approach to compensate for variable network delays.",
                "In general, techniques based on <br>bucket synchronization</br> depend on imposing a worst case delay on all the players.",
                "It has been shown in [9] that multi-player games that use DR vectors together with <br>bucket synchronization</br> are not cheatproof unless additional mechanisms are put in place."
            ],
            "translated_annotated_samples": [
                "El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de <br>sincronización de cubo</br> estático para compensar las variaciones en los retrasos de la red.",
                "En general, las técnicas basadas en la <br>sincronización de cubetas</br> dependen de imponer un retraso máximo en todos los jugadores.",
                "Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la <br>sincronización de cubos</br> no son a prueba de trampas a menos que se implementen mecanismos adicionales."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la precisión del juego. Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores. Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado. El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de <br>sincronización de cubo</br> estático para compensar las variaciones en los retrasos de la red. En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota. Los jugadores con un retraso de red mayor a 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la <br>sincronización de cubetas</br> dependen de imponer un retraso máximo en todos los jugadores. Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados. Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto). Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción. Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización. La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras. En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego. Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor). Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la <br>sincronización de cubos</br> no son a prueba de trampas a menos que se implementen mecanismos adicionales. Tanto el algoritmo de programación como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas. Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida. Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño. En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1]. En la Sección 4, describimos el algoritmo de programación de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFlag. La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de precisión en el juego. Las conclusiones se presentan en la Sección 6.2.3. MODELO DE JUEGO La arquitectura del juego se basa en jugadores distribuidos a través de Internet que intercambian vectores DR entre sí. Los vectores de DR podrían ser enviados directamente de un jugador a otro (modelo peer-to-peer) o podrían ser enviados a través de un servidor de juego que recibe el vector de DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor). Como se mencionó anteriormente, asumimos que los relojes de los jugadores participantes están sincronizados. Cada vector DR enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad. Suponemos un vector DR lineal en el que la información contenida en el vector DR es solo suficiente para que el jugador receptor calcule la trayectoria y represente la entidad en un camino en línea recta. Un vector DR de este tipo contiene información sobre la posición inicial y la velocidad del jugador/entidad, donde la velocidad es constante. Por lo tanto, los vectores DR enviados por un jugador especifican el tiempo actual en el jugador cuando se calcula el vector DR (no el tiempo en el que este vector DR se envía a los otros jugadores, como explicaremos más adelante), la posición actual del jugador/entidad en términos de las coordenadas x, y, z y el vector de velocidad en la dirección de las coordenadas x, y, z. Específicamente, el vector DRi enviado por el jugador j sobre la k-ésima entidad se denota como DRj ik y está representado por la siguiente tupla (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik). Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y para una sola entidad. Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional. Por lo tanto, usamos DRi para denotar el i-ésimo vector DR representado como la tupla (Ti, xi, yi, vxi, vyi). El jugador receptor calcula la posición inicial para la entidad basándose en xi, yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo Ti en el que fue calculado. Ten en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados. El jugador receptor luego utiliza los componentes de velocidad para proyectar y representar la trayectoria de la entidad. Esta trayectoria se sigue hasta que se recibe un nuevo vector DR que cambia la posición y/o velocidad de la entidad. tiempoT1 Real Exportado Colocado dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) calculado en el tiempo T1 y enviado al receptor DR0 = (T0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptor T0 dt0 Colocado E Figura 1: Trayectorias y desviaciones. Basado en este modelo, la Figura 1 ilustra el envío y recepción de vectores DR y los diferentes errores que se encuentran. Otros tipos de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y vectores DR de spline cúbico que consideran la posición y velocidad inicial y la posición y velocidad final de la entidad. La figura muestra la recepción de vectores de DR en un jugador (en adelante llamado receptor). El eje horizontal muestra el tiempo que está sincronizado entre todos los jugadores. El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad. Suponga que en el tiempo T0 se calcula un vector DR0 por el remitente y se envía inmediatamente al receptor. Supongamos que DR0 es recibido por el receptor después de un retraso de dt0 unidades de tiempo. El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (mostrado como punto E). La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor basada en los componentes de velocidad vx0 y vy0 (ruta colocada). En el tiempo T1 se calcula un vector DR1 de enrutamiento dinámico para la misma entidad y se envía inmediatamente al receptor2. Suponga que DR1 es recibido por el receptor después de un retraso de dt1 unidades de tiempo. Cuando se recibe este vector DR, se asume que la entidad está en el punto D. Se calcula una nueva posición para la entidad como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto C). Los componentes de velocidad vx1 y vy1 se utilizan para proyectar y representar esta entidad más lejos. Ahora consideremos el error debido al retraso de la red. Aunque DR1 se calculó en el tiempo T1 y se envió al receptor, no llegó al receptor hasta el tiempo T1 + dt1. Esto significa que, aunque la ruta exportada basada en DR1 en el remitente en el tiempo T1 es la trayectoria AC, hasta el tiempo T1 + dt1, en el receptor, esta entidad estaba siendo representada en la trayectoria BD basada en DR0. Solo en el momento T1 + dt1 la entidad se movió al punto C, a partir del cual los caminos exportados y colocados son iguales. La desviación entre las rutas exportadas y colocadas crea un componente de error al que nos referimos como el error de exportación. Una forma de representar el error de exportación es calcular la integral de la distancia entre las dos trayectorias durante el tiempo en que están desincronizadas. Representamos la integral de las distancias entre las rutas colocadas y exportadas debido a algunos DR DRi en un intervalo de tiempo [t1, t2] como Err(DRi, t1, t2). En la figura, el error de exportación debido a DR1 se calcula como la integral de la distancia entre las trayectorias AC y BD en el intervalo de tiempo [T1, T1 + dt1]. Ten en cuenta que también podría haber otras formas de representar este error, pero en este artículo utilizamos la integral de la distancia entre las dos trayectorias como medida del error de exportación. Tenga en cuenta que se habría producido un error de exportación debido a la recepción de DR0, momento en el que la ruta colocada se basaría en un vector DR anterior. Esto no se muestra en la figura, pero sirve para recordar al lector que el error de exportación es acumulativo cuando se reciben una secuencia de vectores DR. A partir del tiempo T1 en adelante, hay una desviación entre las trayectorias reales y las exportadas. Como discutimos anteriormente, este error de exportación es inevitable. La figura y el ejemplo anterior ilustran solo un receptor. Pero en realidad, los vectores DR DR0 y DR1 son enviados por el remitente a todos los jugadores participantes. Cada uno de estos jugadores recibe DR0 y DR1 después de diferentes retrasos, creando así diferentes valores de error de exportación en cada jugador. El objetivo del algoritmo de programación de vectores DR que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual en cada jugador de forma independiente para cada una de las entidades que conforman el juego. ALGORITMO DE PROGRAMACIÓN PARA EL ENVÍO DE VECTORES DR En la Sección 3 mostramos cómo el retraso desde el remitente de un nuevo vector DR 2 Normalmente, los vectores DR no se calculan de forma periódica, sino bajo demanda, donde la decisión de calcular un nuevo vector DR se basa en la superación de un umbral en la desviación entre la ruta real y la ruta exportada por el vector DR anterior. 3 vector al receptor del vector DR podría llevar a un error de exportación debido a la desviación de la ruta colocada de la ruta exportada en el receptor hasta que se reciba este nuevo vector DR. También mencionamos que el objetivo del algoritmo de programación de vectores DR es igualar el error de exportación en todos los receptores durante un período de tiempo. Dado que el juego se juega en un entorno distribuido, tiene sentido que el remitente de una entidad lleve un registro de todos los errores en los receptores e intente igualarlos. Sin embargo, el remitente no puede conocer el error real en un receptor hasta que reciba alguna información sobre el error del receptor. Nuestro algoritmo estima el error para calcular un horario para enviar vectores DR a los receptores y corrige el error cuando recibe retroalimentación de los receptores. En esta sección proporcionamos las motivaciones para el algoritmo y describimos los pasos por los que atraviesa. A lo largo de esta sección, utilizaremos el siguiente ejemplo para ilustrar el algoritmo. tiempoT1 Ruta exportada Ruta colocada en el receptor 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 enviado al receptor 1 DR1 enviado al receptor 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimado para ser recibido por el receptor 2 DR1 estimado para ser recibido por el receptor 1 DR1 recibido realmente por el receptor 1 DR1 recibido realmente por el receptor 2 DR0 enviado a ambos receptores DR1 calculado por el remitente Ruta colocada en el receptor 1 Figura 2: Flujo de vector DR entre un remitente y dos receptores y la evolución de las rutas colocadas estimadas y reales en los receptores. DR0 = (T0, T0, x0, y0, vx0, vy0), enviado en el tiempo T0 a ambos receptores. DR1 = (T1, T1 1 , x1, y1, vx1, vy1) enviado en el tiempo T1 1 = T1+δ1 al receptor 1 y DR1 = (T1, T2 1 , x1, y1, vx1, vy1) enviado en el tiempo T2 1 = T1 + δ2 al receptor 2. Considera el ejemplo en la Figura 2. La figura muestra un único emisor enviando vectores DR para una entidad a dos receptores diferentes 1 y 2. DR0 calculado en T0 es enviado y recibido por los receptores en algún momento entre T0 y T1, momento en el cual mueven la ubicación de la entidad para que coincida con la ruta exportada. Por lo tanto, la trayectoria de la entidad se muestra solo desde el punto en que la trayectoria colocada coincide con la trayectoria exportada para DR0. Ahora considera DR1. En el tiempo T1, DR1 es calculado por el remitente, pero se asume que no es enviado inmediatamente a los receptores y solo se envía después de un tiempo δ1 al receptor 1 (en el tiempo T1 1 = T1 + δ1) y después de un tiempo δ2 al receptor 2 (en el tiempo T2 1 = T1 + δ2). Ten en cuenta que el remitente incluye la marca de tiempo de envío con el vector DR como se muestra en la figura. Supongamos que el remitente estima (pronto quedará claro por qué el remitente tiene que estimar el retraso) que después de un retraso de dt1, el receptor 1 lo recibirá, utilizará los parámetros de coordenadas y velocidad para calcular la ubicación actual de la entidad y moverla allí (punto C) y a partir de ese momento, los caminos exportado y colocado serán iguales. Sin embargo, en realidad, el receptor 1 recibe DR1 después de un retraso de da1 (que es menor que las estimaciones de los remitentes de dt1), y mueve la entidad correspondiente al punto H. De manera similar, el remitente estima que después de un retraso de dt2, el receptor 2 recibirá DR1, calculará la ubicación actual de la entidad y la moverá a ese punto (punto E), mientras que en realidad recibe DR1 después de un retraso de da2 > dt2 y mueve la entidad al punto N. Los otros puntos mostrados en las rutas colocadas y exportadas se utilizarán más adelante en la discusión para describir diferentes componentes de error. 4.1 Cálculo del Error de Exportación Relativo Volviendo a la discusión de la Sección 3, desde la perspectiva de los remitentes, el error de exportación en el receptor 1 debido a DR1 se da por Err(DR1, T1, T1 + δ1 + dt1) (la integral de la distancia entre las trayectorias AC y DB en el intervalo de tiempo [T1, T1 + δ1 + dt1]) de la Figura 2. Esto se debe a que el remitente utiliza el retraso estimado dt1 para calcular este error. De manera similar, el error de exportación desde la perspectiva del remitente en el recibido 2 debido a DR1 se da por Err(DR1, T1, T1 + δ2 + dt2) (la integral de la distancia entre las trayectorias AE y DF en el intervalo de tiempo [T1, T1 + δ2 + dt2]). Ten en cuenta que los errores anteriores desde la perspectiva del remitente son solo estimaciones. En realidad, el error de exportación será tanto menor como mayor que el valor estimado, dependiendo de si la estimación de retraso fue mayor o menor que el retraso real experimentado por DR1. La diferencia entre el error de exportación estimado y el real es el error de exportación relativo (que puede ser positivo o negativo) que ocurre para cada vector de DR que se envía y se acumula en el remitente. El concepto de error relativo de exportación se ilustra en la Figura 2. Dado que el retraso actual al receptor 1 es da1, el error de exportación inducido por DR1 en el receptor 1 es Err(DR1, T1, T1 + δ1 + da1). Esto significa que hay un error en el error estimado de exportación y el remitente solo puede calcular este error después de recibir un comentario del receptor sobre la demora real en la entrega de DR1, es decir, el valor de da1. Proponemos que una vez que el receptor 1 reciba DR1, envíe el valor de da1 de vuelta al remitente. El receptor puede calcular esta información ya que conoce el momento en que se envió DR1 (T1 1 = T1 + δ1, que se añade al vector DR como se muestra en la Figura 2) y el tiempo local de recepción (que está sincronizado con el reloj del emisor). Por lo tanto, el remitente calcula el error relativo de exportación para el receptor 1, representado como R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1). De manera similar, el error relativo de exportación para el receptor 2 se calcula como R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2). Nótese que R1 > 0 ya que da1 < dt1, y R2 < 0 ya que da2 > dt2. Los errores relativos de exportación son calculados por el remitente en el momento en que recibe la retroalimentación de los destinatarios. Este ejemplo muestra los 4 valores relativos de error de exportación después de que se envía DR1 y se reciben los comentarios correspondientes. 4.2 Igualación del Error Entre Receptores Ahora explicamos lo que queremos decir al hacer que los errores sean iguales en todos los receptores y cómo se puede lograr esto. Como se mencionó anteriormente, el remitente mantiene estimaciones de los retrasos a los receptores, dt1 y dt2 en el ejemplo de la Figura 2. Esto indica que en el momento T1 cuando se calcula DR1, el remitente ya sabe cuánto tiempo pueden tardar los mensajes que llevan este vector DR en llegar a los receptores. El remitente utiliza esta información para calcular los errores de exportación, que son Err(DR1, T1, T1 + δ1 + dt1) y Err(DR1, T1, T1 + δ2 + dt2) para los receptores 1 y 2, respectivamente. Ten en cuenta que las áreas de estos componentes de error son una función de δ1 y δ2, así como de las demoras de red dt1 y dt2. Si queremos que los errores de exportación debido a DR1 sean iguales en ambos receptores, el remitente debe elegir δ1 y δ2 de manera que Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2). Pero cuando se calculó T1, ya podría haberse acumulado errores relativos de exportación debido a los vectores DR anteriores (DR0 y los anteriores). Representemos el error relativo acumulado hasta DRi para el receptor j como Ri j. Para acomodar estos errores relativos acumulados, el remitente debe elegir ahora δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Los δi determinan el instante de programación del vector DR en el remitente para el receptor i. Este método de cálculo de δs garantiza que el error de exportación acumulado (es decir, el error total real) para cada receptor se iguala en la transmisión de cada vector DR. Para establecer esto, asuma que la retroalimentación para el vector DR Di de un receptor llega al remitente antes de que se calcule el horario para Di+1. Que Si m y Ai m denoten el error estimado para el receptor m utilizado para calcular el horario para Di y el error acumulado para el receptor m calculado después de recibir retroalimentación para Di, respectivamente. Entonces Ri m = Ai m − Si m. Para calcular las instancias de programación (es decir, δs) para Di, para cualquier par de receptores m y n, hacemos Ri−1 m + Si m = Ri−1 n + Si n. El siguiente teorema establece el hecho de que el error acumulado de exportación se iguala en cada instante de programación. TEOREMA 4.1. Cuando se calculan las instancias de horario para enviar Di a cualquier par de receptores m y n, se cumple la siguiente condición: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Prueba: Por inducción. Supongamos que la premisa se cumple para algún i. Mostramos que se cumple para i+1. El caso base para i = 1 se cumple ya que inicialmente R0 m = R0 n = 0, y se utiliza S1 m = S1 n para calcular las instancias de programación. Para calcular el horario de Di+1, primero calculamos los errores relativos como Ri m = Ai m − Si m y Ri n = Ai n − Si n. Luego, para calcular δs, ejecutamos Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n. Añadiendo la condición de la premisa en ambos lados obtenemos, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n. 4.3 Cálculo del Error de Exportación. Ahora consideremos cómo se pueden calcular los errores de exportación. De la sección anterior, para encontrar δ1 y δ2 necesitamos encontrar Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2). Se debe tener en cuenta que los valores de R0 1 y R0 2 ya son conocidos en el remitente. Considera el cálculo de Err(DR1, T1, T1 +δ1 +dt1). Esta es la integral de la distancia entre las trayectorias AC debido a DR1 y BD debido a DR0. A partir de DR0 y DR1, el punto A es (X1, Y1) = (x1, y1) y el punto B es (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0). La trayectoria AC puede ser representada como una función del tiempo como (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) y la trayectoria de BD puede ser representada como (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t). La distancia entre las dos trayectorias como función del tiempo se convierte entonces en, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Sea a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Entonces dist(t) se puede escribir como dist(t) = a × t2 + b × t + c. Luego Err(DR1, t1, t2) para algún intervalo de tiempo [t1, t2] se convierte en t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt. Una solución en forma cerrada para la integral indefinida a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2) pueden entonces ser calculadas aplicando los límites apropiados a la solución anterior. En la siguiente sección, consideramos el cálculo de los δs para N receptores. 5 4.4 Cálculo de Instantes de Programación Volvemos a analizar el cálculo de los δs haciendo referencia a la Figura 2. El remitente elige δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 + Err(DR1, T1, T1 + δ2 +dt2). Si R0 1 y R0 2 ambos son cero, entonces δ1 y δ2 deben ser elegidos de tal manera que Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2). Esta igualdad se mantendrá si δ1 + dt1 = δ2 + dt2. Por lo tanto, si no hay error acumulado relativo de exportación, todo lo que el remitente necesita hacer es elegir los δs de tal manera que contrarresten la diferencia en el retraso a los dos receptores, para que reciban el vector DR al mismo tiempo. Como se discutió anteriormente, dado que el remitente no puede aprender de antemano el retraso, siempre habrá un error relativo acumulado de exportación de un vector DR previo que debe tenerse en cuenta. Para profundizar en esto, considera el cálculo del error de exportación como se ilustra en la sección anterior. Para calcular los δs necesitamos que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Es decir, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt. Eso es R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt. Los componentes R0 1, R0 2, ya son conocidos por (o estimados por) el remitente. Además, los componentes de error T1+dt1 T1 dist(t) dt y T1+dt2 T1 dist(t) dt pueden ser calculados a priori por el remitente utilizando valores estimados de dt1 y dt2. Usemos E1 para denotar R0 1 + T1+dt1 T1 dist(t) dt y E2 para denotar R0 2 + T1+dt2 T1 dist(t) dt. Entonces, requerimos que E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. Suponga que E1 > E2. Entonces, para que la ecuación anterior se cumpla, requerimos que T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt. Para hacer el juego lo más rápido posible dentro de este marco, los valores de δ deben ser lo más pequeños posible para que los vectores DR se envíen a los receptores lo antes posible, sujeto al requisito de equidad. Dado esto, elegiríamos δ1 como cero y calcularíamos δ2 a partir de la ecuación E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. En general, si hay N receptores 1, . . . , N, cuando un emisor genera un vector DR y decide programarlos para ser enviados, primero calcula los valores de Ei para todos ellos a partir de los errores relativos acumulados en la exportación y las estimaciones de los retrasos. Luego, encuentra el valor más pequeño de estos valores. Que Ek sea el valor más pequeño. El remitente hace que δk sea cero y calcula el resto de los δs a partir de la igualdad Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) Los δs así obtenidos dan los instantes de programación del vector DR para los receptores. 4.5 Pasos del Algoritmo de Programación Para los fines de la discusión a continuación, como antes, vamos a denotar el error relativo acumulado en un remitente para el receptor k hasta DRi como Ri k. Vamos a denotar el retraso programado en el remitente antes de que DRi sea enviado al receptor k como δi k. Dada la discusión anterior, los pasos del algoritmo son los siguientes: 1. El remitente calcula DRi en el tiempo Ti y luego calcula δi k y Ri−1 k, ∀k, 1 ≤ k ≤ N basándose en la estimación de los retrasos dtk, ∀k, 1 ≤ k ≤ N según la Ecuación (1). Programa que DRi se envíe al receptor k en el tiempo Ti + δi k. 2. Los vectores DR se envían a los receptores en los horarios programados, los cuales se reciben después de un retraso de dak, ∀k, 1 ≤ k ≤ N donde dak ≤ o > dtk. Los receptores envían el valor de dak de vuelta al remitente (el receptor puede calcular este valor basándose en las marcas de tiempo en el vector DR como se describió anteriormente). 3. El remitente calcula Ri k como se describe anteriormente e ilustra en la Figura 2. El remitente también recalcula (utilizando un método de promedio exponencial similar a la estimación del tiempo de ida y vuelta por TCP [10]) la estimación del retraso dtk a partir del nuevo valor de dak para el receptor k. 4. Vuelve al Paso 1 para calcular DRi+1 cuando sea necesario y sigue los pasos del algoritmo para programar y enviar este vector DR a los receptores. 4.6 Manejo de Casos en la Práctica Hasta ahora asumimos implícitamente que DRi se envía a todos los receptores antes de tomar una decisión para calcular el siguiente vector DR DRi+1, y los receptores envían el valor de dak correspondiente a DRi y esta información llega al remitente antes de que calcule DRi+1 para que pueda calcular Ri+1 k y luego usarlo en el cálculo de δi+1 k. Dos cuestiones deben tenerse en cuenta con respecto al algoritmo anterior cuando se utiliza en la práctica. • Puede suceder que se calcule un nuevo vector DR incluso antes de que el vector DR anterior se envíe a todos los receptores. ¿Cómo se manejará esta situación? • ¿Qué sucede si la retroalimentación no llega antes de que se calcule y programe el envío de DRi+1? Consideremos el primer escenario. Suponemos que DRi ha sido programado para ser enviado y los instantes de programación son tales que δi 1 < δi 2 < · · · < δi N. Suponga que se va a calcular DRi+1 (porque la trayectoria real se ha desviado excediendo un umbral de la trayectoria exportada por DRi) en el tiempo Ti+1 donde Ti + δi k < Ti+1 < Ti + δi k+1. Esto significa que DRi ha sido enviado solo a receptores hasta k en el orden programado. En nuestro algoritmo, en este caso, se vacía la cola de ordenación de retrasos programados, lo que significa que DRi no se envía a los receptores que aún están en cola para recibirlo, pero se calcula un nuevo orden de programación para que todos los receptores envíen DRi+1. Para aquellos receptores a quienes se les ha enviado DRi, asumir por ahora que se ha recibido de todos los receptores daj, 1 ≤ j ≤ k (el escenario donde daj no ha sido recibido se considerará como parte del segundo escenario más tarde). Para estos receptores, Ei j, 1 ≤ j ≤ k se pueden calcular. Para aquellos receptores j, k + 1 ≤ j ≤ N a quienes no se les envió DRi, Ei j no aplica. Considera un receptor j, k + 1 ≤ j ≤ N a quien no se le envió DRi. Consulte la Figura 3. Para un receptor j dado, cuando se programa DRi+1 y se exporta la ruta dtj A B C D Ti-1 Gi j, DRi+1 calculado por el remitente y DRi para el receptor k+1 a N se eliminan de la cola. DRi+1 programado para el receptor k+1, Ti+1 G H E F, DRi programado para el receptor j, DRi calculado por el remitente, se coloca la ruta en el receptor k+1, Gi+1 j. Figura 3: Cálculo de programación cuando DRi no se envía al receptor j, k + 1 ≤ j ≤ N. Se necesita calcular δi+1 j, el error total de exportación es el error de exportación relativo acumulado en el tiempo Ti cuando se programó el DRi, más la integral de la distancia entre las dos trayectorias AC y BD de la Figura 3 en el intervalo de tiempo [Ti, Ti+1 + δi+1 j + dtj]. Ten en cuenta que esta integral está dada por Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj). Por lo tanto, en lugar de Ei j de la Ecuación (1), utilizamos el valor Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) donde Ri−1 j es el error relativo de exportación utilizado cuando se calculó el horario para DRi. Ahora considera el segundo escenario. Aquí el dak de retroalimentación correspondiente a DRi no ha llegado antes de que se calcule y programe DRi+1. En este caso, Ri k no se puede calcular. Por lo tanto, en el cálculo de δk para DRi+1, se asumirá que es cero. Suponemos que se utiliza un mecanismo confiable para enviar el dak de vuelta al remitente. Cuando esta información llegue en un momento posterior, Ri k se calculará y acumulará a los errores relativos de exportación futuros (por ejemplo, Ri+1 k si dak se recibe antes de que se calcule DRi+2) y se utilizará en el cálculo de δk cuando se programe un vector DR futuro (por ejemplo, DRi+2). 4.7 Resultados Experimentales Para evaluar la efectividad y cuantificar los beneficios obtenidos a través del uso del algoritmo de programación, implementamos el algoritmo propuesto en el juego BZFlag (Battle Zone Flag) [11]. Es un juego de disparos en primera persona donde los jugadores en equipos conducen tanques y se mueven dentro de un campo de batalla. El objetivo de los jugadores es navegar y capturar las banderas pertenecientes al otro equipo y llevarlas de vuelta a su propia área. Los jugadores disparan a los tanques de los demás usando balas de disparo. El movimiento de los tanques, así como el de los disparos, se intercambian entre los jugadores utilizando vectores DR. Hemos modificado la implementación de BZFlag para incorporar relojes sincronizados entre los jugadores y el servidor, y intercambiar marcas de tiempo con el vector DR. Establecimos un banco de pruebas con cuatro jugadores ejecutando la versión instrumentada de BZFlag, con uno como emisor y el resto como receptores. El enfoque de programación y el caso base en el que cada vector de DR se envió a todos los receptores simultáneamente en cada punto de activación se implementaron en la misma ejecución etiquetando los vectores de DR según el tipo de enfoque utilizado para enviar el vector de DR. NISTNet [12] se utilizó para introducir retrasos en el emisor y los tres receptores. Se introdujeron retrasos medios de 800 ms, 500 ms y 200 ms entre el emisor y el primer, segundo y tercer receptor, respectivamente. Introducimos una variación de 100 milisegundos (al retraso medio de cada receptor) para modelar la variabilidad en el retraso. El remitente registró los errores de cada receptor cada 100 milisegundos tanto para el enfoque de programación como para el caso base. El remitente también calculó la desviación estándar y la media del error de exportación acumulado de todos los receptores cada 100 milisegundos. La Figura 4 representa la media y la desviación estándar del error acumulado de exportación de todos los receptores en el caso de programación frente al caso base. Ten en cuenta que el eje x de estos gráficos (y de los demás gráficos que siguen) representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe que la desviación estándar del error con la programación es mucho menor en comparación con el caso base. Esto implica que los errores acumulados de los receptores en el caso de programación están más cerca unos de otros. Esto demuestra que el enfoque de programación logra equidad entre los receptores incluso si se encuentran a diferentes distancias (es decir, latencias) del emisor. Observe que la media del error acumulado aumentó varias veces con la programación en comparación con el caso base. La exploración adicional de la razón del aumento en la media llevó a la conclusión de que cada vez que los vectores de DR se programan de manera que igualen el error total, empuja el error total de cada receptor hacia arriba. Además, dado que el error acumulado tiene un componente estimado, el horario no es preciso para igualar los errores de los receptores, lo que provoca que el vector de DR llegue antes o después de la programación real. En cualquier caso, el error no se iguala y si el vector de DR llega tarde, en realidad aumenta el error para un receptor más allá del error acumulado más alto. Esto significa que en el próximo disparo, este receptor será el que tenga el error más alto y el error de todos los demás receptores se ajustará a este valor de error. Este efecto de cambio repentino conlleva un aumento en el error acumulado para todos los receptores. La programación para la equidad conduce a la disminución de la desviación estándar (es decir, aumenta la equidad entre los diferentes jugadores), pero esto conlleva un mayor error medio, lo cual puede no ser una característica deseable. Esto nos llevó a explorar diferentes formas de igualar los errores acumulados. El enfoque discutido en la siguiente sección es un enfoque heurístico basado en la siguiente idea. Utilizando la misma cantidad de vectores de DR a lo largo del tiempo que en el caso base, en lugar de enviar los vectores de DR a todos los receptores con la misma frecuencia que en el caso base, si podemos aumentar la frecuencia de envío de los vectores de DR al receptor con un error acumulado más alto y disminuir la frecuencia de envío de los vectores de DR al receptor con un error acumulado más bajo, podemos igualar el error de exportación de todos los receptores a lo largo del tiempo. Al mismo tiempo, deseamos disminuir el error del receptor con el error acumulado más alto en el caso base (por supuesto, este receptor recibiría más vectores DR que en el caso base). Nos referimos a dicho algoritmo como un algoritmo basado en presupuesto. ALGORITMO BASADO EN PRESUPUESTO En un juego, el remitente de una entidad envía vectores DR a todos los receptores cada vez que la entidad cruza un umbral. Al reducir el umbral, se generan más vectores de DR durante un período de tiempo dado. Dado que los vectores DR se envían a todos los receptores y el retraso de red entre los pares emisor-receptor no se puede evitar, el error antes de la exportación 3 con el jugador más distante siempre será 3. Tenga en cuenta que después de la exportación, el error se elimina mediante el uso de un reloj sincronizado entre los jugadores. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 Error acumulado promedio en segundos Algoritmo de programación del caso base #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 Desviación estándar del error acumulado en segundos Algoritmo de programación del caso base #1 Figura 4: Promedio y desviación estándar del error con programación y sin ella (es decir, caso base) serán más altos que el resto. Para mitigar el desequilibrio en el error, proponemos enviar vectores de DR selectivamente a diferentes jugadores basándonos en los errores acumulados de estos jugadores. El algoritmo basado en presupuesto se fundamenta en esta idea y existen dos variaciones de él. Uno es un esquema de presupuesto probabilístico y el otro, un esquema de presupuesto determinístico. 5.1 Esquema de presupuesto probabilístico El esquema de presupuesto probabilístico tiene tres pasos principales: a) reducir el umbral de navegación inercial pero al mismo tiempo mantener el número total de DR enviados igual que en el caso base, b) en cada disparador, elegir probabilísticamente a un jugador para enviarle el vector de DR, y c) enviar el vector de DR al jugador elegido. Estos pasos se describen a continuación. La reducción del umbral de DR se implementa de la siguiente manera. Reducir el umbral es equivalente a aumentar el número de puntos de activación donde se generan los vectores de DR. Supongamos que el umbral es tal que el número de disparadores causados por él en el caso base es t y en cada disparador se envían n vectores DR por el remitente, lo que resulta en un total de nt vectores DR. Nuestro objetivo es mantener el número total de vectores DR enviados por el remitente fijo en nt, pero reducir el número de vectores DR enviados en cada activación (es decir, no enviar el vector DR a todos los receptores). Que n y t sean el número de vectores DR enviados en cada disparo y el número de disparos respectivamente en el caso modificado. Queremos asegurarnos de que n t = nt. Dado que queremos aumentar el número de puntos de activación, es decir, t > t, esto significaría que n < n. Es decir, no todos los receptores recibirán el vector DR en cada activación. En el esquema de presupuesto probabilístico, en cada activación, se calcula una probabilidad para que cada receptor reciba un vector DR y solo un receptor recibe el DR (n = 1). Esta probabilidad se basa en los pesos relativos de los errores acumulados de los receptores. Es decir, un receptor con un error acumulado más alto tendrá una probabilidad más alta de recibir el vector DR. Ten en cuenta que el error acumulado para tres jugadores es a1, a2 y a3 respectivamente. Entonces, la probabilidad de que el jugador 1 reciba el vector DR sería a1 a1+a2+a3. Del mismo modo para los otros jugadores. Una vez que se elige al jugador, el vector DR se envía a ese jugador. Para comparar el algoritmo basado en presupuesto probabilístico con el caso base, necesitábamos reducir el umbral para el caso base (para una comparación justa). Dado que el umbral de cálculo de la posición muerta en el caso base ya era muy fino, se decidió que en lugar de reducir el umbral, se compararía el enfoque basado en el presupuesto probabilístico con un caso base modificado que utilizaría el umbral normal como algoritmo basado en el presupuesto, pero el caso base se modificó de tal manera que cada tercer disparador se usaría realmente para enviar un vector de cálculo de la posición muerta a los tres receptores utilizados en nuestros experimentos. Esto fue llamado como el caso base 1/3 ya que resultó en el envío de 1/3 del número de vectores DR en comparación con el caso base. El presupuesto por disparador para el enfoque basado en la probabilidad se calculó como un vector de DR en cada disparador en comparación con tres vectores de DR en cada tercer disparador en el caso base de 1/3; por lo tanto, los dos casos resultan en el mismo número de vectores de DR enviados con el tiempo. Para evaluar la efectividad del algoritmo de presupuesto probabilístico, instrumentamos el juego BZFlag para utilizar este enfoque. Utilizamos el mismo banco de pruebas que consistía en un emisor y tres receptores con retardos de 800ms, 500ms y 200ms desde el emisor y con baja varianza de retardo (100ms) y moderada varianza de retardo (180ms). Los resultados se muestran en las Figuras 5 y 6. Como se mencionó anteriormente, el eje x de estos gráficos representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe de las figuras que la desviación estándar del error acumulado entre los receptores con el algoritmo basado en presupuesto probabilístico es menor que el caso base de 1/3 y la media es un poco más alta que el caso base de 1/3. Esto implica que el juego es más justo en comparación con el caso base de 1/3 a costa de aumentar ligeramente el error medio en comparación con el caso base de 1/3. El aumento en el error medio en el caso probabilístico en comparación con el caso base de 1/3 se puede atribuir al hecho de que, aunque en promedio el enfoque probabilístico envía el mismo número de vectores DR que el caso base de 1/3, a veces envía vectores DR a un receptor con menos frecuencia y a veces con más frecuencia que el caso base de 1/3 debido a su naturaleza probabilística. Cuando un receptor no recibe un vector DR durante mucho tiempo, la trayectoria del receptor se aleja cada vez más de la trayectoria del emisor y, por lo tanto, la tasa de acumulación del error en el receptor es mayor. En ocasiones, cuando un receptor recibe vectores de DR con más frecuencia, acumula errores a un ritmo más bajo, pero no hay forma de revertir el error acumulado cuando no recibió un vector de DR durante mucho tiempo. Esto lleva a que los receptores acumulen más error en el caso probabilístico en comparación con el caso base de 1/3 donde los receptores reciben un vector DR casi periódicamente. Para limitar el aumento en el error medio, decidimos modificar el algoritmo basado en presupuesto para que sea determinista. Los dos primeros pasos del algoritmo son los mismos que en el algoritmo probabilístico; los puntos de activación se incrementan para reducir el umbral y los errores acumulados se utilizan para calcular la probabilidad de que un receptor reciba un vector DR. Una vez que se completen estos pasos, se calcula un horario determinista para el receptor de la siguiente manera: 1. Si hay algún receptor etiquetado para recibir un vector DR en el disparador actual, el remitente envía el vector DR al(s) receptor(es) respectivo(s). Si al menos un receptor recibió un vector DR, el remitente calcula las probabilidades de que cada receptor reciba un vector DR como se explicó anteriormente y sigue los pasos del 2 al 6; de lo contrario, no hace nada. 2. Para cada receptor, el valor de probabilidad se multiplica por el presupuesto disponible en cada activador (que se establece en 1 como se explica a continuación) para dar la frecuencia de envío del vector DR a cada receptor. Si alguna de las frecuencias de los receptores, después de multiplicarse por el presupuesto, supera 1, la frecuencia del receptor se establece en 1 y la cantidad excedente se distribuye equitativamente entre todos los receptores sumando la cantidad a sus frecuencias existentes. Este proceso se repite hasta que todos los receptores tengan una frecuencia menor o igual a 1. Esto se debe a que en un disparador no podemos enviar más de un vector DR al receptor respectivo. Eso sería un desperdicio de vectores DR al enviar información redundante. 4. (1/frecuencia) nos da el horario en el que el remitente debe enviar vectores DR al receptor respectivo. El crédito obtenido previamente (explicado en el paso 5), si lo hubiera, se resta del horario. Observe que el valor resultante del horario podría no ser un número entero; por lo tanto, el valor se redondea hacia arriba tomando el techo del horario. Por ejemplo, si la frecuencia es de 1/3.5, esto implica que nos gustaría que se enviara un vector de DR cada 3.5 disparadores. Sin embargo, estamos obligados a enviarlo en el cuarto disparo, lo que nos otorga un crédito de 0.5. Cuando enviemos el vector DR la próxima vez, podremos enviarlo en el 3er disparo debido al crédito de 0.5. La diferencia entre el horario y el límite del horario es el crédito que el receptor ha obtenido, que se recuerda para el futuro y se utiliza en el próximo momento, como se explica en el paso 4. 6. Para cada uno de esos receptores a quienes se les envió un vector DR en el disparador actual, los receptores están etiquetados para recibir el próximo vector DR en el disparador que ocurre exactamente el número de veces programado (el techo del programa) lejos del disparador actual. Observe que en este punto no se modifica el horario de ningún otro receptor, ya que todos están ejecutando un horario calculado en algún punto anterior en el tiempo. Esos horarios se modificarán automáticamente en el disparador cuando estén programados para recibir el siguiente vector de DR. En el primer disparador, el remitente envía el vector DR a todos los receptores y utiliza una probabilidad relativa de 1/n para cada receptor y sigue los pasos 2 al 6 para calcular el próximo horario para cada receptor de la misma manera que se menciona para otros disparadores. Este algoritmo garantiza que cada receptor tenga un horario garantizado para recibir vectores DR y, por lo tanto, no haya irregularidades en el envío del vector DR a ningún receptor, como se observó en el algoritmo probabilístico basado en presupuesto. Utilizamos el banco de pruebas descrito anteriormente (tres receptores con retardos variables) para evaluar el algoritmo determinista utilizando el presupuesto de 1 vector DR por activación para así utilizar el mismo número de vectores DR que en el caso base 1/3. Los resultados de nuestros experimentos se muestran en las Figuras 5 y 6. Se puede observar que la desviación estándar del error en el algoritmo basado en presupuesto determinista es menor que el caso base de 1/3 y también tiene el mismo error medio que el caso base de 1/3. Esto indica que el algoritmo determinista es más justo que el caso base de 1/3 y al mismo tiempo no aumenta el error medio, lo que conduce a una mejor calidad de juego en comparación con el algoritmo probabilístico. En general, al comparar el enfoque determinista con el enfoque probabilístico, encontramos que el error acumulado promedio siempre fue menor en el enfoque determinista. Con respecto a la desviación estándar del error acumulado, encontramos que en los casos de varianza fija o baja, el enfoque determinista fue generalmente menor, pero en casos de mayor varianza, era más difícil sacar conclusiones ya que a veces el enfoque probabilístico era mejor que el determinista. CONCLUSIONES Y TRABAJO FUTURO En los juegos multijugador distribuidos que se juegan a través de Internet, los objetos y la trayectoria de los jugadores dentro del espacio de juego se intercambian en términos de vectores DR. Debido al retraso variable entre jugadores, estos vectores DR llegan a diferentes jugadores en momentos distintos. Existe una ventaja injusta obtenida por los receptores que están más cerca del remitente del DR, ya que pueden representar la posición del remitente de manera más precisa en tiempo real. En este documento, primero desarrollamos un modelo para estimar el error en la representación de las trayectorias de los jugadores en los receptores. Luego presentamos un algoritmo basado en programar los vectores de DR para ser enviados a diferentes jugadores en diferentes momentos, igualando así el error en los diferentes jugadores. Este algoritmo tiene como objetivo hacer que el juego sea justo para todos los jugadores, pero tiende a aumentar el error promedio de los jugadores. Para contrarrestar este efecto, presentamos algoritmos basados en presupuestos donde los vectores de DR aún se programan para ser enviados a diferentes jugadores en diferentes momentos, pero el algoritmo equilibra la necesidad de equidad con el requisito de que el error de los jugadores en el peor caso (que están más lejos del remitente) no se incremente en comparación con el caso base (donde todos los vectores de DR se envían a todos los jugadores cada vez que se genera un vector de DR). Presentamos dos variaciones de los algoritmos basados en el presupuesto y, a través de experimentación, demostramos que los algoritmos reducen la desviación estándar del error, haciendo así el juego más justo y al mismo tiempo manteniendo un error medio comparable al caso base. REFERENCIAS [1] S. Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee y S. Rangarajan, Precisión en juegos distribuidos multijugador basados en Dead-Reckoning, Actas del Taller ACM SIGCOMM 2004 sobre Soporte de Redes y Sistemas para Juegos (NetGames 2004), agosto de 2004. [2] L. Gautier y C. Diot, Diseño y Evaluación de MiMaze, un juego multijugador en Internet, en Actas de IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistencia en medios interactivos continuos replicados, en Actas de la Conferencia ACM sobre Trabajo Cooperativo Asistido por Computadora (CSCW00), 2000, pp. 181-190. [4] S.K. Singhal y D.R. Cheriton, Explotando el historial de posición para una representación remota eficiente en la realidad virtual en red, Presencia: Teleoperadores y Entornos Virtuales, vol. 4, núm. 2, pp. 169-193, 1995. [5] C. Diot y L. Gautier, Una arquitectura distribuida para aplicaciones interactivas multijugador en Internet, en la revista IEEE Network, 1999, vol. 13, pp. 6-15. [6] L. Pantel y L.C. Wolf, Sobre el impacto del retraso en los juegos multijugador en tiempo real, en Actas de ACM NOSSDAV02, mayo de 2002. [7] Y. Lin, K. Guo y S. Paul, Sync-MS: Servicio de mensajería sincronizada para juegos distribuidos multijugador en tiempo real, en Actas de la 10ª Conferencia Internacional de Protocolos de Red de IEEE (ICNP), noviembre de 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan y S. Paul, Un marco de intercambio de mensajes justo para juegos distribuidos multijugador, en Actas de NetGames2003, mayo de 2003. [9] N. E. Baughman y B. N. Levine, Reproducción a prueba de trampas para juegos en línea centralizados y distribuidos, en Actas de IEEE INFOCOM01, abril de 2001. [10] M. Allman y V. Paxson, Sobre la estimación de propiedades de la ruta de red de extremo a extremo, en Actas de ACM SIGCOMM99, septiembre de 1999. [11] Foro de BZFlag, Juego de BZFlag, URL: http://www.bzflag.org. [12] Instituto Nacional de Estándares y Tecnología, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. ",
            "candidates": [],
            "error": [
                [
                    "sincronización de cubo",
                    "sincronización de cubetas",
                    "sincronización de cubos"
                ]
            ]
        },
        "network delay": {
            "translated_key": "retraso de red",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to <br>network delay</br> between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the <br>network delay</br> between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero <br>network delay</br>, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a <br>network delay</br> larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to <br>network delay</br>.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the <br>network delay</br> between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to <br>network delay</br> between the sender and the receiver.",
                "Because of the <br>network delay</br> between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero <br>network delay</br>, but can be significantly reduced using our technique [1].",
                "Players with a <br>network delay</br> larger than 100 ms simply cannot participate in the game.",
                "Let us now consider the error due to <br>network delay</br>."
            ],
            "translated_annotated_samples": [
                "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al <br>retraso de red</br> entre el emisor y el receptor.",
                "Debido al <br>retraso de red</br> entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya.",
                "También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un <br>retraso de red</br> no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1].",
                "Los jugadores con un <br>retraso de red</br> mayor a 100 ms simplemente no pueden participar en el juego.",
                "Ahora consideremos el error debido al <br>retraso de la red</br>."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de dead-reckoning para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al <br>retraso de red</br> entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el vector de navegación inercial, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de navegación inercial en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al <br>retraso de red</br> entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un <br>retraso de red</br> no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la precisión del juego. Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores. Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado. El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de sincronización de cubo estático para compensar las variaciones en los retrasos de la red. En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota. Los jugadores con un <br>retraso de red</br> mayor a 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la sincronización de cubetas dependen de imponer un retraso máximo en todos los jugadores. Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados. Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto). Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción. Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización. La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras. En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego. Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor). Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la sincronización de cubos no son a prueba de trampas a menos que se implementen mecanismos adicionales. Tanto el algoritmo de programación como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas. Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida. Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño. En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1]. En la Sección 4, describimos el algoritmo de programación de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFlag. La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de precisión en el juego. Las conclusiones se presentan en la Sección 6.2.3. MODELO DE JUEGO La arquitectura del juego se basa en jugadores distribuidos a través de Internet que intercambian vectores DR entre sí. Los vectores de DR podrían ser enviados directamente de un jugador a otro (modelo peer-to-peer) o podrían ser enviados a través de un servidor de juego que recibe el vector de DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor). Como se mencionó anteriormente, asumimos que los relojes de los jugadores participantes están sincronizados. Cada vector DR enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad. Suponemos un vector DR lineal en el que la información contenida en el vector DR es solo suficiente para que el jugador receptor calcule la trayectoria y represente la entidad en un camino en línea recta. Un vector DR de este tipo contiene información sobre la posición inicial y la velocidad del jugador/entidad, donde la velocidad es constante. Por lo tanto, los vectores DR enviados por un jugador especifican el tiempo actual en el jugador cuando se calcula el vector DR (no el tiempo en el que este vector DR se envía a los otros jugadores, como explicaremos más adelante), la posición actual del jugador/entidad en términos de las coordenadas x, y, z y el vector de velocidad en la dirección de las coordenadas x, y, z. Específicamente, el vector DRi enviado por el jugador j sobre la k-ésima entidad se denota como DRj ik y está representado por la siguiente tupla (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik). Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y para una sola entidad. Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional. Por lo tanto, usamos DRi para denotar el i-ésimo vector DR representado como la tupla (Ti, xi, yi, vxi, vyi). El jugador receptor calcula la posición inicial para la entidad basándose en xi, yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo Ti en el que fue calculado. Ten en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados. El jugador receptor luego utiliza los componentes de velocidad para proyectar y representar la trayectoria de la entidad. Esta trayectoria se sigue hasta que se recibe un nuevo vector DR que cambia la posición y/o velocidad de la entidad. tiempoT1 Real Exportado Colocado dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) calculado en el tiempo T1 y enviado al receptor DR0 = (T0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptor T0 dt0 Colocado E Figura 1: Trayectorias y desviaciones. Basado en este modelo, la Figura 1 ilustra el envío y recepción de vectores DR y los diferentes errores que se encuentran. Otros tipos de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y vectores DR de spline cúbico que consideran la posición y velocidad inicial y la posición y velocidad final de la entidad. La figura muestra la recepción de vectores de DR en un jugador (en adelante llamado receptor). El eje horizontal muestra el tiempo que está sincronizado entre todos los jugadores. El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad. Suponga que en el tiempo T0 se calcula un vector DR0 por el remitente y se envía inmediatamente al receptor. Supongamos que DR0 es recibido por el receptor después de un retraso de dt0 unidades de tiempo. El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (mostrado como punto E). La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor basada en los componentes de velocidad vx0 y vy0 (ruta colocada). En el tiempo T1 se calcula un vector DR1 de enrutamiento dinámico para la misma entidad y se envía inmediatamente al receptor2. Suponga que DR1 es recibido por el receptor después de un retraso de dt1 unidades de tiempo. Cuando se recibe este vector DR, se asume que la entidad está en el punto D. Se calcula una nueva posición para la entidad como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto C). Los componentes de velocidad vx1 y vy1 se utilizan para proyectar y representar esta entidad más lejos. Ahora consideremos el error debido al <br>retraso de la red</br>. ",
            "candidates": [],
            "error": [
                [
                    "retraso de red",
                    "retraso de red",
                    "retraso de red",
                    "retraso de red",
                    "retraso de la red"
                ]
            ]
        },
        "distribute multi-player game": {
            "translated_key": "distribuir un juego multijugador",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "dead-reckon": {
            "translated_key": "dead-reckoning",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses <br>dead-reckon</br>ing vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the <br>dead-reckon</br>ing vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of <br>dead-reckon</br>ing vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses <br>dead-reckon</br>ing vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the <br>dead-reckon</br>ing vector, but by that time, the real position could have changed considerably at the sender.",
                "Then we develop an algorithm for scheduling the sending of <br>dead-reckon</br>ing vectors at a sender that strives to make this error equal at different receivers over time."
            ],
            "translated_annotated_samples": [
                "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de <br>dead-reckoning</br> para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor.",
                "El objeto se coloca en el receptor en la posición indicada por el <br>vector de navegación inercial</br>, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor.",
                "Luego desarrollamos un algoritmo para programar el envío de vectores de <br>navegación inercial</br> en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo."
            ],
            "translated_text": "Equidad en juegos multijugador distribuidos basados en Dead-Reckoning Sudhir Aggarwal Hemant Banavar Departamento de Ciencias de la Computación Universidad Estatal de Florida, Tallahassee, FL Correo electrónico: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Centro de Investigación en Redes Bell Laboratories, Holmdel, NJ Correo electrónico: {sarit, sampath}@bell-labs.com RESUMEN En un juego multijugador distribuido que utiliza vectores de <br>dead-reckoning</br> para intercambiar información de movimiento entre jugadores, hay inexactitudes al renderizar los objetos en el receptor debido al retraso de red entre el emisor y el receptor. El objeto se coloca en el receptor en la posición indicada por el <br>vector de navegación inercial</br>, pero para ese momento, la posición real podría haber cambiado considerablemente en el emisor. Esta inexactitud sería tolerable si es consistente entre todos los jugadores; es decir, en el mismo momento físico, todos los jugadores ven una posición y trayectoria inexactas (con respecto a la posición real del objeto) pero la misma para un objeto. Pero debido a los retrasos de red variables entre el remitente y los diferentes receptores, la inexactitud también es diferente en diferentes jugadores. Esto conduce a la injusticia en el juego. En este documento, primero presentamos una medida de error para estimar esta inexactitud. Luego desarrollamos un algoritmo para programar el envío de vectores de <br>navegación inercial</br> en un emisor que se esfuerza por igualar este error en diferentes receptores a lo largo del tiempo. Este algoritmo hace que el juego sea muy justo a expensas de aumentar el error medio general de todos los jugadores. Para mitigar este efecto, proponemos un algoritmo basado en presupuesto que brinda una mayor equidad sin aumentar el error medio, manteniendo así la precisión del juego. Hemos implementado tanto el algoritmo de programación como el algoritmo basado en presupuesto como parte de BZFlag, un popular juego multijugador distribuido. Mostramos a través de experimentos que estos algoritmos proporcionan equidad entre los jugadores a pesar de las variaciones amplias en los retrasos de red. Una propiedad adicional de los algoritmos propuestos es que requieren menos cantidad de DRs para ser intercambiados (en comparación con la implementación actual de BZflag) para lograr el mismo nivel de precisión en el juego. Categorías y Descriptores de Asignaturas C.2.4 [Redes de Computadoras-Comunicación]: Sistemas Distribuidos-Aplicaciones Distribuidas Términos Generales Algoritmos, Diseño, Experimentación, Rendimiento 1. En un juego multijugador distribuido, los jugadores suelen estar distribuidos a lo largo de Internet y tienen diferentes retrasos entre ellos o hacia un servidor central de juego. Por lo general, en este tipo de juegos, los jugadores forman parte del juego y además pueden controlar entidades que lo componen. Durante el transcurso del juego, los jugadores y las entidades se mueven dentro del espacio del juego. Un jugador envía información sobre su movimiento, así como el movimiento de las entidades que controla, a los otros jugadores utilizando un vector de Dead-Reckoning (DR). Un vector DR contiene información sobre la posición actual del jugador/entidad en términos de coordenadas x, y, y z (en el momento en que se envió el vector DR), así como la trayectoria de la entidad en términos de la componente de velocidad en cada una de las dimensiones. Cada uno de los jugadores participantes recibe tales vectores de DR de los demás y representa a los otros jugadores/entidades en las consolas locales hasta que se reciba un nuevo vector de DR para ese jugador/entidad. En un juego de igual a igual, los jugadores envían vectores DR directamente entre sí; en un juego de cliente-servidor, estos vectores DR pueden ser reenviados a través de un servidor de juego. La idea de DR se utiliza porque es casi imposible que los jugadores/entidades intercambien sus posiciones actuales en cada unidad de tiempo. Los vectores DR son la cuantificación de la trayectoria real (a la que nos referimos como camino real) de un jugador. Normalmente, se calcula y envía un nuevo vector DR cuando la trayectoria real se desvía de la trayectoria extrapolada utilizando el vector DR anterior (digamos, en términos de distancia en el plano x, y, z) por una cantidad especificada por un umbral. Nos referimos a la trayectoria que se puede calcular utilizando la secuencia de vectores DR como la ruta exportada. Por lo tanto, en el jugador que envía, hay una desviación entre la trayectoria real y la trayectoria exportada. El error debido a esta desviación puede ser eliminado si cada movimiento del jugador/entidad se comunica a los otros jugadores en cada unidad de tiempo; es decir, se genera un vector DR en cada unidad de tiempo, haciendo que los caminos reales y exportados sean iguales. Dado que no es factible satisfacer esto debido a limitaciones de ancho de banda, este error no es de interés práctico. Por lo tanto, los jugadores receptores pueden, como máximo, seguir la trayectoria exportada. Debido al retraso de red entre los jugadores que envían y reciben, cuando un vector DR es recibido y representado en un jugador, la trayectoria original del jugador/entidad puede haber cambiado ya. Por lo tanto, en el tiempo físico, hay una desviación en el jugador receptor entre la trayectoria exportada y la trayectoria renderizada (a la que nos referimos como trayectoria colocada). Nos referimos a este error como el error de exportación. Ten en cuenta que el error de exportación, a su vez, resulta en una desviación entre las rutas reales y las colocadas. El error de exportación se manifiesta debido a la desviación entre la ruta exportada en el remitente y la ruta colocada en el receptor (i) 1 antes de que el vector DR sea recibido en el receptor (referido como el error antes de la exportación, y (ii) después de que el vector DR sea recibido en el receptor (referido como el error después de la exportación). En un artículo anterior [1], demostramos que al sincronizar los relojes de todos los jugadores y al utilizar una técnica basada en marcar el tiempo de los mensajes que llevan los vectores DR, podemos garantizar que el error después de la exportación se reduce a cero. Es decir, las rutas colocadas y exportadas coinciden después de recibir el vector de DR. También demostramos que el error antes de la exportación nunca puede ser eliminado ya que siempre existe un retraso de red no nulo, pero puede ser significativamente reducido utilizando nuestra técnica [1]. De ahora en adelante asumimos que los jugadores utilizan una técnica que resulta en un error de exportación general inevitable pero pequeño. En este documento consideramos el problema de los retrasos de red diferentes y variables entre cada par emisor-receptor de un vector DR, y consecuentemente, los errores de exportación diferentes y variables en los receptores. Debido a la diferencia en los errores de exportación entre los receptores, la misma entidad se representa en diferentes momentos físicos en diferentes receptores. Esto introduce injusticia en el juego. Por ejemplo, un jugador con un gran retraso siempre vería una entidad tarde en el tiempo físico en comparación con los otros jugadores y, por lo tanto, su acción sobre la entidad se retrasaría (en tiempo físico) incluso si reaccionara instantáneamente después de que la entidad fuera renderizada. Nuestro objetivo en este artículo es mejorar la equidad de estos juegos a pesar de las variaciones en los retrasos de red al igualar el error de exportación entre los jugadores. Exploramos si el promedio temporal de los errores de exportación (que es el error de exportación acumulado durante un período de tiempo promediado en el período de tiempo) en todos los jugadores puede ser igual al programar el envío de los vectores DR de manera apropiada en el remitente. Proponemos dos algoritmos para lograr esto. Ambos algoritmos se basan en retrasar (o eliminar) el envío de vectores de DR a algunos jugadores de forma continua para intentar que el error de exportación sea el mismo en todos los jugadores. A nivel abstracto, el algoritmo retrasa el envío de vectores DR a los jugadores cuyo error acumulado hasta el momento en el juego es menor que el de los demás; esto significaría que el error de exportación debido a este vector DR en estos jugadores será mayor que el de los otros jugadores, haciendo que sean iguales. El objetivo es hacer que este error sea aproximadamente igual en cada vector de DR, con la desviación en el error disminuyendo a medida que avanza el tiempo. El primer algoritmo (al que nos referimos como algoritmo de programación) se basa en estimar el retraso entre los jugadores y perfeccionar el envío de vectores DR programándolos para ser enviados a diferentes jugadores en diferentes momentos en cada punto de generación de DR. A través de la implementación de este algoritmo utilizando el juego de código abierto BZflag, demostramos que este algoritmo hace que el juego sea muy justo (medimos la equidad en términos de la desviación estándar del error). La desventaja de este algoritmo es que tiende a empujar el error de todos los jugadores hacia el del jugador con el peor error (que es el error del jugador más alejado, en términos de retraso, del remitente del DR). Para aliviar este efecto, proponemos un algoritmo basado en presupuesto que asigna un presupuesto para enviar los DRs a diferentes jugadores. A un nivel alto, el algoritmo se basa en la idea de enviar más DRs a los jugadores que están más lejos del remitente en comparación con aquellos que están más cerca. Los resultados experimentales de BZflag ilustran que el algoritmo basado en presupuesto sigue un enfoque más equilibrado. Mejora la equidad del juego, pero al mismo tiempo lo hace sin aumentar el error promedio de los jugadores, manteniendo así la precisión del juego. Además, se ha demostrado que el algoritmo basado en presupuesto logra el mismo nivel de precisión en el juego que la implementación actual de BZflag utilizando un número mucho menor de vectores DR. 2. Trabajos previos Los trabajos anteriores sobre juegos en red para tratar la latencia de red se han centrado principalmente en técnicas de compensación para el retraso y la pérdida de paquetes [2, 3, 4]. Estos métodos tienen como objetivo hacer que los retrasos grandes y la pérdida de mensajes sean tolerables para los jugadores, pero no consideran los problemas que pueden ser introducidos por los retrasos variables desde el servidor hacia diferentes jugadores o entre los propios jugadores. Por ejemplo, el concepto de retraso local ha sido utilizado en [3], donde cada jugador retrasa cada operación local durante un cierto período de tiempo para que los jugadores remotos puedan recibir información sobre la operación local y ejecutar la misma operación aproximadamente al mismo tiempo, reduciendo así las inconsistencias de estado. El juego en línea multijugador MiMaze [2, 5, 6], por ejemplo, utiliza un enfoque de sincronización de cubo estático para compensar las variaciones en los retrasos de la red. En MiMaze, cada jugador retrasa todos los eventos en 100 ms independientemente de si son generados localmente o de forma remota. Los jugadores con un retraso de red mayor a 100 ms simplemente no pueden participar en el juego. En general, las técnicas basadas en la sincronización de cubetas dependen de imponer un retraso máximo en todos los jugadores. Ha habido algunos artículos que han estudiado el problema de la equidad en un juego distribuido mediante mecanismos de entrega de mensajes más sofisticados. Pero estos trabajos [7, 8] asumen la existencia de una visión global del juego donde un servidor de juego mantiene una visión (o estado) del juego. Los jugadores pueden introducir objetos en el juego o eliminar objetos que ya forman parte del juego (por ejemplo, en un juego de disparos en primera persona, disparando al objeto). Estas adiciones y eliminaciones se comunican al servidor del juego utilizando mensajes de acción. Basándose en estos mensajes de acción, el estado del juego se modifica en el servidor del juego y estos cambios se comunican a los jugadores mediante mensajes de actualización. La equidad se logra ordenando la entrega de mensajes de acción y actualización en el servidor de juegos y en los jugadores respectivamente, basándose en la noción de un orden justo que tiene en cuenta los retrasos entre el servidor de juegos y los diferentes jugadores. Los objetos que forman parte del juego pueden moverse, pero cómo se comunica esta información a los jugadores parece estar más allá del alcance de estas obras. En este sentido, estas obras son muy limitadas en alcance y pueden ser aplicables solo a juegos de disparos en primera persona y también solo a juegos donde los jugadores no son parte del juego. Los vectores DR pueden intercambiarse directamente entre los jugadores (modelo peer-to-peer) o utilizando un servidor central como relé (modelo cliente-servidor). Se ha demostrado en [9] que los juegos multijugador que utilizan vectores DR junto con la sincronización de cubos no son a prueba de trampas a menos que se implementen mecanismos adicionales. Tanto el algoritmo de programación como el algoritmo basado en presupuesto descritos en nuestro artículo utilizan vectores DR y, por lo tanto, no son a prueba de trampas. Por ejemplo, un receptor podría distorsionar la estimación de retraso en el remitente para hacerle creer al remitente que el retraso entre el remitente y el receptor es alto, obteniendo así una ventaja indebida. Enfatizamos que el enfoque de este artículo es la equidad sin abordar el tema del engaño. En la siguiente sección, describimos el modelo de juego que utilizamos e ilustramos cómo los emisores y receptores intercambian vectores DR y cómo las entidades se representan en los receptores basándose en el intercambio de vectores DR aumentados con marcas de tiempo según se describe en [1]. En la Sección 4, describimos el algoritmo de programación de vectores DR que tiene como objetivo igualar el error de exportación entre los jugadores con diferentes retrasos desde el remitente de un vector DR, seguido de los resultados experimentales obtenidos de la instrumentación del algoritmo de programación en el juego de código abierto BZFlag. La sección 5 describe el algoritmo basado en presupuesto que logra una mayor equidad sin reducir el nivel de precisión en el juego. Las conclusiones se presentan en la Sección 6.2.3. MODELO DE JUEGO La arquitectura del juego se basa en jugadores distribuidos a través de Internet que intercambian vectores DR entre sí. Los vectores de DR podrían ser enviados directamente de un jugador a otro (modelo peer-to-peer) o podrían ser enviados a través de un servidor de juego que recibe el vector de DR de un jugador y lo reenvía a otros jugadores (modelo cliente-servidor). Como se mencionó anteriormente, asumimos que los relojes de los jugadores participantes están sincronizados. Cada vector DR enviado de un jugador a otro especifica la trayectoria de exactamente un jugador/entidad. Suponemos un vector DR lineal en el que la información contenida en el vector DR es solo suficiente para que el jugador receptor calcule la trayectoria y represente la entidad en un camino en línea recta. Un vector DR de este tipo contiene información sobre la posición inicial y la velocidad del jugador/entidad, donde la velocidad es constante. Por lo tanto, los vectores DR enviados por un jugador especifican el tiempo actual en el jugador cuando se calcula el vector DR (no el tiempo en el que este vector DR se envía a los otros jugadores, como explicaremos más adelante), la posición actual del jugador/entidad en términos de las coordenadas x, y, z y el vector de velocidad en la dirección de las coordenadas x, y, z. Específicamente, el vector DRi enviado por el jugador j sobre la k-ésima entidad se denota como DRj ik y está representado por la siguiente tupla (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik). Sin pérdida de generalidad, en el resto de la discusión, consideramos una secuencia de vectores DR enviados por un solo jugador y para una sola entidad. Para simplificar, consideramos un espacio de juego bidimensional en lugar de uno tridimensional. Por lo tanto, usamos DRi para denotar el i-ésimo vector DR representado como la tupla (Ti, xi, yi, vxi, vyi). El jugador receptor calcula la posición inicial para la entidad basándose en xi, yi y la diferencia de tiempo entre cuando se recibe el vector DR y el tiempo Ti en el que fue calculado. Ten en cuenta que el cálculo de la diferencia de tiempo es factible ya que todos los relojes están sincronizados. El jugador receptor luego utiliza los componentes de velocidad para proyectar y representar la trayectoria de la entidad. Esta trayectoria se sigue hasta que se recibe un nuevo vector DR que cambia la posición y/o velocidad de la entidad. tiempoT1 Real Exportado Colocado dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) calculado en el tiempo T1 y enviado al receptor DR0 = (T0, x0, y0, vx0, vy0) calculado en el tiempo T0 y enviado al receptor T0 dt0 Colocado E Figura 1: Trayectorias y desviaciones. Basado en este modelo, la Figura 1 ilustra el envío y recepción de vectores DR y los diferentes errores que se encuentran. Otros tipos de vectores DR incluyen vectores DR cuadráticos que especifican la aceleración de la entidad y vectores DR de spline cúbico que consideran la posición y velocidad inicial y la posición y velocidad final de la entidad. La figura muestra la recepción de vectores de DR en un jugador (en adelante llamado receptor). El eje horizontal muestra el tiempo que está sincronizado entre todos los jugadores. El eje vertical intenta capturar conceptualmente la posición bidimensional de una entidad. Suponga que en el tiempo T0 se calcula un vector DR0 por el remitente y se envía inmediatamente al receptor. Supongamos que DR0 es recibido por el receptor después de un retraso de dt0 unidades de tiempo. El receptor calcula la posición inicial de la entidad como (x0 + vx0 × dt0, y0 + vy0 × dt0) (mostrado como punto E). La línea gruesa EBD representa la trayectoria proyectada y renderizada en el receptor basada en los componentes de velocidad vx0 y vy0 (ruta colocada). En el tiempo T1 se calcula un vector DR1 de enrutamiento dinámico para la misma entidad y se envía inmediatamente al receptor2. Suponga que DR1 es recibido por el receptor después de un retraso de dt1 unidades de tiempo. Cuando se recibe este vector DR, se asume que la entidad está en el punto D. Se calcula una nueva posición para la entidad como (x1 + vx1 × dt1, y1 + vy0 × dt1) y la entidad se mueve a esta posición (punto C). Los componentes de velocidad vx1 y vy1 se utilizan para proyectar y representar esta entidad más lejos. Ahora consideremos el error debido al retraso de la red. Aunque DR1 se calculó en el tiempo T1 y se envió al receptor, no llegó al receptor hasta el tiempo T1 + dt1. Esto significa que, aunque la ruta exportada basada en DR1 en el remitente en el tiempo T1 es la trayectoria AC, hasta el tiempo T1 + dt1, en el receptor, esta entidad estaba siendo representada en la trayectoria BD basada en DR0. Solo en el momento T1 + dt1 la entidad se movió al punto C, a partir del cual los caminos exportados y colocados son iguales. La desviación entre las rutas exportadas y colocadas crea un componente de error al que nos referimos como el error de exportación. Una forma de representar el error de exportación es calcular la integral de la distancia entre las dos trayectorias durante el tiempo en que están desincronizadas. Representamos la integral de las distancias entre las rutas colocadas y exportadas debido a algunos DR DRi en un intervalo de tiempo [t1, t2] como Err(DRi, t1, t2). En la figura, el error de exportación debido a DR1 se calcula como la integral de la distancia entre las trayectorias AC y BD en el intervalo de tiempo [T1, T1 + dt1]. Ten en cuenta que también podría haber otras formas de representar este error, pero en este artículo utilizamos la integral de la distancia entre las dos trayectorias como medida del error de exportación. Tenga en cuenta que se habría producido un error de exportación debido a la recepción de DR0, momento en el que la ruta colocada se basaría en un vector DR anterior. Esto no se muestra en la figura, pero sirve para recordar al lector que el error de exportación es acumulativo cuando se reciben una secuencia de vectores DR. A partir del tiempo T1 en adelante, hay una desviación entre las trayectorias reales y las exportadas. Como discutimos anteriormente, este error de exportación es inevitable. La figura y el ejemplo anterior ilustran solo un receptor. Pero en realidad, los vectores DR DR0 y DR1 son enviados por el remitente a todos los jugadores participantes. Cada uno de estos jugadores recibe DR0 y DR1 después de diferentes retrasos, creando así diferentes valores de error de exportación en cada jugador. El objetivo del algoritmo de programación de vectores DR que se describirá en la siguiente sección es hacer que este error de exportación (acumulativo) sea igual en cada jugador de forma independiente para cada una de las entidades que conforman el juego. ALGORITMO DE PROGRAMACIÓN PARA EL ENVÍO DE VECTORES DR En la Sección 3 mostramos cómo el retraso desde el remitente de un nuevo vector DR 2 Normalmente, los vectores DR no se calculan de forma periódica, sino bajo demanda, donde la decisión de calcular un nuevo vector DR se basa en la superación de un umbral en la desviación entre la ruta real y la ruta exportada por el vector DR anterior. 3 vector al receptor del vector DR podría llevar a un error de exportación debido a la desviación de la ruta colocada de la ruta exportada en el receptor hasta que se reciba este nuevo vector DR. También mencionamos que el objetivo del algoritmo de programación de vectores DR es igualar el error de exportación en todos los receptores durante un período de tiempo. Dado que el juego se juega en un entorno distribuido, tiene sentido que el remitente de una entidad lleve un registro de todos los errores en los receptores e intente igualarlos. Sin embargo, el remitente no puede conocer el error real en un receptor hasta que reciba alguna información sobre el error del receptor. Nuestro algoritmo estima el error para calcular un horario para enviar vectores DR a los receptores y corrige el error cuando recibe retroalimentación de los receptores. En esta sección proporcionamos las motivaciones para el algoritmo y describimos los pasos por los que atraviesa. A lo largo de esta sección, utilizaremos el siguiente ejemplo para ilustrar el algoritmo. tiempoT1 Ruta exportada Ruta colocada en el receptor 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 enviado al receptor 1 DR1 enviado al receptor 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimado para ser recibido por el receptor 2 DR1 estimado para ser recibido por el receptor 1 DR1 recibido realmente por el receptor 1 DR1 recibido realmente por el receptor 2 DR0 enviado a ambos receptores DR1 calculado por el remitente Ruta colocada en el receptor 1 Figura 2: Flujo de vector DR entre un remitente y dos receptores y la evolución de las rutas colocadas estimadas y reales en los receptores. DR0 = (T0, T0, x0, y0, vx0, vy0), enviado en el tiempo T0 a ambos receptores. DR1 = (T1, T1 1 , x1, y1, vx1, vy1) enviado en el tiempo T1 1 = T1+δ1 al receptor 1 y DR1 = (T1, T2 1 , x1, y1, vx1, vy1) enviado en el tiempo T2 1 = T1 + δ2 al receptor 2. Considera el ejemplo en la Figura 2. La figura muestra un único emisor enviando vectores DR para una entidad a dos receptores diferentes 1 y 2. DR0 calculado en T0 es enviado y recibido por los receptores en algún momento entre T0 y T1, momento en el cual mueven la ubicación de la entidad para que coincida con la ruta exportada. Por lo tanto, la trayectoria de la entidad se muestra solo desde el punto en que la trayectoria colocada coincide con la trayectoria exportada para DR0. Ahora considera DR1. En el tiempo T1, DR1 es calculado por el remitente, pero se asume que no es enviado inmediatamente a los receptores y solo se envía después de un tiempo δ1 al receptor 1 (en el tiempo T1 1 = T1 + δ1) y después de un tiempo δ2 al receptor 2 (en el tiempo T2 1 = T1 + δ2). Ten en cuenta que el remitente incluye la marca de tiempo de envío con el vector DR como se muestra en la figura. Supongamos que el remitente estima (pronto quedará claro por qué el remitente tiene que estimar el retraso) que después de un retraso de dt1, el receptor 1 lo recibirá, utilizará los parámetros de coordenadas y velocidad para calcular la ubicación actual de la entidad y moverla allí (punto C) y a partir de ese momento, los caminos exportado y colocado serán iguales. Sin embargo, en realidad, el receptor 1 recibe DR1 después de un retraso de da1 (que es menor que las estimaciones de los remitentes de dt1), y mueve la entidad correspondiente al punto H. De manera similar, el remitente estima que después de un retraso de dt2, el receptor 2 recibirá DR1, calculará la ubicación actual de la entidad y la moverá a ese punto (punto E), mientras que en realidad recibe DR1 después de un retraso de da2 > dt2 y mueve la entidad al punto N. Los otros puntos mostrados en las rutas colocadas y exportadas se utilizarán más adelante en la discusión para describir diferentes componentes de error. 4.1 Cálculo del Error de Exportación Relativo Volviendo a la discusión de la Sección 3, desde la perspectiva de los remitentes, el error de exportación en el receptor 1 debido a DR1 se da por Err(DR1, T1, T1 + δ1 + dt1) (la integral de la distancia entre las trayectorias AC y DB en el intervalo de tiempo [T1, T1 + δ1 + dt1]) de la Figura 2. Esto se debe a que el remitente utiliza el retraso estimado dt1 para calcular este error. De manera similar, el error de exportación desde la perspectiva del remitente en el recibido 2 debido a DR1 se da por Err(DR1, T1, T1 + δ2 + dt2) (la integral de la distancia entre las trayectorias AE y DF en el intervalo de tiempo [T1, T1 + δ2 + dt2]). Ten en cuenta que los errores anteriores desde la perspectiva del remitente son solo estimaciones. En realidad, el error de exportación será tanto menor como mayor que el valor estimado, dependiendo de si la estimación de retraso fue mayor o menor que el retraso real experimentado por DR1. La diferencia entre el error de exportación estimado y el real es el error de exportación relativo (que puede ser positivo o negativo) que ocurre para cada vector de DR que se envía y se acumula en el remitente. El concepto de error relativo de exportación se ilustra en la Figura 2. Dado que el retraso actual al receptor 1 es da1, el error de exportación inducido por DR1 en el receptor 1 es Err(DR1, T1, T1 + δ1 + da1). Esto significa que hay un error en el error estimado de exportación y el remitente solo puede calcular este error después de recibir un comentario del receptor sobre la demora real en la entrega de DR1, es decir, el valor de da1. Proponemos que una vez que el receptor 1 reciba DR1, envíe el valor de da1 de vuelta al remitente. El receptor puede calcular esta información ya que conoce el momento en que se envió DR1 (T1 1 = T1 + δ1, que se añade al vector DR como se muestra en la Figura 2) y el tiempo local de recepción (que está sincronizado con el reloj del emisor). Por lo tanto, el remitente calcula el error relativo de exportación para el receptor 1, representado como R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1). De manera similar, el error relativo de exportación para el receptor 2 se calcula como R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2). Nótese que R1 > 0 ya que da1 < dt1, y R2 < 0 ya que da2 > dt2. Los errores relativos de exportación son calculados por el remitente en el momento en que recibe la retroalimentación de los destinatarios. Este ejemplo muestra los 4 valores relativos de error de exportación después de que se envía DR1 y se reciben los comentarios correspondientes. 4.2 Igualación del Error Entre Receptores Ahora explicamos lo que queremos decir al hacer que los errores sean iguales en todos los receptores y cómo se puede lograr esto. Como se mencionó anteriormente, el remitente mantiene estimaciones de los retrasos a los receptores, dt1 y dt2 en el ejemplo de la Figura 2. Esto indica que en el momento T1 cuando se calcula DR1, el remitente ya sabe cuánto tiempo pueden tardar los mensajes que llevan este vector DR en llegar a los receptores. El remitente utiliza esta información para calcular los errores de exportación, que son Err(DR1, T1, T1 + δ1 + dt1) y Err(DR1, T1, T1 + δ2 + dt2) para los receptores 1 y 2, respectivamente. Ten en cuenta que las áreas de estos componentes de error son una función de δ1 y δ2, así como de las demoras de red dt1 y dt2. Si queremos que los errores de exportación debido a DR1 sean iguales en ambos receptores, el remitente debe elegir δ1 y δ2 de manera que Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2). Pero cuando se calculó T1, ya podría haberse acumulado errores relativos de exportación debido a los vectores DR anteriores (DR0 y los anteriores). Representemos el error relativo acumulado hasta DRi para el receptor j como Ri j. Para acomodar estos errores relativos acumulados, el remitente debe elegir ahora δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Los δi determinan el instante de programación del vector DR en el remitente para el receptor i. Este método de cálculo de δs garantiza que el error de exportación acumulado (es decir, el error total real) para cada receptor se iguala en la transmisión de cada vector DR. Para establecer esto, asuma que la retroalimentación para el vector DR Di de un receptor llega al remitente antes de que se calcule el horario para Di+1. Que Si m y Ai m denoten el error estimado para el receptor m utilizado para calcular el horario para Di y el error acumulado para el receptor m calculado después de recibir retroalimentación para Di, respectivamente. Entonces Ri m = Ai m − Si m. Para calcular las instancias de programación (es decir, δs) para Di, para cualquier par de receptores m y n, hacemos Ri−1 m + Si m = Ri−1 n + Si n. El siguiente teorema establece el hecho de que el error acumulado de exportación se iguala en cada instante de programación. TEOREMA 4.1. Cuando se calculan las instancias de horario para enviar Di a cualquier par de receptores m y n, se cumple la siguiente condición: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Prueba: Por inducción. Supongamos que la premisa se cumple para algún i. Mostramos que se cumple para i+1. El caso base para i = 1 se cumple ya que inicialmente R0 m = R0 n = 0, y se utiliza S1 m = S1 n para calcular las instancias de programación. Para calcular el horario de Di+1, primero calculamos los errores relativos como Ri m = Ai m − Si m y Ri n = Ai n − Si n. Luego, para calcular δs, ejecutamos Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n. Añadiendo la condición de la premisa en ambos lados obtenemos, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n. 4.3 Cálculo del Error de Exportación. Ahora consideremos cómo se pueden calcular los errores de exportación. De la sección anterior, para encontrar δ1 y δ2 necesitamos encontrar Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2). Se debe tener en cuenta que los valores de R0 1 y R0 2 ya son conocidos en el remitente. Considera el cálculo de Err(DR1, T1, T1 +δ1 +dt1). Esta es la integral de la distancia entre las trayectorias AC debido a DR1 y BD debido a DR0. A partir de DR0 y DR1, el punto A es (X1, Y1) = (x1, y1) y el punto B es (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0). La trayectoria AC puede ser representada como una función del tiempo como (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) y la trayectoria de BD puede ser representada como (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t). La distancia entre las dos trayectorias como función del tiempo se convierte entonces en, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Sea a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Entonces dist(t) se puede escribir como dist(t) = a × t2 + b × t + c. Luego Err(DR1, t1, t2) para algún intervalo de tiempo [t1, t2] se convierte en t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt. Una solución en forma cerrada para la integral indefinida a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) y Err(DR1, T1, T1 +δ2 +dt2) pueden entonces ser calculadas aplicando los límites apropiados a la solución anterior. En la siguiente sección, consideramos el cálculo de los δs para N receptores. 5 4.4 Cálculo de Instantes de Programación Volvemos a analizar el cálculo de los δs haciendo referencia a la Figura 2. El remitente elige δ1 y δ2 de manera que R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 + Err(DR1, T1, T1 + δ2 +dt2). Si R0 1 y R0 2 ambos son cero, entonces δ1 y δ2 deben ser elegidos de tal manera que Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2). Esta igualdad se mantendrá si δ1 + dt1 = δ2 + dt2. Por lo tanto, si no hay error acumulado relativo de exportación, todo lo que el remitente necesita hacer es elegir los δs de tal manera que contrarresten la diferencia en el retraso a los dos receptores, para que reciban el vector DR al mismo tiempo. Como se discutió anteriormente, dado que el remitente no puede aprender de antemano el retraso, siempre habrá un error relativo acumulado de exportación de un vector DR previo que debe tenerse en cuenta. Para profundizar en esto, considera el cálculo del error de exportación como se ilustra en la sección anterior. Para calcular los δs necesitamos que R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2). Es decir, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt. Eso es R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt. Los componentes R0 1, R0 2, ya son conocidos por (o estimados por) el remitente. Además, los componentes de error T1+dt1 T1 dist(t) dt y T1+dt2 T1 dist(t) dt pueden ser calculados a priori por el remitente utilizando valores estimados de dt1 y dt2. Usemos E1 para denotar R0 1 + T1+dt1 T1 dist(t) dt y E2 para denotar R0 2 + T1+dt2 T1 dist(t) dt. Entonces, requerimos que E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. Suponga que E1 > E2. Entonces, para que la ecuación anterior se cumpla, requerimos que T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt. Para hacer el juego lo más rápido posible dentro de este marco, los valores de δ deben ser lo más pequeños posible para que los vectores DR se envíen a los receptores lo antes posible, sujeto al requisito de equidad. Dado esto, elegiríamos δ1 como cero y calcularíamos δ2 a partir de la ecuación E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt. En general, si hay N receptores 1, . . . , N, cuando un emisor genera un vector DR y decide programarlos para ser enviados, primero calcula los valores de Ei para todos ellos a partir de los errores relativos acumulados en la exportación y las estimaciones de los retrasos. Luego, encuentra el valor más pequeño de estos valores. Que Ek sea el valor más pequeño. El remitente hace que δk sea cero y calcula el resto de los δs a partir de la igualdad Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) Los δs así obtenidos dan los instantes de programación del vector DR para los receptores. 4.5 Pasos del Algoritmo de Programación Para los fines de la discusión a continuación, como antes, vamos a denotar el error relativo acumulado en un remitente para el receptor k hasta DRi como Ri k. Vamos a denotar el retraso programado en el remitente antes de que DRi sea enviado al receptor k como δi k. Dada la discusión anterior, los pasos del algoritmo son los siguientes: 1. El remitente calcula DRi en el tiempo Ti y luego calcula δi k y Ri−1 k, ∀k, 1 ≤ k ≤ N basándose en la estimación de los retrasos dtk, ∀k, 1 ≤ k ≤ N según la Ecuación (1). Programa que DRi se envíe al receptor k en el tiempo Ti + δi k. 2. Los vectores DR se envían a los receptores en los horarios programados, los cuales se reciben después de un retraso de dak, ∀k, 1 ≤ k ≤ N donde dak ≤ o > dtk. Los receptores envían el valor de dak de vuelta al remitente (el receptor puede calcular este valor basándose en las marcas de tiempo en el vector DR como se describió anteriormente). 3. El remitente calcula Ri k como se describe anteriormente e ilustra en la Figura 2. El remitente también recalcula (utilizando un método de promedio exponencial similar a la estimación del tiempo de ida y vuelta por TCP [10]) la estimación del retraso dtk a partir del nuevo valor de dak para el receptor k. 4. Vuelve al Paso 1 para calcular DRi+1 cuando sea necesario y sigue los pasos del algoritmo para programar y enviar este vector DR a los receptores. 4.6 Manejo de Casos en la Práctica Hasta ahora asumimos implícitamente que DRi se envía a todos los receptores antes de tomar una decisión para calcular el siguiente vector DR DRi+1, y los receptores envían el valor de dak correspondiente a DRi y esta información llega al remitente antes de que calcule DRi+1 para que pueda calcular Ri+1 k y luego usarlo en el cálculo de δi+1 k. Dos cuestiones deben tenerse en cuenta con respecto al algoritmo anterior cuando se utiliza en la práctica. • Puede suceder que se calcule un nuevo vector DR incluso antes de que el vector DR anterior se envíe a todos los receptores. ¿Cómo se manejará esta situación? • ¿Qué sucede si la retroalimentación no llega antes de que se calcule y programe el envío de DRi+1? Consideremos el primer escenario. Suponemos que DRi ha sido programado para ser enviado y los instantes de programación son tales que δi 1 < δi 2 < · · · < δi N. Suponga que se va a calcular DRi+1 (porque la trayectoria real se ha desviado excediendo un umbral de la trayectoria exportada por DRi) en el tiempo Ti+1 donde Ti + δi k < Ti+1 < Ti + δi k+1. Esto significa que DRi ha sido enviado solo a receptores hasta k en el orden programado. En nuestro algoritmo, en este caso, se vacía la cola de ordenación de retrasos programados, lo que significa que DRi no se envía a los receptores que aún están en cola para recibirlo, pero se calcula un nuevo orden de programación para que todos los receptores envíen DRi+1. Para aquellos receptores a quienes se les ha enviado DRi, asumir por ahora que se ha recibido de todos los receptores daj, 1 ≤ j ≤ k (el escenario donde daj no ha sido recibido se considerará como parte del segundo escenario más tarde). Para estos receptores, Ei j, 1 ≤ j ≤ k se pueden calcular. Para aquellos receptores j, k + 1 ≤ j ≤ N a quienes no se les envió DRi, Ei j no aplica. Considera un receptor j, k + 1 ≤ j ≤ N a quien no se le envió DRi. Consulte la Figura 3. Para un receptor j dado, cuando se programa DRi+1 y se exporta la ruta dtj A B C D Ti-1 Gi j, DRi+1 calculado por el remitente y DRi para el receptor k+1 a N se eliminan de la cola. DRi+1 programado para el receptor k+1, Ti+1 G H E F, DRi programado para el receptor j, DRi calculado por el remitente, se coloca la ruta en el receptor k+1, Gi+1 j. Figura 3: Cálculo de programación cuando DRi no se envía al receptor j, k + 1 ≤ j ≤ N. Se necesita calcular δi+1 j, el error total de exportación es el error de exportación relativo acumulado en el tiempo Ti cuando se programó el DRi, más la integral de la distancia entre las dos trayectorias AC y BD de la Figura 3 en el intervalo de tiempo [Ti, Ti+1 + δi+1 j + dtj]. Ten en cuenta que esta integral está dada por Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj). Por lo tanto, en lugar de Ei j de la Ecuación (1), utilizamos el valor Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) donde Ri−1 j es el error relativo de exportación utilizado cuando se calculó el horario para DRi. Ahora considera el segundo escenario. Aquí el dak de retroalimentación correspondiente a DRi no ha llegado antes de que se calcule y programe DRi+1. En este caso, Ri k no se puede calcular. Por lo tanto, en el cálculo de δk para DRi+1, se asumirá que es cero. Suponemos que se utiliza un mecanismo confiable para enviar el dak de vuelta al remitente. Cuando esta información llegue en un momento posterior, Ri k se calculará y acumulará a los errores relativos de exportación futuros (por ejemplo, Ri+1 k si dak se recibe antes de que se calcule DRi+2) y se utilizará en el cálculo de δk cuando se programe un vector DR futuro (por ejemplo, DRi+2). 4.7 Resultados Experimentales Para evaluar la efectividad y cuantificar los beneficios obtenidos a través del uso del algoritmo de programación, implementamos el algoritmo propuesto en el juego BZFlag (Battle Zone Flag) [11]. Es un juego de disparos en primera persona donde los jugadores en equipos conducen tanques y se mueven dentro de un campo de batalla. El objetivo de los jugadores es navegar y capturar las banderas pertenecientes al otro equipo y llevarlas de vuelta a su propia área. Los jugadores disparan a los tanques de los demás usando balas de disparo. El movimiento de los tanques, así como el de los disparos, se intercambian entre los jugadores utilizando vectores DR. Hemos modificado la implementación de BZFlag para incorporar relojes sincronizados entre los jugadores y el servidor, y intercambiar marcas de tiempo con el vector DR. Establecimos un banco de pruebas con cuatro jugadores ejecutando la versión instrumentada de BZFlag, con uno como emisor y el resto como receptores. El enfoque de programación y el caso base en el que cada vector de DR se envió a todos los receptores simultáneamente en cada punto de activación se implementaron en la misma ejecución etiquetando los vectores de DR según el tipo de enfoque utilizado para enviar el vector de DR. NISTNet [12] se utilizó para introducir retrasos en el emisor y los tres receptores. Se introdujeron retrasos medios de 800 ms, 500 ms y 200 ms entre el emisor y el primer, segundo y tercer receptor, respectivamente. Introducimos una variación de 100 milisegundos (al retraso medio de cada receptor) para modelar la variabilidad en el retraso. El remitente registró los errores de cada receptor cada 100 milisegundos tanto para el enfoque de programación como para el caso base. El remitente también calculó la desviación estándar y la media del error de exportación acumulado de todos los receptores cada 100 milisegundos. La Figura 4 representa la media y la desviación estándar del error acumulado de exportación de todos los receptores en el caso de programación frente al caso base. Ten en cuenta que el eje x de estos gráficos (y de los demás gráficos que siguen) representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe que la desviación estándar del error con la programación es mucho menor en comparación con el caso base. Esto implica que los errores acumulados de los receptores en el caso de programación están más cerca unos de otros. Esto demuestra que el enfoque de programación logra equidad entre los receptores incluso si se encuentran a diferentes distancias (es decir, latencias) del emisor. Observe que la media del error acumulado aumentó varias veces con la programación en comparación con el caso base. La exploración adicional de la razón del aumento en la media llevó a la conclusión de que cada vez que los vectores de DR se programan de manera que igualen el error total, empuja el error total de cada receptor hacia arriba. Además, dado que el error acumulado tiene un componente estimado, el horario no es preciso para igualar los errores de los receptores, lo que provoca que el vector de DR llegue antes o después de la programación real. En cualquier caso, el error no se iguala y si el vector de DR llega tarde, en realidad aumenta el error para un receptor más allá del error acumulado más alto. Esto significa que en el próximo disparo, este receptor será el que tenga el error más alto y el error de todos los demás receptores se ajustará a este valor de error. Este efecto de cambio repentino conlleva un aumento en el error acumulado para todos los receptores. La programación para la equidad conduce a la disminución de la desviación estándar (es decir, aumenta la equidad entre los diferentes jugadores), pero esto conlleva un mayor error medio, lo cual puede no ser una característica deseable. Esto nos llevó a explorar diferentes formas de igualar los errores acumulados. El enfoque discutido en la siguiente sección es un enfoque heurístico basado en la siguiente idea. Utilizando la misma cantidad de vectores de DR a lo largo del tiempo que en el caso base, en lugar de enviar los vectores de DR a todos los receptores con la misma frecuencia que en el caso base, si podemos aumentar la frecuencia de envío de los vectores de DR al receptor con un error acumulado más alto y disminuir la frecuencia de envío de los vectores de DR al receptor con un error acumulado más bajo, podemos igualar el error de exportación de todos los receptores a lo largo del tiempo. Al mismo tiempo, deseamos disminuir el error del receptor con el error acumulado más alto en el caso base (por supuesto, este receptor recibiría más vectores DR que en el caso base). Nos referimos a dicho algoritmo como un algoritmo basado en presupuesto. ALGORITMO BASADO EN PRESUPUESTO En un juego, el remitente de una entidad envía vectores DR a todos los receptores cada vez que la entidad cruza un umbral. Al reducir el umbral, se generan más vectores de DR durante un período de tiempo dado. Dado que los vectores DR se envían a todos los receptores y el retraso de red entre los pares emisor-receptor no se puede evitar, el error antes de la exportación 3 con el jugador más distante siempre será 3. Tenga en cuenta que después de la exportación, el error se elimina mediante el uso de un reloj sincronizado entre los jugadores. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 Error acumulado promedio en segundos Algoritmo de programación del caso base #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 Desviación estándar del error acumulado en segundos Algoritmo de programación del caso base #1 Figura 4: Promedio y desviación estándar del error con programación y sin ella (es decir, caso base) serán más altos que el resto. Para mitigar el desequilibrio en el error, proponemos enviar vectores de DR selectivamente a diferentes jugadores basándonos en los errores acumulados de estos jugadores. El algoritmo basado en presupuesto se fundamenta en esta idea y existen dos variaciones de él. Uno es un esquema de presupuesto probabilístico y el otro, un esquema de presupuesto determinístico. 5.1 Esquema de presupuesto probabilístico El esquema de presupuesto probabilístico tiene tres pasos principales: a) reducir el umbral de navegación inercial pero al mismo tiempo mantener el número total de DR enviados igual que en el caso base, b) en cada disparador, elegir probabilísticamente a un jugador para enviarle el vector de DR, y c) enviar el vector de DR al jugador elegido. Estos pasos se describen a continuación. La reducción del umbral de DR se implementa de la siguiente manera. Reducir el umbral es equivalente a aumentar el número de puntos de activación donde se generan los vectores de DR. Supongamos que el umbral es tal que el número de disparadores causados por él en el caso base es t y en cada disparador se envían n vectores DR por el remitente, lo que resulta en un total de nt vectores DR. Nuestro objetivo es mantener el número total de vectores DR enviados por el remitente fijo en nt, pero reducir el número de vectores DR enviados en cada activación (es decir, no enviar el vector DR a todos los receptores). Que n y t sean el número de vectores DR enviados en cada disparo y el número de disparos respectivamente en el caso modificado. Queremos asegurarnos de que n t = nt. Dado que queremos aumentar el número de puntos de activación, es decir, t > t, esto significaría que n < n. Es decir, no todos los receptores recibirán el vector DR en cada activación. En el esquema de presupuesto probabilístico, en cada activación, se calcula una probabilidad para que cada receptor reciba un vector DR y solo un receptor recibe el DR (n = 1). Esta probabilidad se basa en los pesos relativos de los errores acumulados de los receptores. Es decir, un receptor con un error acumulado más alto tendrá una probabilidad más alta de recibir el vector DR. Ten en cuenta que el error acumulado para tres jugadores es a1, a2 y a3 respectivamente. Entonces, la probabilidad de que el jugador 1 reciba el vector DR sería a1 a1+a2+a3. Del mismo modo para los otros jugadores. Una vez que se elige al jugador, el vector DR se envía a ese jugador. Para comparar el algoritmo basado en presupuesto probabilístico con el caso base, necesitábamos reducir el umbral para el caso base (para una comparación justa). Dado que el umbral de cálculo de la posición muerta en el caso base ya era muy fino, se decidió que en lugar de reducir el umbral, se compararía el enfoque basado en el presupuesto probabilístico con un caso base modificado que utilizaría el umbral normal como algoritmo basado en el presupuesto, pero el caso base se modificó de tal manera que cada tercer disparador se usaría realmente para enviar un vector de cálculo de la posición muerta a los tres receptores utilizados en nuestros experimentos. Esto fue llamado como el caso base 1/3 ya que resultó en el envío de 1/3 del número de vectores DR en comparación con el caso base. El presupuesto por disparador para el enfoque basado en la probabilidad se calculó como un vector de DR en cada disparador en comparación con tres vectores de DR en cada tercer disparador en el caso base de 1/3; por lo tanto, los dos casos resultan en el mismo número de vectores de DR enviados con el tiempo. Para evaluar la efectividad del algoritmo de presupuesto probabilístico, instrumentamos el juego BZFlag para utilizar este enfoque. Utilizamos el mismo banco de pruebas que consistía en un emisor y tres receptores con retardos de 800ms, 500ms y 200ms desde el emisor y con baja varianza de retardo (100ms) y moderada varianza de retardo (180ms). Los resultados se muestran en las Figuras 5 y 6. Como se mencionó anteriormente, el eje x de estos gráficos representa el tiempo del sistema cuando se tomó la instantánea del juego. Observe de las figuras que la desviación estándar del error acumulado entre los receptores con el algoritmo basado en presupuesto probabilístico es menor que el caso base de 1/3 y la media es un poco más alta que el caso base de 1/3. Esto implica que el juego es más justo en comparación con el caso base de 1/3 a costa de aumentar ligeramente el error medio en comparación con el caso base de 1/3. El aumento en el error medio en el caso probabilístico en comparación con el caso base de 1/3 se puede atribuir al hecho de que, aunque en promedio el enfoque probabilístico envía el mismo número de vectores DR que el caso base de 1/3, a veces envía vectores DR a un receptor con menos frecuencia y a veces con más frecuencia que el caso base de 1/3 debido a su naturaleza probabilística. Cuando un receptor no recibe un vector DR durante mucho tiempo, la trayectoria del receptor se aleja cada vez más de la trayectoria del emisor y, por lo tanto, la tasa de acumulación del error en el receptor es mayor. En ocasiones, cuando un receptor recibe vectores de DR con más frecuencia, acumula errores a un ritmo más bajo, pero no hay forma de revertir el error acumulado cuando no recibió un vector de DR durante mucho tiempo. Esto lleva a que los receptores acumulen más error en el caso probabilístico en comparación con el caso base de 1/3 donde los receptores reciben un vector DR casi periódicamente. Para limitar el aumento en el error medio, decidimos modificar el algoritmo basado en presupuesto para que sea determinista. Los dos primeros pasos del algoritmo son los mismos que en el algoritmo probabilístico; los puntos de activación se incrementan para reducir el umbral y los errores acumulados se utilizan para calcular la probabilidad de que un receptor reciba un vector DR. Una vez que se completen estos pasos, se calcula un horario determinista para el receptor de la siguiente manera: 1. Si hay algún receptor etiquetado para recibir un vector DR en el disparador actual, el remitente envía el vector DR al(s) receptor(es) respectivo(s). Si al menos un receptor recibió un vector DR, el remitente calcula las probabilidades de que cada receptor reciba un vector DR como se explicó anteriormente y sigue los pasos del 2 al 6; de lo contrario, no hace nada. 2. Para cada receptor, el valor de probabilidad se multiplica por el presupuesto disponible en cada activador (que se establece en 1 como se explica a continuación) para dar la frecuencia de envío del vector DR a cada receptor. Si alguna de las frecuencias de los receptores, después de multiplicarse por el presupuesto, supera 1, la frecuencia del receptor se establece en 1 y la cantidad excedente se distribuye equitativamente entre todos los receptores sumando la cantidad a sus frecuencias existentes. Este proceso se repite hasta que todos los receptores tengan una frecuencia menor o igual a 1. Esto se debe a que en un disparador no podemos enviar más de un vector DR al receptor respectivo. Eso sería un desperdicio de vectores DR al enviar información redundante. 4. (1/frecuencia) nos da el horario en el que el remitente debe enviar vectores DR al receptor respectivo. El crédito obtenido previamente (explicado en el paso 5), si lo hubiera, se resta del horario. Observe que el valor resultante del horario podría no ser un número entero; por lo tanto, el valor se redondea hacia arriba tomando el techo del horario. Por ejemplo, si la frecuencia es de 1/3.5, esto implica que nos gustaría que se enviara un vector de DR cada 3.5 disparadores. Sin embargo, estamos obligados a enviarlo en el cuarto disparo, lo que nos otorga un crédito de 0.5. Cuando enviemos el vector DR la próxima vez, podremos enviarlo en el 3er disparo debido al crédito de 0.5. La diferencia entre el horario y el límite del horario es el crédito que el receptor ha obtenido, que se recuerda para el futuro y se utiliza en el próximo momento, como se explica en el paso 4. 6. Para cada uno de esos receptores a quienes se les envió un vector DR en el disparador actual, los receptores están etiquetados para recibir el próximo vector DR en el disparador que ocurre exactamente el número de veces programado (el techo del programa) lejos del disparador actual. Observe que en este punto no se modifica el horario de ningún otro receptor, ya que todos están ejecutando un horario calculado en algún punto anterior en el tiempo. Esos horarios se modificarán automáticamente en el disparador cuando estén programados para recibir el siguiente vector de DR. En el primer disparador, el remitente envía el vector DR a todos los receptores y utiliza una probabilidad relativa de 1/n para cada receptor y sigue los pasos 2 al 6 para calcular el próximo horario para cada receptor de la misma manera que se menciona para otros disparadores. Este algoritmo garantiza que cada receptor tenga un horario garantizado para recibir vectores DR y, por lo tanto, no haya irregularidades en el envío del vector DR a ningún receptor, como se observó en el algoritmo probabilístico basado en presupuesto. Utilizamos el banco de pruebas descrito anteriormente (tres receptores con retardos variables) para evaluar el algoritmo determinista utilizando el presupuesto de 1 vector DR por activación para así utilizar el mismo número de vectores DR que en el caso base 1/3. Los resultados de nuestros experimentos se muestran en las Figuras 5 y 6. Se puede observar que la desviación estándar del error en el algoritmo basado en presupuesto determinista es menor que el caso base de 1/3 y también tiene el mismo error medio que el caso base de 1/3. Esto indica que el algoritmo determinista es más justo que el caso base de 1/3 y al mismo tiempo no aumenta el error medio, lo que conduce a una mejor calidad de juego en comparación con el algoritmo probabilístico. En general, al comparar el enfoque determinista con el enfoque probabilístico, encontramos que el error acumulado promedio siempre fue menor en el enfoque determinista. Con respecto a la desviación estándar del error acumulado, encontramos que en los casos de varianza fija o baja, el enfoque determinista fue generalmente menor, pero en casos de mayor varianza, era más difícil sacar conclusiones ya que a veces el enfoque probabilístico era mejor que el determinista. CONCLUSIONES Y TRABAJO FUTURO En los juegos multijugador distribuidos que se juegan a través de Internet, los objetos y la trayectoria de los jugadores dentro del espacio de juego se intercambian en términos de vectores DR. Debido al retraso variable entre jugadores, estos vectores DR llegan a diferentes jugadores en momentos distintos. Existe una ventaja injusta obtenida por los receptores que están más cerca del remitente del DR, ya que pueden representar la posición del remitente de manera más precisa en tiempo real. En este documento, primero desarrollamos un modelo para estimar el error en la representación de las trayectorias de los jugadores en los receptores. Luego presentamos un algoritmo basado en programar los vectores de DR para ser enviados a diferentes jugadores en diferentes momentos, igualando así el error en los diferentes jugadores. Este algoritmo tiene como objetivo hacer que el juego sea justo para todos los jugadores, pero tiende a aumentar el error promedio de los jugadores. Para contrarrestar este efecto, presentamos algoritmos basados en presupuestos donde los vectores de DR aún se programan para ser enviados a diferentes jugadores en diferentes momentos, pero el algoritmo equilibra la necesidad de equidad con el requisito de que el error de los jugadores en el peor caso (que están más lejos del remitente) no se incremente en comparación con el caso base (donde todos los vectores de DR se envían a todos los jugadores cada vez que se genera un vector de DR). Presentamos dos variaciones de los algoritmos basados en el presupuesto y, a través de experimentación, demostramos que los algoritmos reducen la desviación estándar del error, haciendo así el juego más justo y al mismo tiempo manteniendo un error medio comparable al caso base. REFERENCIAS [1] S. Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee y S. Rangarajan, Precisión en juegos distribuidos multijugador basados en Dead-Reckoning, Actas del Taller ACM SIGCOMM 2004 sobre Soporte de Redes y Sistemas para Juegos (NetGames 2004), agosto de 2004. [2] L. Gautier y C. Diot, Diseño y Evaluación de MiMaze, un juego multijugador en Internet, en Actas de IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistencia en medios interactivos continuos replicados, en Actas de la Conferencia ACM sobre Trabajo Cooperativo Asistido por Computadora (CSCW00), 2000, pp. 181-190. [4] S.K. Singhal y D.R. Cheriton, Explotando el historial de posición para una representación remota eficiente en la realidad virtual en red, Presencia: Teleoperadores y Entornos Virtuales, vol. 4, núm. 2, pp. 169-193, 1995. [5] C. Diot y L. Gautier, Una arquitectura distribuida para aplicaciones interactivas multijugador en Internet, en la revista IEEE Network, 1999, vol. 13, pp. 6-15. [6] L. Pantel y L.C. Wolf, Sobre el impacto del retraso en los juegos multijugador en tiempo real, en Actas de ACM NOSSDAV02, mayo de 2002. [7] Y. Lin, K. Guo y S. Paul, Sync-MS: Servicio de mensajería sincronizada para juegos distribuidos multijugador en tiempo real, en Actas de la 10ª Conferencia Internacional de Protocolos de Red de IEEE (ICNP), noviembre de 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan y S. Paul, Un marco de intercambio de mensajes justo para juegos distribuidos multijugador, en Actas de NetGames2003, mayo de 2003. [9] N. E. Baughman y B. N. Levine, Reproducción a prueba de trampas para juegos en línea centralizados y distribuidos, en Actas de IEEE INFOCOM01, abril de 2001. [10] M. Allman y V. Paxson, Sobre la estimación de propiedades de la ruta de red de extremo a extremo, en Actas de ACM SIGCOMM99, septiembre de 1999. [11] Foro de BZFlag, Juego de BZFlag, URL: http://www.bzflag.org. [12] Instituto Nacional de Estándares y Tecnología, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. ",
            "candidates": [],
            "error": [
                [
                    "dead-reckoning",
                    "vector de navegación inercial",
                    "navegación inercial"
                ]
            ]
        },
        "clock synchronization": {
            "translated_key": "sincronización de relojes",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Fairness in Dead-Reckoning based Distributed Multi-Player Games Sudhir Aggarwal Hemant Banavar Department of Computer Science Florida State University, Tallahassee, FL Email: {sudhir, banavar}@cs.fsu.edu Sarit Mukherjee Sampath Rangarajan Center for Networking Research Bell Laboratories, Holmdel, NJ Email: {sarit, sampath}@bell-labs.com ABSTRACT In a distributed multi-player game that uses dead-reckoning vectors to exchange movement information among players, there is inaccuracy in rendering the objects at the receiver due to network delay between the sender and the receiver.",
                "The object is placed at the receiver at the position indicated by the dead-reckoning vector, but by that time, the real position could have changed considerably at the sender.",
                "This inaccuracy would be tolerable if it is consistent among all players; that is, at the same physical time, all players see inaccurate (with respect to the real position of the object) but the same position and trajectory for an object.",
                "But due to varying network delays between the sender and different receivers, the inaccuracy is different at different players as well.",
                "This leads to unfairness in game playing.",
                "In this paper, we first introduce an error measure for estimating this inaccuracy.",
                "Then we develop an algorithm for scheduling the sending of dead-reckoning vectors at a sender that strives to make this error equal at different receivers over time.",
                "This algorithm makes the game very fair at the expense of increasing the overall mean error of all players.",
                "To mitigate this effect, we propose a budget based algorithm that provides improved fairness without increasing the mean error thereby maintaining the accuracy of game playing.",
                "We have implemented both the scheduling algorithm and the budget based algorithm as part of BZFlag, a popular distributed multi-player game.",
                "We show through experiments that these algorithms provide fairness among players in spite of widely varying network delays.",
                "An additional property of the proposed algorithms is that they require less number of DRs to be exchanged (compared to the current implementation of BZflag) to achieve the same level of accuracy in game playing.",
                "Categories and Subject Descriptors C.2.4 [Computer-Communication Networks]: Distributed Systems-Distributed applications General Terms Algorithms, Design, Experimentation, Performance 1.",
                "INTRODUCTION In a distributed multi-player game, players are normally distributed across the Internet and have varying delays to each other or to a central game server.",
                "Usually, in such games, the players are part of the game and in addition they may control entities that make up the game.",
                "During the course of the game, the players and the entities move within the game space.",
                "A player sends information about her movement as well as the movement of the entities she controls to the other players using a Dead-Reckoning (DR) vector.",
                "A DR vector contains information about the current position of the player/entity in terms of x, y and z coordinates (at the time the DR vector was sent) as well as the trajectory of the entity in terms of the velocity component in each of the dimensions.",
                "Each of the participating players receives such DR vectors from one another and renders the other players/entities on the local consoles until a new DR vector is received for that player/entity.",
                "In a peer-to-peer game, players send DR vectors directly to each other; in a client-server game, these DR vectors may be forwarded through a game server.",
                "The idea of DR is used because it is almost impossible for players/entities to exchange their current positions at every time unit.",
                "DR vectors are quantization of the real trajectory (which we refer to as real path) at a player.",
                "Normally, a new DR vector is computed and sent whenever the real path deviates from the path extrapolated using the previous DR vector (say, in terms of distance in the x, y, z plane) by some amount specified by a threshold.",
                "We refer to the trajectory that can be computed using the sequence of DR vectors as the exported path.",
                "Therefore, at the sending player, there is a deviation between the real path and the exported path.",
                "The error due to this deviation can be removed if each movement of player/entity is communicated to the other players at every time unit; that is a DR vector is generated at every time unit thereby making the real and exported paths the same.",
                "Given that it is not feasible to satisfy this due to bandwidth limitations, this error is not of practical interest.",
                "Therefore, the receiving players can, at best, follow the exported path.",
                "Because of the network delay between the sending and receiving players, when a DR vector is received and rendered at a player, the original trajectory of the player/entity may have already changed.",
                "Thus, in physical time, there is a deviation at the receiving player between the exported path and the rendered trajectory (which we refer to as placed path).",
                "We refer to this error as the export error.",
                "Note that the export error, in turn, results in a deviation between the real and the placed paths.",
                "The export error manifests itself due to the deviation between the exported path at the sender and the placed path at the receiver (i) 1 before the DR vector is received at the receiver (referred to as the before export error, and (ii) after the DR vector is received at the receiver (referred to as the after export error).",
                "In an earlier paper [1], we showed that by synchronizing the clocks at all the players and by using a technique based on time-stamping messages that carry the DR vectors, we can guarantee that the after export error is made zero.",
                "That is, the placed and the exported paths match after the DR vector is received.",
                "We also showed that the before export error can never be eliminated since there is always a non-zero network delay, but can be significantly reduced using our technique [1].",
                "Henceforth we assume that the players use such a technique which results in unavoidable but small overall export error.",
                "In this paper we consider the problem of different and varying network delays between each sender-receiver pair of a DR vector, and consequently, the different and varying export errors at the receivers.",
                "Due to the difference in the export errors among the receivers, the same entity is rendered at different physical time at different receivers.",
                "This brings in unfairness in game playing.",
                "For instance a player with a large delay would always see an entity late in physical time compared to the other players and, therefore, her action on the entity would be delayed (in physical time) even if she reacted instantaneously after the entity was rendered.",
                "Our goal in this paper is to improve the fairness of these games in spite of the varying network delays by equalizing the export error at the players.",
                "We explore whether the time-average of the export errors (which is the cumulative export error over a period of time averaged over the time period) at all the players can be made the same by scheduling the sending of the DR vectors appropriately at the sender.",
                "We propose two algorithms to achieve this.",
                "Both the algorithms are based on delaying (or dropping) the sending of DR vectors to some players on a continuous basis to try and make the export error the same at all the players.",
                "At an abstract level, the algorithm delays sending DR vectors to players whose accumulated error so far in the game is smaller than others; this would mean that the export error due to this DR vector at these players will be larger than that of the other players, thereby making them the same.",
                "The goal is to make this error at least approximately equal at every DR vector with the deviation in the error becoming smaller as time progresses.",
                "The first algorithm (which we refer to as the scheduling algorithm) is based on estimating the delay between players and refining the sending of DR vectors by scheduling them to be sent to different players at different times at every DR generation point.",
                "Through an implementation of this algorithm using the open source game BZflag, we show that this algorithm makes the game very fair (we measure fairness in terms of the standard deviation of the error).",
                "The drawback of this algorithm is that it tends to push the error of all the players towards that of the player with the worst error (which is the error at the farthest player, in terms of delay, from the sender of the DR).",
                "To alleviate this effect, we propose a budget based algorithm which budgets how the DRs are sent to different players.",
                "At a high level, the algorithm is based on the idea of sending more DRs to players who are farther away from the sender compared to those who are closer.",
                "Experimental results from BZflag illustrates that the budget based algorithm follows a more balanced approach.",
                "It improves the fairness of the game but at the same time does so without pushing up the mean error of the players thereby maintaining the accuracy of the game.",
                "In addition, the budget based algorithm is shown to achieve the same level of accuracy of game playing as the current implementation of BZflag using much less number of DR vectors. 2.",
                "PREVIOUS WORK Earlier work on network games to deal with network latency has mostly focussed on compensation techniques for packet delay and loss [2, 3, 4].",
                "These methods are aimed at making large delays and message loss tolerable for players but does not consider the problems that may be introduced by varying delays from the server to different players or from the players to one another.",
                "For example, the concept of local lag has been used in [3] where each player delays every local operation for a certain amount of time so that remote players can receive information about the local operation and execute the same operation at the about same time, thus reducing state inconsistencies.",
                "The online multi-player game MiMaze [2, 5, 6], for example, takes a static bucket synchronization approach to compensate for variable network delays.",
                "In MiMaze, each player delays all events by 100 ms regardless of whether they are generated locally or remotely.",
                "Players with a network delay larger than 100 ms simply cannot participate in the game.",
                "In general, techniques based on bucket synchronization depend on imposing a worst case delay on all the players.",
                "There have been a few papers which have studied the problem of fairness in a distributed game by more sophisticated message delivery mechanisms.",
                "But these works [7, 8] assume the existence of a global view of the game where a game server maintains a view (or state) of the game.",
                "Players can introduce objects into the game or delete objects that are already part of the game (for example, in a first-person shooter game, by shooting down the object).",
                "These additions and deletions are communicated to the game server using action messages.",
                "Based on these action messages, the state of the game is changed at the game server and these changes are communicated to the players using update messages.",
                "Fairness is achieved by ordering the delivery of action and update messages at the game server and players respectively based on the notion of a fair-order which takes into account the delays between the game server and the different players.",
                "Objects that are part of the game may move but how this information is communicated to the players seems to be beyond the scope of these works.",
                "In this sense, these works are very limited in scope and may be applicable only to firstperson shooter games and that too to only games where players are not part of the game.",
                "DR vectors can be exchanged directly among the players (peerto-peer model) or using a central server as a relay (client-server model).",
                "It has been shown in [9] that multi-player games that use DR vectors together with bucket synchronization are not cheatproof unless additional mechanisms are put in place.",
                "Both the scheduling algorithm and the budget-based algorithm described in our paper use DR vectors and hence are not cheat-proof.",
                "For example, a receiver could skew the delay estimate at the sender to make the sender believe that the delay between the sender and the receiver is high thereby gaining undue advantage.",
                "We emphasize that the focus of this paper is on fairness without addressing the issue of cheating.",
                "In the next section, we describe the game model that we use and illustrate how senders and receivers exchange DR vectors and how entities are rendered at the receivers based on the time-stamp augmented DR vector exchange as described in [1].",
                "In Section 4, we describe the DR vector scheduling algorithm that aims to make the export error equal across the players with varying delays from the sender of a DR vector, followed by experimental results obtained from instrumentation of the scheduling algorithm on the open source game BZFlag.",
                "Section 5, describes the budget based algorithm that achieves improved fairness but without reducing the level accuracy of game playing.",
                "Conclusions are presented in Section 6. 2 3.",
                "GAME MODEL The game architecture is based on players distributed across the Internet and exchanging DR vectors to each other.",
                "The DR vectors could either be sent directly from one player to another (peerto-peer model) or could be sent through a game server which receives the DR vector from a player and forwards it to other players (client-server model).",
                "As mentioned before, we assume synchronized clocks among the participating players.",
                "Each DR vector sent from one player to another specifies the trajectory of exactly one player/entity.",
                "We assume a linear DR vector in that the information contained in the DR vector is only enough at the receiving player to compute the trajectory and render the entity in a straight line path.",
                "Such a DR vector contains information about the starting position and velocity of the player/entity where the velocity is constant1 .",
                "Thus, the DR vectors sent by a player specifies the current time at the player when the DR vector is computed (not the time at which this DR vector is sent to the other players as we will explain later), the current position of the player/entity in terms of the x, y, z coordinates and the velocity vector in the direction of x, y and z coordinates.",
                "Specifically, the ith DR vector sent by player j about the kth entity is denoted by DRj ik and is represented by the following tuple (Tj ik, xj ik, yj ik, zj ik, vxj ik, vyj ik, vzj ik).",
                "Without loss of generality, in the rest of the discussion, we consider a sequence of DR vectors sent by only one player and for only one entity.",
                "For simplicity, we consider a two dimensional game space rather than a three dimensional one.",
                "Hence we use DRi to denote the ith such DR vector represented as the tuple (Ti, xi, yi, vxi, vyi).",
                "The receiving player computes the starting position for the entity based on xi, yi and the time difference between when the DR vector is received and the time Ti at which it was computed.",
                "Note that the computation of time difference is feasible since all the clocks are synchronized.",
                "The receiving player then uses the velocity components to project and render the trajectory of the entity.",
                "This trajectory is followed until a new DR vector is received which changes the position and/or velocity of the entity. timeT1 Real Exported Placed dt1 A B C D DR1 = (T1, x1, y1, vx1, vy1) computed at time T1 and sent to the receiver DR0 = (T0, x0, y0, vx0, vy0) computed at time T0 and sent to the receiver T0 dt0 Placed E Figure 1: Trajectories and deviations.",
                "Based on this model, Figure 1 illustrates the sending and receiv1 Other type of DR vectors include quadratic DR vectors which specify the acceleration of the entity and cubic spline DR vectors that consider the starting position and velocity and the ending position and velocity of the entity. ing of DR vectors and the different errors that are encountered.",
                "The figure shows the reception of DR vectors at a player (henceforth called the receiver).",
                "The horizontal axis shows the time which is synchronized among all the players.",
                "The vertical axis tries to conceptually capture the two-dimensional position of an entity.",
                "Assume that at time T0 a DR vector DR0 is computed by the sender and immediately sent to the receiver.",
                "Assume that DR0 is received at the receiver after a delay of dt0 time units.",
                "The receiver computes the initial position of the entity as (x0 + vx0 × dt0, y0 + vy0 × dt0) (shown as point E).",
                "The thick line EBD represents the projected and rendered trajectory at the receiver based on the velocity components vx0 and vy0 (placed path).",
                "At time T1 a DR vector DR1 is computed for the same entity and immediately sent to the receiver2 .",
                "Assume that DR1 is received at the receiver after a delay of dt1 time units.",
                "When this DR vector is received, assume that the entity is at point D. A new position for the entity is computed as (x1 + vx1 × dt1, y1 + vy0 × dt1) and the entity is moved to this position (point C).",
                "The velocity components vx1 and vy1 are used to project and render this entity further.",
                "Let us now consider the error due to network delay.",
                "Although DR1 was computed at time T1 and sent to the receiver, it did not reach the receiver until time T1 + dt1.",
                "This means, although the exported path based on DR1 at the sender at time T1 is the trajectory AC, until time T1 + dt1, at the receiver, this entity was being rendered at trajectory BD based on DR0.",
                "Only at time T1 + dt1 did the entity get moved to point C from which point onwards the exported and the placed paths are the same.",
                "The deviation between the exported and placed paths creates an error component which we refer to as the export error.",
                "A way to represent the export error is to compute the integral of the distance between the two trajectories over the time when they are out of sync.",
                "We represent the integral of the distances between the placed and exported paths due to some DR DRi over a time interval [t1, t2] as Err(DRi, t1, t2).",
                "In the figure, the export error due to DR1 is computed as the integral of the distance between the trajectories AC and BD over the time interval [T1, T1 + dt1].",
                "Note that there could be other ways of representing this error as well, but in this paper, we use the integral of the distance between the two trajectories as a measure of the export error.",
                "Note that there would have been an export error created due to the reception of DR0 at which time the placed path would have been based on a previous DR vector.",
                "This is not shown in the figure but it serves to remind the reader that the export error is cumulative when a sequence of DR vectors are received.",
                "Starting from time T1 onwards, there is a deviation between the real and the exported paths.",
                "As we discussed earlier, this export error is unavoidable.",
                "The above figure and example illustrates one receiver only.",
                "But in reality, DR vectors DR0 and DR1 are sent by the sender to all the participating players.",
                "Each of these players receives DR0 and DR1 after varying delays thereby creating different export error values at different players.",
                "The goal of the DR vector scheduling algorithm to be described in the next section is to make this (cumulative) export error equal at every player independently for each of the entities that make up the game. 4.",
                "SCHEDULING ALGORITHM FORSENDING DR VECTORS In Section 3 we showed how delay from the sender of a new DR 2 Normally, DR vectors are not computed on a periodic basis but on an on-demand basis where the decision to compute a new DR vector is based on some threshold being exceeded on the deviation between the real path and the path exported by the previous DR vector. 3 vector to the receiver of the DR vector could lead to export error because of the deviation of the placed path from the exported path at the receiver until this new DR vector is received.",
                "We also mentioned that the goal of the DR vector scheduling algorithm is to make the export error equal at all receivers over a period of time.",
                "Since the game is played in a distributed environment, it makes sense for the sender of an entity to keep track of all the errors at the receivers and try to make them equal.",
                "However, the sender cannot know the actual error at a receiver till it gets some information regarding the error back from the receiver.",
                "Our algorithm estimates the error to compute a schedule to send DR vectors to the receivers and corrects the error when it gets feedbacks from the receivers.",
                "In this section we provide motivations for the algorithm and describe the steps it goes through.",
                "Throughout this section, we will use the following example to illustrate the algorithm. timeT1 Exported path Placed path at receiver 2 dt1 A B C D E F T0 G2 G1 dt2 DR1 sent to receiver 1 DR1 sent to receiver 2 T1 1 T1 2 da1 da2 G H I J K L N M DR1 estimated to be received by receiver 2 DR1 estimated to be received by receiver 1 DR1 actually received by receiver 1 DR1 actually received by receiver 2 DR0 sent to both receivers DR1 computed by sender Placed path at receiver 1 Figure 2: DR vector flow between a sender and two receivers and the evolution of estimated and actual placed paths at the receivers.",
                "DR0 = (T0, T0, x0, y0, vx0, vy0), sent at time T0 to both receivers.",
                "DR1 = (T1, T1 1 , x1, y1, vx1, vy1) sent at time T1 1 = T1+δ1 to receiver 1 and DR1 = (T1, T2 1 , x1, y1, vx1, vy1) sent at time T2 1 = T1 + δ2 to receiver 2.",
                "Consider the example in Figure 2.",
                "The figure shows a single sender sending DR vectors for an entity to two different receivers 1 and 2.",
                "DR0 computed at T0 is sent and received by the receivers sometime between T0 and T1 at which time they move the location of the entity to match the exported path.",
                "Thus, the path of the entity is shown only from the point where the placed path matches the exported path for DR0.",
                "Now consider DR1.",
                "At time T1, DR1 is computed by the sender but assume that it is not immediately sent to the receivers and is only sent after time δ1 to receiver 1 (at time T1 1 = T1 + δ1) and after time δ2 to receiver 2 (at time T2 1 = T1 + δ2).",
                "Note that the sender includes the sending timestamp with the DR vector as shown in the figure.",
                "Assume that the sender estimates (it will be clear shortly why the sender has to estimate the delay) that after a delay of dt1, receiver 1 will receive it, will use the coordinate and velocity parameters to compute the entitys current location and move it there (point C) and from this time onwards, the exported and the placed paths will become the same.",
                "However, in reality, receiver 1 receives DR1 after a delay of da1 (which is less than senders estimates of dt1), and moves the corresponding entity to point H. Similarly, the sender estimates that after a delay of dt2, receiver 2 will receive DR1, will compute the current location of the entity and move it to that point (point E), while in reality it receives DR1 after a delay of da2 > dt2 and moves the entity to point N. The other points shown on the placed and exported paths will be used later in the discussion to describe different error components. 4.1 Computation of Relative Export Error Referring back to the discussion from Section 3, from the senders perspective, the export error at receiver 1 due to DR1 is given by Err(DR1, T1, T1 + δ1 + dt1) (the integral of the distance between the trajectories AC and DB over the time interval [T1, T1 + δ1 + dt1]) of Figure 2.",
                "This is due to the fact that the sender uses the estimated delay dt1 to compute this error.",
                "Similarly, the export error from the senders perspective at received 2 due to DR1 is given by Err(DR1, T1, T1 + δ2 + dt2) (the integral of the distance between the trajectories AE and DF over the time interval [T1, T1 + δ2 + dt2]).",
                "Note that the above errors from the senders perspective are only estimates.",
                "In reality, the export error will be either smaller or larger than the estimated value, based on whether the delay estimate was larger or smaller than the actual delay that DR1 experienced.",
                "This difference between the estimated and the actual export error is the relative export error (which could either be positive or negative) which occurs for every DR vector that is sent and is accumulated at the sender.",
                "The concept of relative export error is illustrated in Figure 2.",
                "Since the actual delay to receiver 1 is da1, the export error induced by DR1 at receiver 1 is Err(DR1, T1, T1 + δ1 + da1).",
                "This means, there is an error in the estimated export error and the sender can compute this error only after it gets a feedback from the receiver about the actual delay for the delivery of DR1, i.e., the value of da1.",
                "We propose that once receiver 1 receives DR1, it sends the value of da1 back to the sender.",
                "The receiver can compute this information as it knows the time at which DR1 was sent (T1 1 = T1 + δ1, which is appended to the DR vector as shown in Figure 2) and the local receiving time (which is synchronized with the senders clock).",
                "Therefore, the sender computes the relative export error for receiver 1, represented using R1 as R1 = Err(DR1, T1, T1 + δ1 + dt1) − Err(DR1, T1, T1 + δ1 + da1) = Err(DR1, T1 + δ1 + dt1, T1 + δ1 + da1) Similarly the relative export error for receiver 2 is computed as R2 = Err(DR1, T1, T1 + δ2 + dt2) − Err(DR1, T1, T1 + δ2 + da2) = Err(DR1, T1 + δ2 + dt2, T1 + δ2 + da2) Note that R1 > 0 as da1 < dt1, and R2 < 0 as da2 > dt2.",
                "Relative export errors are computed by the sender as and when it receives the feedback from the receivers.",
                "This example shows the 4 relative export error values after DR1 is sent and the corresponding feedbacks are received. 4.2 Equalization of Error Among Receivers We now explain what we mean by making the errors equal at all the receivers and how this can be achieved.",
                "As stated before the sender keeps estimates of the delays to the receivers, dt1 and dt2 in the example of Figure 2.",
                "This says that at time T1 when DR1 is computed, the sender already knows how long it may take messages carrying this DR vector to reach the receivers.",
                "The sender uses this information to compute the export errors, which are Err(DR1, T1, T1 + δ1 + dt1) and Err(DR1, T1, T1 + δ2 + dt2) for receivers 1 and 2, respectively.",
                "Note that the areas of these error components are a function of δ1 and δ2 as well as the network delays dt1 and dt2.",
                "If we are to make the exports errors due to DR1 the same at both receivers, the sender needs to choose δ1 and δ2 such that Err(DR1, T1, T1 + δ1 + dt1) = Err(DR1, T1, T1 + δ2 + dt2).",
                "But when T1 was computed there could already have been accumulated relative export errors due to previous DR vectors (DR0 and the ones before).",
                "Let us represent the accumulated relative error up to DRi for receiver j as Ri j.",
                "To accommodate these accumulated relative errors, the sender should now choose δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2) The δi determines the scheduling instant of the DR vector at the sender for receiver i.",
                "This method of computation of δs ensures that the accumulated export error (i.e., total actual error) for each receiver equalizes at the transmission of each DR vector.",
                "In order to establish this, assume that the feedback for DR vector Di from a receiver comes to the sender before schedule for Di+1 is computed.",
                "Let Si m and Ai m denote the estimated error for receiver m used for computing schedule for Di and accumulated error for receiver m computed after receiving feedback for Di, respectively.",
                "Then Ri m = Ai m −Si m. In order to compute the schedule instances (i.e., δs) for Di, for any pair of receivers m and n, we do Ri−1 m + Si m = Ri−1 n + Si n. The following theorem establishes the fact that the accumulated export error is equalized at every scheduling instant.",
                "THEOREM 4.1.",
                "When the schedule instances for sending Di are computed for any pair of receivers m and n, the following condition is satisfied: i−1 k=1 Ak m + Si m = i−1 k=1 Ak n + Si n. Proof: By induction.",
                "Assume that the premise holds for some i.",
                "We show that it holds for i+1.",
                "The base case for i = 1 holds since initially R0 m = R0 n = 0, and the S1 m = S1 n is used to compute the scheduling instances.",
                "In order to compute the schedule for Di+1, the we first compute the relative errors as Ri m = Ai m − Si m, and Ri n = Ai n − Si n. Then to compute δs we execute Ri m + Si+1 m = Ri n + Si+1 n Ai m − Si m + Si+1 m = Ai n − Si n + Si+1 n .",
                "Adding the condition of the premise on both sides we get, i k=1 Ak m + Si+1 m = i k=1 Ak n + Si+1 n . 4.3 Computation of the Export Error Let us now consider how the export errors can be computed.",
                "From the previous section, to find δ1 and δ2 we need to find Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2).",
                "Note that the values of R0 1 and R0 2 are already known at the sender.",
                "Consider the computation of Err(DR1, T1, T1 +δ1 +dt1).",
                "This is the integral of the distance between the trajectories AC due to DR1 and BD due to DR0.",
                "From DR0 and DR1, point A is (X1, Y1) = (x1, y1) and point B is (X0, Y0) = (x0 + (T1 − T0) × vx0, y0 + (T1 − T0) × vy0).",
                "The trajectory AC can be represented as a function of time as (X1(t), Y1(t) = (X1 + vx1 × t, Y1 + vy1 × t) and the trajectory of BD can be represented as (X0(t), Y0(t) = (X0 + vx0 × t, Y0 + vy0 × t).",
                "The distance between the two trajectories as a function of time then becomes, dist(t) = (X1(t) − X0(t))2 + (Y1(t) − Y0(t))2 = ((X1 − X0) + (vx1 − vx0)t)2 +((Y1 − Y0) + (vy1 − vy0)t)2 = ((vx1 − vx0)2 + (vy1 − vy0)2)t2 +2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0))t +(X1 − X0)2 + (Y1 − Y0)2 Let a = (vx1 − vx0)2 + (vy1 − vy0)2 b = 2((X1 − X0)(vx1 − vx0) +(Y1 − Y0)(vy1 − vy0)) c = (X1 − X0)2 + (Y1 − Y0)2 Then dist(t) can be written as dist(t) = a × t2 + b × t + c. Then Err(DR1, t1, t2) for some time interval [t1, t2] becomes t2 t1 dist(t) dt = t2 t1 a × t2 + b × t + c dt.",
                "A closed form solution for the indefinite integral a × t2 + b × t + c dt = (2at + b) √ at2 + bt + c 4a + 1 2 ln 1 2b + at √ a + at2 + bt + c c 1 √ a − 1 8 ln 1 2b + at √ a + at2 + bt + c b2 a− 3 2 Err(DR1, T1, T1 +δ1 +dt1) and Err(DR1, T1, T1 +δ2 +dt2) can then be calculated by applying the appropriate limits to the above solution.",
                "In the next section, we consider the computation of the δs for N receivers. 5 4.4 Computation of Scheduling Instants We again look at the computation of δs by referring to Figure 2.",
                "The sender chooses δ1 and δ2 such that R0 1 + Err(DR1, T1, T1 + δ1 +dt1) = R0 2 +Err(DR1, T1, T1 +δ2 +dt2).",
                "If R0 1 and R0 2 both are zero, then δ1 and δ2 should be chosen such that Err(DR1, T1, T1+ δ1 +dt1) = Err(DR1, T1, T1 +δ2 +dt2).",
                "This equality will hold if δ1 + dt1 = δ2 + dt2.",
                "Thus, if there is no accumulated relative export error, all that the sender needs to do is to choose the δs in such a way that they counteract the difference in the delay to the two receivers, so that they receive the DR vector at the same time.",
                "As discussed earlier, because the sender is not able to a priori learn the delay, there will always be an accumulated relative export error from a previous DR vector that does have to be taken into account.",
                "To delve deeper into this, consider the computation of the export error as illustrated in the previous section.",
                "To compute the δs we require that R0 1 + Err(DR1, T1, T1 + δ1 + dt1) = R0 2 + Err(DR1, T1, T1 + δ2 + dt2).",
                "That is, R0 1 + T1+δ1+dt1 T1 dist(t) dt = R0 2 + T1+δ2+dt2 T1 dist(t) dt.",
                "That is R0 1 + T1+dt1 T1 dist(t) dt + T1+dt1+δ1 T1+dt1 dist(t) dt = R0 2 + T1+dt2 T1 dist(t) dt + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "The components R0 1, R0 2, are already known to (or estimated by) the sender.",
                "Further, the error components T1+dt1 T1 dist(t) dt and T1+dt2 T1 dist(t) dt can be a priori computed by the sender using estimated values of dt1 and dt2.",
                "Let us use E1 to denote R0 1 + T1+dt1 T1 dist(t) dt and E2 to denote R0 2 + T1+dt2 T1 dist(t) dt.",
                "Then, we require that E1 + T1+dt1+δ1 T1+dt1 dist(t) dt = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "Assume that E1 > E2.",
                "Then, for the above equation to hold, we require that T1+dt1+δ1 T1+dt1 dist(t) dt < T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "To make the game as fast as possible within this framework, the δ values should be made as small as possible so that DR vectors are sent to the receivers as soon as possible subject to the fairness requirement.",
                "Given this, we would choose δ1 to be zero and compute δ2 from the equation E1 = E2 + T1+dt2+δ2 T1+dt2 dist(t) dt.",
                "In general, if there are N receivers 1, . . . , N, when a sender generates a DR vector and decides to schedule them to be sent, it first computes the Ei values for all of them from the accumulated relative export errors and estimates of delays.",
                "Then, it finds the smallest of these values.",
                "Let Ek be the smallest value.",
                "The sender makes δk to be zero and computes the rest of the δs from the equality Ei + T1+dti+δi T1+dti dist(t) dt = Ek, ∀i 1 ≤ i ≤ N, i = k. (1) The δs thus obtained gives the scheduling instants of the DR vector for the receivers. 4.5 Steps of the Scheduling Algorithm For the purpose of the discussion below, as before let us denote the accumulated relative export error at a sender for receiver k up until DRi to be Ri k. Let us denote the scheduled delay at the sender before DRi is sent to receiver k as δi k. Given the above discussion, the algorithm steps are as follows: 1.",
                "The sender computes DRi at (say) time Ti and then computes δi k, and Ri−1 k , ∀k, 1 ≤ k ≤ N based on the estimation of delays dtk, ∀k, 1 ≤ k ≤ N as per Equation (1).",
                "It schedules, DRi to be sent to receiver k at time Ti + δi k. 2.",
                "The DR vectors are sent to the receivers at the scheduled times which are received after a delay of dak, ∀k, 1 ≤ k ≤ N where dak ≤ or > dtk.",
                "The receivers send the value of dak back to the sender (the receiver can compute this value based on the time stamps on the DR vector as described earlier). 3.",
                "The sender computes Ri k as described earlier and illustrated in Figure 2.",
                "The sender also recomputes (using exponential averaging method similar to round-trip time estimation by TCP [10]) the estimate of delay dtk from the new value of dak for receiver k. 4.",
                "Go back to Step 1 to compute DRi+1 when it is required and follow the steps of the algorithm to schedule and send this DR vector to the receivers. 4.6 Handling Cases in Practice So far we implicity assumed that DRi is sent out to all receivers before a decision is made to compute the next DR vector DRi+1, and the receivers send the value of dak corresponding to DRi and this information reaches the sender before it computes DRi+1 so that it can compute Ri+1 k and then use it in the computation of δi+1 k .",
                "Two issues need consideration with respect to the above algorithm when it is used in practice. • It may so happen that a new DR vector is computed even before the previous DR vector is sent out to all receivers.",
                "How will this situation be handled? • What happens if the feedback does not arrive before DRi+1 is computed and scheduled to be sent?",
                "Let us consider the first scenario.",
                "We assume that DRi has been scheduled to be sent and the scheduling instants are such that δi 1 < δi 2 < · · · < δi N .",
                "Assume that DRi+1 is to be computed (because the real path has deviated exceeding a threshold from the path exported by DRi) at time Ti+1 where Ti + δi k < Ti+1 < Ti + δi k+1.",
                "This means, DRi has been sent only to receivers up to k in the scheduled order.",
                "In our algorithm, in this case, the scheduled delay ordering queue is flushed which means DRi is not sent to receivers still queued to receive it, but a new scheduling order is computed for all the receivers to send DRi+1.",
                "For those receivers who have been sent DRi, assume for now that daj, 1 ≤ j ≤ k has been received from all receivers (the scenario where daj has not been received will be considered as a part of the second scenario later).",
                "For these receivers, Ei j, 1 ≤ j ≤ k can be computed.",
                "For those receivers j, k + 1 ≤ j ≤ N to whom DRi was not sent Ei j does not apply.",
                "Consider a receiver j, k + 1 ≤ j ≤ N to whom DRi was not sent.",
                "Refer to Figure 3.",
                "For such a receiver j, when DRi+1 is to be scheduled and 6 timeTi Exported path dtj A B C D Ti-1 Gi j DRi+1 computed by sender and DRi for receiver k+1 to N is removed from queue DRi+1 scheduled for receiver k+1 Ti+1 G H E F DRi scheduled for receiver j DRi computed by sender Placed path at receiver k+1 Gi+1 j Figure 3: Schedule computation when DRi is not sent to receiver j, k + 1 ≤ j ≤ N. δi+1 j needs to be computed, the total export error is the accumulated relative export error at time Ti when schedule for DRi was computed, plus the integral of the distance between the two trajectories AC and BD of Figure 3 over the time interval [Ti, Ti+1 + δi+1 j + dtj].",
                "Note that this integral is given by Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj).",
                "Therefore, instead of Ei j of Equation (1), we use the value Ri−1 j + Err(DRi, Ti, Ti+1) + Err(DRi+1, Ti+1, Ti+1 + δi+1 j + dtj) where Ri−1 j is relative export error used when the schedule for DRi was computed.",
                "Now consider the second scenario.",
                "Here the feedback dak corresponding to DRi has not arrived before DRi+1 is computed and scheduled.",
                "In this case, Ri k cannot be computed.",
                "Thus, in the computation of δk for DRi+1, this will be assumed to be zero.",
                "We do assume that a reliable mechanism is used to send dak back to the sender.",
                "When this information arrives at a later time, Ri k will be computed and accumulated to future relative export errors (for example Ri+1 k if dak is received before DRi+2 is computed) and used in the computation of δk when a future DR vector is to be scheduled (for example DRi+2). 4.7 Experimental Results In order to evaluate the effectiveness and quantify benefits obtained through the use of the scheduling algorithm, we implemented the proposed algorithm in BZFlag (Battle Zone Flag) [11] game.",
                "It is a first-person shooter game where the players in teams drive tanks and move within a battle field.",
                "The aim of the players is to navigate and capture flags belonging to the other team and bring them back to their own area.",
                "The players shoot each others tanks using shooting bullets.",
                "The movement of the tanks as well as that of the shots are exchanged among the players using DR vectors.",
                "We have modified the implementation of BZFlag to incorporate synchronized clocks among the players and the server and exchange time-stamps with the DR vector.",
                "We set up a testbed with four players running the instrumented version of BZFlag, with one as a sender and the rest as receivers.",
                "The scheduling approach and the base case where each DR vector was sent to all the receivers concurrently at every trigger point were implemented in the same run by tagging the DR vectors according to the type of approach used to send the DR vector.",
                "NISTNet [12] was used to introduce delays across the sender and the three receivers.",
                "Mean delays of 800ms, 500ms and 200ms were introduced between the sender and first, second and the third receiver, respectively.",
                "We introduce a variance of 100 msec (to the mean delay of each receiver) to model variability in delay.",
                "The sender logged the errors of each receiver every 100 milliseconds for both the scheduling approach and the base case.",
                "The sender also calculated the standard deviation and the mean of the accumulated export error of all the receivers every 100 milliseconds.",
                "Figure 4 plots the mean and standard deviation of the accumulated export error of all the receivers in the scheduling case against the base case.",
                "Note that the x-axis of these graphs (and the other graphs that follow) represents the system time when the snapshot of the game was taken.",
                "Observe that the standard deviation of the error with scheduling is much lower as compared to the base case.",
                "This implies that the accumulated errors of the receivers in the scheduling case are closer to one another.",
                "This shows that the scheduling approach achieves fairness among the receivers even if they are at different distances (i.e, latencies) from the sender.",
                "Observe that the mean of the accumulated error increased multifold with scheduling in comparison to the base case.",
                "Further exploration for the reason for the rise in the mean led to the conclusion that every time the DR vectors are scheduled in a way to equalize the total error, it pushes each receivers total error higher.",
                "Also, as the accumulated error has an estimated component, the schedule is not accurate to equalize the errors for the receivers, leading to the DR vector reaching earlier or later than the actual schedule.",
                "In either case, the error is not equalized and if the DR vector reaches late, it actually increases the error for a receiver beyond the highest accumulated error.",
                "This means that at the next trigger, this receiver will be the one with highest error and every other receivers error will be pushed to this error value.",
                "This flip-flop effect leads to the increase in the accumulated error for all the receivers.",
                "The scheduling for fairness leads to the decrease in standard deviation (i.e., increases the fairness among different players), but it comes at the cost of higher mean error, which may not be a desirable feature.",
                "This led us to explore different ways of equalizing the accumulated errors.",
                "The approach discussed in the following section is a heuristic approach based on the following idea.",
                "Using the same amount of DR vectors over time as in the base case, instead of sending the DR vectors to all the receivers at the same frequency as in the base case, if we can increase the frequency of sending the DR vectors to the receiver with higher accumulated error and decrease the frequency of sending DR vectors to the receiver with lower accumulated error, we can equalize the export error of all receivers over time.",
                "At the same time we wish to decrease the error of the receiver with the highest accumulated error in the base case (of course, this receiver would be sent more DR vectors than in the base case).",
                "We refer to such an algorithm as a budget based algorithm. 5.",
                "BUDGET BASED ALGORITHM In a game, the sender of an entity sends DR vectors to all the receivers every time a threshold is crossed by the entity.",
                "Lower the threshold, more DR vectors are generated during a given time period.",
                "Since the DR vectors are sent to all the receivers and the network delay between the sender-receiver pairs cannot be avoided, the before export error 3 with the most distant player will always 3 Note that after export error is eliminated by using synchronized clock among the players. 7 0 1000 2000 3000 4000 5000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds Base Case Scheduling Algorithm #1 Figure 4: Mean and standard deviation of error with scheduling and without (i.e., base case). be higher than the rest.",
                "In order to mitigate the imbalance in the error, we propose to send DR vectors selectively to different players based on the accumulated errors of these players.",
                "The budget based algorithm is based on this idea and there are two variations of it.",
                "One is a probabilistic budget based scheme and the other, a deterministic budget base scheme. 5.1 Probabilistic budget based scheme The probabilistic budget based scheme has three main steps: a) lower the dead reckoning threshold but at the same time keep the total number of DRs sent the same as the base case, b) at every trigger, probabilistically pick a player to send the DR vector to, and c) send the DR vector to the chosen player.",
                "These steps are described below.",
                "The lowering of DR threshold is implemented as follows.",
                "Lowering the threshold is equivalent to increasing the number of trigger points where DR vectors are generated.",
                "Suppose the threshold is such that the number of triggers caused by it in the base case is t and at each trigger n DR vectors sent by the sender, which results in a total of nt DR vectors.",
                "Our goal is to keep the total number of DR vectors sent by the sender fixed at nt, but lower the number of DR vectors sent at each trigger (i.e., do not send the DR vector to all the receivers).",
                "Let n and t be the number of DR vectors sent at each trigger and number of triggers respectively in the modified case.",
                "We want to ensure n t = nt.",
                "Since we want to increase the number of trigger points, i.e, t > t, this would mean that n < n. That is, not all receivers will be sent the DR vector at every trigger.",
                "In the probabilistic budget based scheme, at each trigger, a probability is calculated for each receiver to be sent a DR vector and only one receiver is sent the DR (n = 1).",
                "This probability is based on the relative weights of the receivers accumulated errors.",
                "That is, a receiver with a higher accumulated error will have a higher probability of being sent the DR vector.",
                "Consider that the accumulated error for three players are a1, a2 and a3 respectively.",
                "Then the probability of player 1 receiving the DR vector would be a1 a1+a2+a3 .",
                "Similarly for the other players.",
                "Once the player is picked, the DR vector is sent to that player.",
                "To compare the probabilistic budget based algorithm with the base case, we needed to lower the threshold for the base case (for fair comparison).",
                "As the dead reckoning threshold in the base case was already very fine, it was decided that instead of lowering the threshold, the probabilistic budget based approach would be compared against a modified base case that would use the normal threshold as the budget based algorithm but the base case was modified such that every third trigger would be actually used to send out a DR vector to all the three receivers used in our experiments.",
                "This was called as the 1/3 base case as it resulted in 1/3 number of DR vectors being sent as compared to the base case.",
                "The budget per trigger for the probability based approach was calculated as one DR vector at each trigger as compared to three DR vectors at every third trigger in the 1/3 base case; thus the two cases lead to the same number of DR vectors being sent out over time.",
                "In order to evaluate the effectiveness of the probabilistic budget based algorithm, we instrumented the BZFlag game to use this approach.",
                "We used the same testbed consisting of one sender and three receivers with delays of 800ms, 500ms and 200ms from the sender and with low delay variance (100ms) and moderate delay variance (180ms).",
                "The results are shown in Figures 5 and 6.",
                "As mentioned earlier, the x-axis of these graphs represents the system time when the snapshot of the game was taken.",
                "Observe from the figures that the standard deviation of the accumulated error among the receivers with the probabilistic budget based algorithm is less than the 1/3 base case and the mean is a little higher than the 1/3 base case.",
                "This implies that the game is fairer as compared to the 1/3 base case at the cost of increasing the mean error by a small amount as compared to the 1/3 base case.",
                "The increase in mean error in the probabilistic case compared to the 1/3 base case can be attributed to the fact that the even though the probabilistic approach on average sends the same number of DR vectors as the 1/3 base case, it sometimes sends DR vectors to a receiver less frequently and sometimes more frequently than the 1/3 base case due to its probabilistic nature.",
                "When a receiver does not receive a DR vector for a long time, the receivers trajectory is more and more off of the senders trajectory and hence the rate of buildup of the error at the receiver is higher.",
                "At times when a receiver receives DR vectors more frequently, it builds up error at a lower rate but there is no way of reversing the error that was built up when it did not receive a DR vector for a long time.",
                "This leads the receivers to build up more error in the probabilistic case as compared to the 1/3 base case where the receivers receive a DR vector almost periodically. 8 0 200 400 600 800 1000 15950 16000 16050 16100 16150 16200 16250 16300 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 350 400 450 500 15950 16000 16050 16100 16150 16200 16250 16300 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 5: Mean and standard deviation of error for different algorithms (including budget based algorithms) for low delay variance. 0 200 400 600 800 1000 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 MeanAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm 0 50 100 150 200 250 300 16960 16980 17000 17020 17040 17060 17080 17100 17120 17140 17160 17180 StandardDeviationofAccumulatedError Time in Seconds 1/3 Base Case Deterministic Algorithm Probabilistic Algorithm Figure 6: Mean and standard deviation of error for different algorithms (including budget based algorithms) for moderate delay variance. 5.2 Deterministic budget based scheme To bound the increase in mean error we decided to modify the budget based algorithm to be deterministic.",
                "The first two steps of the algorithm are the same as in the probabilistic algorithm; the trigger points are increased to lower the threshold and accumulated errors are used to compute the probability that a receiver will receiver a DR vector.",
                "Once these steps are completed, a deterministic schedule for the receiver is computed as follows: 1.",
                "If there is any receiver(s) tagged to receive a DR vector at the current trigger, the sender sends out the DR vector to the respective receiver(s).",
                "If at least one receiver was sent a DR vector, the sender calculates the probabilities of each receiver receiving a DR vector as explained before and follows steps 2 to 6, else it does not do anything. 2.",
                "For each receiver, the probability value is multiplied with the budget available at each trigger (which is set to 1 as explained below) to give the frequency of sending the DR vector to each receiver. 3.",
                "If any of the receivers frequency after multiplying with the budget goes over 1, the receivers frequency is set as 1 and the surplus amount is equally distributed to all the receivers by adding the amount to their existing frequencies.",
                "This process is repeated until all the receivers have a frequency of less than or equal to 1.",
                "This is due to the fact that at a trigger we cannot send more than one DR vector to the respective receiver.",
                "That will be wastage of DR vectors by sending redundant information. 4. (1/frequency) gives us the schedule at which the sender should send DR vectors to the respective receiver.",
                "Credit obtained previously (explained in step 5) if any is subtracted from the schedule.",
                "Observe that the resulting value of the schedule might not be an integer; hence, the value is rounded off by taking the ceiling of the schedule.",
                "For example, if the frequency is 1/3.5, this implies that we would like to have a DR vector sent every 3.5 triggers.",
                "However, we are constrained to send it at the 4th trigger giving us a credit of 0.5.",
                "When we do send the DR vector next time, we would be able to send it 9 on the 3rd trigger because of the 0.5 credit. 5.",
                "The difference between the schedule and the ceiling of the schedule is the credit that the receiver has obtained which is remembered for the future and used at the next time as explained in step 4. 6.",
                "For each of those receivers who were sent a DR vector at the current trigger, the receivers are tagged to receive the next DR vector at the trigger that happens exactly schedule (the ceiling of the schedule) number of times away from the current trigger.",
                "Observe that no other receivers schedule is modified at this point as they all are running a schedule calculated at some previous point of time.",
                "Those schedules will be automatically modified at the trigger when they are scheduled to receive the next DR vector.",
                "At the first trigger, the sender sends the DR vector to all the receivers and uses a relative probability of 1/n for each receiver and follows the steps 2 to 6 to calculate the next schedule for each receiver in the same way as mentioned for other triggers.",
                "This algorithm ensures that every receiver has a guaranteed schedule of receiving DR vectors and hence there is no irregularity in sending the DR vector to any receiver as was observed in the budget based probabilistic algorithm.",
                "We used the testbed described earlier (three receivers with varying delays) to evaluate the deterministic algorithm using the budget of 1 DR vector per trigger so as to use the same number of DR vectors as in the 1/3 base case.",
                "Results from our experiments are shown in Figures 5 and 6.",
                "It can be observed that the standard deviation of error in the deterministic budget based algorithm is less than the 1/3 base case and also has the same mean error as the 1/3 base case.",
                "This indicates that the deterministic algorithm is more fair than the 1/3 base case and at the same time does not increase the mean error thereby leading to a better game quality compared to the probabilistic algorithm.",
                "In general, when comparing the deterministic approach to the probabilistic approach, we found that the mean accumulated error was always less in the deterministic approach.",
                "With respect to standard deviation of the accumulated error, we found that in the fixed or low variance cases, the deterministic approach was generally lower, but in higher variance cases, it was harder to draw conclusions as the probabilistic approach was sometimes better than the deterministic approach. 6.",
                "CONCLUSIONS AND FUTURE WORK In distributed multi-player games played across the Internet, object and player trajectory within the game space are exchanged in terms of DR vectors.",
                "Due to the variable delay between players, these DR vectors reach different players at different times.",
                "There is unfair advantage gained by receivers who are closer to the sender of the DR as they are able to render the senders position more accurately in real time.",
                "In this paper, we first developed a model for estimating the error in rendering player trajectories at the receivers.",
                "We then presented an algorithm based on scheduling the DR vectors to be sent to different players at different times thereby equalizing the error at different players.",
                "This algorithm is aimed at making the game fair to all players, but tends to increase the mean error of the players.",
                "To counter this effect, we presented budget based algorithms where the DR vectors are still scheduled to be sent at different players at different times but the algorithm balances the need for fairness with the requirement that the error of the worst case players (who are furthest from the sender) are not increased compared to the base case (where all DR vectors are sent to all players every time a DR vector is generated).",
                "We presented two variations of the budget based algorithms and through experimentation showed that the algorithms reduce the standard deviation of the error thereby making the game more fair and at the same time has comparable mean error to the base case. 7.",
                "REFERENCES [1] S.Aggarwal, H. Banavar, A. Khandelwal, S. Mukherjee, and S. Rangarajan, Accuracy in Dead-Reckoning based Distributed Multi-Player Games, Proceedings of ACM SIGCOMM 2004 Workshop on Network and System Support for Games (NetGames 2004), Aug. 2004. [2] L. Gautier and C. Diot, Design and Evaluation of MiMaze, a Multiplayer Game on the Internet, in Proc. of IEEE Multimedia (ICMCS98), 1998. [3] M. Mauve, Consistency in Replicated Continuous Interactive Media, in Proc. of the ACM Conference on Computer Supported Cooperative Work (CSCW00), 2000, pp. 181-190. [4] S.K.",
                "Singhal and D.R.",
                "Cheriton, Exploiting Position History for Efficient Remote Rendering in Networked Virtual Reality, Presence: Teleoperators and Virtual Environments, vol. 4, no. 2, pp. 169-193, 1995. [5] C. Diot and L. Gautier, A Distributed Architecture for Multiplayer Interactive Applications on the Internet, in IEEE Network Magazine, 1999, vol. 13, pp. 6-15. [6] L. Pantel and L.C.",
                "Wolf, On the Impact of Delay on Real-Time Multiplayer Games, in Proc. of ACM NOSSDAV02, May 2002. [7] Y. Lin, K. Guo, and S. Paul, Sync-MS: Synchronized Messaging Service for Real-Time Multi-Player Distributed Games, in Proc. of 10th IEEE International Conference on Network Protocols (ICNP), Nov 2002. [8] K. Guo, S. Mukherjee, S. Rangarajan, and S. Paul, A Fair Message Exchange Framework for Distributed Multi-Player Games, in Proc. of NetGames2003, May 2003. [9] N. E. Baughman and B. N. Levine, Cheat-Proof Playout for Centralized and Distributed Online Games, in Proc. of IEEE INFOCOM01, April 2001. [10] M. Allman and V. Paxson, On Estimating End-to-End Network Path Properties, in Proc. of ACM SIGCOMM99, Sept. 1999. [11] BZFlag Forum, BZFlag Game, URL: http://www.bzflag.org. [12] Nation Institute of Standards and Technology, NIST Net, URL: http://snad.ncsl.nist.gov/nistnet/. 10"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        }
    }
}