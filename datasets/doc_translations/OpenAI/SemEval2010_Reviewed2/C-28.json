{
    "id": "C-28",
    "original_text": "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments. The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies. Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes. Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios. Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1. INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily. SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space. In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive. For this reason, heuristics like BLAST [3] were proposed to reduce execution time. The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale. This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5]. Resource scheduling is one of the most important components of a grid system. The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem. Grid applications usually do not have high communication rates and many of them follow the master/slave model [13]. In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8]. The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13]. In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases. PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies. Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload. As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform. This paper is organized as follows. Section 2 presents the sequence comparison problem and the BLAST algorithm. Section 3 describes allocation policies for grids. Section 4 discusses related work. Section 5 presents the design of PackageBLAST. Experimental results are discussed in section 6. Section 7 concludes the paper. 2. SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7]. Given an alignment between two sequences, a score is usually associated for it as follows (figure 1). For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space. The score is the sum of all the values and the maximal score is the similarity between the sequences. To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity. Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks. By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories. Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes. In this scenario, the use of exact methods such as SW is prohibitive. For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced. Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility. Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7]. BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences. It is designed to obtain high performance with low impact in terms of sensibility. BLAST provides programs to compare many combinations of query and database sequence types (table 1). Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account. In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6]. Basically, the algorithm proceeds in three steps: seeding, extension and evaluation. In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds. A parameter X maintains the recent alignment history and controls this step. Once seeds are extended, the last step begins. The alignments are evaluated to determine if they are statistically significant. The significant ones are termed HSPs (High-scoring Segment Pairs). A new parameter, S, is used to sort alignments. The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3. TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power. The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure. Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world. In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization. OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards. Many OGSA architecture implementations were developed, including one for Globus. The work carried out in this paper is deployed on a grid based on Globus (GT3). Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing. A very important problem to be solved in this context is task allocation. The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13]. In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy. WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes. This strategy is appropriate for homogeneous systems with dedicated resources (equation 3). A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4). A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node. Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size. This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially. Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences. Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4. RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases. First, the genetic database is segmented. Then, the queries are evenly distributed among the nodes. If the node does not have a database fragment, a local copy is made. A method is proposed that associates data fragments to nodes, trying to minimize the number of copies. BLAST++ [10] groups multiple sequences to reduce the number of database accesses. A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3). Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master. GridBlast [9] is a master/slave grid application that uses Globus 2. It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax. Of those, only the last one takes into account the current load and the heterogeneity of the environment. However, to use minmax, the total execution time of each BLAST task must be known. Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node. When the search finishes, the results are compacted and sent to the master. Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3. All genetic databases are statically placed on the grid nodes (without replication). GBTK is a master/slave application that receives the sequences and the name of the genetic database. It then verifies if the node that contains the database is available. If so, it is selected. If the node is not available, the less loaded node is chosen and the database is copied to it. Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5. DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments. The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application. We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently. It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance. Also, a single query sequence can be compared against all segments in parallel. Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size. We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance. Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation. Thus, we propose the use of a framework where many allocation policies can be incorporated. By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3. So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters. Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload. Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node. The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS. A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications. The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi. At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java. Figure 3 presents the PackageBLAST architecture. BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture. The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies. The module Generate Work Units is the core of the PSS mechanism. It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy. Distribute Work Units is the module responsible for the communication between the master and slaves nodes. It distributes the work units generated by the previous module and collects the notifications. Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report. In general, the following execution flow is executed. The user specifies the sequence to be compared and chooses the allocation strategy. The master node starts execution and waits for slave connections. To start processing, a minimum number of slaves must register into the master node, by calling a master grid service. After receiving connections from the slaves, the master notifies them about their initial segments to compare. The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS. Then, the master sends a XML message to the slave informing its new segments to process. This flow continues until all segments are processed. 6. EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network. Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2). All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2. Table 2: Characteristics of the grid testbed. Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes. Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each. Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests. Execution times for all allocation strategies are presented in table 3. Table 3: Execution times for BLASTX. Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes. To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database. Table 4: Sequential execution times and speedups. Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups. Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively. In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time. This variation justifies the allocation framework provided. To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02. The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database. Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload. Table 5: PSS evaluation with local workload. Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS. This is due to the fact that a slow node can easily become a bottleneck in these strategies. TSS also obtained a reduction of 5.56% in its execution time. PSS uses two parameters: τ and Ω (section 5.2). We varied these parameters in order to evaluate the PSS behavior in two scenarios. In both cases, we used a four-node (NB, L01, P01, L04) grid. In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment. The goal was to evaluate the impact of short-lived local tasks in PSS. In the second case, local workload was introduced at the same time of the previous case, but continued until the end. The goal was to evaluate long-lived local tasks. Figure 4 presents the gains. Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters. In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear. For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact. On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7. CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches. PackageBLAST contains a framework where the user can choose or incorporate allocation policies. We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment. The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good. In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min. Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies. Moreover, we showed that the introduction of PSS led to very good performance gains for some policies. As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS. Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8. REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman. A basic local alignment search tool. Journal of Molecular Biology, 215:403-410, 1990. [2] A. Darling, L. Carey, and W. Feng. The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al. Gapped blast and psi-blast: a new generation of protein database search programs. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I. Foster and C. Kesselman. Globus: A metacomputing infrastructure toolkit. International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I. Foster and C. Kesselman. The Grid: Blueprint of a Future Computing Infrastructure. Morgan-Kauffman, 1999. [6] W. Gish. Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algorithms on Strings, Trees and Sequences. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn. Factoring: A method for scheduling parallel loops. Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: High throughput blast on the grid. Symposium on Biocomputing, January 2003. [10] D. Peng., W. Yan, and Z. Lei. Parallelization of blast++. Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck. Guided self-scheduling: A practical scheduling scheme for parallel supercomputers. IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi. Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao. Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources. PhD thesis, Univ. California at San Diego, 2001. [14] T. Smith and M. Waterman. Identification of common molecular subsequences. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew. Processor self-scheduling for multiple nested parallel loops. In Int. Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni. Trapezoidal self-scheduling: A practical scheme for parallel compilers. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160",
    "original_translation": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160",
    "original_sentences": [
        "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
        "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
        "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
        "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
        "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
        "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
        "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
        "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
        "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
        "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
        "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
        "Resource scheduling is one of the most important components of a grid system.",
        "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
        "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
        "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
        "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
        "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
        "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
        "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
        "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
        "This paper is organized as follows.",
        "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
        "Section 3 describes allocation policies for grids.",
        "Section 4 discusses related work.",
        "Section 5 presents the design of PackageBLAST.",
        "Experimental results are discussed in section 6.",
        "Section 7 concludes the paper. 2.",
        "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
        "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
        "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
        "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
        "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
        "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
        "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
        "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
        "In this scenario, the use of exact methods such as SW is prohibitive.",
        "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
        "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
        "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
        "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
        "It is designed to obtain high performance with low impact in terms of sensibility.",
        "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
        "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
        "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
        "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
        "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
        "A parameter X maintains the recent alignment history and controls this step.",
        "Once seeds are extended, the last step begins.",
        "The alignments are evaluated to determine if they are statistically significant.",
        "The significant ones are termed HSPs (High-scoring Segment Pairs).",
        "A new parameter, S, is used to sort alignments.",
        "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
        "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
        "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
        "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
        "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
        "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
        "Many OGSA architecture implementations were developed, including one for Globus.",
        "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
        "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
        "A very important problem to be solved in this context is task allocation.",
        "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
        "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
        "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
        "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
        "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
        "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
        "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
        "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
        "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
        "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
        "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
        "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
        "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
        "First, the genetic database is segmented.",
        "Then, the queries are evenly distributed among the nodes.",
        "If the node does not have a database fragment, a local copy is made.",
        "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
        "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
        "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
        "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
        "GridBlast [9] is a master/slave grid application that uses Globus 2.",
        "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
        "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
        "However, to use minmax, the total execution time of each BLAST task must be known.",
        "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
        "When the search finishes, the results are compacted and sent to the master.",
        "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
        "All genetic databases are statically placed on the grid nodes (without replication).",
        "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
        "It then verifies if the node that contains the database is available.",
        "If so, it is selected.",
        "If the node is not available, the less loaded node is chosen and the database is copied to it.",
        "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
        "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
        "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
        "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
        "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
        "Also, a single query sequence can be compared against all segments in parallel.",
        "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
        "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
        "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
        "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
        "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
        "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
        "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
        "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
        "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
        "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
        "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
        "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
        "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
        "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
        "Figure 3 presents the PackageBLAST architecture.",
        "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
        "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
        "The module Generate Work Units is the core of the PSS mechanism.",
        "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
        "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
        "It distributes the work units generated by the previous module and collects the notifications.",
        "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
        "In general, the following execution flow is executed.",
        "The user specifies the sequence to be compared and chooses the allocation strategy.",
        "The master node starts execution and waits for slave connections.",
        "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
        "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
        "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
        "Then, the master sends a XML message to the slave informing its new segments to process.",
        "This flow continues until all segments are processed. 6.",
        "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
        "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
        "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
        "Table 2: Characteristics of the grid testbed.",
        "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
        "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
        "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
        "Execution times for all allocation strategies are presented in table 3.",
        "Table 3: Execution times for BLASTX.",
        "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
        "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
        "Table 4: Sequential execution times and speedups.",
        "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
        "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
        "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
        "This variation justifies the allocation framework provided.",
        "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
        "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
        "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
        "Table 5: PSS evaluation with local workload.",
        "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
        "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
        "TSS also obtained a reduction of 5.56% in its execution time.",
        "PSS uses two parameters: τ and Ω (section 5.2).",
        "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
        "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
        "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
        "The goal was to evaluate the impact of short-lived local tasks in PSS.",
        "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
        "The goal was to evaluate long-lived local tasks.",
        "Figure 4 presents the gains.",
        "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
        "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
        "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
        "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
        "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
        "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
        "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
        "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
        "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
        "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
        "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
        "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
        "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
        "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
        "A basic local alignment search tool.",
        "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
        "Darling, L. Carey, and W. Feng.",
        "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
        "Gapped blast and psi-blast: a new generation of protein database search programs.",
        "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
        "Foster and C. Kesselman.",
        "Globus: A metacomputing infrastructure toolkit.",
        "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
        "Foster and C. Kesselman.",
        "The Grid: Blueprint of a Future Computing Infrastructure.",
        "Morgan-Kauffman, 1999. [6] W. Gish.",
        "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
        "Algorithms on Strings, Trees and Sequences.",
        "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
        "Factoring: A method for scheduling parallel loops.",
        "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
        "Gridblast: High throughput blast on the grid.",
        "Symposium on Biocomputing, January 2003. [10] D.",
        "Peng., W. Yan, and Z. Lei.",
        "Parallelization of blast++.",
        "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
        "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
        "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
        "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
        "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
        "PhD thesis, Univ.",
        "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
        "Identification of common molecular subsequences.",
        "J. Mol.",
        "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
        "Processor self-scheduling for multiple nested parallel loops.",
        "In Int.",
        "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
        "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
        "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
    ],
    "translated_text_sentences": [
        "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias.",
        "El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas.",
        "Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos.",
        "Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios.",
        "Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1.",
        "La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario.",
        "SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos.",
        "En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa.",
        "Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución.",
        "La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global.",
        "Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente.",
        "La programación de recursos es uno de los componentes más importantes de un sistema de red.",
        "La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo.",
        "Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13].",
        "Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8].",
        "La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13].",
        "En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas.",
        "PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación.",
        "Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual.",
        "Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada.",
        "Este documento está organizado de la siguiente manera.",
        "La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST.",
        "La sección 3 describe las políticas de asignación para las cuadrículas.",
        "La sección 4 discute el trabajo relacionado.",
        "La sección 5 presenta el diseño de PackageBLAST.",
        "Los resultados experimentales se discuten en la sección 6.",
        "La sección 7 concluye el artículo. 2.",
        "COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7].",
        "Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1).",
        "Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio.",
        "El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias.",
        "Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática.",
        "Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos.",
        "Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes.",
        "Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes.",
        "En este escenario, el uso de métodos exactos como SW es prohibitivo.",
        "Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación.",
        "Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad.",
        "La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7].",
        "BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas.",
        "Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad.",
        "BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1).",
        "Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas).",
        "En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6].",
        "Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación.",
        "En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas.",
        "Un parámetro X mantiene el historial reciente de alineación y controla este paso.",
        "Una vez que las semillas están extendidas, comienza el último paso.",
        "Las alineaciones se evalúan para determinar si son estadísticamente significativas.",
        "Los significativos se denominan HSPs (High-scoring Segment Pairs).",
        "Un nuevo parámetro, S, se utiliza para ordenar alineaciones.",
        "La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3.",
        "ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional.",
        "El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla.",
        "Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo.",
        "En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización.",
        "OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria.",
        "Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus.",
        "El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3).",
        "Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo.",
        "Un problema muy importante a resolver en este contexto es la asignación de tareas.",
        "El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13].",
        "En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación.",
        "El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos.",
        "Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3).",
        "A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4).",
        "A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento.",
        "Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente.",
        "Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7).",
        "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente.",
        "Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8).",
        "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S.",
        "La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4.",
        "El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases.",
        "Primero, la base de datos genética se segmenta.",
        "Entonces, las consultas se distribuyen de manera uniforme entre los nodos.",
        "Si el nodo no tiene un fragmento de base de datos, se crea una copia local.",
        "Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias.",
        "BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos.",
        "Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3).",
        "Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro.",
        "GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2.",
        "Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax.",
        "De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno.",
        "Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST.",
        "Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido.",
        "Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro.",
        "El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3.",
        "Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación).",
        "GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética.",
        "Luego verifica si el nodo que contiene la base de datos está disponible.",
        "Si es así, está seleccionado.",
        "Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él.",
        "Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5.",
        "DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias.",
        "El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo.",
        "También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente.",
        "Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST.",
        "Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo.",
        "Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño.",
        "Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos.",
        "La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones.",
        "Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación.",
        "Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3.",
        "Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST.",
        "Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local.",
        "Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo.",
        "La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS.",
        "Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos.",
        "La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi.",
        "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi.",
        "En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas.",
        "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java.",
        "La Figura 3 presenta la arquitectura de PackageBLAST.",
        "BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST.",
        "El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación.",
        "El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS.",
        "Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida.",
        "El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos.",
        "Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones.",
        "Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST.",
        "En general, se ejecuta el siguiente flujo de ejecución.",
        "El usuario especifica la secuencia a comparar y elige la estrategia de asignación.",
        "El nodo maestro comienza la ejecución y espera las conexiones de los esclavos.",
        "Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra.",
        "Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar.",
        "El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS.",
        "Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar.",
        "Este flujo continúa hasta que todos los segmentos sean procesados. 6.",
        "RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local.",
        "Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2).",
        "Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2.",
        "Tabla 2: Características del banco de pruebas de la red.",
        "Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula.",
        "Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una.",
        "Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas.",
        "Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3.",
        "Tabla 3: Tiempos de ejecución para BLASTX.",
        "La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos.",
        "Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr.",
        "Tabla 4: Tiempos de ejecución secuenciales y aceleraciones.",
        "El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad.",
        "Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente.",
        "En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución.",
        "Esta variación justifica el marco de asignación proporcionado.",
        "Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02.",
        "La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces.",
        "Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo.",
        "Tabla 5: Evaluación de PSS con carga de trabajo local.",
        "Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS.",
        "Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias.",
        "TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución.",
        "PSS utiliza dos parámetros: τ y Ω (sección 5.2).",
        "Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios.",
        "En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04).",
        "En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento.",
        "El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS.",
        "En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final.",
        "El objetivo era evaluar tareas locales de larga duración.",
        "La Figura 4 presenta las ganancias.",
        "Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω.",
        "En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá.",
        "Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto.",
        "Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido.",
        "CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo.",
        "PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación.",
        "También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado.",
        "Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos.",
        "Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos.",
        "Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas.",
        "Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas.",
        "Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS.",
        "Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8.",
        "REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman.",
        "Una herramienta básica de búsqueda de alineamiento local.",
        "Revista de Biología Molecular, 215:403-410, 1990. [2] A.",
        "Darling, L. Carey, y W. Feng.",
        "El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col.",
        "Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas.",
        "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I.",
        "Foster y C. Kesselman.",
        "Globus: Un conjunto de herramientas de infraestructura de metacomputación.",
        "Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I.",
        "Foster y C. Kesselman.",
        "La Red: Diseño de una Infraestructura Informática Futura.",
        "Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish.",
        "Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
        "Algoritmos en Cadenas, Árboles y Secuencias.",
        "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn.",
        "Factorización: Un método para programar bucles paralelos.",
        "Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
        "Gridblast: Blast de alto rendimiento en la red.",
        "Simposio sobre Biocomputación, enero de 2003. [10] D.",
        "Peng, W. Yan y Z. Lei.",
        "Paralelización de blast++.",
        "Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck.",
        "Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas.",
        "IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi.",
        "Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao.",
        "Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos.",
        "Tesis de doctorado, Univ.",
        "California en San Diego, 2001. [14] T. Smith y M. Waterman.",
        "Identificación de subsecuencias moleculares comunes.",
        "J. Mol.",
        "Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew.",
        "Auto-programación del procesador para múltiples bucles paralelos anidados.",
        "En Int.",
        "Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni.",
        "Programación automática trapezoidal: Un esquema práctico para compiladores paralelos.",
        "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160"
    ],
    "error_count": 2,
    "keys": {
        "biological sequence comparison": {
            "translated_key": "comparación de secuencias biológicas",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for <br>biological sequence comparison</br> ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION <br>biological sequence comparison</br> (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for <br>biological sequence comparison</br> ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "INTRODUCTION <br>biological sequence comparison</br> (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily."
            ],
            "translated_annotated_samples": [
                "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias.",
                "La <br>comparación de secuencias biológicas</br> (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La <br>comparación de secuencias biológicas</br> (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "adaptive multi-policy grid service": {
            "translated_key": "servicio de grid multi-política adaptativo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An <br>adaptive multi-policy grid service</br> for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an <br>adaptive multi-policy grid service</br> to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an <br>adaptive multi-policy grid service</br> to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "PackageBLAST: An <br>adaptive multi-policy grid service</br> for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "In this paper, we propose PackageBLAST, an <br>adaptive multi-policy grid service</br> to run BLAST searches in grids composed by segmented genetic databases.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an <br>adaptive multi-policy grid service</br> to execute master/slave BLAST searches."
            ],
            "translated_annotated_samples": [
                "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias.",
                "En este artículo, proponemos PackageBLAST, un <br>servicio de grid multi-política adaptativo</br> para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas.",
                "CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un <br>servicio de cuadrícula adaptable de múltiples políticas</br> para ejecutar búsquedas BLAST maestro/esclavo."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un <br>servicio de grid multi-política adaptativo</br> para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un <br>servicio de cuadrícula adaptable de múltiples políticas</br> para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160 ",
            "candidates": [],
            "error": [
                [
                    "servicio de grid multi-política adaptativo",
                    "servicio de cuadrícula adaptable de múltiples políticas"
                ]
            ]
        },
        "task allocation": {
            "translated_key": "asignación de tareas",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive <br>task allocation</br> framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate <br>task allocation</br> strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called <br>task allocation</br>, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many <br>task allocation</br> policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "<br>task allocation</br> FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is <br>task allocation</br>.",
                "The <br>task allocation</br> problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 <br>task allocation</br> Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive <br>task allocation</br> framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 <br>task allocation</br> As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive <br>task allocation</br> framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate <br>task allocation</br> strategies.",
                "The choice of the best resources for a particular application is called <br>task allocation</br>, which is an NP-Complete problem.",
                "In order to schedule master/slave applications many <br>task allocation</br> policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "<br>task allocation</br> FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power."
            ],
            "translated_annotated_samples": [
                "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de <br>asignación de tareas</br> adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias.",
                "El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de <br>asignación de tareas</br>.",
                "La elección de los mejores recursos para una aplicación específica se llama <br>asignación de tareas</br>, lo cual es un problema NP-Completo.",
                "Para programar aplicaciones maestro/esclavo se propusieron varias políticas de <br>asignación de tareas</br>, como la Auto-programación [15] y FAC2 [8].",
                "ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de <br>asignación de tareas</br> adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de <br>asignación de tareas</br>. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama <br>asignación de tareas</br>, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de <br>asignación de tareas</br>, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "blast search": {
            "translated_key": "búsqueda de BLAST",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each <br>blast search</br> compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "Each <br>blast search</br> compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each."
            ],
            "translated_annotated_samples": [
                "Cada <br>búsqueda de BLAST</br> comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada <br>búsqueda de BLAST</br> comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "packageblast": {
            "translated_key": "PackageBLAST",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>packageblast</br>: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called <br>packageblast</br>, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose <br>packageblast</br>, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "<br>packageblast</br> executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of <br>packageblast</br>.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: <br>packageblast</br> segmentation and distribution mechanism. 5.",
                "DESIGN OF <br>packageblast</br> We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called <br>packageblast</br>, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in <br>packageblast</br> with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture <br>packageblast</br> was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the <br>packageblast</br> architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: <br>packageblast</br> architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS <br>packageblast</br> was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of <br>packageblast</br>, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 <br>packageblast</br> achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed <br>packageblast</br> with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated <br>packageblast</br>, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "<br>packageblast</br> contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running <br>packageblast</br> with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run <br>packageblast</br> in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "<br>packageblast</br>: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called <br>packageblast</br>, provides an infrastructure to choose or incorporate task allocation strategies.",
                "In this paper, we propose <br>packageblast</br>, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "<br>packageblast</br> executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Section 5 presents the design of <br>packageblast</br>."
            ],
            "translated_annotated_samples": [
                "PackageBLAST: Un <br>Servicio de Rejilla Multi-Política Adaptativa</br> para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias.",
                "El marco, llamado <br>PackageBLAST</br>, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas.",
                "En este artículo, proponemos <br>PackageBLAST</br>, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas.",
                "PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco <br>políticas de asignación</br>.",
                "La sección 5 presenta el diseño de <br>PackageBLAST</br>."
            ],
            "translated_text": "PackageBLAST: Un <br>Servicio de Rejilla Multi-Política Adaptativa</br> para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado <br>PackageBLAST</br>, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos <br>PackageBLAST</br>, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco <br>políticas de asignación</br>. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de <br>PackageBLAST</br>. ",
            "candidates": [],
            "error": [
                [
                    "Servicio de Rejilla Multi-Política Adaptativa",
                    "PackageBLAST",
                    "PackageBLAST",
                    "políticas de asignación",
                    "PackageBLAST"
                ]
            ]
        },
        "bioinformatics": {
            "translated_key": "bioinformática",
            "is_in_text": false,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "grid computing": {
            "translated_key": "computación en malla",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of <br>grid computing</br>, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 <br>grid computing</br> <br>grid computing</br> was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for <br>grid computing</br> infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "This led to the idea of <br>grid computing</br>, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "TASK ALLOCATION FOR GRIDS 3.1 <br>grid computing</br> <br>grid computing</br> was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for <br>grid computing</br> infrastructure."
            ],
            "translated_annotated_samples": [
                "Esto llevó a la idea de la <br>computación en malla</br>, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente.",
                "ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional.",
                "El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de <br>computación en malla</br>."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la <br>computación en malla</br>, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de <br>computación en malla</br>. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "computational biology": {
            "translated_key": "biología computacional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in <br>computational biology</br>, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in <br>computational biology</br>, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily."
            ],
            "translated_annotated_samples": [
                "La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en <br>biología computacional</br>, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en <br>biología computacional</br>, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "genome project": {
            "translated_key": "proyectos de genoma",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In <br>genome project</br>s, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "In <br>genome project</br>s, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive."
            ],
            "translated_annotated_samples": [
                "En los <br>proyectos de genoma</br>, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los <br>proyectos de genoma</br>, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "segmented genetic database": {
            "translated_key": "bases de datos genéticas segmentadas",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by <br>segmented genetic database</br>s.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by <br>segmented genetic database</br>s."
            ],
            "translated_annotated_samples": [
                "En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por <br>bases de datos genéticas segmentadas</br>."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por <br>bases de datos genéticas segmentadas</br>. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "heterogeneous non-dedicated platform": {
            "translated_key": "plataforma heterogénea no dedicada",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a <br>heterogeneous non-dedicated platform</br>.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a <br>heterogeneous non-dedicated platform</br>."
            ],
            "translated_annotated_samples": [
                "Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una <br>plataforma heterogénea no dedicada</br>."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una <br>plataforma heterogénea no dedicada</br>. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "grid environment": {
            "translated_key": "entorno de rejilla",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a <br>grid environment</br> against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use <br>grid environment</br> knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated <br>grid environment</br>.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a <br>grid environment</br> against sequence database segments.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use <br>grid environment</br> knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated <br>grid environment</br>."
            ],
            "translated_annotated_samples": [
                "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un <br>entorno de rejilla</br> contra segmentos de bases de datos de secuencias.",
                "Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del <br>entorno de la cuadrícula</br> obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo.",
                "También definimos una estrategia, PSS, que adapta la política elegida a un <br>entorno de red heterogéneo</br> no dedicado."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un <br>entorno de rejilla</br> contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (Programación de Autoasignación Adaptativa Ponderada por Paquete), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del <br>entorno de la cuadrícula</br> obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un <br>entorno de red heterogéneo</br> no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160 ",
            "candidates": [],
            "error": [
                [
                    "entorno de rejilla",
                    "entorno de la cuadrícula",
                    "entorno de red heterogéneo"
                ]
            ]
        },
        "pss": {
            "translated_key": "Programación de Autoasignación Adaptativa Ponderada por Paquete",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose <br>pss</br> (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, <br>pss</br> is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by <br>pss</br>.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the <br>pss</br> mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by <br>pss</br>.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate <br>pss</br>, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with <br>pss</br> strategy, but without workload; 2) with <br>pss</br> strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: <br>pss</br> evaluation with local workload.",
                "Gain is the comparison of without <br>pss</br> with <br>pss</br> 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "<br>pss</br> uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the <br>pss</br> behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in <br>pss</br>.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by <br>pss</br> varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), <br>pss</br> tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, <br>pss</br> takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, <br>pss</br>, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of <br>pss</br> led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in <br>pss</br>.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "Besides that, we propose <br>pss</br> (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, <br>pss</br> is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by <br>pss</br>.",
                "The module Generate Work Units is the core of the <br>pss</br> mechanism.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by <br>pss</br>."
            ],
            "translated_annotated_samples": [
                "Además, proponemos PSS (<br>Programación de Autoasignación Adaptativa Ponderada por Paquete</br>), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local.",
                "Considerando la heterogeneidad y las características dinámicas de la red, <br>PSS</br> es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo.",
                "La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS.",
                "El módulo Generar Unidades de Trabajo es el núcleo del <br>mecanismo PSS</br>.",
                "El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (<br>Programación de Autoasignación Adaptativa Ponderada por Paquete</br>), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, <br>PSS</br> es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del <br>mecanismo PSS</br>. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. ",
            "candidates": [],
            "error": [
                [
                    "Programación de Autoasignación Adaptativa Ponderada por Paquete",
                    "PSS",
                    "mecanismo PSS"
                ]
            ]
        },
        "package weighted adaptive self-scheduling": {
            "translated_key": "Programación de Autoasignación Adaptativa Ponderada por Paquete",
            "is_in_text": true,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (<br>package weighted adaptive self-scheduling</br>), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [
                "Besides that, we propose PSS (<br>package weighted adaptive self-scheduling</br>), a new strategy that adapts the chosen allocation policy to a grid with local workload."
            ],
            "translated_annotated_samples": [
                "Además, proponemos PSS (<br>Programación de Autoasignación Adaptativa Ponderada por Paquete</br>), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local."
            ],
            "translated_text": "PackageBLAST: Un Servicio de Rejilla Multi-Política Adaptativa para la Comparación de Secuencias Biológicas ∗ Marcelo S. Sousa Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil msousa@unb.br Alba Cristina M. A. Melo Universidad de Brasilia Campus UNB - ICC Norte, sub-suelo Brasilia, Brasil alves@unb.br RESUMEN En este artículo, proponemos un marco de asignación de tareas adaptativo para realizar búsquedas BLAST en un entorno de rejilla contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación de tareas. Además, proponemos un mecanismo para calcular el peso de ejecución de los nodos de la cuadrícula, adaptando la política de asignación elegida a la potencia computacional actual de los nodos. Nuestros resultados presentan mejoras de velocidad muy buenas y también muestran que ninguna estrategia de asignación única es capaz de lograr los tiempos de ejecución más bajos para todos los escenarios. Categorías y Descriptores de Asignaturas C.2.4 [Sistemas Distribuidos]: Aplicaciones Distribuidas; J.3 [Ciencias de la Vida y Médicas]: Biología y Genética 1. La comparación de secuencias biológicas (o alineamiento de secuencias) es uno de los problemas más importantes en biología computacional, dada la cantidad y diversidad de las secuencias y la frecuencia con la que se necesita resolverlo a diario. SW [14] es un algoritmo exacto que encuentra el mejor alineamiento local entre dos secuencias de tamaño n en tiempo y espacio cuadráticos. En los proyectos de genoma, el tamaño de las secuencias a comparar está aumentando constantemente, por lo que una solución O(n2) resulta costosa. Por esta razón, se propusieron heurísticas como BLAST [3] para reducir el tiempo de ejecución. La popularidad de Internet hizo posible la interconexión de millones de máquinas potentes a escala global. Esto llevó a la idea de la computación en malla, que implica el intercambio cooperativo y seguro de recursos no dedicados y heterogéneos que están distribuidos geográficamente. La programación de recursos es uno de los componentes más importantes de un sistema de red. La elección de los mejores recursos para una aplicación específica se llama asignación de tareas, lo cual es un problema NP-Completo. Las aplicaciones de cuadrícula generalmente no tienen tasas de comunicación altas y muchas de ellas siguen el modelo maestro/esclavo [13]. Para programar aplicaciones maestro/esclavo se propusieron varias políticas de asignación de tareas, como la Auto-programación [15] y FAC2 [8]. La elección de la mejor política de asignación depende del patrón de acceso de la aplicación y del entorno en el que se ejecuta [13]. En este artículo, proponemos PackageBLAST, un servicio de grid multi-política adaptativo para ejecutar búsquedas de BLAST en grids compuestos por bases de datos genéticas segmentadas. PackageBLAST se ejecuta en Globus 3 [4] y, hasta ahora, ofrece cinco políticas de asignación. Además, proponemos un mecanismo adaptativo para asignar pesos a los nodos de la cuadrícula, teniendo en cuenta su carga de trabajo actual. Hasta donde sabemos, este es el primer servicio de red que ejecuta BLAST con múltiples políticas de tareas con una base de datos segmentada en una plataforma heterogénea no dedicada. Este documento está organizado de la siguiente manera. La sección 2 presenta el problema de comparación de secuencias y el algoritmo BLAST. La sección 3 describe las políticas de asignación para las cuadrículas. La sección 4 discute el trabajo relacionado. La sección 5 presenta el diseño de PackageBLAST. Los resultados experimentales se discuten en la sección 6. La sección 7 concluye el artículo. 2. COMPARACIÓN DE SECUENCIAS Para comparar dos secuencias, debemos encontrar el mejor alineamiento, que consiste en colocar una secuencia sobre la otra, dejando clara la correspondencia entre los caracteres similares [7]. Dado un alineamiento entre dos secuencias, generalmente se le asocia una puntuación de la siguiente manera (figura 1). Para cada columna, asociamos, por ejemplo, +1 si los dos caracteres son idénticos, -1 si los caracteres son diferentes y -2 si uno de ellos es un espacio. El puntaje es la suma de todos los valores y el puntaje máximo es la similitud entre las secuencias. Para calcular alineamientos de secuencias locales exactos, [14] propuso un algoritmo (SW), basado en programación dinámica, con complejidad temporal y espacial cuadrática. Normalmente, una secuencia biológica dada se compara con miles o incluso millones de secuencias que componen bancos de datos genéticos. Hasta ahora, hay millones de entradas compuestas por miles de millones de nucleótidos en GenBank, que es uno de los repositorios públicos de genes más importantes. Debido a la tasa de crecimiento actual de 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figura 1: Ejemplo de un alineamiento con puntaje 6, estas bases de datos pronto alcanzarán terabytes. En este escenario, el uso de métodos exactos como SW es prohibitivo. Por esta razón, se proponen métodos heurísticos más rápidos que no garantizan que se producirá la mejor alineación. Por lo general, estos métodos heurísticos se evalúan utilizando los conceptos de sensibilidad y sensibilidad. La sensibilidad es la tasa a la que el método falla al identificar secuencias similares, mientras que la sensibilidad es la tasa a la que el método identifica secuencias que no son similares [7]. BLAST es el método heurístico más ampliamente utilizado para la comparación de secuencias. El algoritmo BLAST (Herramienta Básica de Alineamiento Local) es un conjunto de programas utilizados para buscar similitudes entre secuencias en bases de datos de ADN y proteínas. Está diseñado para obtener un alto rendimiento con bajo impacto en términos de sensibilidad. BLAST proporciona programas para comparar muchas combinaciones de tipos de secuencias de consulta y base de datos (tabla 1). Tabla 1: Algunos de los programas de la familia BLAST Programa Base de datos Consulta Traducción BLASTN Nucleótido Nucleótido Ninguna BLASTP Proteína Proteína Ninguna BLASTX Proteína Nucleótido Consulta La primera versión de BLAST buscaba similitudes locales sin tener en cuenta los espacios (brechas). En 1996-1997, surgieron dos versiones modificadas de BLAST: NCBI-BLAST [3] y WU-BLAST [6]. Básicamente, el algoritmo avanza en tres pasos: siembra, extensión y evaluación. En la etapa de siembra, una secuencia de consulta se divide en porciones llamadas palabras de tamaño W. Estas palabras se comparan con secuencias de la base de datos y se utilizan como semillas de alineación si sus puntuaciones son mayores que un umbral T. En la etapa de extensión, se generan alineaciones a partir de las semillas. Un parámetro X mantiene el historial reciente de alineación y controla este paso. Una vez que las semillas están extendidas, comienza el último paso. Las alineaciones se evalúan para determinar si son estadísticamente significativas. Los significativos se denominan HSPs (High-scoring Segment Pairs). Un nuevo parámetro, S, se utiliza para ordenar alineaciones. La combinación de los parámetros W, T, X y S se utiliza para determinar la sensibilidad y velocidad de las búsquedas de BLAST. 3. ASIGNACIÓN DE TAREAS PARA GRIDS 3.1 Computación en Grid La Computación en Grid fue desarrollada inicialmente para permitir el intercambio de recursos entre instituciones científicas que necesitaban compartir datos, software y potencia computacional. El Globus Toolkit [4] surgió como un proyecto de código abierto y rápidamente se convirtió en el estándar de facto para la infraestructura de computación en malla. Globus implementa un conjunto de protocolos, APIs y servicios utilizados por cientos de aplicaciones de grid en todo el mundo. En 2002, la Arquitectura de Servicios de Grid Abierto (OGSA) fue introducida por el Foro Global de Grid (GGF) para expandir la estandarización. OGSA proporcionó una nueva arquitectura para aplicaciones de grid basada en servicios web con el fin de lograr interoperabilidad utilizando estándares de la industria. Se desarrollaron muchas implementaciones de la arquitectura OGSA, incluida una para Globus. El trabajo realizado en este documento se despliega en una cuadrícula basada en Globus (GT3). Por lo general, las aplicaciones de cuadrícula se modelan como maestro/esclavo, donde un problema se divide en muchas unidades de trabajo independientes (tareas) de menor tamaño que pueden distribuirse a nodos esclavos para su procesamiento en paralelo. Un problema muy importante a resolver en este contexto es la asignación de tareas. El problema de asignación de tareas consiste en asignar tareas a procesadores con el fin de maximizar el rendimiento del sistema [13]. En este problema, se asume que no existen relaciones de precedencia entre las tareas. 3.2 Estrategias de asignación de tareas Dada una aplicación maestro/esclavo compuesta por un maestro m y S esclavos, la función de asignación allocate(m, si, N, S) determina cuántas tareas de N deben ser asignadas a un esclavo si (ecuación 1), donde A(N, S) representa una política de asignación. El WeightFactor(m, si, S) fue definido por [13] (ecuación 2) y proporciona pesos para cada esclavo si, basados en su tasa de procesamiento estáticamente conocida (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ FactorPeso(m, si, S) (1) FactorPeso(m, si, S) = P ∗ TasaTrabajador(m, si) P i=1 TasaTrabajador(m, si) (2) Las siguientes subsecciones presentan algunas políticas de asignación de trabajo, que son instancias A(N, S) de la ecuación 1. 3.3 Fijo (Programación Estática) La estrategia Fijo [13] distribuye todas las unidades de trabajo de manera uniforme a los nodos esclavos. Esta estrategia es apropiada para sistemas homogéneos con recursos dedicados (ecuación 3). A(N, S) = N S (3) 3.4 Auto-programación (SS) La auto-programación (SS) [15] distribuye una única unidad de trabajo a cada nodo esclavo (ecuación 4). A(N, S) = 1, mientras queden unidades de trabajo por asignar (4). En SS, el desequilibrio máximo está limitado por el tiempo de procesamiento de una unidad de trabajo en el nodo más lento. Sin embargo, SS generalmente requiere mucha comunicación, ya que cada recuperación de unidad de trabajo requiere una interacción con el maestro. 3.5 Programación Autónoma Trapezoidal (TSS) La Programación Autónoma Trapezoidal (TSS) [16] asigna unidades de trabajo en grupos con un tamaño que disminuye linealmente. Esta estrategia utiliza dos variables, steps y δ, que representan el número total de pasos de asignación y el factor de reducción de bloque, respectivamente (ecuaciones 5 y 6). steps = 4NS N + 2S (5) δ = N − 2S 2S(steps − 1) (6) TSS calcula la longitud del bloque s-ésimo utilizando la diferencia entre la longitud del primer bloque y la reducción total de los últimos s - 1 bloques (ecuación 7). A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Programación Autónoma Guiada (GSS) La Programación Autónoma Guiada (GSS) [11] asigna unidades de trabajo en grupos cuya longitud disminuye exponencialmente. Su objetivo es crear un equilibrio entre la cantidad de unidades de trabajo procesadas y el desequilibrio en los tiempos de finalización (ecuación 8). A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 asigna unidades de trabajo en ciclos que consisten en secuencias de asignación S. La ecuación 9 muestra la función que define el número de ciclo de una iteración s. En FAC2, la mitad de las unidades de trabajo restantes se asignan en cada ronda (ecuación 10). ronda(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2ronda(s) , 1 (10) 4. El trabajo relacionado MpiBLAST [2] fue propuesto para clústeres y consta de dos fases. Primero, la base de datos genética se segmenta. Entonces, las consultas se distribuyen de manera uniforme entre los nodos. Si el nodo no tiene un fragmento de base de datos, se crea una copia local. Se propone un método que asocia fragmentos de datos a nodos, intentando minimizar el número de copias. BLAST++ [10] agrupa múltiples secuencias para reducir el número de accesos a la base de datos. Se utiliza un enfoque maestro/esclavo que asigna las consultas a los esclavos de acuerdo con la política fija (sección 3.3). Cada trabajador ejecuta BLAST++ de forma independiente y, finalmente, los resultados son recopilados y combinados por el maestro. GridBlast [9] es una aplicación de cuadrícula maestro/esclavo que utiliza Globus 2. Distribuye secuencias entre los nodos de la cuadrícula utilizando dos políticas de asignación: FCFS y minmax. De esos, solo el último tiene en cuenta la carga actual y la heterogeneidad del entorno. Sin embargo, para utilizar minmax, se debe conocer el tiempo total de ejecución de cada tarea de BLAST. Habiendo decidido qué secuencias serán comparadas por cada nodo, GridBlast envía las secuencias, los archivos ejecutables y toda la base de datos al nodo elegido. Cuando la búsqueda finaliza, los resultados se compactan y se envían al maestro. El Toolkit de Explosión de Cuadrícula (GBTK) [12] es un portal web para ejecutar búsquedas de BLAST en Globus 3. Todas las bases de datos genéticas están estáticamente ubicadas en los nodos de la red (sin replicación). GBTK es una aplicación maestro/esclavo que recibe las secuencias y el nombre de la base de datos genética. Luego verifica si el nodo que contiene la base de datos está disponible. Si es así, está seleccionado. Si el nodo no está disponible, se elige el nodo menos cargado y se copia la base de datos en él. Segmento de base de datos de Internet Maestro Esclavo Esclavo Esclavo, pero solo una parte de él se procesa en cada nodo. La base de datos está replicada en los nodos, Figura 2: Mecanismo de segmentación y distribución de PackageBLAST. 5. DISEÑO DE PACKAGEBLAST Proponemos un marco de asignación de tareas adaptativo que es un servicio de cuadrícula para realizar búsquedas BLAST contra segmentos de bases de datos de secuencias. El marco, llamado PackageBLAST, proporciona una infraestructura para elegir o incorporar estrategias de asignación en una aplicación maestro/esclavo. También proponemos una estrategia para calcular el peso de ejecución de los nodos de la cuadrícula que distribuye las unidades de trabajo (segmentos de base de datos) a los nodos de la cuadrícula según su potencia computacional actual. 5.1 Segmentación y Replicación de Bases de Datos La segmentación consiste en la división de un archivo de base de datos en muchas porciones de tamaño más pequeño, llamadas segmentos, que pueden procesarse de forma independiente. Permite a los nodos de la red buscar partes más pequeñas de una base de datos de secuencias, reduciendo el número de accesos al disco y, por lo tanto, mejorando el rendimiento de BLAST. Además, una sola secuencia de consulta se puede comparar con todos los segmentos en paralelo. Al igual que en mpiBLAST (sección 4), decidimos utilizar la segmentación de bases de datos en PackageBLAST con una herramienta de NCBI llamada formatdb, la cual fue modificada para generar más segmentos de base de datos de menor tamaño. Optamos por replicar la base de datos segmentada en cada nodo de la red esclava para mejorar los tiempos de acceso a los datos y proporcionar una potencial tolerancia a fallos. La Figura 2 ilustra esto. 5.2 Asignación de tareas Como [13], creemos que ninguna política de asignación producirá los mejores resultados para todas las situaciones. Por lo tanto, proponemos el uso de un marco de trabajo donde se puedan incorporar múltiples políticas de asignación. Hasta ahora, nuestro marco de trabajo contiene cinco políticas de asignación: Fija, SS, GSS, TSS, FAC2, todas descritas en la sección 3. Por lo tanto, el usuario puede elegir o incluso crear la política de asignación más apropiada para su entorno y sus parámetros de BLAST. Además, proponemos PSS (<br>Programación de Autoasignación Adaptativa Ponderada por Paquete</br>), una nueva estrategia que adapta la política de asignación elegida a una cuadrícula con carga de trabajo local. Considerando la heterogeneidad y las características dinámicas de la red, PSS es capaz de modificar la longitud de las unidades de trabajo durante la ejecución, basándose en el tiempo de procesamiento promedio de cada nodo. La expresión utilizada para la asignación de unidades de trabajo se muestra en la ecuación 11, donde A(N, P) es la política de asignación para un sistema con N unidades de carga de trabajo y P nodos, y Φ(m, pi, P) es el peso calculado por PSS. Un (N, P) puede ser una política de asignación predefinida o una definida por el usuario. 158 asignar(m, pi, N, P) = A(N, P) ∗ Φ(m, pi, P) (11) Para distribuir segmentos de base de datos a nodos, el maestro analiza notificaciones periódicas de los esclavos. La expresión utilizada es Φ(m, pi, P) (ecuación 12), definida como la media ponderada de las últimas Ω notificaciones enviadas por cada nodo esclavo pi. Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (ecuación 13) especifica el tiempo de cálculo promedio de un segmento en un nodo pi, considerando las últimas Ω notificaciones de TE(m, pi, τ), que es el tiempo promedio de cálculo de τ unidades de trabajo (segmentos de base de datos) asignadas por el maestro m a un esclavo pi. En el momento del cálculo de Γ, si no hay suficientes notificaciones de TE, el cálculo se realiza con el total de k notificaciones ya recibidas. Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 La arquitectura general de PackageBLAST PackageBLAST fue diseñado como un servicio de cuadrícula sobre Globus 3, basado en Servicios Web y Java. La Figura 3 presenta la arquitectura de PackageBLAST. BLAST recibe unidades de trabajo de asignación de estrategias maestras, genera unidades de trabajo, distribuye informes y genera unidades de trabajo (a esclavos) informes de búsquedas. Figura 3: Arquitectura de PackageBLAST. El módulo Estrategias de Asignación contiene implementaciones para las políticas de asignación predefinidas (Fija, SS, GSS, TSS y FAC2) y también permite la creación de nuevas estrategias de asignación. El módulo Generar Unidades de Trabajo es el núcleo del mecanismo PSS. Calcula el peso de cada nodo esclavo y decide cuántas unidades de trabajo se asignarán a un nodo esclavo en particular, de acuerdo con la política de asignación elegida. El módulo Distribute Work Units es el responsable de la comunicación entre el nodo maestro y los nodos esclavos. Distribuye las unidades de trabajo generadas por el módulo anterior y recopila las notificaciones. Finalmente, el módulo Generar Informes obtiene las salidas intermedias enviadas por los nodos esclavos a través de transferencia de archivos y las fusiona en un único informe de salida de BLAST. En general, se ejecuta el siguiente flujo de ejecución. El usuario especifica la secuencia a comparar y elige la estrategia de asignación. El nodo maestro comienza la ejecución y espera las conexiones de los esclavos. Para comenzar el procesamiento, un número mínimo de esclavos debe registrarse en el nodo maestro, llamando a un servicio de cuadrícula maestra. Después de recibir las conexiones de los esclavos, el maestro les notifica acerca de los segmentos iniciales para comparar. El proceso esclavo procesa los segmentos de la base de datos y notifica al maestro, que utiliza las últimas notificaciones para calcular el tamaño del siguiente bloque de asignación en función de la estrategia de asignación seleccionada y el peso proporcionado por PSS. Luego, el maestro envía un mensaje XML al esclavo informándole sus nuevos segmentos a procesar. Este flujo continúa hasta que todos los segmentos sean procesados. 6. RESULTADOS EXPERIMENTALES PackageBLAST fue evaluado en un banco de pruebas de 16 nodos, compuesto por dos laboratorios interconectados por una red de área local. Once computadoras de escritorio (P01-11) y una computadora portátil (NB) fueron utilizadas en LABPOS y cuatro computadoras de escritorio (L01-04) fueron utilizadas en LAICO (tabla 2). Todos los nodos de la red utilizaban Linux con Globus 3.2.1, NCBI BLAST 2.2.10 y Java VM 1.4.2. Tabla 2: Características del banco de pruebas de la red. Para investigar las mejoras de rendimiento de PackageBLAST, ejecutamos BLASTX en 2, 4, 8 y 16 nodos de la cuadrícula. Cada búsqueda de BLAST comparó una secuencia de ADN real de 10KBP contra la base de datos genética nr de 1.2GB segmentada en 167 partes de 5MB cada una. Se emplearon estrategias de asignación fijas, SS, TSS, GSS y FAC2 en las pruebas. Los tiempos de ejecución para todas las estrategias de asignación se presentan en la tabla 3. Tabla 3: Tiempos de ejecución para BLASTX. La Tabla 4 presenta los tiempos de ejecución en una sola máquina y las aceleraciones absolutas para 2, 4, 8 y 16 nodos, considerando el mejor tiempo de ejecución para un número dado de nodos. Para calcular las aceleraciones absolutas, se ejecutó la versión secuencial de BLAST con la base de datos no segmentada nr. Tabla 4: Tiempos de ejecución secuenciales y aceleraciones. El tiempo de secuencia de nodos 2 nodos 4 nodos 8 nodos 16 nodos NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 El paquete BLAST logró muy buenos aumentos de velocidad. Considerando el peor (L04), el promedio (P01) y el mejor (NB) nodo en la cuadrícula, los aceleramientos obtenidos fueron superlineales, cercanos a lineales y sublineales, respectivamente. En la tabla 3, también se puede observar que no hay una estrategia de asignación que siempre alcance el mejor tiempo de ejecución. Esta variación justifica el marco de asignación proporcionado. Para evaluar PSS, ejecutamos PackageBLAST con 16 nodos de cuadrícula, introduciendo carga de trabajo local en los nodos L01, L02, P01 y P02. La carga se inició simultáneamente 30 segundos después del comienzo de BLAST y consistió en la ejecución de formatdb en la base de datos nr 159 veces. Se simularon tres escenarios (tabla 5): 1) con estrategia PSS, pero sin carga de trabajo; 2) con estrategia PSS y carga de trabajo (PSS 2x), para utilizar el conocimiento del entorno de la cuadrícula obtenido en la iteración anterior; y 3) Ejecución sin PSS y con carga de trabajo. Tabla 5: Evaluación de PSS con carga de trabajo local. Como era de esperar, las estrategias de asignación que asignan una gran cantidad de trabajo a los nodos (fijo y GSS) obtuvieron un gran beneficio al utilizar PSS. Esto se debe a que un nodo lento puede convertirse fácilmente en un cuello de botella en estas estrategias. TSS también obtuvo una reducción del 5.56% en su tiempo de ejecución. PSS utiliza dos parámetros: τ y Ω (sección 5.2). Variamos estos parámetros para evaluar el comportamiento del PSS en dos escenarios. En ambos casos, utilizamos una cuadrícula de cuatro nodos (NB, L01, P01, L04). En el primer experimento, se introdujo una carga de trabajo local (formatdb) cuando comenzaba la última tarea de la primera asignación de TSS y se detuvo inmediatamente después del procesamiento de un segmento. El objetivo era evaluar el impacto de las tareas locales de corta duración en PSS. En el segundo caso, la carga de trabajo local se introdujo al mismo tiempo que en el caso anterior, pero continuó hasta el final. El objetivo era evaluar tareas locales de larga duración. La Figura 4 presenta las ganancias. Figura 4: Ganancia porcentual obtenida por PSS variando los parámetros τ y Ω. En el escenario 1, cuando se considera una historia muy reciente (τ=1 y Ω=1), PSS intenta adaptarse a una situación que pronto desaparecerá. Para τ=5 y Ω=4, PSS tarda más en notar la modificación y las tareas de corta duración tienen poco impacto. Por otro lado, en el escenario 2, τ=1, Ω=1 presenta mejores resultados que τ=5, Ω=4, porque cambia los pesos más rápido. CONCLUSIÓN En este artículo, propusimos y evaluamos PackageBLAST, un servicio de cuadrícula adaptable de múltiples políticas para ejecutar búsquedas BLAST maestro/esclavo. PackageBLAST contiene un marco en el que el usuario puede elegir o incorporar políticas de asignación. También definimos una estrategia, PSS, que adapta la política elegida a un entorno de red heterogéneo no dedicado. Los resultados recopilados al ejecutar PackageBLAST con 5 políticas de asignación en un banco de pruebas en forma de cuadrícula fueron muy buenos. Para comparar una secuencia de ADN real de 10KBP contra la base de datos genética nr, logramos reducir el tiempo de ejecución de 30.88 minutos a 2.11 minutos. Además, demostramos que, en nuestro entorno de pruebas, no hay una política de asignación que siempre logre el mejor rendimiento y que pone de manifiesto la importancia de proporcionar múltiples políticas. Además, demostramos que la introducción de PSS resultó en mejoras de rendimiento muy significativas para algunas políticas. Como trabajo futuro, tenemos la intención de ejecutar PackageBLAST en una red geográficamente dispersa, para evaluar el impacto de las altas latencias de red en las políticas de asignación y en PSS. Además, tenemos la intención de proporcionar soporte para la sincronización de bases de datos genómicas y operaciones dinámicas de unión/salida para esclavos. 8. REFERENCIAS [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers y D. J. Lipman. Una herramienta básica de búsqueda de alineamiento local. Revista de Biología Molecular, 215:403-410, 1990. [2] A. Darling, L. Carey, y W. Feng. El diseño, implementación y evaluación de mpiblast. 4ta Conferencia Internacional sobre Clústeres de Linux, 2003. [3] S. F. A. y col. Blast con huecos y psi-blast: una nueva generación de programas de búsqueda en bases de datos de proteínas. Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.\nInvestigación de Ácidos Nucleicos, 25(17):3389-3402, 1997. [4] I. Foster y C. Kesselman. Globus: Un conjunto de herramientas de infraestructura de metacomputación. Revista Internacional de Aplicaciones de Supercomputadoras, 11(2):115-128, 1997. [5] I. Foster y C. Kesselman. La Red: Diseño de una Infraestructura Informática Futura. Morgan-Kauffman, 1999. [6] W. Gish.\nMorgan-Kauffman, 1999. [6] W. Gish. Universidad de Washington explosión. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield. Algoritmos en Cadenas, Árboles y Secuencias. Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg y L. E. Flynn. Factorización: Un método para programar bucles paralelos. Comunicaciones de la ACM, 35(8):90-101, 1992. [9] A. Krishnan. Gridblast: Blast de alto rendimiento en la red. Simposio sobre Biocomputación, enero de 2003. [10] D. Peng, W. Yan y Z. Lei. Paralelización de blast++. Informe técnico, Singapur-MIT, 2004. [11] C. D. Polychronopoulos y D. J. Kuck. Programación autoguiada: Un esquema práctico de programación para supercomputadoras paralelas. IEEE Transactions on Computers, 36(12):1425-1439, Dic. 1987. [12] M. K. Satish y R. R. Joshi. Gbtk: Un conjunto de herramientas para la implementación de cuadrículas de blast. 7ª Conferencia Internacional HPCAsia, páginas 378-382, 2004. [13] G. Shao. Programación adaptativa de aplicaciones Maestro/Trabajador en recursos computacionales distribuidos. Tesis de doctorado, Univ. California en San Diego, 2001. [14] T. Smith y M. Waterman. Identificación de subsecuencias moleculares comunes. J. Mol. Biol., 147:195-197, 1981. [15] P. Tang y P. C. Yew. Auto-programación del procesador para múltiples bucles paralelos anidados. En Int. Conf. on Parallel Processing (ICPP), páginas 528-535, 1986. [16] T. H. Tzen y L. M. Ni. Programación automática trapezoidal: Un esquema práctico para compiladores paralelos. IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Ene. 1993. 160 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "bioinformatic": {
            "translated_key": "bioinformática",
            "is_in_text": false,
            "original_annotated_sentences": [
                "PackageBLAST: An Adaptive Multi-Policy Grid Service for Biological Sequence Comparison ∗ Marcelo S. Sousa University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil msousa@unb.br Alba Cristina M. A. Melo University of Brasilia Campus UNB - ICC Norte, sub-solo Brasilia, Brazil alves@unb.br ABSTRACT In this paper, we propose an adaptive task allocation framework to perform BLAST searches in a grid environment against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate task allocation strategies.",
                "Furthermore, we propose a mechanism to compute grid nodes execution weight, adapting the chosen allocation policy to the current computational power of the nodes.",
                "Our results present very good speedups and also show that no single allocation strategy is able to achieve the lowest execution times for all scenarios.",
                "Categories and Subject Descriptors C.2.4 [Distributed Systems]: Distributed Applications; J.3 [Life and Medical Sciences]: Biology and Genetics 1.",
                "INTRODUCTION Biological sequence comparison (or sequence alignment) is one of the most important problems in computational biology, given the number and diversity of the sequences and the frequency on which it is needed to be solved daily.",
                "SW [14] is an exact algorithm that finds the best local alignment between two sequences of size n in quadratic time and space.",
                "In genome projects, the size of the sequences to be compared is constantly increasing, thus an O(n2 ) solution is expensive.",
                "For this reason, heuristics like BLAST [3] were proposed to reduce execution time.",
                "The popularity of the Internet made possible the interconnection of millions of powerful machines in a global scale.",
                "This led to the idea of grid computing, which involves cooperative and secure sharing of non-dedicated and heterogeneous resources that are geographically distributed [5].",
                "Resource scheduling is one of the most important components of a grid system.",
                "The choice of the best resources for a particular application is called task allocation, which is an NP-Complete problem.",
                "Grid applications usually do not have high communication rates and many of them follow the master/slave model [13].",
                "In order to schedule master/slave applications many task allocation policies were proposed such as Self Scheduling [15] and FAC2 [8].",
                "The choice of the best allocation policy depends on the application access pattern and on the environment in which it runs [13].",
                "In this paper, we propose PackageBLAST, an adaptive multi-policy grid service to run BLAST searches in grids composed by segmented genetic databases.",
                "PackageBLAST executes on Globus 3 [4] and, by now, provides five allocation policies.",
                "Also, we propose an adaptive mechanism to assign weights to the grid nodes, taking into account their current workload.",
                "As far as we know, this is the first grid service that runs BLAST with multiple task policies with a segmented database in a heterogeneous non-dedicated platform.",
                "This paper is organized as follows.",
                "Section 2 presents the sequence comparison problem and the BLAST algorithm.",
                "Section 3 describes allocation policies for grids.",
                "Section 4 discusses related work.",
                "Section 5 presents the design of PackageBLAST.",
                "Experimental results are discussed in section 6.",
                "Section 7 concludes the paper. 2.",
                "SEQUENCE COMPARISON To compare two sequences, we must find the best alignment, which is to place one sequence above the other making clear the correspondence between similar characters [7].",
                "Given an alignment between two sequences, a score is usually associated for it as follows (figure 1).",
                "For each column, we associate, for instance, +1 if the two characters are identical, -1 if the characters are different and -2 if one of them is a space.",
                "The score is the sum of all the values and the maximal score is the similarity between the sequences.",
                "To compute exact local sequence alignments, [14] proposed an algorithm (SW), based on dynamic programming, with quadratic time and space complexity.",
                "Usually, one given biological sequence is compared against thousands or even millions of sequences that compose genetic data banks.",
                "By now, there are millions of entries composed of billions of nucleotides at GenBank, which is one of the most important public gene repositories.",
                "Due to the 156 G A C G G A T T A G G A T C G G A A T A G +1 +1 −2 +1 +1 +1 +1 −1 +1 +1 +1 Σ = 6 Figure 1: Example of an alignment with score 6 current growth rate, these databases will soon achieve terabytes.",
                "In this scenario, the use of exact methods such as SW is prohibitive.",
                "For this reason, faster heuristic methods are proposed which do not guarantee that the best alignment will be produced.",
                "Usually, these heuristic methods are evaluated using the concepts of sensitivity and sensibility.",
                "Sensitivity is the rate at which the method fails to identify similar sequences whereas sensibility is the rate at which the method identifies sequences that are not similar [7].",
                "BLAST [1] is the most widely used heuristic method for sequence comparison. 2.1 The BLAST Algorithm BLAST (Basic Local Alignment Tool) [1] is a set of programs used to search DNA and protein databases for similarities between sequences.",
                "It is designed to obtain high performance with low impact in terms of sensibility.",
                "BLAST provides programs to compare many combinations of query and database sequence types (table 1).",
                "Table 1: Some of the BLAST family programs Program Database Query Translation BLASTN Nucleotide Nucleotide None BLASTP Protein Protein None BLASTX Protein Nucleotide Query The first version of BLAST searched for local similarities without taking spaces (gaps) into account.",
                "In 1996-1997, two gapped versions of BLAST emerged: NCBI-BLAST [3] and WU-BLAST [6].",
                "Basically, the algorithm proceeds in three steps: seeding, extension and evaluation.",
                "In the seeding step, a query sequence is split in portions called words of size W. These words are matched to database sequences and used as alignment seeds if their scores are higher than a threshold T. In the extension step, alignments are generated from seeds.",
                "A parameter X maintains the recent alignment history and controls this step.",
                "Once seeds are extended, the last step begins.",
                "The alignments are evaluated to determine if they are statistically significant.",
                "The significant ones are termed HSPs (High-scoring Segment Pairs).",
                "A new parameter, S, is used to sort alignments.",
                "The combination of parameters W, T, X and S is used to determine the sensitivity and speed of BLAST searches. 3.",
                "TASK ALLOCATION FOR GRIDS 3.1 Grid Computing Grid Computing was initially developed to enable resource sharing between scientific institutions who needed to share data, software and computational power.",
                "The Globus Toolkit [4] emerged as an open source project and quickly became a de facto standard for grid computing infrastructure.",
                "Globus implements a set of protocols, APIs and services used by hundreds of grid applications all over the world.",
                "In 2002, the Open Grid Services Architecture (OGSA) was introduced by the Global Grid Forum (GGF) to expand standardization.",
                "OGSA provided a new architecture for grid applications based on web services in order to achieve interoperability using industry standards.",
                "Many OGSA architecture implementations were developed, including one for Globus.",
                "The work carried out in this paper is deployed on a grid based on Globus (GT3).",
                "Usually, grid applications are modelled as master/slave, where one problem is divided in many independent work units (tasks) of smaller size that can be distributed to slave nodes for parallel processing.",
                "A very important problem to be solved in this context is task allocation.",
                "The task allocation problem consists of assigning tasks to processors in order to maximize system performance [13].",
                "In this problem, it is assumed that no precedence relations exist among the tasks. 3.2 Task Allocation Strategies Given a master/slave application composed by a master m and S slaves, the allocation function allocate(m, si, N, S) determines how many tasks out of N must be assigned to a slave si (equation 1), where A(N, S) represents an allocation policy.",
                "WeightFactor(m, si, S) was defined by [13] (equation 2) and provides weights for each slave si, based on its statically known processing rate (WorkerRate). allocate(m, si, N, S) = A(N, S) ∗ W eightF actor(m, si, S) (1) W eightF actor(m, si, S) = P ∗ W orkerRate(m, si) P i=1 W orkerRate(m, si) (2) The following subsections present some work allocation policies, which are instances A(N, S) of equation 1. 3.3 Fixed (Static Scheduling) The Fixed [13] strategy distributes all work units uniformly to slaves nodes.",
                "This strategy is appropriate for homogeneous systems with dedicated resources (equation 3).",
                "A(N, S) = N S (3) 3.4 Self Scheduling (SS) Self Scheduling (SS) [15] distributes a single work unit to every slave node (equation 4).",
                "A(N, S) = 1, while work units are still left to allocate (4) In SS, the maximum imbalance is limited by the processing time of a work unit in the slowest node.",
                "Nevertheless, SS usually demands a lot of communication, since each work unit retrieval requires one interaction with the master. 3.5 Trapezoidal Self Scheduling (TSS) Trapezoidal Self-Scheduling (TSS) [16] allocates work units in groups with a linearly decreasing size.",
                "This strategy uses two variables, steps and δ, that represent the total number of allocation steps and the block reduction factor, respectively (equations 5 and 6). steps = 4NS N + 2S (5) 157 δ = N − 2S 2S(steps − 1) (6) TSS calculates the length of the sth block using the difference between the length of the first block and total reduction from the last s − 1 blocks (equation 7).",
                "A(s, N, S) = max N 2S − [(s − 1) ∗ δ] , 1 (7) 3.6 Guided Self Scheduling (GSS) Guided Self-Scheduling (GSS) [11] allocates work units in groups whose length decrease exponentially.",
                "Its goal is to create a tradeoff between the number of the work units processed and the imbalance in finishing times (equation 8).",
                "A(s, N, S) = max N 1 − 1 S s−1 S , 1 , s > 0 (8) 3.7 Factoring (FAC2) FAC2 allocates work units in cycles consisting of S allocation sequences.",
                "Equation 9 shows the function that defines the cycle number of an iteration s. In FAC2, half of the remaining work units are allocated in each round (equation 10). round(s) = (s − 1) S + 1 (9) A(s, N, S) = max N S ∗ 2round(s) , 1 (10) 4.",
                "RELATED WORK MpiBLAST [2] was proposed for clusters and has two phases.",
                "First, the genetic database is segmented.",
                "Then, the queries are evenly distributed among the nodes.",
                "If the node does not have a database fragment, a local copy is made.",
                "A method is proposed that associates data fragments to nodes, trying to minimize the number of copies.",
                "BLAST++ [10] groups multiple sequences to reduce the number of database accesses.",
                "A master/slave approach is used that allocates the queries to the slaves according to the fixed policy (section 3.3).",
                "Each worker executes BLAST++ independently and, finally, the results are collected and combined by the master.",
                "GridBlast [9] is a master/slave grid application that uses Globus 2.",
                "It distributes sequences among the grid nodes using two allocation policies: FCFS and minmax.",
                "Of those, only the last one takes into account the current load and the heterogeneity of the environment.",
                "However, to use minmax, the total execution time of each BLAST task must be known.",
                "Having decided which sequences will be compared by each node, GridBlast sends the sequences, the executable files and the whole database to the chosen node.",
                "When the search finishes, the results are compacted and sent to the master.",
                "Grid Blast Toolkit (GBTK) [12] is a web portal to execute BLAST searches in Globus 3.",
                "All genetic databases are statically placed on the grid nodes (without replication).",
                "GBTK is a master/slave application that receives the sequences and the name of the genetic database.",
                "It then verifies if the node that contains the database is available.",
                "If so, it is selected.",
                "If the node is not available, the less loaded node is chosen and the database is copied to it.",
                "Master SlaveSlaveSlave Internet database segment but only part of it is processed in each node The database is replicated in the nodes, Figure 2: PackageBLAST segmentation and distribution mechanism. 5.",
                "DESIGN OF PACKAGEBLAST We propose an adaptive task allocation framework which is a grid service to perform BLAST searches against sequence database segments.",
                "The framework, called PackageBLAST, provides an infrastructure to choose or incorporate allocation strategies in a master/slave application.",
                "We also propose a strategy to compute grid nodes execution weight which distributes work units (database segments) to grid nodes according to their current computational power. 5.1 Database Segmentation and Replication Segmentation consists in the division of a database archive in many portions of smaller size, called segments, that can be processed independently.",
                "It enables grid nodes to search smaller parts of a sequence database, reducing the number of disk accesses and hence improving BLAST performance.",
                "Also, a single query sequence can be compared against all segments in parallel.",
                "Just as in mpiBLAST (section 4), we decided to use database segmentation in PackageBLAST with an NCBI tool called formatdb, which was modified to generate more database segments of smaller size.",
                "We opted to replicate the segmented database in every slave grid node to improve data accesses times and to provide a potential for fault tolerance.",
                "Figure 2 illustrates this. 5.2 Task Allocation As [13], we think that no allocation policy will produce the best results for every situation.",
                "Thus, we propose the use of a framework where many allocation policies can be incorporated.",
                "By now, our framework contains five allocation policies: Fixed, SS, GSS, TSS, FAC2, all described in section 3.",
                "So, the user can choose or even create the allocation policy which is the most appropriate to his/her environment and his/her BLAST parameters.",
                "Besides that, we propose PSS (Package Weighted Adaptive Self-Scheduling), a new strategy that adapts the chosen allocation policy to a grid with local workload.",
                "Considering the heterogeneity and dynamic characteristics of the grid, PSS is able to modify the length of the work units during execution, based on average processing time of each node.",
                "The expression used for work unit allocation is shown in equation 11, where A(N, P) is the allocation policy for a system with N workload units and P nodes and Φ(m, pi, P) is the weight calculated by PSS.",
                "A(N, P) can be a pre-defined allocation policy or a user-defined one. 158 allocate(m, pi, N, P ) = A(N, P ) ∗ Φ(m, pi, P ) (11) To distribute database segments to nodes, the master analyzes periodic slave notifications.",
                "The expression used is Φ(m, pi, P) (equation 12), defined as the weighted mean from the last Ω notifications sent by each pi slave node.",
                "Φ(m, pi, P ) = P ∗ P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) P i=1 P i=1 Γ(m,pi,Ω) Γ(m,pi,Ω) (12) Γ(m, pi, Ω) (equation 13) specifies the average computing time of a segment in a node pi, considering the last Ω notifications of TE(m, pi, τ), which is the average computation time of τ work units (database segments) assigned by the master m to a slave pi.",
                "At the moment of computation of Γ, if there is not enough notifications of TE, the calculation is done with total k notifications already received.",
                "Γ(m, pi, Ω) = min(Ω,k) j=1 T E(m, pi, τ) min(Ω, k) (13) 5.3 PackageBLASTs General Architecture PackageBLAST was designed as a grid service over Globus 3, based on Web Services and Java.",
                "Figure 3 presents the PackageBLAST architecture.",
                "BLAST receives MASTER Strategies Allocation Work units Generate Work Units Distribute Reports Generate work units (to slaves)reports searches Figure 3: PackageBLAST architecture.",
                "The module Allocation Strategies contains implementations for the pre-defined allocation policies (Fixed, SS, GSS, TSS and FAC2) and also makes possible the creation of new allocation strategies.",
                "The module Generate Work Units is the core of the PSS mechanism.",
                "It calculates the weight of each slave node and decides how many work units will be assigned to a particular slave node, according to the chosen allocation policy.",
                "Distribute Work Units is the module responsible for the communication between the master and slaves nodes.",
                "It distributes the work units generated by the previous module and collects the notifications.",
                "Finally, the module Generate Reports obtains the intermediary outputs sent by the slave nodes through file transfer and merges them into a single BLAST output report.",
                "In general, the following execution flow is executed.",
                "The user specifies the sequence to be compared and chooses the allocation strategy.",
                "The master node starts execution and waits for slave connections.",
                "To start processing, a minimum number of slaves must register into the master node, by calling a master grid service.",
                "After receiving connections from the slaves, the master notifies them about their initial segments to compare.",
                "The slave processes τ database segments and notifies the master, which uses the last Ω notifications to compute the next allocation block size based on the selected allocation strategy and the weight provided by PSS.",
                "Then, the master sends a XML message to the slave informing its new segments to process.",
                "This flow continues until all segments are processed. 6.",
                "EXPERIMENTAL RESULTS PackageBLAST was evaluated in a 16-node grid testbed, composed by two laboratories, interconnected by a localarea network.",
                "Eleven desktops (P01-11) and a notebook (NB) were used in LABPOS and four desktops (L01-04) were used in LAICO (table 2).",
                "All grid nodes used Linux with Globus 3.2.1, NCBI BLAST 2.2.10 and Java VM 1.4.2.",
                "Table 2: Characteristics of the grid testbed.",
                "Node Names CPU Main Memory HD NB 3200 MHz 512 MB 80 GB L01-L03 1700 MHz 256 MB 30 GB L04 350 MHz 160 MB 6 GB P01-P10 1000 MHz 256 MB 20 GB P11 900 MHz 128 MB 20 GB To investigate the performance gains of PackageBLAST, we executed BLASTX in 2, 4, 8 and 16 grid nodes.",
                "Each BLAST search compared a 10KBP real DNA sequence against the 1.2GB nr genetic database segmented in 167 parts of 5MB each.",
                "Fixed, SS, TSS, GSS and FAC2 allocation strategies were employed in the tests.",
                "Execution times for all allocation strategies are presented in table 3.",
                "Table 3: Execution times for BLASTX.",
                "Strategy 2 nodes 4 nodes 8 nodes 16 nodes FIXED 2037 999 491 252 SS 1112 514 246 134 TSS 1296 570 259 143 GSS 1115 535 250 127 FAC2 1187 514 266 142 Table 4 presents execution times in a single machine and absolute speedups for 2, 4, 8 and 16 nodes, considering the best execution time for a given number of nodes.",
                "To calculate the absolute speedups, the BLAST sequential version was executed with the nr unsegmented database.",
                "Table 4: Sequential execution times and speedups.",
                "Node SeqTime 2 nodes 4 nodes 8 nodes 16 nodes NB 1432 1.29 2.79 5.82 11.28 L01 1585 1.43 3.08 6.44 12.48 P01 1853 1.67 3.61 7.53 14.59 P11 2004 1.80 3.90 8.15 15.78 L04 3810 3.43 7.41 15.49 30.00 PackageBLAST achieved very good speedups.",
                "Considering the worst (L04), average (P01) and best (NB) node in the grid, the speedups obtained were superlinear, close to linear and sublinear, respectively.",
                "In table 3, it can also be noticed that there is no allocation strategy that always reaches the best execution time.",
                "This variation justifies the allocation framework provided.",
                "To evaluate PSS, we executed PackageBLAST with 16 grid nodes, introducing local workload in nodes L01, L02, P01 and P02.",
                "The load was started simultaneously 30 seconds after the beginning of BLAST and consisted of the 159 execution of formatdb on the nr database.",
                "Three scenarios were simulated (table 5): 1) with PSS strategy, but without workload; 2) with PSS strategy and workload (PSS 2x), to use grid environment knowledge obtained in the preceeding iteration; and 3) Execution without PSS and with workload.",
                "Table 5: PSS evaluation with local workload.",
                "Gain is the comparison of without PSS with PSS 2x Strategy with PSS PSS 2x without PSS Gain Fixed 316 184 393 113.59% SS 186 177 179 1.13% TSS 160 162 171 5.56% GSS 149 159 339 113.21% FAC2 156 165 153 -7.27% As expected, the allocation strategies that assign a large amount of work to the nodes (fixed and GSS) obtained great benefit from using PSS.",
                "This is due to the fact that a slow node can easily become a bottleneck in these strategies.",
                "TSS also obtained a reduction of 5.56% in its execution time.",
                "PSS uses two parameters: τ and Ω (section 5.2).",
                "We varied these parameters in order to evaluate the PSS behavior in two scenarios.",
                "In both cases, we used a four-node (NB, L01, P01, L04) grid.",
                "In the first experiment, a local workload (formatdb) was introduced when the last task of the first TSS allocation starts and was stopped immediately after the processing of one segment.",
                "The goal was to evaluate the impact of short-lived local tasks in PSS.",
                "In the second case, local workload was introduced at the same time of the previous case, but continued until the end.",
                "The goal was to evaluate long-lived local tasks.",
                "Figure 4 presents the gains.",
                "Figure 4: Percentual gain obtained by PSS varying τ and Ω parameters.",
                "In scenario 1, when a very recent history is considered (τ=1 and Ω=1), PSS tries to adapt to a situation that will shortly disappear.",
                "For τ=5 and Ω=4, PSS takes longer to notice modification and short-lived tasks have low impact.",
                "On the other hand, in scenario 2, τ=1,Ω=1 presents better results than τ=5, Ω=4, because it changes weights faster. 7.",
                "CONCLUSION In this article, we proposed and evaluated PackageBLAST, an adaptive multi-policy grid service to execute master/slave BLAST searches.",
                "PackageBLAST contains a framework where the user can choose or incorporate allocation policies.",
                "We also defined a strategy, PSS, that adapts the chosen policy to a heterogeneous non-dedicated grid environment.",
                "The results collected by running PackageBLAST with 5 allocation policies in a grid testbed were very good.",
                "In order to compare a 10KBP real DNA sequence against the nr genetic database, we were able to reduce execution time from 30.88 min to 2.11 min.",
                "Also, we showed that, in our testbed, there is no allocation policy that always achieves the best performance and that makes evident the importance of providing multiple policies.",
                "Moreover, we showed that the introduction of PSS led to very good performance gains for some policies.",
                "As future work, we intend to run PackageBLAST in a geographically dispersed grid, to evaluate the impact of high network latencies in the allocation policies and in PSS.",
                "Also, we intend to provide support for genomic database synchronization and dynamic join/leave operations for slaves. 8.",
                "REFERENCES [1] S. F. Altschul, W. Gish, W. Miller, E. W. Myers, and D. J. Lipman.",
                "A basic local alignment search tool.",
                "Journal of Molecular Biology, 215:403-410, 1990. [2] A.",
                "Darling, L. Carey, and W. Feng.",
                "The design, implementation, and evaluation of mpiblast. 4th International Conference on Linux Clusters, 2003. [3] S. F. A. et al.",
                "Gapped blast and psi-blast: a new generation of protein database search programs.",
                "Nucleic Acids Research, 25(17):3389-3402, 1997. [4] I.",
                "Foster and C. Kesselman.",
                "Globus: A metacomputing infrastructure toolkit.",
                "International Journal of Supercomputer Applications, 11(2):115-128, 1997. [5] I.",
                "Foster and C. Kesselman.",
                "The Grid: Blueprint of a Future Computing Infrastructure.",
                "Morgan-Kauffman, 1999. [6] W. Gish.",
                "Washington university blast. http://blast.wustl.edu, 1996-2002. [7] D. Gusfield.",
                "Algorithms on Strings, Trees and Sequences.",
                "Cambridge University Press, 1997. [8] S. F. Hummel, E. Schonberg, and L. E. Flynn.",
                "Factoring: A method for scheduling parallel loops.",
                "Communications of the ACM, 35(8):90-101, 1992. [9] A. Krishnan.",
                "Gridblast: High throughput blast on the grid.",
                "Symposium on Biocomputing, January 2003. [10] D.",
                "Peng., W. Yan, and Z. Lei.",
                "Parallelization of blast++.",
                "Technical report, Singapore-MIT, 2004. [11] C. D. Polychronopoulos and D. J. Kuck.",
                "Guided self-scheduling: A practical scheduling scheme for parallel supercomputers.",
                "IEEE Transactions on Computers, 36(12):1425-1439, Dec. 1987. [12] M. K. Satish and R. R. Joshi.",
                "Gbtk: A toolkit for grid implementation of blast. 7th International Conference HPCAsia, pages 378-382, 2004. [13] G. Shao.",
                "Adaptive Scheduling of Master/Worker Applications on Distributed Computational Resources.",
                "PhD thesis, Univ.",
                "California at San Diego, 2001. [14] T. Smith and M. Waterman.",
                "Identification of common molecular subsequences.",
                "J. Mol.",
                "Biol., 147:195-197, 1981. [15] P. Tang and P. C. Yew.",
                "Processor self-scheduling for multiple nested parallel loops.",
                "In Int.",
                "Conf. on Parallel Processing (ICPP), pages 528-535, 1986. [16] T. H. Tzen and L. M. Ni.",
                "Trapezoidal self-scheduling: A practical scheme for parallel compilers.",
                "IEEE Transactions on Parallel and Distributed Systems, 4(1):87-98, Jan. 1993. 160"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        }
    }
}